"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os2 = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os2.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    import_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    validate_default = validate;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset = 0) {
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v1.js"() {
    "use strict";
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/parse.js"() {
    "use strict";
    init_validate();
    parse_default = parse;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v35.js"() {
    "use strict";
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/md5.js"() {
    "use strict";
    import_crypto2 = __toESM(require("crypto"));
    md5_default = md5;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v3.js"() {
    "use strict";
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_crypto3.default.createHash("sha1").update(bytes).digest();
}
var import_crypto3, sha1_default;
var init_sha1 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/sha1.js"() {
    "use strict";
    import_crypto3 = __toESM(require("crypto"));
    sha1_default = sha1;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v5.js"() {
    "use strict";
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/nil.js"() {
    "use strict";
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/version.js"() {
    "use strict";
    init_validate();
    version_default = version;
  }
});

// node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var fs = __importStar(require("fs"));
    var os2 = __importStar(require("os"));
    var uuid_1 = (init_esm_node(), __toCommonJS(esm_node_exports));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os2.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${uuid_1.v4()}`;
      const convertedValue = utils_1.toCommandValue(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os2.EOL}${convertedValue}${os2.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new URL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new URL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
  }
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.debug = debug2;
  }
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_tunnel();
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil2 = require("util");
    var { stringify: stringify2 } = require("querystring");
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify2(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer2(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers))
        return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer2(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil2.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil2.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil2.toUSVString) {
        return nodeUtil2.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "")
        return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer: isBuffer2,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("node:util").inherits;
    var ReadableStream = require("node:stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module2.exports = PartStream;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var inherits = require("node:util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this._events.preamble) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this._events.trailer) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self2._unpause();
        };
        if (this._isPreamble && this._events.preamble) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this._events.part) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch (e) {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("node:stream");
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (!boy._events.file) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module2.exports = Multipart;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/@fastify+busboy@2.1.0/node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:")
        return true;
      if (url.protocol === "file:")
        return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null")
          return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto5 === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      const strongest = list[0].algo;
      const metadata = list.filter((item) => item.algo === strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        let expectedValue = item.hash;
        if (expectedValue.endsWith("==")) {
          expectedValue = expectedValue.slice(0, -2);
        }
        let actualValue = crypto5.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue.endsWith("==")) {
          actualValue = actualValue.slice(0, -2);
        }
        if (actualValue === expectedValue) {
          return true;
        }
        let actualBase64URL = crypto5.createHash(algorithm).update(bytes).digest("base64url");
        if (actualBase64URL.endsWith("==")) {
          actualBase64URL = actualBase64URL.slice(0, -2);
        }
        if (actualBase64URL === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto5.getHashes();
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (x === 0) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O) => {
        if (webidl.util.Type(O) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O)) {
          const keys2 = Object.keys(O);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        if (x.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "signed");
      return x;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++)
          ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--)
          ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData2 = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
    Object.defineProperties(FormData2.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData: FormData2 };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData: FormData2 } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;
            const responseFormData = new FormData2();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData2();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0)
            continue;
          if (headers[key])
            headers[key] += `,${value}`;
          else
            headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend)
          request.headers[key] = processHeaderValue(key, val, skipAppend);
        else
          request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key])
                request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else
                request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend)
            request.headers[key] = processHeaderValue(key, val, skipAppend);
          else
            request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert = require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    "use strict";
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    "use strict";
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net = require("net");
    var http = require("http");
    var { pipeline } = require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string")
        headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else
        headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0)
            session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    "use strict";
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module2.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    "use strict";
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL3 } = require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL3(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL3(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent)
          return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
        --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
        ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData: FormData2 } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError2 = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError2 ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData2
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable, pipeline } = require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa: btoa2 } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error) {
                  fr[kError] = error;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa2(decoder.write(chunk));
          }
          dataURL += btoa2(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = require("assert");
    var { getGlobalDispatcher } = require_global2();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0)
          request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r = operation.request;
              if (!urlIsHttpHttpsScheme(r.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify2(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );
        assert(kHeadersListNode, "Headers cannot be parsed");
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module2.exports = {
      isCTLExcludingHtab,
      stringify: stringify2,
      getHeadersList
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify: stringify2, getHeadersList } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify2(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify2(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants4();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("diagnostics_channel");
    var { uid, states } = require_constants4();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto5.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto5.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants4();
    var crypto5;
    try {
      crypto5 = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto5.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > this.#byteOffset) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            this.#buffers[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("util");
    var experimentalWarned = false;
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser;
        this[kReadyState] = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// node_modules/.pnpm/undici@5.28.3/node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/.pnpm/undici@5.28.3/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `${proxyUrl.username}:${proxyUrl.password}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.2.0/node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/@actions+core@1.10.1/node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os2 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("ENV", file_command_1.prepareKeyValueMessage(name, val));
      }
      command_1.issueCommand("set-env", { name }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath2(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueFileCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath2;
    function getInput2(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput2;
    function getMultilineInput(name, options) {
      const inputs = getInput2(name, options).split("\n").filter((x) => x !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("OUTPUT", file_command_1.prepareKeyValueMessage(name, value));
      }
      process.stdout.write(os2.EOL);
      command_1.issueCommand("set-output", { name }, utils_1.toCommandValue(value));
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports2.setFailed = setFailed2;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug2(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports2.debug = debug2;
    function error(message, properties = {}) {
      command_1.issueCommand("error", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error;
    function warning(message, properties = {}) {
      command_1.issueCommand("warning", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      command_1.issueCommand("notice", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info(message) {
      process.stdout.write(message + os2.EOL);
    }
    exports2.info = info;
    function startGroup(name) {
      command_1.issue("group", name);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      command_1.issue("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return file_command_1.issueFileCommand("STATE", file_command_1.prepareKeyValueMessage(name, value));
      }
      command_1.issueCommand("save-state", { name }, utils_1.toCommandValue(value));
    }
    exports2.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
  }
});

// node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.READONLY = exports2.UV_FS_O_EXLOCK = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rm = exports2.rename = exports2.readlink = exports2.readdir = exports2.open = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs = __importStar(require("fs"));
    var path = __importStar(require("path"));
    _a = fs.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.open = _a.open, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rm = _a.rm, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    exports2.UV_FS_O_EXLOCK = 268435456;
    exports2.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports2.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports2.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports2.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            const upperExt = path.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports2.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                const directory = path.dirname(filePath);
                const upperName = path.basename(filePath).toUpperCase();
                for (const actualName of yield exports2.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports2.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert");
    var path = __importStar(require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path.join(dest, path.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"(exports2, module2) {
    "use strict";
    exports2 = module2.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug2(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse2;
    function parse2(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version2, options) {
      var v = parse2(version2, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version2, options) {
      var s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug2("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v12 = parse2(version1);
        var v2 = parse2(version2);
        var prefix = "";
        if (v12.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug2("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug2("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version2, options) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version2.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse2(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/manifest.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._readLinuxVersionFile = exports2._getOsVersion = exports2._findMatch = void 0;
    var semver = __importStar(require_semver());
    var core_1 = require_core();
    var os2 = require("os");
    var cp = require("child_process");
    var fs = require("fs");
    function _findMatch(versionSpec, stable, candidates, archFilter) {
      return __awaiter(this, void 0, void 0, function* () {
        const platFilter = os2.platform();
        let result;
        let match;
        let file;
        for (const candidate of candidates) {
          const version2 = candidate.version;
          core_1.debug(`check ${version2} satisfies ${versionSpec}`);
          if (semver.satisfies(version2, versionSpec) && (!stable || candidate.stable === stable)) {
            file = candidate.files.find((item) => {
              core_1.debug(`${item.arch}===${archFilter} && ${item.platform}===${platFilter}`);
              let chk = item.arch === archFilter && item.platform === platFilter;
              if (chk && item.platform_version) {
                const osVersion = module2.exports._getOsVersion();
                if (osVersion === item.platform_version) {
                  chk = true;
                } else {
                  chk = semver.satisfies(osVersion, item.platform_version);
                }
              }
              return chk;
            });
            if (file) {
              core_1.debug(`matched ${candidate.version}`);
              match = candidate;
              break;
            }
          }
        }
        if (match && file) {
          result = Object.assign({}, match);
          result.files = [file];
        }
        return result;
      });
    }
    exports2._findMatch = _findMatch;
    function _getOsVersion() {
      const plat = os2.platform();
      let version2 = "";
      if (plat === "darwin") {
        version2 = cp.execSync("sw_vers -productVersion").toString();
      } else if (plat === "linux") {
        const lsbContents = module2.exports._readLinuxVersionFile();
        if (lsbContents) {
          const lines = lsbContents.split("\n");
          for (const line of lines) {
            const parts = line.split("=");
            if (parts.length === 2 && (parts[0].trim() === "VERSION_ID" || parts[0].trim() === "DISTRIB_RELEASE")) {
              version2 = parts[1].trim().replace(/^"/, "").replace(/"$/, "");
              break;
            }
          }
        }
      }
      return version2;
    }
    exports2._getOsVersion = _getOsVersion;
    function _readLinuxVersionFile() {
      const lsbReleaseFile = "/etc/lsb-release";
      const osReleaseFile = "/etc/os-release";
      let contents = "";
      if (fs.existsSync(lsbReleaseFile)) {
        contents = fs.readFileSync(lsbReleaseFile).toString();
      } else if (fs.existsSync(osReleaseFile)) {
        contents = fs.readFileSync(osReleaseFile).toString();
      }
      return contents;
    }
    exports2._readLinuxVersionFile = _readLinuxVersionFile;
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js"(exports2, module2) {
    "use strict";
    var crypto5 = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto5.randomBytes(16);
    };
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    "use strict";
    var byteToHex2 = [];
    for (i = 0; i < 256; ++i) {
      byteToHex2[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex2;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js"(exports2, module2) {
    "use strict";
    var rng2 = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v42(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng2)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v42;
  }
});

// node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os2 = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path = __importStar(require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n = s.indexOf(os2.EOL);
          while (n > -1) {
            const line = s.substring(0, n);
            onLine(line);
            s = s.substring(n + os2.EOL.length);
            n = s.indexOf(os2.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os2.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error) {
                reject(error);
              } else {
                resolve(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        if (this.processExited) {
          if (this.processError) {
            error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder");
    var tr = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports2.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/retry-helper.js
var require_retry_helper = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/retry-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryHelper = void 0;
    var core = __importStar(require_core());
    var RetryHelper = class {
      constructor(maxAttempts, minSeconds, maxSeconds) {
        if (maxAttempts < 1) {
          throw new Error("max attempts should be greater than or equal to 1");
        }
        this.maxAttempts = maxAttempts;
        this.minSeconds = Math.floor(minSeconds);
        this.maxSeconds = Math.floor(maxSeconds);
        if (this.minSeconds > this.maxSeconds) {
          throw new Error("min seconds should be less than or equal to max seconds");
        }
      }
      execute(action, isRetryable) {
        return __awaiter(this, void 0, void 0, function* () {
          let attempt = 1;
          while (attempt < this.maxAttempts) {
            try {
              return yield action();
            } catch (err) {
              if (isRetryable && !isRetryable(err)) {
                throw err;
              }
              core.info(err.message);
            }
            const seconds = this.getSleepAmount();
            core.info(`Waiting ${seconds} seconds before trying again`);
            yield this.sleep(seconds);
            attempt++;
          }
          return yield action();
        });
      }
      getSleepAmount() {
        return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
      }
      sleep(seconds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
        });
      }
    };
    exports2.RetryHelper = RetryHelper;
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/tool-cache.js
var require_tool_cache = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/tool-cache.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluateVersions = exports2.isExplicitVersion = exports2.findFromManifest = exports2.getManifestFromRepo = exports2.findAllVersions = exports2.find = exports2.cacheFile = exports2.cacheDir = exports2.extractZip = exports2.extractXar = exports2.extractTar = exports2.extract7z = exports2.downloadTool = exports2.HTTPError = void 0;
    var core = __importStar(require_core());
    var io = __importStar(require_io());
    var fs = __importStar(require("fs"));
    var mm = __importStar(require_manifest());
    var os2 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var httpm = __importStar(require_lib());
    var semver = __importStar(require_semver());
    var stream = __importStar(require("stream"));
    var util = __importStar(require("util"));
    var assert_1 = require("assert");
    var v4_1 = __importDefault(require_v4());
    var exec_1 = require_exec();
    var retry_helper_1 = require_retry_helper();
    var HTTPError = class extends Error {
      constructor(httpStatusCode) {
        super(`Unexpected HTTP response: ${httpStatusCode}`);
        this.httpStatusCode = httpStatusCode;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports2.HTTPError = HTTPError;
    var IS_WINDOWS = process.platform === "win32";
    var IS_MAC = process.platform === "darwin";
    var userAgent = "actions/tool-cache";
    function downloadTool2(url, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        dest = dest || path.join(_getTempDirectory(), v4_1.default());
        yield io.mkdirP(path.dirname(dest));
        core.debug(`Downloading ${url}`);
        core.debug(`Destination ${dest}`);
        const maxAttempts = 3;
        const minSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10);
        const maxSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
        const retryHelper = new retry_helper_1.RetryHelper(maxAttempts, minSeconds, maxSeconds);
        return yield retryHelper.execute(() => __awaiter(this, void 0, void 0, function* () {
          return yield downloadToolAttempt(url, dest || "", auth, headers);
        }), (err) => {
          if (err instanceof HTTPError && err.httpStatusCode) {
            if (err.httpStatusCode < 500 && err.httpStatusCode !== 408 && err.httpStatusCode !== 429) {
              return false;
            }
          }
          return true;
        });
      });
    }
    exports2.downloadTool = downloadTool2;
    function downloadToolAttempt(url, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (fs.existsSync(dest)) {
          throw new Error(`Destination file path ${dest} already exists`);
        }
        const http = new httpm.HttpClient(userAgent, [], {
          allowRetries: false
        });
        if (auth) {
          core.debug("set auth");
          if (headers === void 0) {
            headers = {};
          }
          headers.authorization = auth;
        }
        const response = yield http.get(url, headers);
        if (response.message.statusCode !== 200) {
          const err = new HTTPError(response.message.statusCode);
          core.debug(`Failed to download from "${url}". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);
          throw err;
        }
        const pipeline = util.promisify(stream.pipeline);
        const responseMessageFactory = _getGlobal("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => response.message);
        const readStream = responseMessageFactory();
        let succeeded = false;
        try {
          yield pipeline(readStream, fs.createWriteStream(dest));
          core.debug("download complete");
          succeeded = true;
          return dest;
        } finally {
          if (!succeeded) {
            core.debug("download failed");
            try {
              yield io.rmRF(dest);
            } catch (err) {
              core.debug(`Failed to delete '${dest}'. ${err.message}`);
            }
          }
        }
      });
    }
    function extract7z(file, dest, _7zPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(IS_WINDOWS, "extract7z() not supported on current OS");
        assert_1.ok(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        const originalCwd = process.cwd();
        process.chdir(dest);
        if (_7zPath) {
          try {
            const logLevel = core.isDebug() ? "-bb1" : "-bb0";
            const args = [
              "x",
              logLevel,
              "-bd",
              "-sccUTF-8",
              file
            ];
            const options = {
              silent: true
            };
            yield exec_1.exec(`"${_7zPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        } else {
          const escapedScript = path.join(__dirname, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedTarget = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const command = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}'`;
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            command
          ];
          const options = {
            silent: true
          };
          try {
            const powershellPath = yield io.which("powershell", true);
            yield exec_1.exec(`"${powershellPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        }
        return dest;
      });
    }
    exports2.extract7z = extract7z;
    function extractTar(file, dest, flags = "xz") {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        core.debug("Checking tar --version");
        let versionOutput = "";
        yield exec_1.exec("tar --version", [], {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
        core.debug(versionOutput.trim());
        const isGnuTar = versionOutput.toUpperCase().includes("GNU TAR");
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        if (core.isDebug() && !flags.includes("v")) {
          args.push("-v");
        }
        let destArg = dest;
        let fileArg = file;
        if (IS_WINDOWS && isGnuTar) {
          args.push("--force-local");
          destArg = dest.replace(/\\/g, "/");
          fileArg = file.replace(/\\/g, "/");
        }
        if (isGnuTar) {
          args.push("--warning=no-unknown-keyword");
          args.push("--overwrite");
        }
        args.push("-C", destArg, "-f", fileArg);
        yield exec_1.exec(`tar`, args);
        return dest;
      });
    }
    exports2.extractTar = extractTar;
    function extractXar(file, dest, flags = []) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(IS_MAC, "extractXar() not supported on current OS");
        assert_1.ok(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        args.push("-x", "-C", dest, "-f", file);
        if (core.isDebug()) {
          args.push("-v");
        }
        const xarPath = yield io.which("xar", true);
        yield exec_1.exec(`"${xarPath}"`, _unique(args));
        return dest;
      });
    }
    exports2.extractXar = extractXar;
    function extractZip2(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        if (IS_WINDOWS) {
          yield extractZipWin(file, dest);
        } else {
          yield extractZipNix(file, dest);
        }
        return dest;
      });
    }
    exports2.extractZip = extractZip2;
    function extractZipWin(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const escapedDest = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const pwshPath = yield io.which("pwsh", false);
        if (pwshPath) {
          const pwshCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;`,
            `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`,
            `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force } else { throw $_ } } ;`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            pwshCommand
          ];
          core.debug(`Using pwsh at path: ${pwshPath}`);
          yield exec_1.exec(`"${pwshPath}"`, args);
        } else {
          const powershellCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;`,
            `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force }`,
            `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            powershellCommand
          ];
          const powershellPath = yield io.which("powershell", true);
          core.debug(`Using powershell at path: ${powershellPath}`);
          yield exec_1.exec(`"${powershellPath}"`, args);
        }
      });
    }
    function extractZipNix(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const unzipPath = yield io.which("unzip", true);
        const args = [file];
        if (!core.isDebug()) {
          args.unshift("-q");
        }
        args.unshift("-o");
        yield exec_1.exec(`"${unzipPath}"`, args, { cwd: dest });
      });
    }
    function cacheDir(sourceDir, tool, version2, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        version2 = semver.clean(version2) || version2;
        arch = arch || os2.arch();
        core.debug(`Caching tool ${tool} ${version2} ${arch}`);
        core.debug(`source dir: ${sourceDir}`);
        if (!fs.statSync(sourceDir).isDirectory()) {
          throw new Error("sourceDir is not a directory");
        }
        const destPath = yield _createToolPath(tool, version2, arch);
        for (const itemName of fs.readdirSync(sourceDir)) {
          const s = path.join(sourceDir, itemName);
          yield io.cp(s, destPath, { recursive: true });
        }
        _completeToolPath(tool, version2, arch);
        return destPath;
      });
    }
    exports2.cacheDir = cacheDir;
    function cacheFile(sourceFile, targetFile, tool, version2, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        version2 = semver.clean(version2) || version2;
        arch = arch || os2.arch();
        core.debug(`Caching tool ${tool} ${version2} ${arch}`);
        core.debug(`source file: ${sourceFile}`);
        if (!fs.statSync(sourceFile).isFile()) {
          throw new Error("sourceFile is not a file");
        }
        const destFolder = yield _createToolPath(tool, version2, arch);
        const destPath = path.join(destFolder, targetFile);
        core.debug(`destination file ${destPath}`);
        yield io.cp(sourceFile, destPath);
        _completeToolPath(tool, version2, arch);
        return destFolder;
      });
    }
    exports2.cacheFile = cacheFile;
    function find2(toolName, versionSpec, arch) {
      if (!toolName) {
        throw new Error("toolName parameter is required");
      }
      if (!versionSpec) {
        throw new Error("versionSpec parameter is required");
      }
      arch = arch || os2.arch();
      if (!isExplicitVersion(versionSpec)) {
        const localVersions = findAllVersions(toolName, arch);
        const match = evaluateVersions(localVersions, versionSpec);
        versionSpec = match;
      }
      let toolPath = "";
      if (versionSpec) {
        versionSpec = semver.clean(versionSpec) || "";
        const cachePath = path.join(_getCacheDirectory(), toolName, versionSpec, arch);
        core.debug(`checking cache: ${cachePath}`);
        if (fs.existsSync(cachePath) && fs.existsSync(`${cachePath}.complete`)) {
          core.debug(`Found tool in cache ${toolName} ${versionSpec} ${arch}`);
          toolPath = cachePath;
        } else {
          core.debug("not found");
        }
      }
      return toolPath;
    }
    exports2.find = find2;
    function findAllVersions(toolName, arch) {
      const versions = [];
      arch = arch || os2.arch();
      const toolPath = path.join(_getCacheDirectory(), toolName);
      if (fs.existsSync(toolPath)) {
        const children = fs.readdirSync(toolPath);
        for (const child of children) {
          if (isExplicitVersion(child)) {
            const fullPath = path.join(toolPath, child, arch || "");
            if (fs.existsSync(fullPath) && fs.existsSync(`${fullPath}.complete`)) {
              versions.push(child);
            }
          }
        }
      }
      return versions;
    }
    exports2.findAllVersions = findAllVersions;
    function getManifestFromRepo(owner, repo, auth, branch = "master") {
      return __awaiter(this, void 0, void 0, function* () {
        let releases = [];
        const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}`;
        const http = new httpm.HttpClient("tool-cache");
        const headers = {};
        if (auth) {
          core.debug("set auth");
          headers.authorization = auth;
        }
        const response = yield http.getJson(treeUrl, headers);
        if (!response.result) {
          return releases;
        }
        let manifestUrl = "";
        for (const item of response.result.tree) {
          if (item.path === "versions-manifest.json") {
            manifestUrl = item.url;
            break;
          }
        }
        headers["accept"] = "application/vnd.github.VERSION.raw";
        let versionsRaw = yield (yield http.get(manifestUrl, headers)).readBody();
        if (versionsRaw) {
          versionsRaw = versionsRaw.replace(/^\uFEFF/, "");
          try {
            releases = JSON.parse(versionsRaw);
          } catch (_a) {
            core.debug("Invalid json");
          }
        }
        return releases;
      });
    }
    exports2.getManifestFromRepo = getManifestFromRepo;
    function findFromManifest(versionSpec, stable, manifest, archFilter = os2.arch()) {
      return __awaiter(this, void 0, void 0, function* () {
        const match = yield mm._findMatch(versionSpec, stable, manifest, archFilter);
        return match;
      });
    }
    exports2.findFromManifest = findFromManifest;
    function _createExtractFolder(dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!dest) {
          dest = path.join(_getTempDirectory(), v4_1.default());
        }
        yield io.mkdirP(dest);
        return dest;
      });
    }
    function _createToolPath(tool, version2, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version2) || version2, arch || "");
        core.debug(`destination ${folderPath}`);
        const markerPath = `${folderPath}.complete`;
        yield io.rmRF(folderPath);
        yield io.rmRF(markerPath);
        yield io.mkdirP(folderPath);
        return folderPath;
      });
    }
    function _completeToolPath(tool, version2, arch) {
      const folderPath = path.join(_getCacheDirectory(), tool, semver.clean(version2) || version2, arch || "");
      const markerPath = `${folderPath}.complete`;
      fs.writeFileSync(markerPath, "");
      core.debug("finished caching tool");
    }
    function isExplicitVersion(versionSpec) {
      const c = semver.clean(versionSpec) || "";
      core.debug(`isExplicit: ${c}`);
      const valid = semver.valid(c) != null;
      core.debug(`explicit? ${valid}`);
      return valid;
    }
    exports2.isExplicitVersion = isExplicitVersion;
    function evaluateVersions(versions, versionSpec) {
      let version2 = "";
      core.debug(`evaluating ${versions.length} versions`);
      versions = versions.sort((a, b) => {
        if (semver.gt(a, b)) {
          return 1;
        }
        return -1;
      });
      for (let i = versions.length - 1; i >= 0; i--) {
        const potential = versions[i];
        const satisfied = semver.satisfies(potential, versionSpec);
        if (satisfied) {
          version2 = potential;
          break;
        }
      }
      if (version2) {
        core.debug(`matched: ${version2}`);
      } else {
        core.debug("match not found");
      }
      return version2;
    }
    exports2.evaluateVersions = evaluateVersions;
    function _getCacheDirectory() {
      const cacheDirectory = process.env["RUNNER_TOOL_CACHE"] || "";
      assert_1.ok(cacheDirectory, "Expected RUNNER_TOOL_CACHE to be defined");
      return cacheDirectory;
    }
    function _getTempDirectory() {
      const tempDirectory = process.env["RUNNER_TEMP"] || "";
      assert_1.ok(tempDirectory, "Expected RUNNER_TEMP to be defined");
      return tempDirectory;
    }
    function _getGlobal(key, defaultValue) {
      const value = global[key];
      return value !== void 0 ? value : defaultValue;
    }
    function _unique(values) {
      return Array.from(new Set(values));
    }
  }
});

// node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    "use strict";
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports2, module2) {
    "use strict";
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer3) {
      if (!Buffer3.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer3[key];
    }
    safer.Buffer.prototype = Buffer3.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer3(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer3(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/reporter.js"(exports2) {
    "use strict";
    var inherits = require_inherits();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports2.Reporter = Reporter;
    Reporter.prototype.isError = function isError2(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      let err;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/buffer.js"(exports2) {
    "use strict";
    var inherits = require_inherits();
    var Reporter = require_reporter().Reporter;
    var Buffer3 = require_safer().Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer3.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports2.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && Buffer3.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty2() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!EncoderBuffer.isEncoderBuffer(item))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer3.byteLength(value);
      } else if (Buffer3.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports2.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = Buffer3.alloc(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer3.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports2, module2) {
    "use strict";
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/node.js"(exports2, module2) {
    "use strict";
    var Reporter = require_reporter().Reporter;
    var EncoderBuffer = require_buffer().EncoderBuffer;
    var DecoderBuffer = require_buffer().DecoderBuffer;
    var assert = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent, name) {
      const state = {};
      this._baseState = state;
      state.name = name;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module2.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      const state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            const value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state = this._baseState;
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode(input, options) {
      const state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        let tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          const save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          const explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
          let save;
          if (state.any)
            save = input.save();
          const body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      const state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match = false;
      Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
          const value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter, data);
          if (child._baseState.key === null)
            return reporter.error("Child should have a key");
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/der.js"(exports2) {
    "use strict";
    function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    }
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = reverse(exports2.tag);
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der2 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/der.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Buffer3 = require_safer().Buffer;
    var Node = require_node();
    var der = require_der();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer3.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i = content.length; i >= 256; i >>= 8)
        lenOctets++;
      const header = Buffer3.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = Buffer3.alloc(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s.]+/g);
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      let size = 0;
      for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      const objid = Buffer3.alloc(size);
      let offset = objid.length - 1;
      for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer3.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer3.from(numArray);
      }
      if (Buffer3.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0)
          size2++;
        const out2 = Buffer3.alloc(size2);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size = 1;
      for (let i = num; i >= 256; i >>= 8)
        size++;
      const out = new Array(size);
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer3.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      const state = this._baseState;
      let i;
      if (state["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var DEREncoder = require_der2();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module2.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/index.js"(exports2) {
    "use strict";
    var encoders = exports2;
    encoders.der = require_der2();
    encoders.pem = require_pem();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der3 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/der.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var bignum = require_bn();
    var DecoderBuffer = require_buffer().DecoderBuffer;
    var Node = require_node();
    var der = require_der();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
      }
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      const state = buffer.save();
      const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      buffer.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      const decodedTag = derDecodeTag(
        buffer,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer.isError(decodedTag))
        return decodedTag;
      let len = derDecodeLen(
        buffer,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      const state = buffer.save();
      const res = this._skipUntilEnd(
        buffer,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer.isError(res))
        return res;
      len = buffer.offset - state.offset;
      buffer.restore(state);
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      for (; ; ) {
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
        let res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      const result = [];
      while (!buffer.isEmpty()) {
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i = 0; i < raw.length / 2; i++) {
          str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer.raw();
      } else if (tag === "objDesc") {
        return buffer.raw();
      } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
      } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer.isEmpty()) {
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      const str = buffer.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      const res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      const raw = buffer.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      let tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      const cls = der.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      let len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len |= j;
      }
      return len;
    }
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Buffer3 = require_safer().Buffer;
    var DERDecoder = require_der3();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module2.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i;
        } else {
          if (match[1] !== "END")
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer3.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/index.js"(exports2) {
    "use strict";
    var decoders = exports2;
    decoders.der = require_der3();
    decoders.pem = require_pem2();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/api.js
var require_api2 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/api.js"(exports2) {
    "use strict";
    var encoders = require_encoders();
    var decoders = require_decoders();
    var inherits = require_inherits();
    var api = exports2;
    api.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(Base) {
      const name = this.name;
      function Generated(entity) {
        this._initNamed(entity, name);
      }
      inherits(Generated, Base);
      Generated.prototype._initNamed = function _initNamed(entity, name2) {
        Base.call(this, entity, name2);
      };
      return new Generated(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/index.js
var require_base = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/index.js"(exports2) {
    "use strict";
    var base = exports2;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer().DecoderBuffer;
    base.EncoderBuffer = require_buffer().EncoderBuffer;
    base.Node = require_node();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants5 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/index.js"(exports2) {
    "use strict";
    var constants = exports2;
    constants._reverse = function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1.js"(exports2) {
    "use strict";
    var asn1 = exports2;
    asn1.bignum = require_bn();
    asn1.define = require_api2().define;
    asn1.base = require_base();
    asn1.constants = require_constants5();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/.pnpm/openpgp@5.11.0/node_modules/openpgp/dist/node/openpgp.min.js
var require_openpgp_min = __commonJS({
  "node_modules/.pnpm/openpgp@5.11.0/node_modules/openpgp/dist/node/openpgp.min.js"(exports2) {
    "use strict";
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    Object.defineProperty(exports2, "__esModule", { value: true });
    var t = require("buffer");
    var r = require("stream");
    var i = require("crypto");
    var n = require("zlib");
    var a = require("os");
    var s = require("util");
    var o = require_asn1();
    function c(e2) {
      return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
    }
    var u = /* @__PURE__ */ c(t);
    var h = /* @__PURE__ */ c(r);
    var d = /* @__PURE__ */ c(i);
    var f = /* @__PURE__ */ c(n);
    var l = /* @__PURE__ */ c(a);
    var p = /* @__PURE__ */ c(s);
    var y = /* @__PURE__ */ c(o);
    var b = Symbol("doneWritingPromise");
    var g = Symbol("doneWritingResolve");
    var m = Symbol("doneWritingReject");
    var w = Symbol("readingIndex");
    var v = class extends Array {
      constructor() {
        super(), this[b] = new Promise((e2, t2) => {
          this[g] = e2, this[m] = t2;
        }), this[b].catch(() => {
        });
      }
    };
    function _(e2) {
      return e2 && e2.getReader && Array.isArray(e2);
    }
    function k(e2) {
      if (!_(e2)) {
        const t2 = e2.getWriter(), r2 = t2.releaseLock;
        return t2.releaseLock = () => {
          t2.closed.catch(function() {
          }), r2.call(t2);
        }, t2;
      }
      this.stream = e2;
    }
    v.prototype.getReader = function() {
      return void 0 === this[w] && (this[w] = 0), { read: async () => (await this[b], this[w] === this.length ? { value: void 0, done: true } : { value: this[this[w]++], done: false }) };
    }, v.prototype.readToEnd = async function(e2) {
      await this[b];
      const t2 = e2(this.slice(this[w]));
      return this.length = 0, t2;
    }, v.prototype.clone = function() {
      const e2 = new v();
      return e2[b] = this[b].then(() => {
        e2.push(...this);
      }), e2;
    }, k.prototype.write = async function(e2) {
      this.stream.push(e2);
    }, k.prototype.close = async function() {
      this.stream[g]();
    }, k.prototype.abort = async function(e2) {
      return this.stream[m](e2), e2;
    }, k.prototype.releaseLock = function() {
    };
    var A = "object" == typeof e.process && "object" == typeof e.process.versions;
    var S = A && h.default.Readable;
    function E(t2) {
      return _(t2) ? "array" : e.ReadableStream && e.ReadableStream.prototype.isPrototypeOf(t2) ? "web" : z && z.prototype.isPrototypeOf(t2) ? "ponyfill" : S && S.prototype.isPrototypeOf(t2) ? "node" : !(!t2 || !t2.getReader) && "web-like";
    }
    function P(e2) {
      return Uint8Array.prototype.isPrototypeOf(e2);
    }
    function x(e2) {
      if (1 === e2.length)
        return e2[0];
      let t2 = 0;
      for (let r3 = 0; r3 < e2.length; r3++) {
        if (!P(e2[r3]))
          throw Error("concatUint8Array: Data must be in the form of a Uint8Array");
        t2 += e2[r3].length;
      }
      const r2 = new Uint8Array(t2);
      let i2 = 0;
      return e2.forEach(function(e3) {
        r2.set(e3, i2), i2 += e3.length;
      }), r2;
    }
    var M = A && u.default.Buffer;
    var K = A && h.default.Readable;
    var C;
    var D;
    if (K) {
      C = function(e3) {
        let t2 = false;
        return new z({ start(r2) {
          e3.pause(), e3.on("data", (i2) => {
            t2 || (M.isBuffer(i2) && (i2 = new Uint8Array(i2.buffer, i2.byteOffset, i2.byteLength)), r2.enqueue(i2), e3.pause());
          }), e3.on("end", () => {
            t2 || r2.close();
          }), e3.on("error", (e4) => r2.error(e4));
        }, pull() {
          e3.resume();
        }, cancel(r2) {
          t2 = true, e3.destroy(r2);
        } });
      };
      class e2 extends K {
        constructor(e3, t2) {
          super(t2), this._reader = W(e3);
        }
        async _read(e3) {
          try {
            for (; ; ) {
              const { done: e4, value: t2 } = await this._reader.read();
              if (e4) {
                this.push(null);
                break;
              }
              if (!this.push(t2))
                break;
            }
          } catch (e4) {
            this.destroy(e4);
          }
        }
        async _destroy(e3, t2) {
          this._reader.cancel(e3).then(t2, t2);
        }
      }
      D = function(t2, r2) {
        return new e2(t2, r2);
      };
    }
    var U = /* @__PURE__ */ new WeakSet();
    var R = Symbol("externalBuffer");
    function I(e2) {
      if (this.stream = e2, e2[R] && (this[R] = e2[R].slice()), _(e2)) {
        const t3 = e2.getReader();
        return this._read = t3.read.bind(t3), this._releaseLock = () => {
        }, void (this._cancel = async () => {
        });
      }
      let t2 = E(e2);
      if ("node" === t2 && (e2 = C(e2)), t2) {
        const t3 = e2.getReader();
        return this._read = t3.read.bind(t3), this._releaseLock = () => {
          t3.closed.catch(function() {
          }), t3.releaseLock();
        }, void (this._cancel = t3.cancel.bind(t3));
      }
      let r2 = false;
      this._read = async () => r2 || U.has(e2) ? { value: void 0, done: true } : (r2 = true, { value: e2, done: false }), this._releaseLock = () => {
        if (r2)
          try {
            U.add(e2);
          } catch (e3) {
          }
      };
    }
    I.prototype.read = async function() {
      if (this[R] && this[R].length) {
        return { done: false, value: this[R].shift() };
      }
      return this._read();
    }, I.prototype.releaseLock = function() {
      this[R] && (this.stream[R] = this[R]), this._releaseLock();
    }, I.prototype.cancel = function(e2) {
      return this._cancel(e2);
    }, I.prototype.readLine = async function() {
      let e2, t2 = [];
      for (; !e2; ) {
        let { done: r2, value: i2 } = await this.read();
        if (i2 += "", r2)
          return t2.length ? H(t2) : void 0;
        const n2 = i2.indexOf("\n") + 1;
        n2 && (e2 = H(t2.concat(i2.substr(0, n2))), t2 = []), n2 !== i2.length && t2.push(i2.substr(n2));
      }
      return this.unshift(...t2), e2;
    }, I.prototype.readByte = async function() {
      const { done: e2, value: t2 } = await this.read();
      if (e2)
        return;
      const r2 = t2[0];
      return this.unshift(re(t2, 1)), r2;
    }, I.prototype.readBytes = async function(e2) {
      const t2 = [];
      let r2 = 0;
      for (; ; ) {
        const { done: i2, value: n2 } = await this.read();
        if (i2)
          return t2.length ? H(t2) : void 0;
        if (t2.push(n2), r2 += n2.length, r2 >= e2) {
          const r3 = H(t2);
          return this.unshift(re(r3, e2)), re(r3, 0, e2);
        }
      }
    }, I.prototype.peekBytes = async function(e2) {
      const t2 = await this.readBytes(e2);
      return this.unshift(t2), t2;
    }, I.prototype.unshift = function(...e2) {
      this[R] || (this[R] = []), 1 === e2.length && P(e2[0]) && this[R].length && e2[0].length && this[R][0].byteOffset >= e2[0].length ? this[R][0] = new Uint8Array(this[R][0].buffer, this[R][0].byteOffset - e2[0].length, this[R][0].byteLength + e2[0].length) : this[R].unshift(...e2.filter((e3) => e3 && e3.length));
    }, I.prototype.readToEnd = async function(e2 = H) {
      const t2 = [];
      for (; ; ) {
        const { done: e3, value: r2 } = await this.read();
        if (e3)
          break;
        t2.push(r2);
      }
      return e2(t2);
    };
    var B;
    var T;
    var { ReadableStream: z, WritableStream: q, TransformStream: F } = e;
    async function O() {
      if (F)
        return;
      const [t2, r2] = await Promise.all([Promise.resolve().then(function() {
        return Cp;
      }), Promise.resolve().then(function() {
        return Yp;
      })]);
      ({ ReadableStream: z, WritableStream: q, TransformStream: F } = t2);
      const { createReadableStreamWrapper: i2 } = r2;
      e.ReadableStream && z !== e.ReadableStream && (B = i2(z), T = i2(e.ReadableStream));
    }
    var L = A && u.default.Buffer;
    function N(e2) {
      let t2 = E(e2);
      return "node" === t2 ? C(e2) : "web" === t2 && B ? B(e2) : t2 ? e2 : new z({ start(t3) {
        t3.enqueue(e2), t3.close();
      } });
    }
    function j(e2) {
      if (E(e2))
        return e2;
      const t2 = new v();
      return (async () => {
        const r2 = G(t2);
        await r2.write(e2), await r2.close();
      })(), t2;
    }
    function H(e2) {
      return e2.some((e3) => E(e3) && !_(e3)) ? function(e3) {
        e3 = e3.map(N);
        const t2 = Z(async function(e4) {
          await Promise.all(i2.map((t3) => ne(t3, e4)));
        });
        let r2 = Promise.resolve();
        const i2 = e3.map((i3, n2) => Y(i3, (i4, a2) => (r2 = r2.then(() => V(i4, t2.writable, { preventClose: n2 !== e3.length - 1 })), r2)));
        return t2.readable;
      }(e2) : e2.some((e3) => _(e3)) ? function(e3) {
        const t2 = new v();
        let r2 = Promise.resolve();
        return e3.forEach((i2, n2) => (r2 = r2.then(() => V(i2, t2, { preventClose: n2 !== e3.length - 1 })), r2)), t2;
      }(e2) : "string" == typeof e2[0] ? e2.join("") : L && L.isBuffer(e2[0]) ? L.concat(e2) : x(e2);
    }
    function W(e2) {
      return new I(e2);
    }
    function G(e2) {
      return new k(e2);
    }
    async function V(e2, t2, { preventClose: r2 = false, preventAbort: i2 = false, preventCancel: n2 = false } = {}) {
      if (E(e2) && !_(e2)) {
        e2 = N(e2);
        try {
          if (e2[R]) {
            const r3 = G(t2);
            for (let t3 = 0; t3 < e2[R].length; t3++)
              await r3.ready, await r3.write(e2[R][t3]);
            r3.releaseLock();
          }
          await e2.pipeTo(t2, { preventClose: r2, preventAbort: i2, preventCancel: n2 });
        } catch (e3) {
        }
        return;
      }
      const a2 = W(e2 = j(e2)), s2 = G(t2);
      try {
        for (; ; ) {
          await s2.ready;
          const { done: e3, value: t3 } = await a2.read();
          if (e3) {
            r2 || await s2.close();
            break;
          }
          await s2.write(t3);
        }
      } catch (e3) {
        i2 || await s2.abort(e3);
      } finally {
        a2.releaseLock(), s2.releaseLock();
      }
    }
    function $(e2, t2) {
      const r2 = new F(t2);
      return V(e2, r2.writable), r2.readable;
    }
    function Z(e2) {
      let t2, r2, i2 = false;
      return { readable: new z({ start(e3) {
        r2 = e3;
      }, pull() {
        t2 ? t2() : i2 = true;
      }, cancel: e2 }, { highWaterMark: 0 }), writable: new q({ write: async function(e3) {
        r2.enqueue(e3), i2 ? i2 = false : (await new Promise((e4) => {
          t2 = e4;
        }), t2 = null);
      }, close: r2.close.bind(r2), abort: r2.error.bind(r2) }) };
    }
    function X(e2, t2 = () => {
    }, r2 = () => {
    }) {
      if (_(e2)) {
        const i3 = new v();
        return (async () => {
          const n3 = G(i3);
          try {
            const i4 = await ie(e2), a2 = t2(i4), s2 = r2();
            let o2;
            o2 = void 0 !== a2 && void 0 !== s2 ? H([a2, s2]) : void 0 !== a2 ? a2 : s2, await n3.write(o2), await n3.close();
          } catch (e3) {
            await n3.abort(e3);
          }
        })(), i3;
      }
      if (E(e2))
        return $(e2, { async transform(e3, r3) {
          try {
            const i3 = await t2(e3);
            void 0 !== i3 && r3.enqueue(i3);
          } catch (e4) {
            r3.error(e4);
          }
        }, async flush(e3) {
          try {
            const t3 = await r2();
            void 0 !== t3 && e3.enqueue(t3);
          } catch (t3) {
            e3.error(t3);
          }
        } });
      const i2 = t2(e2), n2 = r2();
      return void 0 !== i2 && void 0 !== n2 ? H([i2, n2]) : void 0 !== i2 ? i2 : n2;
    }
    function Y(e2, t2) {
      if (E(e2) && !_(e2)) {
        let r3;
        const i2 = new F({ start(e3) {
          r3 = e3;
        } }), n2 = V(e2, i2.writable), a2 = Z(async function(e3) {
          r3.error(e3), await n2, await new Promise(setTimeout);
        });
        return t2(i2.readable, a2.writable), a2.readable;
      }
      e2 = j(e2);
      const r2 = new v();
      return t2(e2, r2), r2;
    }
    function Q(e2, t2) {
      let r2;
      const i2 = Y(e2, (e3, n2) => {
        const a2 = W(e3);
        a2.remainder = () => (a2.releaseLock(), V(e3, n2), i2), r2 = t2(a2);
      });
      return r2;
    }
    function J(e2) {
      if (_(e2))
        return e2.clone();
      if (E(e2)) {
        const t2 = function(e3) {
          if (_(e3))
            throw Error("ArrayStream cannot be tee()d, use clone() instead");
          if (E(e3)) {
            const t3 = N(e3).tee();
            return t3[0][R] = t3[1][R] = e3[R], t3;
          }
          return [re(e3), re(e3)];
        }(e2);
        return te(e2, t2[0]), t2[1];
      }
      return re(e2);
    }
    function ee(e2) {
      return _(e2) ? J(e2) : E(e2) ? new z({ start(t2) {
        const r2 = Y(e2, async (e3, r3) => {
          const i2 = W(e3), n2 = G(r3);
          try {
            for (; ; ) {
              await n2.ready;
              const { done: e4, value: r4 } = await i2.read();
              if (e4) {
                try {
                  t2.close();
                } catch (e5) {
                }
                return void await n2.close();
              }
              try {
                t2.enqueue(r4);
              } catch (e5) {
              }
              await n2.write(r4);
            }
          } catch (e4) {
            t2.error(e4), await n2.abort(e4);
          }
        });
        te(e2, r2);
      } }) : re(e2);
    }
    function te(e2, t2) {
      Object.entries(Object.getOwnPropertyDescriptors(e2.constructor.prototype)).forEach(([r2, i2]) => {
        "constructor" !== r2 && (i2.value ? i2.value = i2.value.bind(t2) : i2.get = i2.get.bind(t2), Object.defineProperty(e2, r2, i2));
      });
    }
    function re(e2, t2 = 0, r2 = 1 / 0) {
      if (_(e2))
        throw Error("Not implemented");
      if (E(e2)) {
        if (t2 >= 0 && r2 >= 0) {
          let i2 = 0;
          return $(e2, { transform(e3, n2) {
            i2 < r2 ? (i2 + e3.length >= t2 && n2.enqueue(re(e3, Math.max(t2 - i2, 0), r2 - i2)), i2 += e3.length) : n2.terminate();
          } });
        }
        if (t2 < 0 && (r2 < 0 || r2 === 1 / 0)) {
          let i2 = [];
          return X(e2, (e3) => {
            e3.length >= -t2 ? i2 = [e3] : i2.push(e3);
          }, () => re(H(i2), t2, r2));
        }
        if (0 === t2 && r2 < 0) {
          let i2;
          return X(e2, (e3) => {
            const n2 = i2 ? H([i2, e3]) : e3;
            if (n2.length >= -r2)
              return i2 = re(n2, r2), re(n2, t2, r2);
            i2 = n2;
          });
        }
        return console.warn(`stream.slice(input, ${t2}, ${r2}) not implemented efficiently.`), ae(async () => re(await ie(e2), t2, r2));
      }
      return e2[R] && (e2 = H(e2[R].concat([e2]))), !P(e2) || L && L.isBuffer(e2) ? e2.slice(t2, r2) : (r2 === 1 / 0 && (r2 = e2.length), e2.subarray(t2, r2));
    }
    async function ie(e2, t2 = H) {
      return _(e2) ? e2.readToEnd(t2) : E(e2) ? W(e2).readToEnd(t2) : e2;
    }
    async function ne(e2, t2) {
      if (E(e2)) {
        if (e2.cancel)
          return e2.cancel(t2);
        if (e2.destroy)
          return e2.destroy(t2), await new Promise(setTimeout), t2;
      }
    }
    function ae(e2) {
      const t2 = new v();
      return (async () => {
        const r2 = G(t2);
        try {
          await r2.write(await e2()), await r2.close();
        } catch (e3) {
          await r2.abort(e3);
        }
      })(), t2;
    }
    var se = class _se {
      constructor(e2) {
        if (void 0 === e2)
          throw Error("Invalid BigInteger input");
        if (e2 instanceof Uint8Array) {
          const t2 = e2, r2 = Array(t2.length);
          for (let e3 = 0; e3 < t2.length; e3++) {
            const i2 = t2[e3].toString(16);
            r2[e3] = t2[e3] <= 15 ? "0" + i2 : i2;
          }
          this.value = BigInt("0x0" + r2.join(""));
        } else
          this.value = BigInt(e2);
      }
      clone() {
        return new _se(this.value);
      }
      iinc() {
        return this.value++, this;
      }
      inc() {
        return this.clone().iinc();
      }
      idec() {
        return this.value--, this;
      }
      dec() {
        return this.clone().idec();
      }
      iadd(e2) {
        return this.value += e2.value, this;
      }
      add(e2) {
        return this.clone().iadd(e2);
      }
      isub(e2) {
        return this.value -= e2.value, this;
      }
      sub(e2) {
        return this.clone().isub(e2);
      }
      imul(e2) {
        return this.value *= e2.value, this;
      }
      mul(e2) {
        return this.clone().imul(e2);
      }
      imod(e2) {
        return this.value %= e2.value, this.isNegative() && this.iadd(e2), this;
      }
      mod(e2) {
        return this.clone().imod(e2);
      }
      modExp(e2, t2) {
        if (t2.isZero())
          throw Error("Modulo cannot be zero");
        if (t2.isOne())
          return new _se(0);
        if (e2.isNegative())
          throw Error("Unsopported negative exponent");
        let r2 = e2.value, i2 = this.value;
        i2 %= t2.value;
        let n2 = BigInt(1);
        for (; r2 > BigInt(0); ) {
          const e3 = r2 & BigInt(1);
          r2 >>= BigInt(1);
          const a2 = n2 * i2 % t2.value;
          n2 = e3 ? a2 : n2, i2 = i2 * i2 % t2.value;
        }
        return new _se(n2);
      }
      modInv(e2) {
        const { gcd: t2, x: r2 } = this._egcd(e2);
        if (!t2.isOne())
          throw Error("Inverse does not exist");
        return r2.add(e2).mod(e2);
      }
      _egcd(e2) {
        let t2 = BigInt(0), r2 = BigInt(1), i2 = BigInt(1), n2 = BigInt(0), a2 = this.value;
        for (e2 = e2.value; e2 !== BigInt(0); ) {
          const s2 = a2 / e2;
          let o2 = t2;
          t2 = i2 - s2 * t2, i2 = o2, o2 = r2, r2 = n2 - s2 * r2, n2 = o2, o2 = e2, e2 = a2 % e2, a2 = o2;
        }
        return { x: new _se(i2), y: new _se(n2), gcd: new _se(a2) };
      }
      gcd(e2) {
        let t2 = this.value;
        for (e2 = e2.value; e2 !== BigInt(0); ) {
          const r2 = e2;
          e2 = t2 % e2, t2 = r2;
        }
        return new _se(t2);
      }
      ileftShift(e2) {
        return this.value <<= e2.value, this;
      }
      leftShift(e2) {
        return this.clone().ileftShift(e2);
      }
      irightShift(e2) {
        return this.value >>= e2.value, this;
      }
      rightShift(e2) {
        return this.clone().irightShift(e2);
      }
      equal(e2) {
        return this.value === e2.value;
      }
      lt(e2) {
        return this.value < e2.value;
      }
      lte(e2) {
        return this.value <= e2.value;
      }
      gt(e2) {
        return this.value > e2.value;
      }
      gte(e2) {
        return this.value >= e2.value;
      }
      isZero() {
        return this.value === BigInt(0);
      }
      isOne() {
        return this.value === BigInt(1);
      }
      isNegative() {
        return this.value < BigInt(0);
      }
      isEven() {
        return !(this.value & BigInt(1));
      }
      abs() {
        const e2 = this.clone();
        return this.isNegative() && (e2.value = -e2.value), e2;
      }
      toString() {
        return this.value.toString();
      }
      toNumber() {
        const e2 = Number(this.value);
        if (e2 > Number.MAX_SAFE_INTEGER)
          throw Error("Number can only safely store up to 53 bits");
        return e2;
      }
      getBit(e2) {
        return (this.value >> BigInt(e2) & BigInt(1)) === BigInt(0) ? 0 : 1;
      }
      bitLength() {
        const e2 = new _se(0), t2 = new _se(1), r2 = new _se(-1), i2 = this.isNegative() ? r2 : e2;
        let n2 = 1;
        const a2 = this.clone();
        for (; !a2.irightShift(t2).equal(i2); )
          n2++;
        return n2;
      }
      byteLength() {
        const e2 = new _se(0), t2 = new _se(-1), r2 = this.isNegative() ? t2 : e2, i2 = new _se(8);
        let n2 = 1;
        const a2 = this.clone();
        for (; !a2.irightShift(i2).equal(r2); )
          n2++;
        return n2;
      }
      toUint8Array(e2 = "be", t2) {
        let r2 = this.value.toString(16);
        r2.length % 2 == 1 && (r2 = "0" + r2);
        const i2 = r2.length / 2, n2 = new Uint8Array(t2 || i2), a2 = t2 ? t2 - i2 : 0;
        let s2 = 0;
        for (; s2 < i2; )
          n2[s2 + a2] = parseInt(r2.slice(2 * s2, 2 * s2 + 2), 16), s2++;
        return "be" !== e2 && n2.reverse(), n2;
      }
    };
    var oe = () => "undefined" != typeof BigInt;
    var ce = Symbol("byValue");
    var ue = { curve: { p256: "p256", "P-256": "p256", secp256r1: "p256", prime256v1: "p256", "1.2.840.10045.3.1.7": "p256", "2a8648ce3d030107": "p256", "2A8648CE3D030107": "p256", p384: "p384", "P-384": "p384", secp384r1: "p384", "1.3.132.0.34": "p384", "2b81040022": "p384", "2B81040022": "p384", p521: "p521", "P-521": "p521", secp521r1: "p521", "1.3.132.0.35": "p521", "2b81040023": "p521", "2B81040023": "p521", secp256k1: "secp256k1", "1.3.132.0.10": "secp256k1", "2b8104000a": "secp256k1", "2B8104000A": "secp256k1", ed25519Legacy: "ed25519", ED25519: "ed25519", ed25519: "ed25519", Ed25519: "ed25519", "1.3.6.1.4.1.11591.15.1": "ed25519", "2b06010401da470f01": "ed25519", "2B06010401DA470F01": "ed25519", curve25519Legacy: "curve25519", X25519: "curve25519", cv25519: "curve25519", curve25519: "curve25519", Curve25519: "curve25519", "1.3.6.1.4.1.3029.1.5.1": "curve25519", "2b060104019755010501": "curve25519", "2B060104019755010501": "curve25519", brainpoolP256r1: "brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1", "2b2403030208010107": "brainpoolP256r1", "2B2403030208010107": "brainpoolP256r1", brainpoolP384r1: "brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1", "2b240303020801010b": "brainpoolP384r1", "2B240303020801010B": "brainpoolP384r1", brainpoolP512r1: "brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1", "2b240303020801010d": "brainpoolP512r1", "2B240303020801010D": "brainpoolP512r1" }, s2k: { simple: 0, salted: 1, iterated: 3, gnu: 101 }, publicKey: { rsaEncryptSign: 1, rsaEncrypt: 2, rsaSign: 3, elgamal: 16, dsa: 17, ecdh: 18, ecdsa: 19, eddsaLegacy: 22, ed25519Legacy: 22, eddsa: 22, aedh: 23, aedsa: 24, x25519: 25, x448: 26, ed25519: 27, ed448: 28 }, symmetric: { plaintext: 0, idea: 1, tripledes: 2, cast5: 3, blowfish: 4, aes128: 7, aes192: 8, aes256: 9, twofish: 10 }, compression: { uncompressed: 0, zip: 1, zlib: 2, bzip2: 3 }, hash: { md5: 1, sha1: 2, ripemd: 3, sha256: 8, sha384: 9, sha512: 10, sha224: 11 }, webHash: { "SHA-1": 2, "SHA-256": 8, "SHA-384": 9, "SHA-512": 10 }, aead: { eax: 1, ocb: 2, experimentalGCM: 100 }, packet: { publicKeyEncryptedSessionKey: 1, signature: 2, symEncryptedSessionKey: 3, onePassSignature: 4, secretKey: 5, publicKey: 6, secretSubkey: 7, compressedData: 8, symmetricallyEncryptedData: 9, marker: 10, literalData: 11, trust: 12, userID: 13, publicSubkey: 14, userAttribute: 17, symEncryptedIntegrityProtectedData: 18, modificationDetectionCode: 19, aeadEncryptedData: 20 }, literal: { binary: 98, text: 116, utf8: 117, mime: 109 }, signature: { binary: 0, text: 1, standalone: 2, certGeneric: 16, certPersona: 17, certCasual: 18, certPositive: 19, certRevocation: 48, subkeyBinding: 24, keyBinding: 25, key: 31, keyRevocation: 32, subkeyRevocation: 40, timestamp: 64, thirdParty: 80 }, signatureSubpacket: { signatureCreationTime: 2, signatureExpirationTime: 3, exportableCertification: 4, trustSignature: 5, regularExpression: 6, revocable: 7, keyExpirationTime: 9, placeholderBackwardsCompatibility: 10, preferredSymmetricAlgorithms: 11, revocationKey: 12, issuer: 16, notationData: 20, preferredHashAlgorithms: 21, preferredCompressionAlgorithms: 22, keyServerPreferences: 23, preferredKeyServer: 24, primaryUserID: 25, policyURI: 26, keyFlags: 27, signersUserID: 28, reasonForRevocation: 29, features: 30, signatureTarget: 31, embeddedSignature: 32, issuerFingerprint: 33, preferredAEADAlgorithms: 34 }, keyFlags: { certifyKeys: 1, signData: 2, encryptCommunication: 4, encryptStorage: 8, splitPrivateKey: 16, authentication: 32, sharedPrivateKey: 128 }, armor: { multipartSection: 0, multipartLast: 1, signed: 2, message: 3, publicKey: 4, privateKey: 5, signature: 6 }, reasonForRevocation: { noReason: 0, keySuperseded: 1, keyCompromised: 2, keyRetired: 3, userIDInvalid: 32 }, features: { modificationDetection: 1, aead: 2, v5Keys: 4 }, write: function(e2, t2) {
      if ("number" == typeof t2 && (t2 = this.read(e2, t2)), void 0 !== e2[t2])
        return e2[t2];
      throw Error("Invalid enum value.");
    }, read: function(e2, t2) {
      if (e2[ce] || (e2[ce] = [], Object.entries(e2).forEach(([t3, r2]) => {
        e2[ce][r2] = t3;
      })), void 0 !== e2[ce][t2])
        return e2[ce][t2];
      throw Error("Invalid enum value.");
    } };
    var he = (() => {
      try {
        return "development" === process.env.NODE_ENV;
      } catch (e2) {
      }
      return false;
    })();
    var de = { isString: function(e2) {
      return "string" == typeof e2 || e2 instanceof String;
    }, isArray: function(e2) {
      return e2 instanceof Array;
    }, isUint8Array: P, isStream: E, readNumber: function(e2) {
      let t2 = 0;
      for (let r2 = 0; r2 < e2.length; r2++)
        t2 += 256 ** r2 * e2[e2.length - 1 - r2];
      return t2;
    }, writeNumber: function(e2, t2) {
      const r2 = new Uint8Array(t2);
      for (let i2 = 0; i2 < t2; i2++)
        r2[i2] = e2 >> 8 * (t2 - i2 - 1) & 255;
      return r2;
    }, readDate: function(e2) {
      const t2 = de.readNumber(e2);
      return new Date(1e3 * t2);
    }, writeDate: function(e2) {
      const t2 = Math.floor(e2.getTime() / 1e3);
      return de.writeNumber(t2, 4);
    }, normalizeDate: function(e2 = Date.now()) {
      return null === e2 || e2 === 1 / 0 ? e2 : new Date(1e3 * Math.floor(+e2 / 1e3));
    }, readMPI: function(e2) {
      const t2 = (e2[0] << 8 | e2[1]) + 7 >>> 3;
      return e2.subarray(2, 2 + t2);
    }, leftPad(e2, t2) {
      const r2 = new Uint8Array(t2), i2 = t2 - e2.length;
      return r2.set(e2, i2), r2;
    }, uint8ArrayToMPI: function(e2) {
      const t2 = de.uint8ArrayBitLength(e2);
      if (0 === t2)
        throw Error("Zero MPI");
      const r2 = e2.subarray(e2.length - Math.ceil(t2 / 8)), i2 = new Uint8Array([(65280 & t2) >> 8, 255 & t2]);
      return de.concatUint8Array([i2, r2]);
    }, uint8ArrayBitLength: function(e2) {
      let t2;
      for (t2 = 0; t2 < e2.length && 0 === e2[t2]; t2++)
        ;
      if (t2 === e2.length)
        return 0;
      const r2 = e2.subarray(t2);
      return 8 * (r2.length - 1) + de.nbits(r2[0]);
    }, hexToUint8Array: function(e2) {
      const t2 = new Uint8Array(e2.length >> 1);
      for (let r2 = 0; r2 < e2.length >> 1; r2++)
        t2[r2] = parseInt(e2.substr(r2 << 1, 2), 16);
      return t2;
    }, uint8ArrayToHex: function(e2) {
      const t2 = [], r2 = e2.length;
      let i2, n2 = 0;
      for (; n2 < r2; ) {
        for (i2 = e2[n2++].toString(16); i2.length < 2; )
          i2 = "0" + i2;
        t2.push("" + i2);
      }
      return t2.join("");
    }, stringToUint8Array: function(e2) {
      return X(e2, (e3) => {
        if (!de.isString(e3))
          throw Error("stringToUint8Array: Data must be in the form of a string");
        const t2 = new Uint8Array(e3.length);
        for (let r2 = 0; r2 < e3.length; r2++)
          t2[r2] = e3.charCodeAt(r2);
        return t2;
      });
    }, uint8ArrayToString: function(e2) {
      const t2 = [], r2 = 16384, i2 = (e2 = new Uint8Array(e2)).length;
      for (let n2 = 0; n2 < i2; n2 += r2)
        t2.push(String.fromCharCode.apply(String, e2.subarray(n2, n2 + r2 < i2 ? n2 + r2 : i2)));
      return t2.join("");
    }, encodeUTF8: function(e2) {
      const t2 = new TextEncoder("utf-8");
      function r2(e3, r3 = false) {
        return t2.encode(e3, { stream: !r3 });
      }
      return X(e2, r2, () => r2("", true));
    }, decodeUTF8: function(e2) {
      const t2 = new TextDecoder("utf-8");
      function r2(e3, r3 = false) {
        return t2.decode(e3, { stream: !r3 });
      }
      return X(e2, r2, () => r2(new Uint8Array(), true));
    }, concat: H, concatUint8Array: x, equalsUint8Array: function(e2, t2) {
      if (!de.isUint8Array(e2) || !de.isUint8Array(t2))
        throw Error("Data must be in the form of a Uint8Array");
      if (e2.length !== t2.length)
        return false;
      for (let r2 = 0; r2 < e2.length; r2++)
        if (e2[r2] !== t2[r2])
          return false;
      return true;
    }, writeChecksum: function(e2) {
      let t2 = 0;
      for (let r2 = 0; r2 < e2.length; r2++)
        t2 = t2 + e2[r2] & 65535;
      return de.writeNumber(t2, 2);
    }, printDebug: function(e2) {
      he && console.log("[OpenPGP.js debug]", e2);
    }, printDebugError: function(e2) {
      he && console.error("[OpenPGP.js debug]", e2);
    }, nbits: function(e2) {
      let t2 = 1, r2 = e2 >>> 16;
      return 0 !== r2 && (e2 = r2, t2 += 16), r2 = e2 >> 8, 0 !== r2 && (e2 = r2, t2 += 8), r2 = e2 >> 4, 0 !== r2 && (e2 = r2, t2 += 4), r2 = e2 >> 2, 0 !== r2 && (e2 = r2, t2 += 2), r2 = e2 >> 1, 0 !== r2 && (e2 = r2, t2 += 1), t2;
    }, double: function(e2) {
      const t2 = new Uint8Array(e2.length), r2 = e2.length - 1;
      for (let i2 = 0; i2 < r2; i2++)
        t2[i2] = e2[i2] << 1 ^ e2[i2 + 1] >> 7;
      return t2[r2] = e2[r2] << 1 ^ 135 * (e2[0] >> 7), t2;
    }, shiftRight: function(e2, t2) {
      if (t2)
        for (let r2 = e2.length - 1; r2 >= 0; r2--)
          e2[r2] >>= t2, r2 > 0 && (e2[r2] |= e2[r2 - 1] << 8 - t2);
      return e2;
    }, getWebCrypto: function() {
      return void 0 !== e && e.crypto && e.crypto.subtle;
    }, getBigInteger: async function() {
      if (oe())
        return se;
      {
        const { default: e2 } = await Promise.resolve().then(function() {
          return ry;
        });
        return e2;
      }
    }, getNodeCrypto: function() {
      return d.default;
    }, getNodeZlib: function() {
      return f.default;
    }, getNodeBuffer: function() {
      return (u.default || {}).Buffer;
    }, getHardwareConcurrency: function() {
      if ("undefined" != typeof navigator)
        return navigator.hardwareConcurrency || 1;
      return l.default.cpus().length;
    }, isEmailAddress: function(e2) {
      if (!de.isString(e2))
        return false;
      return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+([a-zA-Z]{2,}[0-9]*|xn--[a-zA-Z\-0-9]+)))$/.test(e2);
    }, canonicalizeEOL: function(e2) {
      let t2 = false;
      return X(e2, (e3) => {
        let r2;
        t2 && (e3 = de.concatUint8Array([new Uint8Array([13]), e3])), 13 === e3[e3.length - 1] ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
        const i2 = [];
        for (let t3 = 0; r2 = e3.indexOf(10, t3) + 1, r2; t3 = r2)
          13 !== e3[r2 - 2] && i2.push(r2);
        if (!i2.length)
          return e3;
        const n2 = new Uint8Array(e3.length + i2.length);
        let a2 = 0;
        for (let t3 = 0; t3 < i2.length; t3++) {
          const r3 = e3.subarray(i2[t3 - 1] || 0, i2[t3]);
          n2.set(r3, a2), a2 += r3.length, n2[a2 - 1] = 13, n2[a2] = 10, a2++;
        }
        return n2.set(e3.subarray(i2[i2.length - 1] || 0), a2), n2;
      }, () => t2 ? new Uint8Array([13]) : void 0);
    }, nativeEOL: function(e2) {
      let t2 = false;
      return X(e2, (e3) => {
        let r2;
        13 === (e3 = t2 && 10 !== e3[0] ? de.concatUint8Array([new Uint8Array([13]), e3]) : new Uint8Array(e3))[e3.length - 1] ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
        let i2 = 0;
        for (let t3 = 0; t3 !== e3.length; t3 = r2) {
          r2 = e3.indexOf(13, t3) + 1, r2 || (r2 = e3.length);
          const n2 = r2 - (10 === e3[r2] ? 1 : 0);
          t3 && e3.copyWithin(i2, t3, n2), i2 += n2 - t3;
        }
        return e3.subarray(0, i2);
      }, () => t2 ? new Uint8Array([13]) : void 0);
    }, removeTrailingSpaces: function(e2) {
      return e2.split("\n").map((e3) => {
        let t2 = e3.length - 1;
        for (; t2 >= 0 && (" " === e3[t2] || "	" === e3[t2] || "\r" === e3[t2]); t2--)
          ;
        return e3.substr(0, t2 + 1);
      }).join("\n");
    }, wrapError: function(e2, t2) {
      if (!t2)
        return Error(e2);
      try {
        t2.message = e2 + ": " + t2.message;
      } catch (e3) {
      }
      return t2;
    }, constructAllowedPackets: function(e2) {
      const t2 = {};
      return e2.forEach((e3) => {
        if (!e3.tag)
          throw Error("Invalid input: expected a packet class");
        t2[e3.tag] = e3;
      }), t2;
    }, anyPromise: function(e2) {
      return new Promise(async (t2, r2) => {
        let i2;
        await Promise.all(e2.map(async (e3) => {
          try {
            t2(await e3);
          } catch (e4) {
            i2 = e4;
          }
        })), r2(i2);
      });
    }, selectUint8Array: function(e2, t2, r2) {
      const i2 = Math.max(t2.length, r2.length), n2 = new Uint8Array(i2);
      let a2 = 0;
      for (let i3 = 0; i3 < n2.length; i3++)
        n2[i3] = t2[i3] & 256 - e2 | r2[i3] & 255 + e2, a2 += e2 & i3 < t2.length | 1 - e2 & i3 < r2.length;
      return n2.subarray(0, a2);
    }, selectUint8: function(e2, t2, r2) {
      return t2 & 256 - e2 | r2 & 255 + e2;
    }, isAES: function(e2) {
      return e2 === ue.symmetric.aes128 || e2 === ue.symmetric.aes192 || e2 === ue.symmetric.aes256;
    } };
    var fe = de.getNodeBuffer();
    var le;
    var pe;
    function ye(e2) {
      let t2 = new Uint8Array();
      return X(e2, (e3) => {
        t2 = de.concatUint8Array([t2, e3]);
        const r2 = [], i2 = Math.floor(t2.length / 45), n2 = 45 * i2, a2 = le(t2.subarray(0, n2));
        for (let e4 = 0; e4 < i2; e4++)
          r2.push(a2.substr(60 * e4, 60)), r2.push("\n");
        return t2 = t2.subarray(n2), r2.join("");
      }, () => t2.length ? le(t2) + "\n" : "");
    }
    function be(e2) {
      let t2 = "";
      return X(e2, (e3) => {
        t2 += e3;
        let r2 = 0;
        const i2 = [" ", "	", "\r", "\n"];
        for (let e4 = 0; e4 < i2.length; e4++) {
          const n3 = i2[e4];
          for (let e5 = t2.indexOf(n3); -1 !== e5; e5 = t2.indexOf(n3, e5 + 1))
            r2++;
        }
        let n2 = t2.length;
        for (; n2 > 0 && (n2 - r2) % 4 != 0; n2--)
          i2.includes(t2[n2]) && r2--;
        const a2 = pe(t2.substr(0, n2));
        return t2 = t2.substr(n2), a2;
      }, () => pe(t2));
    }
    function ge(e2) {
      return be(e2.replace(/-/g, "+").replace(/_/g, "/"));
    }
    function me(e2, t2) {
      let r2 = ye(e2).replace(/[\r\n]/g, "");
      return t2 && (r2 = r2.replace(/[+]/g, "-").replace(/[/]/g, "_").replace(/[=]/g, "")), r2;
    }
    fe ? (le = (e2) => fe.from(e2).toString("base64"), pe = (e2) => {
      const t2 = fe.from(e2, "base64");
      return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
    }) : (le = (e2) => btoa(de.uint8ArrayToString(e2)), pe = (e2) => de.stringToUint8Array(atob(e2)));
    var we = { preferredHashAlgorithm: ue.hash.sha256, preferredSymmetricAlgorithm: ue.symmetric.aes256, preferredCompressionAlgorithm: ue.compression.uncompressed, deflateLevel: 6, aeadProtect: false, preferredAEADAlgorithm: ue.aead.eax, aeadChunkSizeByte: 12, v5Keys: false, s2kIterationCountByte: 224, allowUnauthenticatedMessages: false, allowUnauthenticatedStream: false, checksumRequired: false, minRSABits: 2047, passwordCollisionCheck: false, revocationsExpire: false, allowInsecureDecryptionWithSigningKeys: false, allowInsecureVerificationWithReformattedKeys: false, constantTimePKCS1Decryption: false, constantTimePKCS1DecryptionSupportedSymmetricAlgorithms: /* @__PURE__ */ new Set([ue.symmetric.aes128, ue.symmetric.aes192, ue.symmetric.aes256]), minBytesForWebCrypto: 1e3, ignoreUnsupportedPackets: true, ignoreMalformedPackets: false, additionalAllowedPackets: [], showVersion: false, showComment: false, versionString: "OpenPGP.js 5.11.0", commentString: "https://openpgpjs.org", maxUserIDLength: 5120, knownNotations: [], useIndutnyElliptic: true, rejectHashAlgorithms: /* @__PURE__ */ new Set([ue.hash.md5, ue.hash.ripemd]), rejectMessageHashAlgorithms: /* @__PURE__ */ new Set([ue.hash.md5, ue.hash.ripemd, ue.hash.sha1]), rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set([ue.publicKey.elgamal, ue.publicKey.dsa]), rejectCurves: /* @__PURE__ */ new Set([ue.curve.secp256k1]) };
    function ve(e2) {
      const t2 = e2.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);
      if (!t2)
        throw Error("Unknown ASCII armor type");
      return /MESSAGE, PART \d+\/\d+/.test(t2[1]) ? ue.armor.multipartSection : /MESSAGE, PART \d+/.test(t2[1]) ? ue.armor.multipartLast : /SIGNED MESSAGE/.test(t2[1]) ? ue.armor.signed : /MESSAGE/.test(t2[1]) ? ue.armor.message : /PUBLIC KEY BLOCK/.test(t2[1]) ? ue.armor.publicKey : /PRIVATE KEY BLOCK/.test(t2[1]) ? ue.armor.privateKey : /SIGNATURE/.test(t2[1]) ? ue.armor.signature : void 0;
    }
    function _e(e2, t2) {
      let r2 = "";
      return t2.showVersion && (r2 += "Version: " + t2.versionString + "\n"), t2.showComment && (r2 += "Comment: " + t2.commentString + "\n"), e2 && (r2 += "Comment: " + e2 + "\n"), r2 += "\n", r2;
    }
    function ke(e2) {
      return ye(function(e3) {
        let t2 = 13501623;
        return X(e3, (e4) => {
          const r2 = Se ? Math.floor(e4.length / 4) : 0, i2 = new Uint32Array(e4.buffer, e4.byteOffset, r2);
          for (let e5 = 0; e5 < r2; e5++)
            t2 ^= i2[e5], t2 = Ae[0][t2 >> 24 & 255] ^ Ae[1][t2 >> 16 & 255] ^ Ae[2][t2 >> 8 & 255] ^ Ae[3][t2 >> 0 & 255];
          for (let i3 = 4 * r2; i3 < e4.length; i3++)
            t2 = t2 >> 8 ^ Ae[0][255 & t2 ^ e4[i3]];
        }, () => new Uint8Array([t2, t2 >> 8, t2 >> 16]));
      }(e2));
    }
    var Ae = [Array(255), Array(255), Array(255), Array(255)];
    for (let e2 = 0; e2 <= 255; e2++) {
      let t2 = e2 << 16;
      for (let e3 = 0; e3 < 8; e3++)
        t2 = t2 << 1 ^ (0 != (8388608 & t2) ? 8801531 : 0);
      Ae[0][e2] = (16711680 & t2) >> 16 | 65280 & t2 | (255 & t2) << 16;
    }
    for (let e2 = 0; e2 <= 255; e2++)
      Ae[1][e2] = Ae[0][e2] >> 8 ^ Ae[0][255 & Ae[0][e2]];
    for (let e2 = 0; e2 <= 255; e2++)
      Ae[2][e2] = Ae[1][e2] >> 8 ^ Ae[0][255 & Ae[1][e2]];
    for (let e2 = 0; e2 <= 255; e2++)
      Ae[3][e2] = Ae[2][e2] >> 8 ^ Ae[0][255 & Ae[2][e2]];
    var Se = function() {
      const e2 = new ArrayBuffer(2);
      return new DataView(e2).setInt16(0, 255, true), 255 === new Int16Array(e2)[0];
    }();
    function Ee(e2) {
      for (let t2 = 0; t2 < e2.length; t2++)
        /^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e2[t2]) || de.printDebugError(Error("Improperly formatted armor header: " + e2[t2])), /^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e2[t2]) || de.printDebugError(Error("Unknown header: " + e2[t2]));
    }
    function Pe(e2) {
      let t2 = e2, r2 = "";
      const i2 = e2.lastIndexOf("=");
      return i2 >= 0 && i2 !== e2.length - 1 && (t2 = e2.slice(0, i2), r2 = e2.slice(i2 + 1).substr(0, 4)), { body: t2, checksum: r2 };
    }
    function xe(e2, t2 = we) {
      return new Promise(async (r2, i2) => {
        try {
          const n2 = /^-----[^-]+-----$/m, a2 = /^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;
          let s2;
          const o2 = [];
          let c2, u2, h2, d2 = o2, f2 = [], l2 = be(Y(e2, async (e3, t3) => {
            const p2 = W(e3);
            try {
              for (; ; ) {
                let e4 = await p2.readLine();
                if (void 0 === e4)
                  throw Error("Misformed armored text");
                if (e4 = de.removeTrailingSpaces(e4.replace(/[\r\n]/g, "")), s2)
                  if (c2)
                    u2 || 2 !== s2 || (n2.test(e4) ? (f2 = f2.join("\r\n"), u2 = true, Ee(d2), d2 = [], c2 = false) : f2.push(e4.replace(/^- /, "")));
                  else if (n2.test(e4) && i2(Error("Mandatory blank line missing between armor headers and armor data")), a2.test(e4)) {
                    if (Ee(d2), c2 = true, u2 || 2 !== s2) {
                      r2({ text: f2, data: l2, headers: o2, type: s2 });
                      break;
                    }
                  } else
                    d2.push(e4);
                else
                  n2.test(e4) && (s2 = ve(e4));
              }
            } catch (e4) {
              return void i2(e4);
            }
            const y2 = G(t3);
            try {
              for (; ; ) {
                await y2.ready;
                const { done: e4, value: t4 } = await p2.read();
                if (e4)
                  throw Error("Misformed armored text");
                const r3 = t4 + "";
                if (-1 !== r3.indexOf("=") || -1 !== r3.indexOf("-")) {
                  let e5 = await p2.readToEnd();
                  e5.length || (e5 = ""), e5 = r3 + e5, e5 = de.removeTrailingSpaces(e5.replace(/\r/g, ""));
                  const t5 = e5.split(n2);
                  if (1 === t5.length)
                    throw Error("Misformed armored text");
                  const i3 = Pe(t5[0].slice(0, -1));
                  h2 = i3.checksum, await y2.write(i3.body);
                  break;
                }
                await y2.write(r3);
              }
              await y2.ready, await y2.close();
            } catch (e4) {
              await y2.abort(e4);
            }
          }));
          l2 = Y(l2, async (e3, r3) => {
            const i3 = ie(ke(ee(e3)));
            i3.catch(() => {
            }), await V(e3, r3, { preventClose: true });
            const n3 = G(r3);
            try {
              const e4 = (await i3).replace("\n", "");
              if (h2 !== e4 && (h2 || t2.checksumRequired))
                throw Error("Ascii armor integrity check failed");
              await n3.ready, await n3.close();
            } catch (e4) {
              await n3.abort(e4);
            }
          });
        } catch (e3) {
          i2(e3);
        }
      }).then(async (e3) => (_(e3.data) && (e3.data = await ie(e3.data)), e3));
    }
    function Me(e2, t2, r2, i2, n2, a2 = we) {
      let s2, o2;
      e2 === ue.armor.signed && (s2 = t2.text, o2 = t2.hash, t2 = t2.data);
      const c2 = ee(t2), u2 = [];
      switch (e2) {
        case ue.armor.multipartSection:
          u2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "/" + i2 + "-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP MESSAGE, PART " + r2 + "/" + i2 + "-----\n");
          break;
        case ue.armor.multipartLast:
          u2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP MESSAGE, PART " + r2 + "-----\n");
          break;
        case ue.armor.signed:
          u2.push("-----BEGIN PGP SIGNED MESSAGE-----\n"), u2.push("Hash: " + o2 + "\n\n"), u2.push(s2.replace(/^-/gm, "- -")), u2.push("\n-----BEGIN PGP SIGNATURE-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP SIGNATURE-----\n");
          break;
        case ue.armor.message:
          u2.push("-----BEGIN PGP MESSAGE-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP MESSAGE-----\n");
          break;
        case ue.armor.publicKey:
          u2.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP PUBLIC KEY BLOCK-----\n");
          break;
        case ue.armor.privateKey:
          u2.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP PRIVATE KEY BLOCK-----\n");
          break;
        case ue.armor.signature:
          u2.push("-----BEGIN PGP SIGNATURE-----\n"), u2.push(_e(n2, a2)), u2.push(ye(t2)), u2.push("=", ke(c2)), u2.push("-----END PGP SIGNATURE-----\n");
      }
      return de.concat(u2);
    }
    var Ke = class _Ke {
      constructor() {
        this.bytes = "";
      }
      read(e2) {
        return this.bytes = de.uint8ArrayToString(e2.subarray(0, 8)), this.bytes.length;
      }
      write() {
        return de.stringToUint8Array(this.bytes);
      }
      toHex() {
        return de.uint8ArrayToHex(de.stringToUint8Array(this.bytes));
      }
      equals(e2, t2 = false) {
        return t2 && (e2.isWildcard() || this.isWildcard()) || this.bytes === e2.bytes;
      }
      isNull() {
        return "" === this.bytes;
      }
      isWildcard() {
        return /^0+$/.test(this.toHex());
      }
      static mapToHex(e2) {
        return e2.toHex();
      }
      static fromID(e2) {
        const t2 = new _Ke();
        return t2.read(de.hexToUint8Array(e2)), t2;
      }
      static wildcard() {
        const e2 = new _Ke();
        return e2.read(new Uint8Array(8)), e2;
      }
    };
    var Ce = function() {
      var e2, t2, r2 = false;
      function i2(r3, i3) {
        var n3 = e2[(t2[r3] + t2[i3]) % 255];
        return 0 !== r3 && 0 !== i3 || (n3 = 0), n3;
      }
      var n2, a2, s2, o2, c2 = false;
      function u2() {
        function u3(r3) {
          var i3, n3, a3;
          for (n3 = a3 = function(r4) {
            var i4 = e2[255 - t2[r4]];
            return 0 === r4 && (i4 = 0), i4;
          }(r3), i3 = 0; i3 < 4; i3++)
            a3 ^= n3 = 255 & (n3 << 1 | n3 >>> 7);
          return a3 ^= 99;
        }
        r2 || function() {
          e2 = [], t2 = [];
          var i3, n3, a3 = 1;
          for (i3 = 0; i3 < 255; i3++)
            e2[i3] = a3, n3 = 128 & a3, a3 <<= 1, a3 &= 255, 128 === n3 && (a3 ^= 27), a3 ^= e2[i3], t2[e2[i3]] = i3;
          e2[255] = e2[0], t2[0] = 0, r2 = true;
        }(), n2 = [], a2 = [], s2 = [[], [], [], []], o2 = [[], [], [], []];
        for (var h3 = 0; h3 < 256; h3++) {
          var d2 = u3(h3);
          n2[h3] = d2, a2[d2] = h3, s2[0][h3] = i2(2, d2) << 24 | d2 << 16 | d2 << 8 | i2(3, d2), o2[0][d2] = i2(14, h3) << 24 | i2(9, h3) << 16 | i2(13, h3) << 8 | i2(11, h3);
          for (var f2 = 1; f2 < 4; f2++)
            s2[f2][h3] = s2[f2 - 1][h3] >>> 8 | s2[f2 - 1][h3] << 24, o2[f2][d2] = o2[f2 - 1][d2] >>> 8 | o2[f2 - 1][d2] << 24;
        }
        c2 = true;
      }
      var h2 = function(e3, t3) {
        c2 || u2();
        var r3 = new Uint32Array(t3);
        r3.set(n2, 512), r3.set(a2, 768);
        for (var i3 = 0; i3 < 4; i3++)
          r3.set(s2[i3], 4096 + 1024 * i3 >> 2), r3.set(o2[i3], 8192 + 1024 * i3 >> 2);
        var h3 = function(e4, t4, r4) {
          ;
          var i4 = 0, n3 = 0, a3 = 0, s3 = 0, o3 = 0, c3 = 0, u3 = 0, h4 = 0, d2 = 0, f2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, g2 = 0, m2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0;
          var S2 = new e4.Uint32Array(r4), E2 = new e4.Uint8Array(r4);
          function P2(e5, t5, r5, o4, c4, u4, h5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            c4 = c4 | 0;
            u4 = u4 | 0;
            h5 = h5 | 0;
            d3 = d3 | 0;
            var f3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0, m3 = 0, w3 = 0;
            f3 = r5 | 1024, l3 = r5 | 2048, p3 = r5 | 3072;
            c4 = c4 ^ S2[(e5 | 0) >> 2], u4 = u4 ^ S2[(e5 | 4) >> 2], h5 = h5 ^ S2[(e5 | 8) >> 2], d3 = d3 ^ S2[(e5 | 12) >> 2];
            for (w3 = 16; (w3 | 0) <= o4 << 4; w3 = w3 + 16 | 0) {
              y3 = S2[(r5 | c4 >> 22 & 1020) >> 2] ^ S2[(f3 | u4 >> 14 & 1020) >> 2] ^ S2[(l3 | h5 >> 6 & 1020) >> 2] ^ S2[(p3 | d3 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 0) >> 2], b3 = S2[(r5 | u4 >> 22 & 1020) >> 2] ^ S2[(f3 | h5 >> 14 & 1020) >> 2] ^ S2[(l3 | d3 >> 6 & 1020) >> 2] ^ S2[(p3 | c4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 4) >> 2], g3 = S2[(r5 | h5 >> 22 & 1020) >> 2] ^ S2[(f3 | d3 >> 14 & 1020) >> 2] ^ S2[(l3 | c4 >> 6 & 1020) >> 2] ^ S2[(p3 | u4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 8) >> 2], m3 = S2[(r5 | d3 >> 22 & 1020) >> 2] ^ S2[(f3 | c4 >> 14 & 1020) >> 2] ^ S2[(l3 | u4 >> 6 & 1020) >> 2] ^ S2[(p3 | h5 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 12) >> 2];
              c4 = y3, u4 = b3, h5 = g3, d3 = m3;
            }
            i4 = S2[(t5 | c4 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | u4 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | h5 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | d3 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 0) >> 2], n3 = S2[(t5 | u4 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | h5 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | d3 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | c4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 4) >> 2], a3 = S2[(t5 | h5 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | d3 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | c4 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | u4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 8) >> 2], s3 = S2[(t5 | d3 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | c4 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | u4 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | h5 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 12) >> 2];
          }
          function x2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            P2(0, 2048, 4096, A2, e5, t5, r5, i5);
          }
          function M2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            var a4 = 0;
            P2(1024, 3072, 8192, A2, e5, i5, r5, t5);
            a4 = n3, n3 = s3, s3 = a4;
          }
          function K2(e5, t5, r5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            d3 = d3 | 0;
            P2(0, 2048, 4096, A2, o3 ^ e5, c3 ^ t5, u3 ^ r5, h4 ^ d3);
            o3 = i4, c3 = n3, u3 = a3, h4 = s3;
          }
          function C2(e5, t5, r5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            d3 = d3 | 0;
            var f3 = 0;
            P2(1024, 3072, 8192, A2, e5, d3, r5, t5);
            f3 = n3, n3 = s3, s3 = f3;
            i4 = i4 ^ o3, n3 = n3 ^ c3, a3 = a3 ^ u3, s3 = s3 ^ h4;
            o3 = e5, c3 = t5, u3 = r5, h4 = d3;
          }
          function D2(e5, t5, r5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            d3 = d3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            o3 = i4 = i4 ^ e5, c3 = n3 = n3 ^ t5, u3 = a3 = a3 ^ r5, h4 = s3 = s3 ^ d3;
          }
          function U2(e5, t5, r5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            d3 = d3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            i4 = i4 ^ e5, n3 = n3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ d3;
            o3 = e5, c3 = t5, u3 = r5, h4 = d3;
          }
          function R2(e5, t5, r5, d3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            d3 = d3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            o3 = i4, c3 = n3, u3 = a3, h4 = s3;
            i4 = i4 ^ e5, n3 = n3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ d3;
          }
          function I2(e5, t5, r5, o4) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            P2(0, 2048, 4096, A2, d2, f2, l2, p2);
            p2 = ~m2 & p2 | m2 & p2 + 1;
            l2 = ~g2 & l2 | g2 & l2 + ((p2 | 0) == 0);
            f2 = ~b2 & f2 | b2 & f2 + ((l2 | 0) == 0);
            d2 = ~y2 & d2 | y2 & d2 + ((f2 | 0) == 0);
            i4 = i4 ^ e5;
            n3 = n3 ^ t5;
            a3 = a3 ^ r5;
            s3 = s3 ^ o4;
          }
          function B2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            var n4 = 0, a4 = 0, s4 = 0, d3 = 0, f3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0;
            e5 = e5 ^ o3, t5 = t5 ^ c3, r5 = r5 ^ u3, i5 = i5 ^ h4;
            n4 = w2 | 0, a4 = v2 | 0, s4 = _2 | 0, d3 = k2 | 0;
            for (; (b3 | 0) < 128; b3 = b3 + 1 | 0) {
              if (n4 >>> 31) {
                f3 = f3 ^ e5, l3 = l3 ^ t5, p3 = p3 ^ r5, y3 = y3 ^ i5;
              }
              n4 = n4 << 1 | a4 >>> 31, a4 = a4 << 1 | s4 >>> 31, s4 = s4 << 1 | d3 >>> 31, d3 = d3 << 1;
              g3 = i5 & 1;
              i5 = i5 >>> 1 | r5 << 31, r5 = r5 >>> 1 | t5 << 31, t5 = t5 >>> 1 | e5 << 31, e5 = e5 >>> 1;
              if (g3)
                e5 = e5 ^ 3774873600;
            }
            o3 = f3, c3 = l3, u3 = p3, h4 = y3;
          }
          function T2(e5) {
            e5 = e5 | 0;
            A2 = e5;
          }
          function z2(e5, t5, r5, o4) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            i4 = e5, n3 = t5, a3 = r5, s3 = o4;
          }
          function q2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            o3 = e5, c3 = t5, u3 = r5, h4 = i5;
          }
          function F2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            d2 = e5, f2 = t5, l2 = r5, p2 = i5;
          }
          function O2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            y2 = e5, b2 = t5, g2 = r5, m2 = i5;
          }
          function L2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            p2 = ~m2 & p2 | m2 & i5, l2 = ~g2 & l2 | g2 & r5, f2 = ~b2 & f2 | b2 & t5, d2 = ~y2 & d2 | y2 & e5;
          }
          function N2(e5) {
            e5 = e5 | 0;
            if (e5 & 15)
              return -1;
            E2[e5 | 0] = i4 >>> 24, E2[e5 | 1] = i4 >>> 16 & 255, E2[e5 | 2] = i4 >>> 8 & 255, E2[e5 | 3] = i4 & 255, E2[e5 | 4] = n3 >>> 24, E2[e5 | 5] = n3 >>> 16 & 255, E2[e5 | 6] = n3 >>> 8 & 255, E2[e5 | 7] = n3 & 255, E2[e5 | 8] = a3 >>> 24, E2[e5 | 9] = a3 >>> 16 & 255, E2[e5 | 10] = a3 >>> 8 & 255, E2[e5 | 11] = a3 & 255, E2[e5 | 12] = s3 >>> 24, E2[e5 | 13] = s3 >>> 16 & 255, E2[e5 | 14] = s3 >>> 8 & 255, E2[e5 | 15] = s3 & 255;
            return 16;
          }
          function j2(e5) {
            e5 = e5 | 0;
            if (e5 & 15)
              return -1;
            E2[e5 | 0] = o3 >>> 24, E2[e5 | 1] = o3 >>> 16 & 255, E2[e5 | 2] = o3 >>> 8 & 255, E2[e5 | 3] = o3 & 255, E2[e5 | 4] = c3 >>> 24, E2[e5 | 5] = c3 >>> 16 & 255, E2[e5 | 6] = c3 >>> 8 & 255, E2[e5 | 7] = c3 & 255, E2[e5 | 8] = u3 >>> 24, E2[e5 | 9] = u3 >>> 16 & 255, E2[e5 | 10] = u3 >>> 8 & 255, E2[e5 | 11] = u3 & 255, E2[e5 | 12] = h4 >>> 24, E2[e5 | 13] = h4 >>> 16 & 255, E2[e5 | 14] = h4 >>> 8 & 255, E2[e5 | 15] = h4 & 255;
            return 16;
          }
          function H2() {
            x2(0, 0, 0, 0);
            w2 = i4, v2 = n3, _2 = a3, k2 = s3;
          }
          function W2(e5, t5, r5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            var o4 = 0;
            if (t5 & 15)
              return -1;
            while ((r5 | 0) >= 16) {
              V2[e5 & 7](E2[t5 | 0] << 24 | E2[t5 | 1] << 16 | E2[t5 | 2] << 8 | E2[t5 | 3], E2[t5 | 4] << 24 | E2[t5 | 5] << 16 | E2[t5 | 6] << 8 | E2[t5 | 7], E2[t5 | 8] << 24 | E2[t5 | 9] << 16 | E2[t5 | 10] << 8 | E2[t5 | 11], E2[t5 | 12] << 24 | E2[t5 | 13] << 16 | E2[t5 | 14] << 8 | E2[t5 | 15]);
              E2[t5 | 0] = i4 >>> 24, E2[t5 | 1] = i4 >>> 16 & 255, E2[t5 | 2] = i4 >>> 8 & 255, E2[t5 | 3] = i4 & 255, E2[t5 | 4] = n3 >>> 24, E2[t5 | 5] = n3 >>> 16 & 255, E2[t5 | 6] = n3 >>> 8 & 255, E2[t5 | 7] = n3 & 255, E2[t5 | 8] = a3 >>> 24, E2[t5 | 9] = a3 >>> 16 & 255, E2[t5 | 10] = a3 >>> 8 & 255, E2[t5 | 11] = a3 & 255, E2[t5 | 12] = s3 >>> 24, E2[t5 | 13] = s3 >>> 16 & 255, E2[t5 | 14] = s3 >>> 8 & 255, E2[t5 | 15] = s3 & 255;
              o4 = o4 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
            }
            return o4 | 0;
          }
          function G2(e5, t5, r5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            var i5 = 0;
            if (t5 & 15)
              return -1;
            while ((r5 | 0) >= 16) {
              $2[e5 & 1](E2[t5 | 0] << 24 | E2[t5 | 1] << 16 | E2[t5 | 2] << 8 | E2[t5 | 3], E2[t5 | 4] << 24 | E2[t5 | 5] << 16 | E2[t5 | 6] << 8 | E2[t5 | 7], E2[t5 | 8] << 24 | E2[t5 | 9] << 16 | E2[t5 | 10] << 8 | E2[t5 | 11], E2[t5 | 12] << 24 | E2[t5 | 13] << 16 | E2[t5 | 14] << 8 | E2[t5 | 15]);
              i5 = i5 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
            }
            return i5 | 0;
          }
          var V2 = [x2, M2, K2, C2, D2, U2, R2, I2];
          var $2 = [K2, B2];
          return { set_rounds: T2, set_state: z2, set_iv: q2, set_nonce: F2, set_mask: O2, set_counter: L2, get_state: N2, get_iv: j2, gcm_init: H2, cipher: W2, mac: G2 };
        }({ Uint8Array, Uint32Array }, e3, t3);
        return h3.set_key = function(e4, t4, i4, a3, s3, c3, u3, d2, f2) {
          var l2 = r3.subarray(0, 60), p2 = r3.subarray(256, 316);
          l2.set([t4, i4, a3, s3, c3, u3, d2, f2]);
          for (var y2 = e4, b2 = 1; y2 < 4 * e4 + 28; y2++) {
            var g2 = l2[y2 - 1];
            (y2 % e4 == 0 || 8 === e4 && y2 % e4 == 4) && (g2 = n2[g2 >>> 24] << 24 ^ n2[g2 >>> 16 & 255] << 16 ^ n2[g2 >>> 8 & 255] << 8 ^ n2[255 & g2]), y2 % e4 == 0 && (g2 = g2 << 8 ^ g2 >>> 24 ^ b2 << 24, b2 = b2 << 1 ^ (128 & b2 ? 27 : 0)), l2[y2] = l2[y2 - e4] ^ g2;
          }
          for (var m2 = 0; m2 < y2; m2 += 4)
            for (var w2 = 0; w2 < 4; w2++) {
              g2 = l2[y2 - (4 + m2) + (4 - w2) % 4];
              p2[m2 + w2] = m2 < 4 || m2 >= y2 - 4 ? g2 : o2[0][n2[g2 >>> 24]] ^ o2[1][n2[g2 >>> 16 & 255]] ^ o2[2][n2[g2 >>> 8 & 255]] ^ o2[3][n2[255 & g2]];
            }
          h3.set_rounds(e4 + 5);
        }, h3;
      };
      return h2.ENC = { ECB: 0, CBC: 2, CFB: 4, OFB: 6, CTR: 7 }, h2.DEC = { ECB: 1, CBC: 3, CFB: 5, OFB: 6, CTR: 7 }, h2.MAC = { CBC: 0, GCM: 1 }, h2.HEAP_DATA = 16384, h2;
    }();
    function De(e2) {
      return e2 instanceof Uint8Array;
    }
    function Ue(e2, t2) {
      const r2 = e2 ? e2.byteLength : t2 || 65536;
      if (4095 & r2 || r2 <= 0)
        throw Error("heap size must be a positive integer and a multiple of 4096");
      return e2 = e2 || new Uint8Array(new ArrayBuffer(r2));
    }
    function Re(e2, t2, r2, i2, n2) {
      const a2 = e2.length - t2, s2 = a2 < n2 ? a2 : n2;
      return e2.set(r2.subarray(i2, i2 + s2), t2), s2;
    }
    function Ie(...e2) {
      const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
      let i2 = 0;
      for (let t3 = 0; t3 < e2.length; t3++)
        r2.set(e2[t3], i2), i2 += e2[t3].length;
      return r2;
    }
    var Be = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var Te = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var ze = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var qe = [];
    var Fe = [];
    var Oe = class {
      constructor(e2, t2, r2 = true, i2, n2, a2) {
        this.pos = 0, this.len = 0, this.mode = i2, this.pos = 0, this.len = 0, this.key = e2, this.iv = t2, this.padding = r2, this.acquire_asm(n2, a2);
      }
      acquire_asm(e2, t2) {
        return void 0 !== this.heap && void 0 !== this.asm || (this.heap = e2 || qe.pop() || Ue().subarray(Ce.HEAP_DATA), this.asm = t2 || Fe.pop() || new Ce(null, this.heap.buffer), this.reset(this.key, this.iv)), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        void 0 !== this.heap && void 0 !== this.asm && (qe.push(this.heap), Fe.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      reset(e2, t2) {
        const { asm: r2 } = this.acquire_asm(), i2 = e2.length;
        if (16 !== i2 && 24 !== i2 && 32 !== i2)
          throw new Te("illegal key size");
        const n2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
        if (r2.set_key(i2 >> 2, n2.getUint32(0), n2.getUint32(4), n2.getUint32(8), n2.getUint32(12), i2 > 16 ? n2.getUint32(16) : 0, i2 > 16 ? n2.getUint32(20) : 0, i2 > 24 ? n2.getUint32(24) : 0, i2 > 24 ? n2.getUint32(28) : 0), void 0 !== t2) {
          if (16 !== t2.length)
            throw new Te("illegal iv size");
          let e3 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
          r2.set_iv(e3.getUint32(0), e3.getUint32(4), e3.getUint32(8), e3.getUint32(12));
        } else
          r2.set_iv(0, 0, 0, 0);
      }
      AES_Encrypt_process(e2) {
        if (!De(e2))
          throw new TypeError("data isn't of expected type");
        let { heap: t2, asm: r2 } = this.acquire_asm(), i2 = Ce.ENC[this.mode], n2 = Ce.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, u2 = 0, h2 = 0, d2 = new Uint8Array(s2 + c2 & -16);
        for (; c2 > 0; )
          h2 = Re(t2, a2 + s2, e2, o2, c2), s2 += h2, o2 += h2, c2 -= h2, h2 = r2.cipher(i2, n2 + a2, s2), h2 && d2.set(t2.subarray(a2, a2 + h2), u2), u2 += h2, h2 < s2 ? (a2 += h2, s2 -= h2) : (a2 = 0, s2 = 0);
        return this.pos = a2, this.len = s2, d2;
      }
      AES_Encrypt_finish() {
        let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = Ce.ENC[this.mode], i2 = Ce.HEAP_DATA, n2 = this.pos, a2 = this.len, s2 = 16 - a2 % 16, o2 = a2;
        if (this.hasOwnProperty("padding")) {
          if (this.padding) {
            for (let t3 = 0; t3 < s2; ++t3)
              e2[n2 + a2 + t3] = s2;
            a2 += s2, o2 = a2;
          } else if (a2 % 16)
            throw new Te("data length must be a multiple of the block size");
        } else
          a2 += s2;
        const c2 = new Uint8Array(o2);
        return a2 && t2.cipher(r2, i2 + n2, a2), o2 && c2.set(e2.subarray(n2, n2 + o2)), this.pos = 0, this.len = 0, this.release_asm(), c2;
      }
      AES_Decrypt_process(e2) {
        if (!De(e2))
          throw new TypeError("data isn't of expected type");
        let { heap: t2, asm: r2 } = this.acquire_asm(), i2 = Ce.DEC[this.mode], n2 = Ce.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, u2 = 0, h2 = s2 + c2 & -16, d2 = 0, f2 = 0;
        this.padding && (d2 = s2 + c2 - h2 || 16, h2 -= d2);
        const l2 = new Uint8Array(h2);
        for (; c2 > 0; )
          f2 = Re(t2, a2 + s2, e2, o2, c2), s2 += f2, o2 += f2, c2 -= f2, f2 = r2.cipher(i2, n2 + a2, s2 - (c2 ? 0 : d2)), f2 && l2.set(t2.subarray(a2, a2 + f2), u2), u2 += f2, f2 < s2 ? (a2 += f2, s2 -= f2) : (a2 = 0, s2 = 0);
        return this.pos = a2, this.len = s2, l2;
      }
      AES_Decrypt_finish() {
        let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = Ce.DEC[this.mode], i2 = Ce.HEAP_DATA, n2 = this.pos, a2 = this.len, s2 = a2;
        if (a2 > 0) {
          if (a2 % 16) {
            if (this.hasOwnProperty("padding"))
              throw new Te("data length must be a multiple of the block size");
            a2 += 16 - a2 % 16;
          }
          if (t2.cipher(r2, i2 + n2, a2), this.hasOwnProperty("padding") && this.padding) {
            let t3 = e2[n2 + s2 - 1];
            if (t3 < 1 || t3 > 16 || t3 > s2)
              throw new ze("bad padding");
            let r3 = 0;
            for (let i3 = t3; i3 > 1; i3--)
              r3 |= t3 ^ e2[n2 + s2 - i3];
            if (r3)
              throw new ze("bad padding");
            s2 -= t3;
          }
        }
        const o2 = new Uint8Array(s2);
        return s2 > 0 && o2.set(e2.subarray(n2, n2 + s2)), this.pos = 0, this.len = 0, this.release_asm(), o2;
      }
    };
    var Le = class _Le {
      static encrypt(e2, t2, r2 = false) {
        return new _Le(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2 = false) {
        return new _Le(t2, r2).decrypt(e2);
      }
      constructor(e2, t2 = false, r2) {
        this.aes = r2 || new Oe(e2, void 0, t2, "ECB");
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    function Ne(e2) {
      const t2 = function(e3) {
        const t3 = new Le(e3);
        this.encrypt = function(e4) {
          return t3.encrypt(e4);
        }, this.decrypt = function(e4) {
          return t3.decrypt(e4);
        };
      };
      return t2.blockSize = t2.prototype.blockSize = 16, t2.keySize = t2.prototype.keySize = e2 / 8, t2;
    }
    function je(e2, t2, r2, i2, n2, a2) {
      const s2 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], o2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], c2 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], u2 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], h2 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], d2 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], f2 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], l2 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
      let p2, y2, b2, g2, m2, w2, v2, _2, k2, A2, S2, E2, P2, x2, M2 = 0, K2 = t2.length;
      const C2 = 32 === e2.length ? 3 : 9;
      _2 = 3 === C2 ? r2 ? [0, 32, 2] : [30, -2, -2] : r2 ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2], r2 && (t2 = function(e3, t3) {
        const r3 = 8 - e3.length % 8;
        let i3;
        if (2 === t3 && r3 < 8)
          i3 = 32;
        else if (1 === t3)
          i3 = r3;
        else {
          if (t3 || !(r3 < 8)) {
            if (8 === r3)
              return e3;
            throw Error("des: invalid padding");
          }
          i3 = 0;
        }
        const n3 = new Uint8Array(e3.length + r3);
        for (let t4 = 0; t4 < e3.length; t4++)
          n3[t4] = e3[t4];
        for (let t4 = 0; t4 < r3; t4++)
          n3[e3.length + t4] = i3;
        return n3;
      }(t2, a2), K2 = t2.length);
      let D2 = new Uint8Array(K2), U2 = 0;
      for (1 === i2 && (k2 = n2[M2++] << 24 | n2[M2++] << 16 | n2[M2++] << 8 | n2[M2++], S2 = n2[M2++] << 24 | n2[M2++] << 16 | n2[M2++] << 8 | n2[M2++], M2 = 0); M2 < K2; ) {
        for (w2 = t2[M2++] << 24 | t2[M2++] << 16 | t2[M2++] << 8 | t2[M2++], v2 = t2[M2++] << 24 | t2[M2++] << 16 | t2[M2++] << 8 | t2[M2++], 1 === i2 && (r2 ? (w2 ^= k2, v2 ^= S2) : (A2 = k2, E2 = S2, k2 = w2, S2 = v2)), b2 = 252645135 & (w2 >>> 4 ^ v2), v2 ^= b2, w2 ^= b2 << 4, b2 = 65535 & (w2 >>> 16 ^ v2), v2 ^= b2, w2 ^= b2 << 16, b2 = 858993459 & (v2 >>> 2 ^ w2), w2 ^= b2, v2 ^= b2 << 2, b2 = 16711935 & (v2 >>> 8 ^ w2), w2 ^= b2, v2 ^= b2 << 8, b2 = 1431655765 & (w2 >>> 1 ^ v2), v2 ^= b2, w2 ^= b2 << 1, w2 = w2 << 1 | w2 >>> 31, v2 = v2 << 1 | v2 >>> 31, y2 = 0; y2 < C2; y2 += 3) {
          for (P2 = _2[y2 + 1], x2 = _2[y2 + 2], p2 = _2[y2]; p2 !== P2; p2 += x2)
            g2 = v2 ^ e2[p2], m2 = (v2 >>> 4 | v2 << 28) ^ e2[p2 + 1], b2 = w2, w2 = v2, v2 = b2 ^ (o2[g2 >>> 24 & 63] | u2[g2 >>> 16 & 63] | d2[g2 >>> 8 & 63] | l2[63 & g2] | s2[m2 >>> 24 & 63] | c2[m2 >>> 16 & 63] | h2[m2 >>> 8 & 63] | f2[63 & m2]);
          b2 = w2, w2 = v2, v2 = b2;
        }
        w2 = w2 >>> 1 | w2 << 31, v2 = v2 >>> 1 | v2 << 31, b2 = 1431655765 & (w2 >>> 1 ^ v2), v2 ^= b2, w2 ^= b2 << 1, b2 = 16711935 & (v2 >>> 8 ^ w2), w2 ^= b2, v2 ^= b2 << 8, b2 = 858993459 & (v2 >>> 2 ^ w2), w2 ^= b2, v2 ^= b2 << 2, b2 = 65535 & (w2 >>> 16 ^ v2), v2 ^= b2, w2 ^= b2 << 16, b2 = 252645135 & (w2 >>> 4 ^ v2), v2 ^= b2, w2 ^= b2 << 4, 1 === i2 && (r2 ? (k2 = w2, S2 = v2) : (w2 ^= A2, v2 ^= E2)), D2[U2++] = w2 >>> 24, D2[U2++] = w2 >>> 16 & 255, D2[U2++] = w2 >>> 8 & 255, D2[U2++] = 255 & w2, D2[U2++] = v2 >>> 24, D2[U2++] = v2 >>> 16 & 255, D2[U2++] = v2 >>> 8 & 255, D2[U2++] = 255 & v2;
      }
      return r2 || (D2 = function(e3, t3) {
        let r3, i3 = null;
        if (2 === t3)
          r3 = 32;
        else if (1 === t3)
          i3 = e3[e3.length - 1];
        else {
          if (t3)
            throw Error("des: invalid padding");
          r3 = 0;
        }
        if (!i3) {
          for (i3 = 1; e3[e3.length - i3] === r3; )
            i3++;
          i3--;
        }
        return e3.subarray(0, e3.length - i3);
      }(D2, a2)), D2;
    }
    function He(e2) {
      const t2 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], r2 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], i2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], n2 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], a2 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], s2 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], o2 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c2 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], u2 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], h2 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], d2 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], f2 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], l2 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], p2 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], y2 = e2.length > 8 ? 3 : 1, b2 = Array(32 * y2), g2 = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      let m2, w2, v2, _2 = 0, k2 = 0;
      for (let A2 = 0; A2 < y2; A2++) {
        let y3 = e2[_2++] << 24 | e2[_2++] << 16 | e2[_2++] << 8 | e2[_2++], A3 = e2[_2++] << 24 | e2[_2++] << 16 | e2[_2++] << 8 | e2[_2++];
        v2 = 252645135 & (y3 >>> 4 ^ A3), A3 ^= v2, y3 ^= v2 << 4, v2 = 65535 & (A3 >>> -16 ^ y3), y3 ^= v2, A3 ^= v2 << -16, v2 = 858993459 & (y3 >>> 2 ^ A3), A3 ^= v2, y3 ^= v2 << 2, v2 = 65535 & (A3 >>> -16 ^ y3), y3 ^= v2, A3 ^= v2 << -16, v2 = 1431655765 & (y3 >>> 1 ^ A3), A3 ^= v2, y3 ^= v2 << 1, v2 = 16711935 & (A3 >>> 8 ^ y3), y3 ^= v2, A3 ^= v2 << 8, v2 = 1431655765 & (y3 >>> 1 ^ A3), A3 ^= v2, y3 ^= v2 << 1, v2 = y3 << 8 | A3 >>> 20 & 240, y3 = A3 << 24 | A3 << 8 & 16711680 | A3 >>> 8 & 65280 | A3 >>> 24 & 240, A3 = v2;
        for (let e3 = 0; e3 < 16; e3++)
          g2[e3] ? (y3 = y3 << 2 | y3 >>> 26, A3 = A3 << 2 | A3 >>> 26) : (y3 = y3 << 1 | y3 >>> 27, A3 = A3 << 1 | A3 >>> 27), y3 &= -15, A3 &= -15, m2 = t2[y3 >>> 28] | r2[y3 >>> 24 & 15] | i2[y3 >>> 20 & 15] | n2[y3 >>> 16 & 15] | a2[y3 >>> 12 & 15] | s2[y3 >>> 8 & 15] | o2[y3 >>> 4 & 15], w2 = c2[A3 >>> 28] | u2[A3 >>> 24 & 15] | h2[A3 >>> 20 & 15] | d2[A3 >>> 16 & 15] | f2[A3 >>> 12 & 15] | l2[A3 >>> 8 & 15] | p2[A3 >>> 4 & 15], v2 = 65535 & (w2 >>> 16 ^ m2), b2[k2++] = m2 ^ v2, b2[k2++] = w2 ^ v2 << 16;
      }
      return b2;
    }
    function We(e2) {
      this.key = [];
      for (let t2 = 0; t2 < 3; t2++)
        this.key.push(new Uint8Array(e2.subarray(8 * t2, 8 * t2 + 8)));
      this.encrypt = function(e3) {
        return je(He(this.key[2]), je(He(this.key[1]), je(He(this.key[0]), e3, true, 0, null, null), false, 0, null, null), true, 0, null, null);
      };
    }
    function Ge() {
      this.BlockSize = 8, this.KeySize = 16, this.setKey = function(e3) {
        if (this.masking = Array(16), this.rotate = Array(16), this.reset(), e3.length !== this.KeySize)
          throw Error("CAST-128: keys must be 16 bytes");
        return this.keySchedule(e3), true;
      }, this.reset = function() {
        for (let e3 = 0; e3 < 16; e3++)
          this.masking[e3] = 0, this.rotate[e3] = 0;
      }, this.getBlockSize = function() {
        return this.BlockSize;
      }, this.encrypt = function(e3) {
        const t3 = Array(e3.length);
        for (let a3 = 0; a3 < e3.length; a3 += 8) {
          let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
          s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >>> 16 & 255, t3[a3 + 6] = o2 >>> 8 & 255, t3[a3 + 7] = 255 & o2;
        }
        return t3;
      }, this.decrypt = function(e3) {
        const t3 = Array(e3.length);
        for (let a3 = 0; a3 < e3.length; a3 += 8) {
          let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
          s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >> 16 & 255, t3[a3 + 6] = o2 >> 8 & 255, t3[a3 + 7] = 255 & o2;
        }
        return t3;
      };
      const e2 = [, , , ,];
      e2[0] = [, , , ,], e2[0][0] = [4, 0, 13, 15, 12, 14, 8], e2[0][1] = [5, 2, 16, 18, 17, 19, 10], e2[0][2] = [6, 3, 23, 22, 21, 20, 9], e2[0][3] = [7, 1, 26, 25, 27, 24, 11], e2[1] = [, , , ,], e2[1][0] = [0, 6, 21, 23, 20, 22, 16], e2[1][1] = [1, 4, 0, 2, 1, 3, 18], e2[1][2] = [2, 5, 7, 6, 5, 4, 17], e2[1][3] = [3, 7, 10, 9, 11, 8, 19], e2[2] = [, , , ,], e2[2][0] = [4, 0, 13, 15, 12, 14, 8], e2[2][1] = [5, 2, 16, 18, 17, 19, 10], e2[2][2] = [6, 3, 23, 22, 21, 20, 9], e2[2][3] = [7, 1, 26, 25, 27, 24, 11], e2[3] = [, , , ,], e2[3][0] = [0, 6, 21, 23, 20, 22, 16], e2[3][1] = [1, 4, 0, 2, 1, 3, 18], e2[3][2] = [2, 5, 7, 6, 5, 4, 17], e2[3][3] = [3, 7, 10, 9, 11, 8, 19];
      const t2 = [, , , ,];
      function r2(e3, t3, r3) {
        const i3 = t3 + e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return (a2[0][n3 >>> 24] ^ a2[1][n3 >>> 16 & 255]) - a2[2][n3 >>> 8 & 255] + a2[3][255 & n3];
      }
      function i2(e3, t3, r3) {
        const i3 = t3 ^ e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return a2[0][n3 >>> 24] - a2[1][n3 >>> 16 & 255] + a2[2][n3 >>> 8 & 255] ^ a2[3][255 & n3];
      }
      function n2(e3, t3, r3) {
        const i3 = t3 - e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return (a2[0][n3 >>> 24] + a2[1][n3 >>> 16 & 255] ^ a2[2][n3 >>> 8 & 255]) - a2[3][255 & n3];
      }
      t2[0] = [, , , ,], t2[0][0] = [24, 25, 23, 22, 18], t2[0][1] = [26, 27, 21, 20, 22], t2[0][2] = [28, 29, 19, 18, 25], t2[0][3] = [30, 31, 17, 16, 28], t2[1] = [, , , ,], t2[1][0] = [3, 2, 12, 13, 8], t2[1][1] = [1, 0, 14, 15, 13], t2[1][2] = [7, 6, 8, 9, 3], t2[1][3] = [5, 4, 10, 11, 7], t2[2] = [, , , ,], t2[2][0] = [19, 18, 28, 29, 25], t2[2][1] = [17, 16, 30, 31, 28], t2[2][2] = [23, 22, 24, 25, 18], t2[2][3] = [21, 20, 26, 27, 22], t2[3] = [, , , ,], t2[3][0] = [8, 9, 7, 6, 3], t2[3][1] = [10, 11, 5, 4, 7], t2[3][2] = [12, 13, 3, 2, 8], t2[3][3] = [14, 15, 1, 0, 13], this.keySchedule = function(r3) {
        const i3 = [, , , , , , , ,], n3 = Array(32);
        let s2;
        for (let e3 = 0; e3 < 4; e3++)
          s2 = 4 * e3, i3[e3] = r3[s2] << 24 | r3[s2 + 1] << 16 | r3[s2 + 2] << 8 | r3[s2 + 3];
        const o2 = [6, 7, 4, 5];
        let c2, u2 = 0;
        for (let r4 = 0; r4 < 2; r4++)
          for (let r5 = 0; r5 < 4; r5++) {
            for (s2 = 0; s2 < 4; s2++) {
              const t3 = e2[r5][s2];
              c2 = i3[t3[1]], c2 ^= a2[4][i3[t3[2] >>> 2] >>> 24 - 8 * (3 & t3[2]) & 255], c2 ^= a2[5][i3[t3[3] >>> 2] >>> 24 - 8 * (3 & t3[3]) & 255], c2 ^= a2[6][i3[t3[4] >>> 2] >>> 24 - 8 * (3 & t3[4]) & 255], c2 ^= a2[7][i3[t3[5] >>> 2] >>> 24 - 8 * (3 & t3[5]) & 255], c2 ^= a2[o2[s2]][i3[t3[6] >>> 2] >>> 24 - 8 * (3 & t3[6]) & 255], i3[t3[0]] = c2;
            }
            for (s2 = 0; s2 < 4; s2++) {
              const e3 = t2[r5][s2];
              c2 = a2[4][i3[e3[0] >>> 2] >>> 24 - 8 * (3 & e3[0]) & 255], c2 ^= a2[5][i3[e3[1] >>> 2] >>> 24 - 8 * (3 & e3[1]) & 255], c2 ^= a2[6][i3[e3[2] >>> 2] >>> 24 - 8 * (3 & e3[2]) & 255], c2 ^= a2[7][i3[e3[3] >>> 2] >>> 24 - 8 * (3 & e3[3]) & 255], c2 ^= a2[4 + s2][i3[e3[4] >>> 2] >>> 24 - 8 * (3 & e3[4]) & 255], n3[u2] = c2, u2++;
            }
          }
        for (let e3 = 0; e3 < 16; e3++)
          this.masking[e3] = n3[e3], this.rotate[e3] = 31 & n3[16 + e3];
      };
      const a2 = [, , , , , , , ,];
      a2[0] = [821772500, 2678128395, 1810681135, 1059425402, 505495343, 2617265619, 1610868032, 3483355465, 3218386727, 2294005173, 3791863952, 2563806837, 1852023008, 365126098, 3269944861, 584384398, 677919599, 3229601881, 4280515016, 2002735330, 1136869587, 3744433750, 2289869850, 2731719981, 2714362070, 879511577, 1639411079, 575934255, 717107937, 2857637483, 576097850, 2731753936, 1725645e3, 2810460463, 5111599, 767152862, 2543075244, 1251459544, 1383482551, 3052681127, 3089939183, 3612463449, 1878520045, 1510570527, 2189125840, 2431448366, 582008916, 3163445557, 1265446783, 1354458274, 3529918736, 3202711853, 3073581712, 3912963487, 3029263377, 1275016285, 4249207360, 2905708351, 3304509486, 1442611557, 3585198765, 2712415662, 2731849581, 3248163920, 2283946226, 208555832, 2766454743, 1331405426, 1447828783, 3315356441, 3108627284, 2957404670, 2981538698, 3339933917, 1669711173, 286233437, 1465092821, 1782121619, 3862771680, 710211251, 980974943, 1651941557, 430374111, 2051154026, 704238805, 4128970897, 3144820574, 2857402727, 948965521, 3333752299, 2227686284, 718756367, 2269778983, 2731643755, 718440111, 2857816721, 3616097120, 1113355533, 2478022182, 410092745, 1811985197, 1944238868, 2696854588, 1415722873, 1682284203, 1060277122, 1998114690, 1503841958, 82706478, 2315155686, 1068173648, 845149890, 2167947013, 1768146376, 1993038550, 3566826697, 3390574031, 940016341, 3355073782, 2328040721, 904371731, 1205506512, 4094660742, 2816623006, 825647681, 85914773, 2857843460, 1249926541, 1417871568, 3287612, 3211054559, 3126306446, 1975924523, 1353700161, 2814456437, 2438597621, 1800716203, 722146342, 2873936343, 1151126914, 4160483941, 2877670899, 458611604, 2866078500, 3483680063, 770352098, 2652916994, 3367839148, 3940505011, 3585973912, 3809620402, 718646636, 2504206814, 2914927912, 3631288169, 2857486607, 2860018678, 575749918, 2857478043, 718488780, 2069512688, 3548183469, 453416197, 1106044049, 3032691430, 52586708, 3378514636, 3459808877, 3211506028, 1785789304, 218356169, 3571399134, 3759170522, 1194783844, 1523787992, 3007827094, 1975193539, 2555452411, 1341901877, 3045838698, 3776907964, 3217423946, 2802510864, 2889438986, 1057244207, 1636348243, 3761863214, 1462225785, 2632663439, 481089165, 718503062, 24497053, 3332243209, 3344655856, 3655024856, 3960371065, 1195698900, 2971415156, 3710176158, 2115785917, 4027663609, 3525578417, 2524296189, 2745972565, 3564906415, 1372086093, 1452307862, 2780501478, 1476592880, 3389271281, 18495466, 2378148571, 901398090, 891748256, 3279637769, 3157290713, 2560960102, 1447622437, 4284372637, 216884176, 2086908623, 1879786977, 3588903153, 2242455666, 2938092967, 3559082096, 2810645491, 758861177, 1121993112, 215018983, 642190776, 4169236812, 1196255959, 2081185372, 3508738393, 941322904, 4124243163, 2877523539, 1848581667, 2205260958, 3180453958, 2589345134, 3694731276, 550028657, 2519456284, 3789985535, 2973870856, 2093648313, 443148163, 46942275, 2734146937, 1117713533, 1115362972, 1523183689, 3717140224, 1551984063], a2[1] = [522195092, 4010518363, 1776537470, 960447360, 4267822970, 4005896314, 1435016340, 1929119313, 2913464185, 1310552629, 3579470798, 3724818106, 2579771631, 1594623892, 417127293, 2715217907, 2696228731, 1508390405, 3994398868, 3925858569, 3695444102, 4019471449, 3129199795, 3770928635, 3520741761, 990456497, 4187484609, 2783367035, 21106139, 3840405339, 631373633, 3783325702, 532942976, 396095098, 3548038825, 4267192484, 2564721535, 2011709262, 2039648873, 620404603, 3776170075, 2898526339, 3612357925, 4159332703, 1645490516, 223693667, 1567101217, 3362177881, 1029951347, 3470931136, 3570957959, 1550265121, 119497089, 972513919, 907948164, 3840628539, 1613718692, 3594177948, 465323573, 2659255085, 654439692, 2575596212, 2699288441, 3127702412, 277098644, 624404830, 4100943870, 2717858591, 546110314, 2403699828, 3655377447, 1321679412, 4236791657, 1045293279, 4010672264, 895050893, 2319792268, 494945126, 1914543101, 2777056443, 3894764339, 2219737618, 311263384, 4275257268, 3458730721, 669096869, 3584475730, 3835122877, 3319158237, 3949359204, 2005142349, 2713102337, 2228954793, 3769984788, 569394103, 3855636576, 1425027204, 108000370, 2736431443, 3671869269, 3043122623, 1750473702, 2211081108, 762237499, 3972989403, 2798899386, 3061857628, 2943854345, 867476300, 964413654, 1591880597, 1594774276, 2179821409, 552026980, 3026064248, 3726140315, 2283577634, 3110545105, 2152310760, 582474363, 1582640421, 1383256631, 2043843868, 3322775884, 1217180674, 463797851, 2763038571, 480777679, 2718707717, 2289164131, 3118346187, 214354409, 200212307, 3810608407, 3025414197, 2674075964, 3997296425, 1847405948, 1342460550, 510035443, 4080271814, 815934613, 833030224, 1620250387, 1945732119, 2703661145, 3966000196, 1388869545, 3456054182, 2687178561, 2092620194, 562037615, 1356438536, 3409922145, 3261847397, 1688467115, 2150901366, 631725691, 3840332284, 549916902, 3455104640, 394546491, 837744717, 2114462948, 751520235, 2221554606, 2415360136, 3999097078, 2063029875, 803036379, 2702586305, 821456707, 3019566164, 360699898, 4018502092, 3511869016, 3677355358, 2402471449, 812317050, 49299192, 2570164949, 3259169295, 2816732080, 3331213574, 3101303564, 2156015656, 3705598920, 3546263921, 143268808, 3200304480, 1638124008, 3165189453, 3341807610, 578956953, 2193977524, 3638120073, 2333881532, 807278310, 658237817, 2969561766, 1641658566, 11683945, 3086995007, 148645947, 1138423386, 4158756760, 1981396783, 2401016740, 3699783584, 380097457, 2680394679, 2803068651, 3334260286, 441530178, 4016580796, 1375954390, 761952171, 891809099, 2183123478, 157052462, 3683840763, 1592404427, 341349109, 2438483839, 1417898363, 644327628, 2233032776, 2353769706, 2201510100, 220455161, 1815641738, 182899273, 2995019788, 3627381533, 3702638151, 2890684138, 1052606899, 588164016, 1681439879, 4038439418, 2405343923, 4229449282, 167996282, 1336969661, 1688053129, 2739224926, 1543734051, 1046297529, 1138201970, 2121126012, 115334942, 1819067631, 1902159161, 1941945968, 2206692869, 1159982321], a2[2] = [2381300288, 637164959, 3952098751, 3893414151, 1197506559, 916448331, 2350892612, 2932787856, 3199334847, 4009478890, 3905886544, 1373570990, 2450425862, 4037870920, 3778841987, 2456817877, 286293407, 124026297, 3001279700, 1028597854, 3115296800, 4208886496, 2691114635, 2188540206, 1430237888, 1218109995, 3572471700, 308166588, 570424558, 2187009021, 2455094765, 307733056, 1310360322, 3135275007, 1384269543, 2388071438, 863238079, 2359263624, 2801553128, 3380786597, 2831162807, 1470087780, 1728663345, 4072488799, 1090516929, 532123132, 2389430977, 1132193179, 2578464191, 3051079243, 1670234342, 1434557849, 2711078940, 1241591150, 3314043432, 3435360113, 3091448339, 1812415473, 2198440252, 267246943, 796911696, 3619716990, 38830015, 1526438404, 2806502096, 374413614, 2943401790, 1489179520, 1603809326, 1920779204, 168801282, 260042626, 2358705581, 1563175598, 2397674057, 1356499128, 2217211040, 514611088, 2037363785, 2186468373, 4022173083, 2792511869, 2913485016, 1173701892, 4200428547, 3896427269, 1334932762, 2455136706, 602925377, 2835607854, 1613172210, 41346230, 2499634548, 2457437618, 2188827595, 41386358, 4172255629, 1313404830, 2405527007, 3801973774, 2217704835, 873260488, 2528884354, 2478092616, 4012915883, 2555359016, 2006953883, 2463913485, 575479328, 2218240648, 2099895446, 660001756, 2341502190, 3038761536, 3888151779, 3848713377, 3286851934, 1022894237, 1620365795, 3449594689, 1551255054, 15374395, 3570825345, 4249311020, 4151111129, 3181912732, 310226346, 1133119310, 530038928, 136043402, 2476768958, 3107506709, 2544909567, 1036173560, 2367337196, 1681395281, 1758231547, 3641649032, 306774401, 1575354324, 3716085866, 1990386196, 3114533736, 2455606671, 1262092282, 3124342505, 2768229131, 4210529083, 1833535011, 423410938, 660763973, 2187129978, 1639812e3, 3508421329, 3467445492, 310289298, 272797111, 2188552562, 2456863912, 310240523, 677093832, 1013118031, 901835429, 3892695601, 1116285435, 3036471170, 1337354835, 243122523, 520626091, 277223598, 4244441197, 4194248841, 1766575121, 594173102, 316590669, 742362309, 3536858622, 4176435350, 3838792410, 2501204839, 1229605004, 3115755532, 1552908988, 2312334149, 979407927, 3959474601, 1148277331, 176638793, 3614686272, 2083809052, 40992502, 1340822838, 2731552767, 3535757508, 3560899520, 1354035053, 122129617, 7215240, 2732932949, 3118912700, 2718203926, 2539075635, 3609230695, 3725561661, 1928887091, 2882293555, 1988674909, 2063640240, 2491088897, 1459647954, 4189817080, 2302804382, 1113892351, 2237858528, 1927010603, 4002880361, 1856122846, 1594404395, 2944033133, 3855189863, 3474975698, 1643104450, 4054590833, 3431086530, 1730235576, 2984608721, 3084664418, 2131803598, 4178205752, 267404349, 1617849798, 1616132681, 1462223176, 736725533, 2327058232, 551665188, 2945899023, 1749386277, 2575514597, 1611482493, 674206544, 2201269090, 3642560800, 728599968, 1680547377, 2620414464, 1388111496, 453204106, 4156223445, 1094905244, 2754698257, 2201108165, 3757000246, 2704524545, 3922940700, 3996465027], a2[3] = [2645754912, 532081118, 2814278639, 3530793624, 1246723035, 1689095255, 2236679235, 4194438865, 2116582143, 3859789411, 157234593, 2045505824, 4245003587, 1687664561, 4083425123, 605965023, 672431967, 1336064205, 3376611392, 214114848, 4258466608, 3232053071, 489488601, 605322005, 3998028058, 264917351, 1912574028, 756637694, 436560991, 202637054, 135989450, 85393697, 2152923392, 3896401662, 2895836408, 2145855233, 3535335007, 115294817, 3147733898, 1922296357, 3464822751, 4117858305, 1037454084, 2725193275, 2127856640, 1417604070, 1148013728, 1827919605, 642362335, 2929772533, 909348033, 1346338451, 3547799649, 297154785, 1917849091, 4161712827, 2883604526, 3968694238, 1469521537, 3780077382, 3375584256, 1763717519, 136166297, 4290970789, 1295325189, 2134727907, 2798151366, 1566297257, 3672928234, 2677174161, 2672173615, 965822077, 2780786062, 289653839, 1133871874, 3491843819, 35685304, 1068898316, 418943774, 672553190, 642281022, 2346158704, 1954014401, 3037126780, 4079815205, 2030668546, 3840588673, 672283427, 1776201016, 359975446, 3750173538, 555499703, 2769985273, 1324923, 69110472, 152125443, 3176785106, 3822147285, 1340634837, 798073664, 1434183902, 15393959, 216384236, 1303690150, 3881221631, 3711134124, 3960975413, 106373927, 2578434224, 1455997841, 1801814300, 1578393881, 1854262133, 3188178946, 3258078583, 2302670060, 1539295533, 3505142565, 3078625975, 2372746020, 549938159, 3278284284, 2620926080, 181285381, 2865321098, 3970029511, 68876850, 488006234, 1728155692, 2608167508, 836007927, 2435231793, 919367643, 3339422534, 3655756360, 1457871481, 40520939, 1380155135, 797931188, 234455205, 2255801827, 3990488299, 397000196, 739833055, 3077865373, 2871719860, 4022553888, 772369276, 390177364, 3853951029, 557662966, 740064294, 1640166671, 1699928825, 3535942136, 622006121, 3625353122, 68743880, 1742502, 219489963, 1664179233, 1577743084, 1236991741, 410585305, 2366487942, 823226535, 1050371084, 3426619607, 3586839478, 212779912, 4147118561, 1819446015, 1911218849, 530248558, 3486241071, 3252585495, 2886188651, 3410272728, 2342195030, 20547779, 2982490058, 3032363469, 3631753222, 312714466, 1870521650, 1493008054, 3491686656, 615382978, 4103671749, 2534517445, 1932181, 2196105170, 278426614, 6369430, 3274544417, 2913018367, 697336853, 2143000447, 2946413531, 701099306, 1558357093, 2805003052, 3500818408, 2321334417, 3567135975, 216290473, 3591032198, 23009561, 1996984579, 3735042806, 2024298078, 3739440863, 569400510, 2339758983, 3016033873, 3097871343, 3639523026, 3844324983, 3256173865, 795471839, 2951117563, 4101031090, 4091603803, 3603732598, 971261452, 534414648, 428311343, 3389027175, 2844869880, 694888862, 1227866773, 2456207019, 3043454569, 2614353370, 3749578031, 3676663836, 459166190, 4132644070, 1794958188, 51825668, 2252611902, 3084671440, 2036672799, 3436641603, 1099053433, 2469121526, 3059204941, 1323291266, 2061838604, 1018778475, 2233344254, 2553501054, 334295216, 3556750194, 1065731521, 183467730], a2[4] = [2127105028, 745436345, 2601412319, 2788391185, 3093987327, 500390133, 1155374404, 389092991, 150729210, 3891597772, 3523549952, 1935325696, 716645080, 946045387, 2901812282, 1774124410, 3869435775, 4039581901, 3293136918, 3438657920, 948246080, 363898952, 3867875531, 1286266623, 1598556673, 68334250, 630723836, 1104211938, 1312863373, 613332731, 2377784574, 1101634306, 441780740, 3129959883, 1917973735, 2510624549, 3238456535, 2544211978, 3308894634, 1299840618, 4076074851, 1756332096, 3977027158, 297047435, 3790297736, 2265573040, 3621810518, 1311375015, 1667687725, 47300608, 3299642885, 2474112369, 201668394, 1468347890, 576830978, 3594690761, 3742605952, 1958042578, 1747032512, 3558991340, 1408974056, 3366841779, 682131401, 1033214337, 1545599232, 4265137049, 206503691, 103024618, 2855227313, 1337551222, 2428998917, 2963842932, 4015366655, 3852247746, 2796956967, 3865723491, 3747938335, 247794022, 3755824572, 702416469, 2434691994, 397379957, 851939612, 2314769512, 218229120, 1380406772, 62274761, 214451378, 3170103466, 2276210409, 3845813286, 28563499, 446592073, 1693330814, 3453727194, 29968656, 3093872512, 220656637, 2470637031, 77972100, 1667708854, 1358280214, 4064765667, 2395616961, 325977563, 4277240721, 4220025399, 3605526484, 3355147721, 811859167, 3069544926, 3962126810, 652502677, 3075892249, 4132761541, 3498924215, 1217549313, 3250244479, 3858715919, 3053989961, 1538642152, 2279026266, 2875879137, 574252750, 3324769229, 2651358713, 1758150215, 141295887, 2719868960, 3515574750, 4093007735, 4194485238, 1082055363, 3417560400, 395511885, 2966884026, 179534037, 3646028556, 3738688086, 1092926436, 2496269142, 257381841, 3772900718, 1636087230, 1477059743, 2499234752, 3811018894, 2675660129, 3285975680, 90732309, 1684827095, 1150307763, 1723134115, 3237045386, 1769919919, 1240018934, 815675215, 750138730, 2239792499, 1234303040, 1995484674, 138143821, 675421338, 1145607174, 1936608440, 3238603024, 2345230278, 2105974004, 323969391, 779555213, 3004902369, 2861610098, 1017501463, 2098600890, 2628620304, 2940611490, 2682542546, 1171473753, 3656571411, 3687208071, 4091869518, 393037935, 159126506, 1662887367, 1147106178, 391545844, 3452332695, 1891500680, 3016609650, 1851642611, 546529401, 1167818917, 3194020571, 2848076033, 3953471836, 575554290, 475796850, 4134673196, 450035699, 2351251534, 844027695, 1080539133, 86184846, 1554234488, 3692025454, 1972511363, 2018339607, 1491841390, 1141460869, 1061690759, 4244549243, 2008416118, 2351104703, 2868147542, 1598468138, 722020353, 1027143159, 212344630, 1387219594, 1725294528, 3745187956, 2500153616, 458938280, 4129215917, 1828119673, 544571780, 3503225445, 2297937496, 1241802790, 267843827, 2694610800, 1397140384, 1558801448, 3782667683, 1806446719, 929573330, 2234912681, 400817706, 616011623, 4121520928, 3603768725, 1761550015, 1968522284, 4053731006, 4192232858, 4005120285, 872482584, 3140537016, 3894607381, 2287405443, 1963876937, 3663887957, 1584857e3, 2975024454, 1833426440, 4025083860], a2[5] = [4143615901, 749497569, 1285769319, 3795025788, 2514159847, 23610292, 3974978748, 844452780, 3214870880, 3751928557, 2213566365, 1676510905, 448177848, 3730751033, 4086298418, 2307502392, 871450977, 3222878141, 4110862042, 3831651966, 2735270553, 1310974780, 2043402188, 1218528103, 2736035353, 4274605013, 2702448458, 3936360550, 2693061421, 162023535, 2827510090, 687910808, 23484817, 3784910947, 3371371616, 779677500, 3503626546, 3473927188, 4157212626, 3500679282, 4248902014, 2466621104, 3899384794, 1958663117, 925738300, 1283408968, 3669349440, 1840910019, 137959847, 2679828185, 1239142320, 1315376211, 1547541505, 1690155329, 739140458, 3128809933, 3933172616, 3876308834, 905091803, 1548541325, 4040461708, 3095483362, 144808038, 451078856, 676114313, 2861728291, 2469707347, 993665471, 373509091, 2599041286, 4025009006, 4170239449, 2149739950, 3275793571, 3749616649, 2794760199, 1534877388, 572371878, 2590613551, 1753320020, 3467782511, 1405125690, 4270405205, 633333386, 3026356924, 3475123903, 632057672, 2846462855, 1404951397, 3882875879, 3915906424, 195638627, 2385783745, 3902872553, 1233155085, 3355999740, 2380578713, 2702246304, 2144565621, 3663341248, 3894384975, 2502479241, 4248018925, 3094885567, 1594115437, 572884632, 3385116731, 767645374, 1331858858, 1475698373, 3793881790, 3532746431, 1321687957, 619889600, 1121017241, 3440213920, 2070816767, 2833025776, 1933951238, 4095615791, 890643334, 3874130214, 859025556, 360630002, 925594799, 1764062180, 3920222280, 4078305929, 979562269, 2810700344, 4087740022, 1949714515, 546639971, 1165388173, 3069891591, 1495988560, 922170659, 1291546247, 2107952832, 1813327274, 3406010024, 3306028637, 4241950635, 153207855, 2313154747, 1608695416, 1150242611, 1967526857, 721801357, 1220138373, 3691287617, 3356069787, 2112743302, 3281662835, 1111556101, 1778980689, 250857638, 2298507990, 673216130, 2846488510, 3207751581, 3562756981, 3008625920, 3417367384, 2198807050, 529510932, 3547516680, 3426503187, 2364944742, 102533054, 2294910856, 1617093527, 1204784762, 3066581635, 1019391227, 1069574518, 1317995090, 1691889997, 3661132003, 510022745, 3238594800, 1362108837, 1817929911, 2184153760, 805817662, 1953603311, 3699844737, 120799444, 2118332377, 207536705, 2282301548, 4120041617, 145305846, 2508124933, 3086745533, 3261524335, 1877257368, 2977164480, 3160454186, 2503252186, 4221677074, 759945014, 254147243, 2767453419, 3801518371, 629083197, 2471014217, 907280572, 3900796746, 940896768, 2751021123, 2625262786, 3161476951, 3661752313, 3260732218, 1425318020, 2977912069, 1496677566, 3988592072, 2140652971, 3126511541, 3069632175, 977771578, 1392695845, 1698528874, 1411812681, 1369733098, 1343739227, 3620887944, 1142123638, 67414216, 3102056737, 3088749194, 1626167401, 2546293654, 3941374235, 697522451, 33404913, 143560186, 2595682037, 994885535, 1247667115, 3859094837, 2699155541, 3547024625, 4114935275, 2968073508, 3199963069, 2732024527, 1237921620, 951448369, 1898488916, 1211705605, 2790989240, 2233243581, 3598044975], a2[6] = [2246066201, 858518887, 1714274303, 3485882003, 713916271, 2879113490, 3730835617, 539548191, 36158695, 1298409750, 419087104, 1358007170, 749914897, 2989680476, 1261868530, 2995193822, 2690628854, 3443622377, 3780124940, 3796824509, 2976433025, 4259637129, 1551479e3, 512490819, 1296650241, 951993153, 2436689437, 2460458047, 144139966, 3136204276, 310820559, 3068840729, 643875328, 1969602020, 1680088954, 2185813161, 3283332454, 672358534, 198762408, 896343282, 276269502, 3014846926, 84060815, 197145886, 376173866, 3943890818, 3813173521, 3545068822, 1316698879, 1598252827, 2633424951, 1233235075, 859989710, 2358460855, 3503838400, 3409603720, 1203513385, 1193654839, 2792018475, 2060853022, 207403770, 1144516871, 3068631394, 1121114134, 177607304, 3785736302, 326409831, 1929119770, 2983279095, 4183308101, 3474579288, 3200513878, 3228482096, 119610148, 1170376745, 3378393471, 3163473169, 951863017, 3337026068, 3135789130, 2907618374, 1183797387, 2015970143, 4045674555, 2182986399, 2952138740, 3928772205, 384012900, 2454997643, 10178499, 2879818989, 2596892536, 111523738, 2995089006, 451689641, 3196290696, 235406569, 1441906262, 3890558523, 3013735005, 4158569349, 1644036924, 376726067, 1006849064, 3664579700, 2041234796, 1021632941, 1374734338, 2566452058, 371631263, 4007144233, 490221539, 206551450, 3140638584, 1053219195, 1853335209, 3412429660, 3562156231, 735133835, 1623211703, 3104214392, 2738312436, 4096837757, 3366392578, 3110964274, 3956598718, 3196820781, 2038037254, 3877786376, 2339753847, 300912036, 3766732888, 2372630639, 1516443558, 4200396704, 1574567987, 4069441456, 4122592016, 2699739776, 146372218, 2748961456, 2043888151, 35287437, 2596680554, 655490400, 1132482787, 110692520, 1031794116, 2188192751, 1324057718, 1217253157, 919197030, 686247489, 3261139658, 1028237775, 3135486431, 3059715558, 2460921700, 986174950, 2661811465, 4062904701, 2752986992, 3709736643, 367056889, 1353824391, 731860949, 1650113154, 1778481506, 784341916, 357075625, 3608602432, 1074092588, 2480052770, 3811426202, 92751289, 877911070, 3600361838, 1231880047, 480201094, 3756190983, 3094495953, 434011822, 87971354, 363687820, 1717726236, 1901380172, 3926403882, 2481662265, 400339184, 1490350766, 2661455099, 1389319756, 2558787174, 784598401, 1983468483, 30828846, 3550527752, 2716276238, 3841122214, 1765724805, 1955612312, 1277890269, 1333098070, 1564029816, 2704417615, 1026694237, 3287671188, 1260819201, 3349086767, 1016692350, 1582273796, 1073413053, 1995943182, 694588404, 1025494639, 3323872702, 3551898420, 4146854327, 453260480, 1316140391, 1435673405, 3038941953, 3486689407, 1622062951, 403978347, 817677117, 950059133, 4246079218, 3278066075, 1486738320, 1417279718, 481875527, 2549965225, 3933690356, 760697757, 1452955855, 3897451437, 1177426808, 1702951038, 4085348628, 2447005172, 1084371187, 3516436277, 3068336338, 1073369276, 1027665953, 3284188590, 1230553676, 1368340146, 2226246512, 267243139, 2274220762, 4070734279, 2497715176, 2423353163, 2504755875], a2[7] = [3793104909, 3151888380, 2817252029, 895778965, 2005530807, 3871412763, 237245952, 86829237, 296341424, 3851759377, 3974600970, 2475086196, 709006108, 1994621201, 2972577594, 937287164, 3734691505, 168608556, 3189338153, 2225080640, 3139713551, 3033610191, 3025041904, 77524477, 185966941, 1208824168, 2344345178, 1721625922, 3354191921, 1066374631, 1927223579, 1971335949, 2483503697, 1551748602, 2881383779, 2856329572, 3003241482, 48746954, 1398218158, 2050065058, 313056748, 4255789917, 393167848, 1912293076, 940740642, 3465845460, 3091687853, 2522601570, 2197016661, 1727764327, 364383054, 492521376, 1291706479, 3264136376, 1474851438, 1685747964, 2575719748, 1619776915, 1814040067, 970743798, 1561002147, 2925768690, 2123093554, 1880132620, 3151188041, 697884420, 2550985770, 2607674513, 2659114323, 110200136, 1489731079, 997519150, 1378877361, 3527870668, 478029773, 2766872923, 1022481122, 431258168, 1112503832, 897933369, 2635587303, 669726182, 3383752315, 918222264, 163866573, 3246985393, 3776823163, 114105080, 1903216136, 761148244, 3571337562, 1690750982, 3166750252, 1037045171, 1888456500, 2010454850, 642736655, 616092351, 365016990, 1185228132, 4174898510, 1043824992, 2023083429, 2241598885, 3863320456, 3279669087, 3674716684, 108438443, 2132974366, 830746235, 606445527, 4173263986, 2204105912, 1844756978, 2532684181, 4245352700, 2969441100, 3796921661, 1335562986, 4061524517, 2720232303, 2679424040, 634407289, 885462008, 3294724487, 3933892248, 2094100220, 339117932, 4048830727, 3202280980, 1458155303, 2689246273, 1022871705, 2464987878, 3714515309, 353796843, 2822958815, 4256850100, 4052777845, 551748367, 618185374, 3778635579, 4020649912, 1904685140, 3069366075, 2670879810, 3407193292, 2954511620, 4058283405, 2219449317, 3135758300, 1120655984, 3447565834, 1474845562, 3577699062, 550456716, 3466908712, 2043752612, 881257467, 869518812, 2005220179, 938474677, 3305539448, 3850417126, 1315485940, 3318264702, 226533026, 965733244, 321539988, 1136104718, 804158748, 573969341, 3708209826, 937399083, 3290727049, 2901666755, 1461057207, 4013193437, 4066861423, 3242773476, 2421326174, 1581322155, 3028952165, 786071460, 3900391652, 3918438532, 1485433313, 4023619836, 3708277595, 3678951060, 953673138, 1467089153, 1930354364, 1533292819, 2492563023, 1346121658, 1685000834, 1965281866, 3765933717, 4190206607, 2052792609, 3515332758, 690371149, 3125873887, 2180283551, 2903598061, 3933952357, 436236910, 289419410, 14314871, 1242357089, 2904507907, 1616633776, 2666382180, 585885352, 3471299210, 2699507360, 1432659641, 277164553, 3354103607, 770115018, 2303809295, 3741942315, 3177781868, 2853364978, 2269453327, 3774259834, 987383833, 1290892879, 225909803, 1741533526, 890078084, 1496906255, 1111072499, 916028167, 243534141, 1252605537, 2204162171, 531204876, 290011180, 3916834213, 102027703, 237315147, 209093447, 1486785922, 220223953, 2758195998, 4175039106, 82940208, 3127791296, 2569425252, 518464269, 1353887104, 3941492737, 2377294467, 3935040926];
    }
    function Ve(e2) {
      this.cast5 = new Ge(), this.cast5.setKey(e2), this.encrypt = function(e3) {
        return this.cast5.encrypt(e3);
      };
    }
    We.keySize = We.prototype.keySize = 24, We.blockSize = We.prototype.blockSize = 8, Ve.blockSize = Ve.prototype.blockSize = 8, Ve.keySize = Ve.prototype.keySize = 16;
    var $e = 4294967295;
    function Ze(e2, t2) {
      return (e2 << t2 | e2 >>> 32 - t2) & $e;
    }
    function Xe(e2, t2) {
      return e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24;
    }
    function Ye(e2, t2, r2) {
      e2.splice(t2, 4, 255 & r2, r2 >>> 8 & 255, r2 >>> 16 & 255, r2 >>> 24 & 255);
    }
    function Qe(e2, t2) {
      return e2 >>> 8 * t2 & 255;
    }
    function Je(e2) {
      this.tf = /* @__PURE__ */ function() {
        let e3 = null, t2 = null, r2 = -1, i2 = [], n2 = [[], [], [], []];
        function a2(e4) {
          return n2[0][Qe(e4, 0)] ^ n2[1][Qe(e4, 1)] ^ n2[2][Qe(e4, 2)] ^ n2[3][Qe(e4, 3)];
        }
        function s2(e4) {
          return n2[0][Qe(e4, 3)] ^ n2[1][Qe(e4, 0)] ^ n2[2][Qe(e4, 1)] ^ n2[3][Qe(e4, 2)];
        }
        function o2(e4, t3) {
          let r3 = a2(t3[0]), n3 = s2(t3[1]);
          t3[2] = Ze(t3[2] ^ r3 + n3 + i2[4 * e4 + 8] & $e, 31), t3[3] = Ze(t3[3], 1) ^ r3 + 2 * n3 + i2[4 * e4 + 9] & $e, r3 = a2(t3[2]), n3 = s2(t3[3]), t3[0] = Ze(t3[0] ^ r3 + n3 + i2[4 * e4 + 10] & $e, 31), t3[1] = Ze(t3[1], 1) ^ r3 + 2 * n3 + i2[4 * e4 + 11] & $e;
        }
        function c2(e4, t3) {
          let r3 = a2(t3[0]), n3 = s2(t3[1]);
          t3[2] = Ze(t3[2], 1) ^ r3 + n3 + i2[4 * e4 + 10] & $e, t3[3] = Ze(t3[3] ^ r3 + 2 * n3 + i2[4 * e4 + 11] & $e, 31), r3 = a2(t3[2]), n3 = s2(t3[3]), t3[0] = Ze(t3[0], 1) ^ r3 + n3 + i2[4 * e4 + 8] & $e, t3[1] = Ze(t3[1] ^ r3 + 2 * n3 + i2[4 * e4 + 9] & $e, 31);
        }
        return { name: "twofish", blocksize: 16, open: function(t3) {
          let r3, a3, s3, o3, c3;
          e3 = t3;
          const u2 = [], h2 = [], d2 = [];
          let f2;
          const l2 = [];
          let p2, y2, b2;
          const g2 = [[8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4], [2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5]], m2 = [[14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13], [1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8]], w2 = [[11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1], [4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15]], v2 = [[13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10], [11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10]], _2 = [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15], k2 = [0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7], A2 = [[], []], S2 = [[], [], [], []];
          function E2(e4) {
            return e4 ^ e4 >> 2 ^ [0, 90, 180, 238][3 & e4];
          }
          function P2(e4) {
            return e4 ^ e4 >> 1 ^ e4 >> 2 ^ [0, 238, 180, 90][3 & e4];
          }
          function x2(e4, t4) {
            let r4, i3, n3;
            for (r4 = 0; r4 < 8; r4++)
              i3 = t4 >>> 24, t4 = t4 << 8 & $e | e4 >>> 24, e4 = e4 << 8 & $e, n3 = i3 << 1, 128 & i3 && (n3 ^= 333), t4 ^= i3 ^ n3 << 16, n3 ^= i3 >>> 1, 1 & i3 && (n3 ^= 166), t4 ^= n3 << 24 | n3 << 8;
            return t4;
          }
          function M2(e4, t4) {
            const r4 = t4 >> 4, i3 = 15 & t4, n3 = g2[e4][r4 ^ i3], a4 = m2[e4][_2[i3] ^ k2[r4]];
            return v2[e4][_2[a4] ^ k2[n3]] << 4 | w2[e4][n3 ^ a4];
          }
          function K2(e4, t4) {
            let r4 = Qe(e4, 0), i3 = Qe(e4, 1), n3 = Qe(e4, 2), a4 = Qe(e4, 3);
            switch (f2) {
              case 4:
                r4 = A2[1][r4] ^ Qe(t4[3], 0), i3 = A2[0][i3] ^ Qe(t4[3], 1), n3 = A2[0][n3] ^ Qe(t4[3], 2), a4 = A2[1][a4] ^ Qe(t4[3], 3);
              case 3:
                r4 = A2[1][r4] ^ Qe(t4[2], 0), i3 = A2[1][i3] ^ Qe(t4[2], 1), n3 = A2[0][n3] ^ Qe(t4[2], 2), a4 = A2[0][a4] ^ Qe(t4[2], 3);
              case 2:
                r4 = A2[0][A2[0][r4] ^ Qe(t4[1], 0)] ^ Qe(t4[0], 0), i3 = A2[0][A2[1][i3] ^ Qe(t4[1], 1)] ^ Qe(t4[0], 1), n3 = A2[1][A2[0][n3] ^ Qe(t4[1], 2)] ^ Qe(t4[0], 2), a4 = A2[1][A2[1][a4] ^ Qe(t4[1], 3)] ^ Qe(t4[0], 3);
            }
            return S2[0][r4] ^ S2[1][i3] ^ S2[2][n3] ^ S2[3][a4];
          }
          for (e3 = e3.slice(0, 32), r3 = e3.length; 16 !== r3 && 24 !== r3 && 32 !== r3; )
            e3[r3++] = 0;
          for (r3 = 0; r3 < e3.length; r3 += 4)
            d2[r3 >> 2] = Xe(e3, r3);
          for (r3 = 0; r3 < 256; r3++)
            A2[0][r3] = M2(0, r3), A2[1][r3] = M2(1, r3);
          for (r3 = 0; r3 < 256; r3++)
            p2 = A2[1][r3], y2 = E2(p2), b2 = P2(p2), S2[0][r3] = p2 + (y2 << 8) + (b2 << 16) + (b2 << 24), S2[2][r3] = y2 + (b2 << 8) + (p2 << 16) + (b2 << 24), p2 = A2[0][r3], y2 = E2(p2), b2 = P2(p2), S2[1][r3] = b2 + (b2 << 8) + (y2 << 16) + (p2 << 24), S2[3][r3] = y2 + (p2 << 8) + (b2 << 16) + (y2 << 24);
          for (f2 = d2.length / 2, r3 = 0; r3 < f2; r3++)
            a3 = d2[r3 + r3], u2[r3] = a3, s3 = d2[r3 + r3 + 1], h2[r3] = s3, l2[f2 - r3 - 1] = x2(a3, s3);
          for (r3 = 0; r3 < 40; r3 += 2)
            a3 = 16843009 * r3, s3 = a3 + 16843009, a3 = K2(a3, u2), s3 = Ze(K2(s3, h2), 8), i2[r3] = a3 + s3 & $e, i2[r3 + 1] = Ze(a3 + 2 * s3, 9);
          for (r3 = 0; r3 < 256; r3++)
            switch (a3 = s3 = o3 = c3 = r3, f2) {
              case 4:
                a3 = A2[1][a3] ^ Qe(l2[3], 0), s3 = A2[0][s3] ^ Qe(l2[3], 1), o3 = A2[0][o3] ^ Qe(l2[3], 2), c3 = A2[1][c3] ^ Qe(l2[3], 3);
              case 3:
                a3 = A2[1][a3] ^ Qe(l2[2], 0), s3 = A2[1][s3] ^ Qe(l2[2], 1), o3 = A2[0][o3] ^ Qe(l2[2], 2), c3 = A2[0][c3] ^ Qe(l2[2], 3);
              case 2:
                n2[0][r3] = S2[0][A2[0][A2[0][a3] ^ Qe(l2[1], 0)] ^ Qe(l2[0], 0)], n2[1][r3] = S2[1][A2[0][A2[1][s3] ^ Qe(l2[1], 1)] ^ Qe(l2[0], 1)], n2[2][r3] = S2[2][A2[1][A2[0][o3] ^ Qe(l2[1], 2)] ^ Qe(l2[0], 2)], n2[3][r3] = S2[3][A2[1][A2[1][c3] ^ Qe(l2[1], 3)] ^ Qe(l2[0], 3)];
            }
        }, close: function() {
          i2 = [], n2 = [[], [], [], []];
        }, encrypt: function(e4, n3) {
          t2 = e4, r2 = n3;
          const a3 = [Xe(t2, r2) ^ i2[0], Xe(t2, r2 + 4) ^ i2[1], Xe(t2, r2 + 8) ^ i2[2], Xe(t2, r2 + 12) ^ i2[3]];
          for (let e5 = 0; e5 < 8; e5++)
            o2(e5, a3);
          return Ye(t2, r2, a3[2] ^ i2[4]), Ye(t2, r2 + 4, a3[3] ^ i2[5]), Ye(t2, r2 + 8, a3[0] ^ i2[6]), Ye(t2, r2 + 12, a3[1] ^ i2[7]), r2 += 16, t2;
        }, decrypt: function(e4, n3) {
          t2 = e4, r2 = n3;
          const a3 = [Xe(t2, r2) ^ i2[4], Xe(t2, r2 + 4) ^ i2[5], Xe(t2, r2 + 8) ^ i2[6], Xe(t2, r2 + 12) ^ i2[7]];
          for (let e5 = 7; e5 >= 0; e5--)
            c2(e5, a3);
          Ye(t2, r2, a3[2] ^ i2[0]), Ye(t2, r2 + 4, a3[3] ^ i2[1]), Ye(t2, r2 + 8, a3[0] ^ i2[2]), Ye(t2, r2 + 12, a3[1] ^ i2[3]), r2 += 16;
        }, finalize: function() {
          return t2;
        } };
      }(), this.tf.open(Array.from(e2), 0), this.encrypt = function(e3) {
        return this.tf.encrypt(Array.from(e3), 0);
      };
    }
    function et() {
    }
    function tt(e2) {
      this.bf = new et(), this.bf.init(e2), this.encrypt = function(e3) {
        return this.bf.encryptBlock(e3);
      };
    }
    Je.keySize = Je.prototype.keySize = 32, Je.blockSize = Je.prototype.blockSize = 16, et.prototype.BLOCKSIZE = 8, et.prototype.SBOXES = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]], et.prototype.PARRAY = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], et.prototype.NN = 16, et.prototype._clean = function(e2) {
      if (e2 < 0) {
        e2 = (2147483647 & e2) + 2147483648;
      }
      return e2;
    }, et.prototype._F = function(e2) {
      let t2;
      const r2 = 255 & e2, i2 = 255 & (e2 >>>= 8), n2 = 255 & (e2 >>>= 8), a2 = 255 & (e2 >>>= 8);
      return t2 = this.sboxes[0][a2] + this.sboxes[1][n2], t2 ^= this.sboxes[2][i2], t2 += this.sboxes[3][r2], t2;
    }, et.prototype._encryptBlock = function(e2) {
      let t2, r2 = e2[0], i2 = e2[1];
      for (t2 = 0; t2 < this.NN; ++t2) {
        r2 ^= this.parray[t2], i2 = this._F(r2) ^ i2;
        const e3 = r2;
        r2 = i2, i2 = e3;
      }
      r2 ^= this.parray[this.NN + 0], i2 ^= this.parray[this.NN + 1], e2[0] = this._clean(i2), e2[1] = this._clean(r2);
    }, et.prototype.encryptBlock = function(e2) {
      let t2;
      const r2 = [0, 0], i2 = this.BLOCKSIZE / 2;
      for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2)
        r2[0] = r2[0] << 8 | 255 & e2[t2 + 0], r2[1] = r2[1] << 8 | 255 & e2[t2 + i2];
      this._encryptBlock(r2);
      const n2 = [];
      for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2)
        n2[t2 + 0] = r2[0] >>> 24 - 8 * t2 & 255, n2[t2 + i2] = r2[1] >>> 24 - 8 * t2 & 255;
      return n2;
    }, et.prototype._decryptBlock = function(e2) {
      let t2, r2 = e2[0], i2 = e2[1];
      for (t2 = this.NN + 1; t2 > 1; --t2) {
        r2 ^= this.parray[t2], i2 = this._F(r2) ^ i2;
        const e3 = r2;
        r2 = i2, i2 = e3;
      }
      r2 ^= this.parray[1], i2 ^= this.parray[0], e2[0] = this._clean(i2), e2[1] = this._clean(r2);
    }, et.prototype.init = function(e2) {
      let t2, r2 = 0;
      for (this.parray = [], t2 = 0; t2 < this.NN + 2; ++t2) {
        let i3 = 0;
        for (let t3 = 0; t3 < 4; ++t3)
          i3 = i3 << 8 | 255 & e2[r2], ++r2 >= e2.length && (r2 = 0);
        this.parray[t2] = this.PARRAY[t2] ^ i3;
      }
      for (this.sboxes = [], t2 = 0; t2 < 4; ++t2)
        for (this.sboxes[t2] = [], r2 = 0; r2 < 256; ++r2)
          this.sboxes[t2][r2] = this.SBOXES[t2][r2];
      const i2 = [0, 0];
      for (t2 = 0; t2 < this.NN + 2; t2 += 2)
        this._encryptBlock(i2), this.parray[t2 + 0] = i2[0], this.parray[t2 + 1] = i2[1];
      for (t2 = 0; t2 < 4; ++t2)
        for (r2 = 0; r2 < 256; r2 += 2)
          this._encryptBlock(i2), this.sboxes[t2][r2 + 0] = i2[0], this.sboxes[t2][r2 + 1] = i2[1];
    }, tt.keySize = tt.prototype.keySize = 16, tt.blockSize = tt.prototype.blockSize = 8;
    var rt = Ne(128);
    var it = Ne(192);
    var nt = Ne(256);
    var at = function(e2) {
      this.key = e2, this.encrypt = function(e3, t2) {
        return je(He(this.key), e3, true, 0, null, t2);
      }, this.decrypt = function(e3, t2) {
        return je(He(this.key), e3, false, 0, null, t2);
      };
    };
    var st = /* @__PURE__ */ Object.freeze({ __proto__: null, aes128: rt, aes192: it, aes256: nt, des: at, tripledes: We, cast5: Ve, twofish: Je, blowfish: tt, idea: function() {
      throw Error("IDEA symmetric-key algorithm not implemented");
    } });
    var ot = function(e2, t2, r2) {
      ;
      var i2 = 0, n2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, u2 = 0;
      var h2 = 0, d2 = 0, f2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, g2 = 0, m2 = 0, w2 = 0;
      var v2 = new e2.Uint8Array(r2);
      function _2(e3, t3, r3, c3, u3, h3, d3, f3, l3, p3, y3, b3, g3, m3, w3, v6) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        c3 = c3 | 0;
        u3 = u3 | 0;
        h3 = h3 | 0;
        d3 = d3 | 0;
        f3 = f3 | 0;
        l3 = l3 | 0;
        p3 = p3 | 0;
        y3 = y3 | 0;
        b3 = b3 | 0;
        g3 = g3 | 0;
        m3 = m3 | 0;
        w3 = w3 | 0;
        v6 = v6 | 0;
        var _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, K3 = 0, C3 = 0, D3 = 0, U3 = 0, R2 = 0, I2 = 0, B2 = 0, T2 = 0, z2 = 0, q2 = 0, F2 = 0, O2 = 0, L2 = 0, N2 = 0, j2 = 0, H2 = 0, W2 = 0, G2 = 0, V2 = 0, $2 = 0, Z2 = 0, X2 = 0, Y2 = 0, Q2 = 0, J2 = 0, ee2 = 0, te2 = 0, re2 = 0, ie2 = 0, ne2 = 0, ae2 = 0, se2 = 0, oe2 = 0, ce2 = 0, ue2 = 0, he2 = 0, de2 = 0, fe2 = 0, le2 = 0, pe2 = 0, ye2 = 0, be2 = 0, ge2 = 0, me2 = 0, we2 = 0, ve2 = 0, _e2 = 0, ke2 = 0, Ae2 = 0, Se2 = 0, Ee2 = 0, Pe2 = 0, xe2 = 0, Me2 = 0, Ke2 = 0, Ce2 = 0, De2 = 0, Ue2 = 0, Re2 = 0, Ie2 = 0, Be2 = 0, Te2 = 0, ze2 = 0;
        _3 = i2;
        k3 = n2;
        A3 = a2;
        S3 = s2;
        E3 = o2;
        x3 = e3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = t3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = r3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = c3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = u3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = h3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = d3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = f3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = l3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = p3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = y3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = b3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = g3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = m3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = w3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = v6 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = m3 ^ l3 ^ r3 ^ e3;
        M3 = P3 << 1 | P3 >>> 31;
        x3 = M3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = w3 ^ p3 ^ c3 ^ t3;
        K3 = P3 << 1 | P3 >>> 31;
        x3 = K3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = v6 ^ y3 ^ u3 ^ r3;
        C3 = P3 << 1 | P3 >>> 31;
        x3 = C3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = M3 ^ b3 ^ h3 ^ c3;
        D3 = P3 << 1 | P3 >>> 31;
        x3 = D3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = K3 ^ g3 ^ d3 ^ u3;
        U3 = P3 << 1 | P3 >>> 31;
        x3 = U3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = C3 ^ m3 ^ f3 ^ h3;
        R2 = P3 << 1 | P3 >>> 31;
        x3 = R2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = D3 ^ w3 ^ l3 ^ d3;
        I2 = P3 << 1 | P3 >>> 31;
        x3 = I2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = U3 ^ v6 ^ p3 ^ f3;
        B2 = P3 << 1 | P3 >>> 31;
        x3 = B2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = R2 ^ M3 ^ y3 ^ l3;
        T2 = P3 << 1 | P3 >>> 31;
        x3 = T2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = I2 ^ K3 ^ b3 ^ p3;
        z2 = P3 << 1 | P3 >>> 31;
        x3 = z2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = B2 ^ C3 ^ g3 ^ y3;
        q2 = P3 << 1 | P3 >>> 31;
        x3 = q2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = T2 ^ D3 ^ m3 ^ b3;
        F2 = P3 << 1 | P3 >>> 31;
        x3 = F2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = z2 ^ U3 ^ w3 ^ g3;
        O2 = P3 << 1 | P3 >>> 31;
        x3 = O2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = q2 ^ R2 ^ v6 ^ m3;
        L2 = P3 << 1 | P3 >>> 31;
        x3 = L2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = F2 ^ I2 ^ M3 ^ w3;
        N2 = P3 << 1 | P3 >>> 31;
        x3 = N2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = O2 ^ B2 ^ K3 ^ v6;
        j2 = P3 << 1 | P3 >>> 31;
        x3 = j2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = L2 ^ T2 ^ C3 ^ M3;
        H2 = P3 << 1 | P3 >>> 31;
        x3 = H2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = N2 ^ z2 ^ D3 ^ K3;
        W2 = P3 << 1 | P3 >>> 31;
        x3 = W2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = j2 ^ q2 ^ U3 ^ C3;
        G2 = P3 << 1 | P3 >>> 31;
        x3 = G2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = H2 ^ F2 ^ R2 ^ D3;
        V2 = P3 << 1 | P3 >>> 31;
        x3 = V2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = W2 ^ O2 ^ I2 ^ U3;
        $2 = P3 << 1 | P3 >>> 31;
        x3 = $2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = G2 ^ L2 ^ B2 ^ R2;
        Z2 = P3 << 1 | P3 >>> 31;
        x3 = Z2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = V2 ^ N2 ^ T2 ^ I2;
        X2 = P3 << 1 | P3 >>> 31;
        x3 = X2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = $2 ^ j2 ^ z2 ^ B2;
        Y2 = P3 << 1 | P3 >>> 31;
        x3 = Y2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Z2 ^ H2 ^ q2 ^ T2;
        Q2 = P3 << 1 | P3 >>> 31;
        x3 = Q2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = X2 ^ W2 ^ F2 ^ z2;
        J2 = P3 << 1 | P3 >>> 31;
        x3 = J2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Y2 ^ G2 ^ O2 ^ q2;
        ee2 = P3 << 1 | P3 >>> 31;
        x3 = ee2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Q2 ^ V2 ^ L2 ^ F2;
        te2 = P3 << 1 | P3 >>> 31;
        x3 = te2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = J2 ^ $2 ^ N2 ^ O2;
        re2 = P3 << 1 | P3 >>> 31;
        x3 = re2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ee2 ^ Z2 ^ j2 ^ L2;
        ie2 = P3 << 1 | P3 >>> 31;
        x3 = ie2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = te2 ^ X2 ^ H2 ^ N2;
        ne2 = P3 << 1 | P3 >>> 31;
        x3 = ne2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = re2 ^ Y2 ^ W2 ^ j2;
        ae2 = P3 << 1 | P3 >>> 31;
        x3 = ae2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ie2 ^ Q2 ^ G2 ^ H2;
        se2 = P3 << 1 | P3 >>> 31;
        x3 = se2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ne2 ^ J2 ^ V2 ^ W2;
        oe2 = P3 << 1 | P3 >>> 31;
        x3 = oe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ae2 ^ ee2 ^ $2 ^ G2;
        ce2 = P3 << 1 | P3 >>> 31;
        x3 = ce2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = se2 ^ te2 ^ Z2 ^ V2;
        ue2 = P3 << 1 | P3 >>> 31;
        x3 = ue2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = oe2 ^ re2 ^ X2 ^ $2;
        he2 = P3 << 1 | P3 >>> 31;
        x3 = he2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ce2 ^ ie2 ^ Y2 ^ Z2;
        de2 = P3 << 1 | P3 >>> 31;
        x3 = de2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ue2 ^ ne2 ^ Q2 ^ X2;
        fe2 = P3 << 1 | P3 >>> 31;
        x3 = fe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = he2 ^ ae2 ^ J2 ^ Y2;
        le2 = P3 << 1 | P3 >>> 31;
        x3 = le2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = de2 ^ se2 ^ ee2 ^ Q2;
        pe2 = P3 << 1 | P3 >>> 31;
        x3 = pe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = fe2 ^ oe2 ^ te2 ^ J2;
        ye2 = P3 << 1 | P3 >>> 31;
        x3 = ye2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = le2 ^ ce2 ^ re2 ^ ee2;
        be2 = P3 << 1 | P3 >>> 31;
        x3 = be2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = pe2 ^ ue2 ^ ie2 ^ te2;
        ge2 = P3 << 1 | P3 >>> 31;
        x3 = ge2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ye2 ^ he2 ^ ne2 ^ re2;
        me2 = P3 << 1 | P3 >>> 31;
        x3 = me2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = be2 ^ de2 ^ ae2 ^ ie2;
        we2 = P3 << 1 | P3 >>> 31;
        x3 = we2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ge2 ^ fe2 ^ se2 ^ ne2;
        ve2 = P3 << 1 | P3 >>> 31;
        x3 = ve2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = me2 ^ le2 ^ oe2 ^ ae2;
        _e2 = P3 << 1 | P3 >>> 31;
        x3 = _e2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = we2 ^ pe2 ^ ce2 ^ se2;
        ke2 = P3 << 1 | P3 >>> 31;
        x3 = ke2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ve2 ^ ye2 ^ ue2 ^ oe2;
        Ae2 = P3 << 1 | P3 >>> 31;
        x3 = Ae2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = _e2 ^ be2 ^ he2 ^ ce2;
        Se2 = P3 << 1 | P3 >>> 31;
        x3 = Se2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ke2 ^ ge2 ^ de2 ^ ue2;
        Ee2 = P3 << 1 | P3 >>> 31;
        x3 = Ee2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ae2 ^ me2 ^ fe2 ^ he2;
        Pe2 = P3 << 1 | P3 >>> 31;
        x3 = Pe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Se2 ^ we2 ^ le2 ^ de2;
        xe2 = P3 << 1 | P3 >>> 31;
        x3 = xe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ee2 ^ ve2 ^ pe2 ^ fe2;
        Me2 = P3 << 1 | P3 >>> 31;
        x3 = Me2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Pe2 ^ _e2 ^ ye2 ^ le2;
        Ke2 = P3 << 1 | P3 >>> 31;
        x3 = Ke2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = xe2 ^ ke2 ^ be2 ^ pe2;
        Ce2 = P3 << 1 | P3 >>> 31;
        x3 = Ce2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Me2 ^ Ae2 ^ ge2 ^ ye2;
        De2 = P3 << 1 | P3 >>> 31;
        x3 = De2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ke2 ^ Se2 ^ me2 ^ be2;
        Ue2 = P3 << 1 | P3 >>> 31;
        x3 = Ue2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ce2 ^ Ee2 ^ we2 ^ ge2;
        Re2 = P3 << 1 | P3 >>> 31;
        x3 = Re2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = De2 ^ Pe2 ^ ve2 ^ me2;
        Ie2 = P3 << 1 | P3 >>> 31;
        x3 = Ie2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ue2 ^ xe2 ^ _e2 ^ we2;
        Be2 = P3 << 1 | P3 >>> 31;
        x3 = Be2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Re2 ^ Me2 ^ ke2 ^ ve2;
        Te2 = P3 << 1 | P3 >>> 31;
        x3 = Te2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ie2 ^ Ke2 ^ Ae2 ^ _e2;
        ze2 = P3 << 1 | P3 >>> 31;
        x3 = ze2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        i2 = i2 + _3 | 0;
        n2 = n2 + k3 | 0;
        a2 = a2 + A3 | 0;
        s2 = s2 + S3 | 0;
        o2 = o2 + E3 | 0;
      }
      function k2(e3) {
        e3 = e3 | 0;
        _2(v2[e3 | 0] << 24 | v2[e3 | 1] << 16 | v2[e3 | 2] << 8 | v2[e3 | 3], v2[e3 | 4] << 24 | v2[e3 | 5] << 16 | v2[e3 | 6] << 8 | v2[e3 | 7], v2[e3 | 8] << 24 | v2[e3 | 9] << 16 | v2[e3 | 10] << 8 | v2[e3 | 11], v2[e3 | 12] << 24 | v2[e3 | 13] << 16 | v2[e3 | 14] << 8 | v2[e3 | 15], v2[e3 | 16] << 24 | v2[e3 | 17] << 16 | v2[e3 | 18] << 8 | v2[e3 | 19], v2[e3 | 20] << 24 | v2[e3 | 21] << 16 | v2[e3 | 22] << 8 | v2[e3 | 23], v2[e3 | 24] << 24 | v2[e3 | 25] << 16 | v2[e3 | 26] << 8 | v2[e3 | 27], v2[e3 | 28] << 24 | v2[e3 | 29] << 16 | v2[e3 | 30] << 8 | v2[e3 | 31], v2[e3 | 32] << 24 | v2[e3 | 33] << 16 | v2[e3 | 34] << 8 | v2[e3 | 35], v2[e3 | 36] << 24 | v2[e3 | 37] << 16 | v2[e3 | 38] << 8 | v2[e3 | 39], v2[e3 | 40] << 24 | v2[e3 | 41] << 16 | v2[e3 | 42] << 8 | v2[e3 | 43], v2[e3 | 44] << 24 | v2[e3 | 45] << 16 | v2[e3 | 46] << 8 | v2[e3 | 47], v2[e3 | 48] << 24 | v2[e3 | 49] << 16 | v2[e3 | 50] << 8 | v2[e3 | 51], v2[e3 | 52] << 24 | v2[e3 | 53] << 16 | v2[e3 | 54] << 8 | v2[e3 | 55], v2[e3 | 56] << 24 | v2[e3 | 57] << 16 | v2[e3 | 58] << 8 | v2[e3 | 59], v2[e3 | 60] << 24 | v2[e3 | 61] << 16 | v2[e3 | 62] << 8 | v2[e3 | 63]);
      }
      function A2(e3) {
        e3 = e3 | 0;
        v2[e3 | 0] = i2 >>> 24;
        v2[e3 | 1] = i2 >>> 16 & 255;
        v2[e3 | 2] = i2 >>> 8 & 255;
        v2[e3 | 3] = i2 & 255;
        v2[e3 | 4] = n2 >>> 24;
        v2[e3 | 5] = n2 >>> 16 & 255;
        v2[e3 | 6] = n2 >>> 8 & 255;
        v2[e3 | 7] = n2 & 255;
        v2[e3 | 8] = a2 >>> 24;
        v2[e3 | 9] = a2 >>> 16 & 255;
        v2[e3 | 10] = a2 >>> 8 & 255;
        v2[e3 | 11] = a2 & 255;
        v2[e3 | 12] = s2 >>> 24;
        v2[e3 | 13] = s2 >>> 16 & 255;
        v2[e3 | 14] = s2 >>> 8 & 255;
        v2[e3 | 15] = s2 & 255;
        v2[e3 | 16] = o2 >>> 24;
        v2[e3 | 17] = o2 >>> 16 & 255;
        v2[e3 | 18] = o2 >>> 8 & 255;
        v2[e3 | 19] = o2 & 255;
      }
      function S2() {
        i2 = 1732584193;
        n2 = 4023233417;
        a2 = 2562383102;
        s2 = 271733878;
        o2 = 3285377520;
        c2 = u2 = 0;
      }
      function E2(e3, t3, r3, h3, d3, f3, l3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        h3 = h3 | 0;
        d3 = d3 | 0;
        f3 = f3 | 0;
        l3 = l3 | 0;
        i2 = e3;
        n2 = t3;
        a2 = r3;
        s2 = h3;
        o2 = d3;
        c2 = f3;
        u2 = l3;
      }
      function P2(e3, t3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        var r3 = 0;
        if (e3 & 63)
          return -1;
        while ((t3 | 0) >= 64) {
          k2(e3);
          e3 = e3 + 64 | 0;
          t3 = t3 - 64 | 0;
          r3 = r3 + 64 | 0;
        }
        c2 = c2 + r3 | 0;
        if (c2 >>> 0 < r3 >>> 0)
          u2 = u2 + 1 | 0;
        return r3 | 0;
      }
      function x2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var i3 = 0, n3 = 0;
        if (e3 & 63)
          return -1;
        if (~r3) {
          if (r3 & 31)
            return -1;
        }
        if ((t3 | 0) >= 64) {
          i3 = P2(e3, t3) | 0;
          if ((i3 | 0) == -1)
            return -1;
          e3 = e3 + i3 | 0;
          t3 = t3 - i3 | 0;
        }
        i3 = i3 + t3 | 0;
        c2 = c2 + t3 | 0;
        if (c2 >>> 0 < t3 >>> 0)
          u2 = u2 + 1 | 0;
        v2[e3 | t3] = 128;
        if ((t3 | 0) >= 56) {
          for (n3 = t3 + 1 | 0; (n3 | 0) < 64; n3 = n3 + 1 | 0)
            v2[e3 | n3] = 0;
          k2(e3);
          t3 = 0;
          v2[e3 | 0] = 0;
        }
        for (n3 = t3 + 1 | 0; (n3 | 0) < 59; n3 = n3 + 1 | 0)
          v2[e3 | n3] = 0;
        v2[e3 | 56] = u2 >>> 21 & 255;
        v2[e3 | 57] = u2 >>> 13 & 255;
        v2[e3 | 58] = u2 >>> 5 & 255;
        v2[e3 | 59] = u2 << 3 & 255 | c2 >>> 29;
        v2[e3 | 60] = c2 >>> 21 & 255;
        v2[e3 | 61] = c2 >>> 13 & 255;
        v2[e3 | 62] = c2 >>> 5 & 255;
        v2[e3 | 63] = c2 << 3 & 255;
        k2(e3);
        if (~r3)
          A2(r3);
        return i3 | 0;
      }
      function M2() {
        i2 = h2;
        n2 = d2;
        a2 = f2;
        s2 = l2;
        o2 = p2;
        c2 = 64;
        u2 = 0;
      }
      function K2() {
        i2 = y2;
        n2 = b2;
        a2 = g2;
        s2 = m2;
        o2 = w2;
        c2 = 64;
        u2 = 0;
      }
      function C2(e3, t3, r3, v6, k3, A3, E3, P3, x3, M3, K3, C3, D3, U3, R2, I2) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        v6 = v6 | 0;
        k3 = k3 | 0;
        A3 = A3 | 0;
        E3 = E3 | 0;
        P3 = P3 | 0;
        x3 = x3 | 0;
        M3 = M3 | 0;
        K3 = K3 | 0;
        C3 = C3 | 0;
        D3 = D3 | 0;
        U3 = U3 | 0;
        R2 = R2 | 0;
        I2 = I2 | 0;
        S2();
        _2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, v6 ^ 1549556828, k3 ^ 1549556828, A3 ^ 1549556828, E3 ^ 1549556828, P3 ^ 1549556828, x3 ^ 1549556828, M3 ^ 1549556828, K3 ^ 1549556828, C3 ^ 1549556828, D3 ^ 1549556828, U3 ^ 1549556828, R2 ^ 1549556828, I2 ^ 1549556828);
        y2 = i2;
        b2 = n2;
        g2 = a2;
        m2 = s2;
        w2 = o2;
        S2();
        _2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, v6 ^ 909522486, k3 ^ 909522486, A3 ^ 909522486, E3 ^ 909522486, P3 ^ 909522486, x3 ^ 909522486, M3 ^ 909522486, K3 ^ 909522486, C3 ^ 909522486, D3 ^ 909522486, U3 ^ 909522486, R2 ^ 909522486, I2 ^ 909522486);
        h2 = i2;
        d2 = n2;
        f2 = a2;
        l2 = s2;
        p2 = o2;
        c2 = 64;
        u2 = 0;
      }
      function D2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var c3 = 0, u3 = 0, h3 = 0, d3 = 0, f3 = 0, l3 = 0;
        if (e3 & 63)
          return -1;
        if (~r3) {
          if (r3 & 31)
            return -1;
        }
        l3 = x2(e3, t3, -1) | 0;
        c3 = i2, u3 = n2, h3 = a2, d3 = s2, f3 = o2;
        K2();
        _2(c3, u3, h3, d3, f3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
        if (~r3)
          A2(r3);
        return l3 | 0;
      }
      function U2(e3, t3, r3, c3, u3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        c3 = c3 | 0;
        u3 = u3 | 0;
        var h3 = 0, d3 = 0, f3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0, m3 = 0, w3 = 0;
        if (e3 & 63)
          return -1;
        if (~u3) {
          if (u3 & 31)
            return -1;
        }
        v2[e3 + t3 | 0] = r3 >>> 24;
        v2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
        v2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
        v2[e3 + t3 + 3 | 0] = r3 & 255;
        D2(e3, t3 + 4 | 0, -1) | 0;
        h3 = y3 = i2, d3 = b3 = n2, f3 = g3 = a2, l3 = m3 = s2, p3 = w3 = o2;
        c3 = c3 - 1 | 0;
        while ((c3 | 0) > 0) {
          M2();
          _2(y3, b3, g3, m3, w3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
          y3 = i2, b3 = n2, g3 = a2, m3 = s2, w3 = o2;
          K2();
          _2(y3, b3, g3, m3, w3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
          y3 = i2, b3 = n2, g3 = a2, m3 = s2, w3 = o2;
          h3 = h3 ^ i2;
          d3 = d3 ^ n2;
          f3 = f3 ^ a2;
          l3 = l3 ^ s2;
          p3 = p3 ^ o2;
          c3 = c3 - 1 | 0;
        }
        i2 = h3;
        n2 = d3;
        a2 = f3;
        s2 = l3;
        o2 = p3;
        if (~u3)
          A2(u3);
        return 0;
      }
      return { reset: S2, init: E2, process: P2, finish: x2, hmac_reset: M2, hmac_init: C2, hmac_finish: D2, pbkdf2_generate_block: U2 };
    };
    var ct = class {
      constructor() {
        this.pos = 0, this.len = 0;
      }
      reset() {
        const { asm: e2 } = this.acquire_asm();
        return this.result = null, this.pos = 0, this.len = 0, e2.reset(), this;
      }
      process(e2) {
        if (null !== this.result)
          throw new Be("state must be reset before processing new data");
        const { asm: t2, heap: r2 } = this.acquire_asm();
        let i2 = this.pos, n2 = this.len, a2 = 0, s2 = e2.length, o2 = 0;
        for (; s2 > 0; )
          o2 = Re(r2, i2 + n2, e2, a2, s2), n2 += o2, a2 += o2, s2 -= o2, o2 = t2.process(i2, n2), i2 += o2, n2 -= o2, n2 || (i2 = 0);
        return this.pos = i2, this.len = n2, this;
      }
      finish() {
        if (null !== this.result)
          throw new Be("state must be reset before processing new data");
        const { asm: e2, heap: t2 } = this.acquire_asm();
        return e2.finish(this.pos, this.len, 0), this.result = new Uint8Array(this.HASH_SIZE), this.result.set(t2.subarray(0, this.HASH_SIZE)), this.pos = 0, this.len = 0, this.release_asm(), this;
      }
    };
    var ut = [];
    var ht = [];
    var dt = class _dt extends ct {
      constructor() {
        super(), this.NAME = "sha1", this.BLOCK_SIZE = 64, this.HASH_SIZE = 20, this.acquire_asm();
      }
      acquire_asm() {
        return void 0 !== this.heap && void 0 !== this.asm || (this.heap = ut.pop() || Ue(), this.asm = ht.pop() || ot({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        void 0 !== this.heap && void 0 !== this.asm && (ut.push(this.heap), ht.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      static bytes(e2) {
        return new _dt().process(e2).finish().result;
      }
    };
    dt.NAME = "sha1", dt.heap_pool = [], dt.asm_pool = [], dt.asm_function = ot;
    var ft = [];
    var lt = [];
    var pt = class _pt extends ct {
      constructor() {
        super(), this.NAME = "sha256", this.BLOCK_SIZE = 64, this.HASH_SIZE = 32, this.acquire_asm();
      }
      acquire_asm() {
        return void 0 !== this.heap && void 0 !== this.asm || (this.heap = ft.pop() || Ue(), this.asm = lt.pop() || function(e2, t2, r2) {
          ;
          var i2 = 0, n2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, u2 = 0, h2 = 0, d2 = 0, f2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, g2 = 0, m2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0, S2 = 0, E2 = 0, P2 = 0, x2 = 0, M2 = 0, K2 = new e2.Uint8Array(r2);
          function C2(e3, t3, r3, d3, f3, l3, p3, y3, b3, g3, m3, w3, v6, _3, k3, A3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            d3 = d3 | 0;
            f3 = f3 | 0;
            l3 = l3 | 0;
            p3 = p3 | 0;
            y3 = y3 | 0;
            b3 = b3 | 0;
            g3 = g3 | 0;
            m3 = m3 | 0;
            w3 = w3 | 0;
            v6 = v6 | 0;
            _3 = _3 | 0;
            k3 = k3 | 0;
            A3 = A3 | 0;
            var S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, K3 = 0, C3 = 0, D3 = 0;
            S3 = i2;
            E3 = n2;
            P3 = a2;
            x3 = s2;
            M3 = o2;
            K3 = c2;
            C3 = u2;
            D3 = h2;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 1116352408 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            C3 = t3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 1899447441 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            K3 = r3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 3049323471 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            M3 = d3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3921009573 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            x3 = f3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 961987163 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1508970993 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            E3 = p3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 2453635748 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            S3 = y3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 2870763221 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 3624381080 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            C3 = g3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 310598401 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            K3 = m3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 607225278 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 1426881987 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            x3 = v6 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 1925078388 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 2162078206 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            E3 = k3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 2614888103 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            S3 = A3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 3248222580 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + g3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 3835390401 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + m3 | 0;
            C3 = t3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 4022224774 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            K3 = r3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 264347078 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + d3 + v6 | 0;
            M3 = d3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 604807628 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + f3 + _3 | 0;
            x3 = f3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 770255983 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1249150122 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 1555081692 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 1996064986 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 2554220882 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + g3 + r3 | 0;
            C3 = g3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 2821834349 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + m3 + d3 | 0;
            K3 = m3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 2952996808 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            w3 = (v6 >>> 7 ^ v6 >>> 18 ^ v6 >>> 3 ^ v6 << 25 ^ v6 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + f3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3210313671 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            v6 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + v6 + l3 | 0;
            x3 = v6 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 3336571891 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 3584528711 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v6 >>> 17 ^ v6 >>> 19 ^ v6 >>> 10 ^ v6 << 15 ^ v6 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 113926993 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 338241895 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + g3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 666307205 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + m3 | 0;
            C3 = t3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 773529912 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            K3 = r3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 1294757372 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + d3 + v6 | 0;
            M3 = d3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 1396182291 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + f3 + _3 | 0;
            x3 = f3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 1695183700 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1986661051 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 2177026350 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 2456956037 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 2730485921 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + g3 + r3 | 0;
            C3 = g3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 2820302411 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + m3 + d3 | 0;
            K3 = m3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 3259730800 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            w3 = (v6 >>> 7 ^ v6 >>> 18 ^ v6 >>> 3 ^ v6 << 25 ^ v6 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + f3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3345764771 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            v6 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + v6 + l3 | 0;
            x3 = v6 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 3516065817 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 3600352804 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v6 >>> 17 ^ v6 >>> 19 ^ v6 >>> 10 ^ v6 << 15 ^ v6 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 4094571909 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 275423344 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + g3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 430227734 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + m3 | 0;
            C3 = t3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 506948616 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            K3 = r3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 659060556 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + d3 + v6 | 0;
            M3 = d3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 883997877 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + f3 + _3 | 0;
            x3 = f3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 958139571 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1322822218 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 1537002063 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 1747873779 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (C3 ^ M3 & (K3 ^ C3)) + 1955562222 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            g3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + g3 + r3 | 0;
            C3 = g3 + C3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (K3 ^ x3 & (M3 ^ K3)) + 2024104815 | 0;
            P3 = P3 + C3 | 0;
            C3 = C3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            m3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + m3 + d3 | 0;
            K3 = m3 + K3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 2227730452 | 0;
            E3 = E3 + K3 | 0;
            K3 = K3 + (C3 & D3 ^ S3 & (C3 ^ D3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            w3 = (v6 >>> 7 ^ v6 >>> 18 ^ v6 >>> 3 ^ v6 << 25 ^ v6 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + w3 + f3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 2361852424 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (K3 & C3 ^ D3 & (K3 ^ C3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            v6 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + v6 + l3 | 0;
            x3 = v6 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 2428436474 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & K3 ^ C3 & (M3 ^ K3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 2756734187 | 0;
            C3 = C3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ K3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v6 >>> 17 ^ v6 >>> 19 ^ v6 >>> 10 ^ v6 << 15 ^ v6 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (S3 ^ C3 & (D3 ^ S3)) + 3204031479 | 0;
            K3 = K3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (D3 ^ K3 & (C3 ^ D3)) + 3329325298 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            i2 = i2 + S3 | 0;
            n2 = n2 + E3 | 0;
            a2 = a2 + P3 | 0;
            s2 = s2 + x3 | 0;
            o2 = o2 + M3 | 0;
            c2 = c2 + K3 | 0;
            u2 = u2 + C3 | 0;
            h2 = h2 + D3 | 0;
          }
          function D2(e3) {
            e3 = e3 | 0;
            C2(K2[e3 | 0] << 24 | K2[e3 | 1] << 16 | K2[e3 | 2] << 8 | K2[e3 | 3], K2[e3 | 4] << 24 | K2[e3 | 5] << 16 | K2[e3 | 6] << 8 | K2[e3 | 7], K2[e3 | 8] << 24 | K2[e3 | 9] << 16 | K2[e3 | 10] << 8 | K2[e3 | 11], K2[e3 | 12] << 24 | K2[e3 | 13] << 16 | K2[e3 | 14] << 8 | K2[e3 | 15], K2[e3 | 16] << 24 | K2[e3 | 17] << 16 | K2[e3 | 18] << 8 | K2[e3 | 19], K2[e3 | 20] << 24 | K2[e3 | 21] << 16 | K2[e3 | 22] << 8 | K2[e3 | 23], K2[e3 | 24] << 24 | K2[e3 | 25] << 16 | K2[e3 | 26] << 8 | K2[e3 | 27], K2[e3 | 28] << 24 | K2[e3 | 29] << 16 | K2[e3 | 30] << 8 | K2[e3 | 31], K2[e3 | 32] << 24 | K2[e3 | 33] << 16 | K2[e3 | 34] << 8 | K2[e3 | 35], K2[e3 | 36] << 24 | K2[e3 | 37] << 16 | K2[e3 | 38] << 8 | K2[e3 | 39], K2[e3 | 40] << 24 | K2[e3 | 41] << 16 | K2[e3 | 42] << 8 | K2[e3 | 43], K2[e3 | 44] << 24 | K2[e3 | 45] << 16 | K2[e3 | 46] << 8 | K2[e3 | 47], K2[e3 | 48] << 24 | K2[e3 | 49] << 16 | K2[e3 | 50] << 8 | K2[e3 | 51], K2[e3 | 52] << 24 | K2[e3 | 53] << 16 | K2[e3 | 54] << 8 | K2[e3 | 55], K2[e3 | 56] << 24 | K2[e3 | 57] << 16 | K2[e3 | 58] << 8 | K2[e3 | 59], K2[e3 | 60] << 24 | K2[e3 | 61] << 16 | K2[e3 | 62] << 8 | K2[e3 | 63]);
          }
          function U2(e3) {
            e3 = e3 | 0;
            K2[e3 | 0] = i2 >>> 24;
            K2[e3 | 1] = i2 >>> 16 & 255;
            K2[e3 | 2] = i2 >>> 8 & 255;
            K2[e3 | 3] = i2 & 255;
            K2[e3 | 4] = n2 >>> 24;
            K2[e3 | 5] = n2 >>> 16 & 255;
            K2[e3 | 6] = n2 >>> 8 & 255;
            K2[e3 | 7] = n2 & 255;
            K2[e3 | 8] = a2 >>> 24;
            K2[e3 | 9] = a2 >>> 16 & 255;
            K2[e3 | 10] = a2 >>> 8 & 255;
            K2[e3 | 11] = a2 & 255;
            K2[e3 | 12] = s2 >>> 24;
            K2[e3 | 13] = s2 >>> 16 & 255;
            K2[e3 | 14] = s2 >>> 8 & 255;
            K2[e3 | 15] = s2 & 255;
            K2[e3 | 16] = o2 >>> 24;
            K2[e3 | 17] = o2 >>> 16 & 255;
            K2[e3 | 18] = o2 >>> 8 & 255;
            K2[e3 | 19] = o2 & 255;
            K2[e3 | 20] = c2 >>> 24;
            K2[e3 | 21] = c2 >>> 16 & 255;
            K2[e3 | 22] = c2 >>> 8 & 255;
            K2[e3 | 23] = c2 & 255;
            K2[e3 | 24] = u2 >>> 24;
            K2[e3 | 25] = u2 >>> 16 & 255;
            K2[e3 | 26] = u2 >>> 8 & 255;
            K2[e3 | 27] = u2 & 255;
            K2[e3 | 28] = h2 >>> 24;
            K2[e3 | 29] = h2 >>> 16 & 255;
            K2[e3 | 30] = h2 >>> 8 & 255;
            K2[e3 | 31] = h2 & 255;
          }
          function R2() {
            i2 = 1779033703;
            n2 = 3144134277;
            a2 = 1013904242;
            s2 = 2773480762;
            o2 = 1359893119;
            c2 = 2600822924;
            u2 = 528734635;
            h2 = 1541459225;
            d2 = f2 = 0;
          }
          function I2(e3, t3, r3, l3, p3, y3, b3, g3, m3, w3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            l3 = l3 | 0;
            p3 = p3 | 0;
            y3 = y3 | 0;
            b3 = b3 | 0;
            g3 = g3 | 0;
            m3 = m3 | 0;
            w3 = w3 | 0;
            i2 = e3;
            n2 = t3;
            a2 = r3;
            s2 = l3;
            o2 = p3;
            c2 = y3;
            u2 = b3;
            h2 = g3;
            d2 = m3;
            f2 = w3;
          }
          function B2(e3, t3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            var r3 = 0;
            if (e3 & 63)
              return -1;
            while ((t3 | 0) >= 64) {
              D2(e3);
              e3 = e3 + 64 | 0;
              t3 = t3 - 64 | 0;
              r3 = r3 + 64 | 0;
            }
            d2 = d2 + r3 | 0;
            if (d2 >>> 0 < r3 >>> 0)
              f2 = f2 + 1 | 0;
            return r3 | 0;
          }
          function T2(e3, t3, r3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            var i3 = 0, n3 = 0;
            if (e3 & 63)
              return -1;
            if (~r3) {
              if (r3 & 31)
                return -1;
            }
            if ((t3 | 0) >= 64) {
              i3 = B2(e3, t3) | 0;
              if ((i3 | 0) == -1)
                return -1;
              e3 = e3 + i3 | 0;
              t3 = t3 - i3 | 0;
            }
            i3 = i3 + t3 | 0;
            d2 = d2 + t3 | 0;
            if (d2 >>> 0 < t3 >>> 0)
              f2 = f2 + 1 | 0;
            K2[e3 | t3] = 128;
            if ((t3 | 0) >= 56) {
              for (n3 = t3 + 1 | 0; (n3 | 0) < 64; n3 = n3 + 1 | 0)
                K2[e3 | n3] = 0;
              D2(e3);
              t3 = 0;
              K2[e3 | 0] = 0;
            }
            for (n3 = t3 + 1 | 0; (n3 | 0) < 59; n3 = n3 + 1 | 0)
              K2[e3 | n3] = 0;
            K2[e3 | 56] = f2 >>> 21 & 255;
            K2[e3 | 57] = f2 >>> 13 & 255;
            K2[e3 | 58] = f2 >>> 5 & 255;
            K2[e3 | 59] = f2 << 3 & 255 | d2 >>> 29;
            K2[e3 | 60] = d2 >>> 21 & 255;
            K2[e3 | 61] = d2 >>> 13 & 255;
            K2[e3 | 62] = d2 >>> 5 & 255;
            K2[e3 | 63] = d2 << 3 & 255;
            D2(e3);
            if (~r3)
              U2(r3);
            return i3 | 0;
          }
          function z2() {
            i2 = l2;
            n2 = p2;
            a2 = y2;
            s2 = b2;
            o2 = g2;
            c2 = m2;
            u2 = w2;
            h2 = v2;
            d2 = 64;
            f2 = 0;
          }
          function q2() {
            i2 = _2;
            n2 = k2;
            a2 = A2;
            s2 = S2;
            o2 = E2;
            c2 = P2;
            u2 = x2;
            h2 = M2;
            d2 = 64;
            f2 = 0;
          }
          function F2(e3, t3, r3, K3, D3, U3, I3, B3, T3, z3, q3, F3, O3, L3, N2, j2) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            K3 = K3 | 0;
            D3 = D3 | 0;
            U3 = U3 | 0;
            I3 = I3 | 0;
            B3 = B3 | 0;
            T3 = T3 | 0;
            z3 = z3 | 0;
            q3 = q3 | 0;
            F3 = F3 | 0;
            O3 = O3 | 0;
            L3 = L3 | 0;
            N2 = N2 | 0;
            j2 = j2 | 0;
            R2();
            C2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, K3 ^ 1549556828, D3 ^ 1549556828, U3 ^ 1549556828, I3 ^ 1549556828, B3 ^ 1549556828, T3 ^ 1549556828, z3 ^ 1549556828, q3 ^ 1549556828, F3 ^ 1549556828, O3 ^ 1549556828, L3 ^ 1549556828, N2 ^ 1549556828, j2 ^ 1549556828);
            _2 = i2;
            k2 = n2;
            A2 = a2;
            S2 = s2;
            E2 = o2;
            P2 = c2;
            x2 = u2;
            M2 = h2;
            R2();
            C2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, K3 ^ 909522486, D3 ^ 909522486, U3 ^ 909522486, I3 ^ 909522486, B3 ^ 909522486, T3 ^ 909522486, z3 ^ 909522486, q3 ^ 909522486, F3 ^ 909522486, O3 ^ 909522486, L3 ^ 909522486, N2 ^ 909522486, j2 ^ 909522486);
            l2 = i2;
            p2 = n2;
            y2 = a2;
            b2 = s2;
            g2 = o2;
            m2 = c2;
            w2 = u2;
            v2 = h2;
            d2 = 64;
            f2 = 0;
          }
          function O2(e3, t3, r3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            var d3 = 0, f3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0, m3 = 0, w3 = 0;
            if (e3 & 63)
              return -1;
            if (~r3) {
              if (r3 & 31)
                return -1;
            }
            w3 = T2(e3, t3, -1) | 0;
            d3 = i2, f3 = n2, l3 = a2, p3 = s2, y3 = o2, b3 = c2, g3 = u2, m3 = h2;
            q2();
            C2(d3, f3, l3, p3, y3, b3, g3, m3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
            if (~r3)
              U2(r3);
            return w3 | 0;
          }
          function L2(e3, t3, r3, d3, f3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            d3 = d3 | 0;
            f3 = f3 | 0;
            var l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0, m3 = 0, w3 = 0, v6 = 0, _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0;
            if (e3 & 63)
              return -1;
            if (~f3) {
              if (f3 & 31)
                return -1;
            }
            K2[e3 + t3 | 0] = r3 >>> 24;
            K2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
            K2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
            K2[e3 + t3 + 3 | 0] = r3 & 255;
            O2(e3, t3 + 4 | 0, -1) | 0;
            l3 = _3 = i2, p3 = k3 = n2, y3 = A3 = a2, b3 = S3 = s2, g3 = E3 = o2, m3 = P3 = c2, w3 = x3 = u2, v6 = M3 = h2;
            d3 = d3 - 1 | 0;
            while ((d3 | 0) > 0) {
              z2();
              C2(_3, k3, A3, S3, E3, P3, x3, M3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
              _3 = i2, k3 = n2, A3 = a2, S3 = s2, E3 = o2, P3 = c2, x3 = u2, M3 = h2;
              q2();
              C2(_3, k3, A3, S3, E3, P3, x3, M3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
              _3 = i2, k3 = n2, A3 = a2, S3 = s2, E3 = o2, P3 = c2, x3 = u2, M3 = h2;
              l3 = l3 ^ i2;
              p3 = p3 ^ n2;
              y3 = y3 ^ a2;
              b3 = b3 ^ s2;
              g3 = g3 ^ o2;
              m3 = m3 ^ c2;
              w3 = w3 ^ u2;
              v6 = v6 ^ h2;
              d3 = d3 - 1 | 0;
            }
            i2 = l3;
            n2 = p3;
            a2 = y3;
            s2 = b3;
            o2 = g3;
            c2 = m3;
            u2 = w3;
            h2 = v6;
            if (~f3)
              U2(f3);
            return 0;
          }
          return { reset: R2, init: I2, process: B2, finish: T2, hmac_reset: z2, hmac_init: F2, hmac_finish: O2, pbkdf2_generate_block: L2 };
        }({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        void 0 !== this.heap && void 0 !== this.asm && (ft.push(this.heap), lt.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      static bytes(e2) {
        return new _pt().process(e2).finish().result;
      }
    };
    pt.NAME = "sha256";
    var yt = bt;
    function bt(e2, t2) {
      if (!e2)
        throw Error(t2 || "Assertion failed");
    }
    bt.equal = function(e2, t2, r2) {
      if (e2 != t2)
        throw Error(r2 || "Assertion failed: " + e2 + " != " + t2);
    };
    var gt = void 0 !== e ? e : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
    function mt(e2, t2) {
      return e2(t2 = { exports: {} }, t2.exports), t2.exports;
    }
    function wt() {
      throw Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
    }
    var vt = mt(function(e2) {
      e2.exports = "function" == typeof Object.create ? function(e3, t2) {
        e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
      } : function(e3, t2) {
        e3.super_ = t2;
        var r2 = function() {
        };
        r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
      };
    });
    var _t = mt(function(e2) {
      try {
        var t2 = p.default;
        if ("function" != typeof t2.inherits)
          throw "";
        e2.exports = t2.inherits;
      } catch (t3) {
        e2.exports = vt;
      }
    });
    var kt = function(e2, t2) {
      if (Array.isArray(e2))
        return e2.slice();
      if (!e2)
        return [];
      var r2 = [];
      if ("string" == typeof e2)
        if (t2) {
          if ("hex" === t2)
            for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), i2 = 0; i2 < e2.length; i2 += 2)
              r2.push(parseInt(e2[i2] + e2[i2 + 1], 16));
        } else
          for (var i2 = 0; i2 < e2.length; i2++) {
            var n2 = e2.charCodeAt(i2), a2 = n2 >> 8, s2 = 255 & n2;
            a2 ? r2.push(a2, s2) : r2.push(s2);
          }
      else
        for (i2 = 0; i2 < e2.length; i2++)
          r2[i2] = 0 | e2[i2];
      return r2;
    };
    var At = function(e2) {
      for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
        t2 += Pt(e2[r2].toString(16));
      return t2;
    };
    function St(e2) {
      return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
    }
    var Et = function(e2, t2) {
      for (var r2 = "", i2 = 0; i2 < e2.length; i2++) {
        var n2 = e2[i2];
        "little" === t2 && (n2 = St(n2)), r2 += xt(n2.toString(16));
      }
      return r2;
    };
    function Pt(e2) {
      return 1 === e2.length ? "0" + e2 : e2;
    }
    function xt(e2) {
      return 7 === e2.length ? "0" + e2 : 6 === e2.length ? "00" + e2 : 5 === e2.length ? "000" + e2 : 4 === e2.length ? "0000" + e2 : 3 === e2.length ? "00000" + e2 : 2 === e2.length ? "000000" + e2 : 1 === e2.length ? "0000000" + e2 : e2;
    }
    var Mt = function(e2, t2, r2, i2) {
      var n2 = r2 - t2;
      yt(n2 % 4 == 0);
      for (var a2 = Array(n2 / 4), s2 = 0, o2 = t2; s2 < a2.length; s2++, o2 += 4) {
        var c2;
        c2 = "big" === i2 ? e2[o2] << 24 | e2[o2 + 1] << 16 | e2[o2 + 2] << 8 | e2[o2 + 3] : e2[o2 + 3] << 24 | e2[o2 + 2] << 16 | e2[o2 + 1] << 8 | e2[o2], a2[s2] = c2 >>> 0;
      }
      return a2;
    };
    var Kt = function(e2, t2) {
      for (var r2 = Array(4 * e2.length), i2 = 0, n2 = 0; i2 < e2.length; i2++, n2 += 4) {
        var a2 = e2[i2];
        "big" === t2 ? (r2[n2] = a2 >>> 24, r2[n2 + 1] = a2 >>> 16 & 255, r2[n2 + 2] = a2 >>> 8 & 255, r2[n2 + 3] = 255 & a2) : (r2[n2 + 3] = a2 >>> 24, r2[n2 + 2] = a2 >>> 16 & 255, r2[n2 + 1] = a2 >>> 8 & 255, r2[n2] = 255 & a2);
      }
      return r2;
    };
    var Ct = { inherits: _t, toArray: kt, toHex: At, htonl: St, toHex32: Et, zero2: Pt, zero8: xt, join32: Mt, split32: Kt, rotr32: function(e2, t2) {
      return e2 >>> t2 | e2 << 32 - t2;
    }, rotl32: function(e2, t2) {
      return e2 << t2 | e2 >>> 32 - t2;
    }, sum32: function(e2, t2) {
      return e2 + t2 >>> 0;
    }, sum32_3: function(e2, t2, r2) {
      return e2 + t2 + r2 >>> 0;
    }, sum32_4: function(e2, t2, r2, i2) {
      return e2 + t2 + r2 + i2 >>> 0;
    }, sum32_5: function(e2, t2, r2, i2, n2) {
      return e2 + t2 + r2 + i2 + n2 >>> 0;
    }, sum64: function(e2, t2, r2, i2) {
      var n2 = e2[t2], a2 = i2 + e2[t2 + 1] >>> 0, s2 = (a2 < i2 ? 1 : 0) + r2 + n2;
      e2[t2] = s2 >>> 0, e2[t2 + 1] = a2;
    }, sum64_hi: function(e2, t2, r2, i2) {
      return (t2 + i2 >>> 0 < t2 ? 1 : 0) + e2 + r2 >>> 0;
    }, sum64_lo: function(e2, t2, r2, i2) {
      return t2 + i2 >>> 0;
    }, sum64_4_hi: function(e2, t2, r2, i2, n2, a2, s2, o2) {
      var c2 = 0, u2 = t2;
      return c2 += (u2 = u2 + i2 >>> 0) < t2 ? 1 : 0, c2 += (u2 = u2 + a2 >>> 0) < a2 ? 1 : 0, e2 + r2 + n2 + s2 + (c2 += (u2 = u2 + o2 >>> 0) < o2 ? 1 : 0) >>> 0;
    }, sum64_4_lo: function(e2, t2, r2, i2, n2, a2, s2, o2) {
      return t2 + i2 + a2 + o2 >>> 0;
    }, sum64_5_hi: function(e2, t2, r2, i2, n2, a2, s2, o2, c2, u2) {
      var h2 = 0, d2 = t2;
      return h2 += (d2 = d2 + i2 >>> 0) < t2 ? 1 : 0, h2 += (d2 = d2 + a2 >>> 0) < a2 ? 1 : 0, h2 += (d2 = d2 + o2 >>> 0) < o2 ? 1 : 0, e2 + r2 + n2 + s2 + c2 + (h2 += (d2 = d2 + u2 >>> 0) < u2 ? 1 : 0) >>> 0;
    }, sum64_5_lo: function(e2, t2, r2, i2, n2, a2, s2, o2, c2, u2) {
      return t2 + i2 + a2 + o2 + u2 >>> 0;
    }, rotr64_hi: function(e2, t2, r2) {
      return (t2 << 32 - r2 | e2 >>> r2) >>> 0;
    }, rotr64_lo: function(e2, t2, r2) {
      return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
    }, shr64_hi: function(e2, t2, r2) {
      return e2 >>> r2;
    }, shr64_lo: function(e2, t2, r2) {
      return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
    } };
    function Dt() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    var Ut = Dt;
    Dt.prototype.update = function(e2, t2) {
      if (e2 = Ct.toArray(e2, t2), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
        var r2 = (e2 = this.pending).length % this._delta8;
        this.pending = e2.slice(e2.length - r2, e2.length), 0 === this.pending.length && (this.pending = null), e2 = Ct.join32(e2, 0, e2.length - r2, this.endian);
        for (var i2 = 0; i2 < e2.length; i2 += this._delta32)
          this._update(e2, i2, i2 + this._delta32);
      }
      return this;
    }, Dt.prototype.digest = function(e2) {
      return this.update(this._pad()), yt(null === this.pending), this._digest(e2);
    }, Dt.prototype._pad = function() {
      var e2 = this.pendingTotal, t2 = this._delta8, r2 = t2 - (e2 + this.padLength) % t2, i2 = Array(r2 + this.padLength);
      i2[0] = 128;
      for (var n2 = 1; n2 < r2; n2++)
        i2[n2] = 0;
      if (e2 <<= 3, "big" === this.endian) {
        for (var a2 = 8; a2 < this.padLength; a2++)
          i2[n2++] = 0;
        i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = e2 >>> 24 & 255, i2[n2++] = e2 >>> 16 & 255, i2[n2++] = e2 >>> 8 & 255, i2[n2++] = 255 & e2;
      } else
        for (i2[n2++] = 255 & e2, i2[n2++] = e2 >>> 8 & 255, i2[n2++] = e2 >>> 16 & 255, i2[n2++] = e2 >>> 24 & 255, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, a2 = 8; a2 < this.padLength; a2++)
          i2[n2++] = 0;
      return i2;
    };
    var Rt = { BlockHash: Ut };
    var It = Ct.rotr32;
    var Bt = function(e2, t2, r2, i2) {
      return 0 === e2 ? Tt(t2, r2, i2) : 1 === e2 || 3 === e2 ? qt(t2, r2, i2) : 2 === e2 ? zt(t2, r2, i2) : void 0;
    };
    function Tt(e2, t2, r2) {
      return e2 & t2 ^ ~e2 & r2;
    }
    function zt(e2, t2, r2) {
      return e2 & t2 ^ e2 & r2 ^ t2 & r2;
    }
    function qt(e2, t2, r2) {
      return e2 ^ t2 ^ r2;
    }
    var Ft = { ft_1: Bt, ch32: Tt, maj32: zt, p32: qt, s0_256: function(e2) {
      return It(e2, 2) ^ It(e2, 13) ^ It(e2, 22);
    }, s1_256: function(e2) {
      return It(e2, 6) ^ It(e2, 11) ^ It(e2, 25);
    }, g0_256: function(e2) {
      return It(e2, 7) ^ It(e2, 18) ^ e2 >>> 3;
    }, g1_256: function(e2) {
      return It(e2, 17) ^ It(e2, 19) ^ e2 >>> 10;
    } };
    var Ot = Ct.sum32;
    var Lt = Ct.sum32_4;
    var Nt = Ct.sum32_5;
    var jt = Ft.ch32;
    var Ht = Ft.maj32;
    var Wt = Ft.s0_256;
    var Gt = Ft.s1_256;
    var Vt = Ft.g0_256;
    var $t = Ft.g1_256;
    var Zt = Rt.BlockHash;
    var Xt = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function Yt() {
      if (!(this instanceof Yt))
        return new Yt();
      Zt.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Xt, this.W = Array(64);
    }
    Ct.inherits(Yt, Zt);
    var Qt = Yt;
    function Jt() {
      if (!(this instanceof Jt))
        return new Jt();
      Qt.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Yt.blockSize = 512, Yt.outSize = 256, Yt.hmacStrength = 192, Yt.padLength = 64, Yt.prototype._update = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 16; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2++)
        r2[i2] = Lt($t(r2[i2 - 2]), r2[i2 - 7], Vt(r2[i2 - 15]), r2[i2 - 16]);
      var n2 = this.h[0], a2 = this.h[1], s2 = this.h[2], o2 = this.h[3], c2 = this.h[4], u2 = this.h[5], h2 = this.h[6], d2 = this.h[7];
      for (yt(this.k.length === r2.length), i2 = 0; i2 < r2.length; i2++) {
        var f2 = Nt(d2, Gt(c2), jt(c2, u2, h2), this.k[i2], r2[i2]), l2 = Ot(Wt(n2), Ht(n2, a2, s2));
        d2 = h2, h2 = u2, u2 = c2, c2 = Ot(o2, f2), o2 = s2, s2 = a2, a2 = n2, n2 = Ot(f2, l2);
      }
      this.h[0] = Ot(this.h[0], n2), this.h[1] = Ot(this.h[1], a2), this.h[2] = Ot(this.h[2], s2), this.h[3] = Ot(this.h[3], o2), this.h[4] = Ot(this.h[4], c2), this.h[5] = Ot(this.h[5], u2), this.h[6] = Ot(this.h[6], h2), this.h[7] = Ot(this.h[7], d2);
    }, Yt.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h, "big") : Ct.split32(this.h, "big");
    }, Ct.inherits(Jt, Qt);
    var er = Jt;
    Jt.blockSize = 512, Jt.outSize = 224, Jt.hmacStrength = 192, Jt.padLength = 64, Jt.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h.slice(0, 7), "big") : Ct.split32(this.h.slice(0, 7), "big");
    };
    var tr = Ct.rotr64_hi;
    var rr = Ct.rotr64_lo;
    var ir = Ct.shr64_hi;
    var nr = Ct.shr64_lo;
    var ar = Ct.sum64;
    var sr = Ct.sum64_hi;
    var or = Ct.sum64_lo;
    var cr = Ct.sum64_4_hi;
    var ur = Ct.sum64_4_lo;
    var hr = Ct.sum64_5_hi;
    var dr = Ct.sum64_5_lo;
    var fr = Rt.BlockHash;
    var lr = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function pr() {
      if (!(this instanceof pr))
        return new pr();
      fr.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = lr, this.W = Array(160);
    }
    Ct.inherits(pr, fr);
    var yr = pr;
    function br(e2, t2, r2, i2, n2) {
      var a2 = e2 & r2 ^ ~e2 & n2;
      return a2 < 0 && (a2 += 4294967296), a2;
    }
    function gr(e2, t2, r2, i2, n2, a2) {
      var s2 = t2 & i2 ^ ~t2 & a2;
      return s2 < 0 && (s2 += 4294967296), s2;
    }
    function mr(e2, t2, r2, i2, n2) {
      var a2 = e2 & r2 ^ e2 & n2 ^ r2 & n2;
      return a2 < 0 && (a2 += 4294967296), a2;
    }
    function wr(e2, t2, r2, i2, n2, a2) {
      var s2 = t2 & i2 ^ t2 & a2 ^ i2 & a2;
      return s2 < 0 && (s2 += 4294967296), s2;
    }
    function vr(e2, t2) {
      var r2 = tr(e2, t2, 28) ^ tr(t2, e2, 2) ^ tr(t2, e2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function _r(e2, t2) {
      var r2 = rr(e2, t2, 28) ^ rr(t2, e2, 2) ^ rr(t2, e2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function kr(e2, t2) {
      var r2 = tr(e2, t2, 14) ^ tr(e2, t2, 18) ^ tr(t2, e2, 9);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function Ar(e2, t2) {
      var r2 = rr(e2, t2, 14) ^ rr(e2, t2, 18) ^ rr(t2, e2, 9);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function Sr(e2, t2) {
      var r2 = tr(e2, t2, 1) ^ tr(e2, t2, 8) ^ ir(e2, t2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function Er(e2, t2) {
      var r2 = rr(e2, t2, 1) ^ rr(e2, t2, 8) ^ nr(e2, t2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function Pr(e2, t2) {
      var r2 = tr(e2, t2, 19) ^ tr(t2, e2, 29) ^ ir(e2, t2, 6);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function xr(e2, t2) {
      var r2 = rr(e2, t2, 19) ^ rr(t2, e2, 29) ^ nr(e2, t2, 6);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function Mr() {
      if (!(this instanceof Mr))
        return new Mr();
      yr.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    pr.blockSize = 1024, pr.outSize = 512, pr.hmacStrength = 192, pr.padLength = 128, pr.prototype._prepareBlock = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 32; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2 += 2) {
        var n2 = Pr(r2[i2 - 4], r2[i2 - 3]), a2 = xr(r2[i2 - 4], r2[i2 - 3]), s2 = r2[i2 - 14], o2 = r2[i2 - 13], c2 = Sr(r2[i2 - 30], r2[i2 - 29]), u2 = Er(r2[i2 - 30], r2[i2 - 29]), h2 = r2[i2 - 32], d2 = r2[i2 - 31];
        r2[i2] = cr(n2, a2, s2, o2, c2, u2, h2, d2), r2[i2 + 1] = ur(n2, a2, s2, o2, c2, u2, h2, d2);
      }
    }, pr.prototype._update = function(e2, t2) {
      this._prepareBlock(e2, t2);
      var r2 = this.W, i2 = this.h[0], n2 = this.h[1], a2 = this.h[2], s2 = this.h[3], o2 = this.h[4], c2 = this.h[5], u2 = this.h[6], h2 = this.h[7], d2 = this.h[8], f2 = this.h[9], l2 = this.h[10], p2 = this.h[11], y2 = this.h[12], b2 = this.h[13], g2 = this.h[14], m2 = this.h[15];
      yt(this.k.length === r2.length);
      for (var w2 = 0; w2 < r2.length; w2 += 2) {
        var v2 = g2, _2 = m2, k2 = kr(d2, f2), A2 = Ar(d2, f2), S2 = br(d2, f2, l2, p2, y2), E2 = gr(d2, f2, l2, p2, y2, b2), P2 = this.k[w2], x2 = this.k[w2 + 1], M2 = r2[w2], K2 = r2[w2 + 1], C2 = hr(v2, _2, k2, A2, S2, E2, P2, x2, M2, K2), D2 = dr(v2, _2, k2, A2, S2, E2, P2, x2, M2, K2);
        v2 = vr(i2, n2), _2 = _r(i2, n2), k2 = mr(i2, n2, a2, s2, o2), A2 = wr(i2, n2, a2, s2, o2, c2);
        var U2 = sr(v2, _2, k2, A2), R2 = or(v2, _2, k2, A2);
        g2 = y2, m2 = b2, y2 = l2, b2 = p2, l2 = d2, p2 = f2, d2 = sr(u2, h2, C2, D2), f2 = or(h2, h2, C2, D2), u2 = o2, h2 = c2, o2 = a2, c2 = s2, a2 = i2, s2 = n2, i2 = sr(C2, D2, U2, R2), n2 = or(C2, D2, U2, R2);
      }
      ar(this.h, 0, i2, n2), ar(this.h, 2, a2, s2), ar(this.h, 4, o2, c2), ar(this.h, 6, u2, h2), ar(this.h, 8, d2, f2), ar(this.h, 10, l2, p2), ar(this.h, 12, y2, b2), ar(this.h, 14, g2, m2);
    }, pr.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h, "big") : Ct.split32(this.h, "big");
    }, Ct.inherits(Mr, yr);
    var Kr = Mr;
    Mr.blockSize = 1024, Mr.outSize = 384, Mr.hmacStrength = 192, Mr.padLength = 128, Mr.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h.slice(0, 12), "big") : Ct.split32(this.h.slice(0, 12), "big");
    };
    var Cr = Ct.rotl32;
    var Dr = Ct.sum32;
    var Ur = Ct.sum32_3;
    var Rr = Ct.sum32_4;
    var Ir = Rt.BlockHash;
    function Br() {
      if (!(this instanceof Br))
        return new Br();
      Ir.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    Ct.inherits(Br, Ir);
    var Tr = Br;
    function zr(e2, t2, r2, i2) {
      return e2 <= 15 ? t2 ^ r2 ^ i2 : e2 <= 31 ? t2 & r2 | ~t2 & i2 : e2 <= 47 ? (t2 | ~r2) ^ i2 : e2 <= 63 ? t2 & i2 | r2 & ~i2 : t2 ^ (r2 | ~i2);
    }
    function qr(e2) {
      return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
    }
    function Fr(e2) {
      return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
    }
    Br.blockSize = 512, Br.outSize = 160, Br.hmacStrength = 192, Br.padLength = 64, Br.prototype._update = function(e2, t2) {
      for (var r2 = this.h[0], i2 = this.h[1], n2 = this.h[2], a2 = this.h[3], s2 = this.h[4], o2 = r2, c2 = i2, u2 = n2, h2 = a2, d2 = s2, f2 = 0; f2 < 80; f2++) {
        var l2 = Dr(Cr(Rr(r2, zr(f2, i2, n2, a2), e2[Or[f2] + t2], qr(f2)), Nr[f2]), s2);
        r2 = s2, s2 = a2, a2 = Cr(n2, 10), n2 = i2, i2 = l2, l2 = Dr(Cr(Rr(o2, zr(79 - f2, c2, u2, h2), e2[Lr[f2] + t2], Fr(f2)), jr[f2]), d2), o2 = d2, d2 = h2, h2 = Cr(u2, 10), u2 = c2, c2 = l2;
      }
      l2 = Ur(this.h[1], n2, h2), this.h[1] = Ur(this.h[2], a2, d2), this.h[2] = Ur(this.h[3], s2, o2), this.h[3] = Ur(this.h[4], r2, c2), this.h[4] = Ur(this.h[0], i2, u2), this.h[0] = l2;
    }, Br.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h, "little") : Ct.split32(this.h, "little");
    };
    var Or = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var Lr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var Nr = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var jr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var Hr = { ripemd160: Tr };
    function Wr(e2, t2) {
      let r2 = e2[0], i2 = e2[1], n2 = e2[2], a2 = e2[3];
      r2 = Vr(r2, i2, n2, a2, t2[0], 7, -680876936), a2 = Vr(a2, r2, i2, n2, t2[1], 12, -389564586), n2 = Vr(n2, a2, r2, i2, t2[2], 17, 606105819), i2 = Vr(i2, n2, a2, r2, t2[3], 22, -1044525330), r2 = Vr(r2, i2, n2, a2, t2[4], 7, -176418897), a2 = Vr(a2, r2, i2, n2, t2[5], 12, 1200080426), n2 = Vr(n2, a2, r2, i2, t2[6], 17, -1473231341), i2 = Vr(i2, n2, a2, r2, t2[7], 22, -45705983), r2 = Vr(r2, i2, n2, a2, t2[8], 7, 1770035416), a2 = Vr(a2, r2, i2, n2, t2[9], 12, -1958414417), n2 = Vr(n2, a2, r2, i2, t2[10], 17, -42063), i2 = Vr(i2, n2, a2, r2, t2[11], 22, -1990404162), r2 = Vr(r2, i2, n2, a2, t2[12], 7, 1804603682), a2 = Vr(a2, r2, i2, n2, t2[13], 12, -40341101), n2 = Vr(n2, a2, r2, i2, t2[14], 17, -1502002290), i2 = Vr(i2, n2, a2, r2, t2[15], 22, 1236535329), r2 = $r(r2, i2, n2, a2, t2[1], 5, -165796510), a2 = $r(a2, r2, i2, n2, t2[6], 9, -1069501632), n2 = $r(n2, a2, r2, i2, t2[11], 14, 643717713), i2 = $r(i2, n2, a2, r2, t2[0], 20, -373897302), r2 = $r(r2, i2, n2, a2, t2[5], 5, -701558691), a2 = $r(a2, r2, i2, n2, t2[10], 9, 38016083), n2 = $r(n2, a2, r2, i2, t2[15], 14, -660478335), i2 = $r(i2, n2, a2, r2, t2[4], 20, -405537848), r2 = $r(r2, i2, n2, a2, t2[9], 5, 568446438), a2 = $r(a2, r2, i2, n2, t2[14], 9, -1019803690), n2 = $r(n2, a2, r2, i2, t2[3], 14, -187363961), i2 = $r(i2, n2, a2, r2, t2[8], 20, 1163531501), r2 = $r(r2, i2, n2, a2, t2[13], 5, -1444681467), a2 = $r(a2, r2, i2, n2, t2[2], 9, -51403784), n2 = $r(n2, a2, r2, i2, t2[7], 14, 1735328473), i2 = $r(i2, n2, a2, r2, t2[12], 20, -1926607734), r2 = Zr(r2, i2, n2, a2, t2[5], 4, -378558), a2 = Zr(a2, r2, i2, n2, t2[8], 11, -2022574463), n2 = Zr(n2, a2, r2, i2, t2[11], 16, 1839030562), i2 = Zr(i2, n2, a2, r2, t2[14], 23, -35309556), r2 = Zr(r2, i2, n2, a2, t2[1], 4, -1530992060), a2 = Zr(a2, r2, i2, n2, t2[4], 11, 1272893353), n2 = Zr(n2, a2, r2, i2, t2[7], 16, -155497632), i2 = Zr(i2, n2, a2, r2, t2[10], 23, -1094730640), r2 = Zr(r2, i2, n2, a2, t2[13], 4, 681279174), a2 = Zr(a2, r2, i2, n2, t2[0], 11, -358537222), n2 = Zr(n2, a2, r2, i2, t2[3], 16, -722521979), i2 = Zr(i2, n2, a2, r2, t2[6], 23, 76029189), r2 = Zr(r2, i2, n2, a2, t2[9], 4, -640364487), a2 = Zr(a2, r2, i2, n2, t2[12], 11, -421815835), n2 = Zr(n2, a2, r2, i2, t2[15], 16, 530742520), i2 = Zr(i2, n2, a2, r2, t2[2], 23, -995338651), r2 = Xr(r2, i2, n2, a2, t2[0], 6, -198630844), a2 = Xr(a2, r2, i2, n2, t2[7], 10, 1126891415), n2 = Xr(n2, a2, r2, i2, t2[14], 15, -1416354905), i2 = Xr(i2, n2, a2, r2, t2[5], 21, -57434055), r2 = Xr(r2, i2, n2, a2, t2[12], 6, 1700485571), a2 = Xr(a2, r2, i2, n2, t2[3], 10, -1894986606), n2 = Xr(n2, a2, r2, i2, t2[10], 15, -1051523), i2 = Xr(i2, n2, a2, r2, t2[1], 21, -2054922799), r2 = Xr(r2, i2, n2, a2, t2[8], 6, 1873313359), a2 = Xr(a2, r2, i2, n2, t2[15], 10, -30611744), n2 = Xr(n2, a2, r2, i2, t2[6], 15, -1560198380), i2 = Xr(i2, n2, a2, r2, t2[13], 21, 1309151649), r2 = Xr(r2, i2, n2, a2, t2[4], 6, -145523070), a2 = Xr(a2, r2, i2, n2, t2[11], 10, -1120210379), n2 = Xr(n2, a2, r2, i2, t2[2], 15, 718787259), i2 = Xr(i2, n2, a2, r2, t2[9], 21, -343485551), e2[0] = ei(r2, e2[0]), e2[1] = ei(i2, e2[1]), e2[2] = ei(n2, e2[2]), e2[3] = ei(a2, e2[3]);
    }
    function Gr(e2, t2, r2, i2, n2, a2) {
      return t2 = ei(ei(t2, e2), ei(i2, a2)), ei(t2 << n2 | t2 >>> 32 - n2, r2);
    }
    function Vr(e2, t2, r2, i2, n2, a2, s2) {
      return Gr(t2 & r2 | ~t2 & i2, e2, t2, n2, a2, s2);
    }
    function $r(e2, t2, r2, i2, n2, a2, s2) {
      return Gr(t2 & i2 | r2 & ~i2, e2, t2, n2, a2, s2);
    }
    function Zr(e2, t2, r2, i2, n2, a2, s2) {
      return Gr(t2 ^ r2 ^ i2, e2, t2, n2, a2, s2);
    }
    function Xr(e2, t2, r2, i2, n2, a2, s2) {
      return Gr(r2 ^ (t2 | ~i2), e2, t2, n2, a2, s2);
    }
    function Yr(e2) {
      const t2 = [];
      let r2;
      for (r2 = 0; r2 < 64; r2 += 4)
        t2[r2 >> 2] = e2.charCodeAt(r2) + (e2.charCodeAt(r2 + 1) << 8) + (e2.charCodeAt(r2 + 2) << 16) + (e2.charCodeAt(r2 + 3) << 24);
      return t2;
    }
    var Qr = "0123456789abcdef".split("");
    function Jr(e2) {
      let t2 = "", r2 = 0;
      for (; r2 < 4; r2++)
        t2 += Qr[e2 >> 8 * r2 + 4 & 15] + Qr[e2 >> 8 * r2 & 15];
      return t2;
    }
    function ei(e2, t2) {
      return e2 + t2 & 4294967295;
    }
    var ti = de.getWebCrypto();
    var ri = de.getNodeCrypto();
    var ii = ri && ri.getHashes();
    function ni(e2) {
      if (ri && ii.includes(e2))
        return async function(t2) {
          const r2 = ri.createHash(e2);
          return X(t2, (e3) => {
            r2.update(e3);
          }, () => new Uint8Array(r2.digest()));
        };
    }
    function ai(e2, t2) {
      return async function(r2, i2 = we) {
        if (_(r2) && (r2 = await ie(r2)), !de.isStream(r2) && ti && t2 && r2.length >= i2.minBytesForWebCrypto)
          return new Uint8Array(await ti.digest(t2, r2));
        const n2 = e2();
        return X(r2, (e3) => {
          n2.update(e3);
        }, () => new Uint8Array(n2.digest()));
      };
    }
    function si(e2, t2) {
      return async function(r2, i2 = we) {
        if (_(r2) && (r2 = await ie(r2)), de.isStream(r2)) {
          const t3 = new e2();
          return X(r2, (e3) => {
            t3.process(e3);
          }, () => t3.finish().result);
        }
        return ti && t2 && r2.length >= i2.minBytesForWebCrypto ? new Uint8Array(await ti.digest(t2, r2)) : e2.bytes(r2);
      };
    }
    var oi = { md5: ni("md5") || async function(e2) {
      const t2 = function(e3) {
        const t3 = e3.length, r2 = [1732584193, -271733879, -1732584194, 271733878];
        let i2;
        for (i2 = 64; i2 <= e3.length; i2 += 64)
          Wr(r2, Yr(e3.substring(i2 - 64, i2)));
        e3 = e3.substring(i2 - 64);
        const n2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i2 = 0; i2 < e3.length; i2++)
          n2[i2 >> 2] |= e3.charCodeAt(i2) << (i2 % 4 << 3);
        if (n2[i2 >> 2] |= 128 << (i2 % 4 << 3), i2 > 55)
          for (Wr(r2, n2), i2 = 0; i2 < 16; i2++)
            n2[i2] = 0;
        return n2[14] = 8 * t3, Wr(r2, n2), r2;
      }(de.uint8ArrayToString(e2));
      return de.hexToUint8Array(function(e3) {
        for (let t3 = 0; t3 < e3.length; t3++)
          e3[t3] = Jr(e3[t3]);
        return e3.join("");
      }(t2));
    }, sha1: ni("sha1") || si(dt, "SHA-1"), sha224: ni("sha224") || ai(er), sha256: ni("sha256") || si(pt, "SHA-256"), sha384: ni("sha384") || ai(Kr, "SHA-384"), sha512: ni("sha512") || ai(yr, "SHA-512"), ripemd: ni("ripemd160") || ai(Tr) };
    var ci = { md5: oi.md5, sha1: oi.sha1, sha224: oi.sha224, sha256: oi.sha256, sha384: oi.sha384, sha512: oi.sha512, ripemd: oi.ripemd, digest: function(e2, t2) {
      switch (e2) {
        case ue.hash.md5:
          return this.md5(t2);
        case ue.hash.sha1:
          return this.sha1(t2);
        case ue.hash.ripemd:
          return this.ripemd(t2);
        case ue.hash.sha256:
          return this.sha256(t2);
        case ue.hash.sha384:
          return this.sha384(t2);
        case ue.hash.sha512:
          return this.sha512(t2);
        case ue.hash.sha224:
          return this.sha224(t2);
        default:
          throw Error("Invalid hash function.");
      }
    }, getHashByteLength: function(e2) {
      switch (e2) {
        case ue.hash.md5:
          return 16;
        case ue.hash.sha1:
        case ue.hash.ripemd:
          return 20;
        case ue.hash.sha256:
          return 32;
        case ue.hash.sha384:
          return 48;
        case ue.hash.sha512:
          return 64;
        case ue.hash.sha224:
          return 28;
        default:
          throw Error("Invalid hash algorithm.");
      }
    } };
    var ui = class _ui {
      static encrypt(e2, t2, r2) {
        return new _ui(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2) {
        return new _ui(t2, r2).decrypt(e2);
      }
      constructor(e2, t2, r2) {
        this.aes = r2 || new Oe(e2, t2, true, "CFB"), delete this.aes.padding;
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    function hi(e2) {
      const t2 = ue.read(ue.symmetric, e2);
      return st[t2];
    }
    var di = de.getWebCrypto();
    var fi = de.getNodeCrypto();
    var li = fi ? fi.getCiphers() : [];
    var pi = { idea: li.includes("idea-cfb") ? "idea-cfb" : void 0, tripledes: li.includes("des-ede3-cfb") ? "des-ede3-cfb" : void 0, cast5: li.includes("cast5-cfb") ? "cast5-cfb" : void 0, blowfish: li.includes("bf-cfb") ? "bf-cfb" : void 0, aes128: li.includes("aes-128-cfb") ? "aes-128-cfb" : void 0, aes192: li.includes("aes-192-cfb") ? "aes-192-cfb" : void 0, aes256: li.includes("aes-256-cfb") ? "aes-256-cfb" : void 0 };
    var yi = /* @__PURE__ */ Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = ue.read(ue.symmetric, e2);
      if (de.getNodeCrypto() && pi[a2])
        return function(e3, t3, r3, i3) {
          const n3 = ue.read(ue.symmetric, e3), a3 = new fi.createCipheriv(pi[n3], t3, i3);
          return X(r3, (e4) => new Uint8Array(a3.update(e4)));
        }(e2, t2, r2, i2);
      if (de.isAES(e2))
        return function(e3, t3, r3, i3, n3) {
          if (de.getWebCrypto() && 24 !== t3.length && !de.isStream(r3) && r3.length >= 3e3 * n3.minBytesForWebCrypto)
            return async function(e4, t4, r4, i4) {
              const n4 = "AES-CBC", a4 = await di.importKey("raw", t4, { name: n4 }, false, ["encrypt"]), { blockSize: s3 } = hi(e4), o3 = de.concatUint8Array([new Uint8Array(s3), r4]), c3 = new Uint8Array(await di.encrypt({ name: n4, iv: i4 }, a4, o3)).subarray(0, r4.length);
              return function(e5, t5) {
                for (let r5 = 0; r5 < e5.length; r5++)
                  e5[r5] = e5[r5] ^ t5[r5];
              }(c3, r4), c3;
            }(e3, t3, r3, i3);
          const a3 = new ui(t3, i3);
          return X(r3, (e4) => a3.aes.AES_Encrypt_process(e4), () => a3.aes.AES_Encrypt_finish());
        }(e2, t2, r2, i2, n2);
      const s2 = new (hi(e2))(t2), o2 = s2.blockSize, c2 = i2.slice();
      let u2 = new Uint8Array();
      const h2 = (e3) => {
        e3 && (u2 = de.concatUint8Array([u2, e3]));
        const t3 = new Uint8Array(u2.length);
        let r3, i3 = 0;
        for (; e3 ? u2.length >= o2 : u2.length; ) {
          const e4 = s2.encrypt(c2);
          for (r3 = 0; r3 < o2; r3++)
            c2[r3] = u2[r3] ^ e4[r3], t3[i3++] = c2[r3];
          u2 = u2.subarray(o2);
        }
        return t3.subarray(0, i3);
      };
      return X(r2, h2, h2);
    }, decrypt: async function(e2, t2, r2, i2) {
      const n2 = ue.read(ue.symmetric, e2);
      if (de.getNodeCrypto() && pi[n2])
        return function(e3, t3, r3, i3) {
          const n3 = ue.read(ue.symmetric, e3), a3 = new fi.createDecipheriv(pi[n3], t3, i3);
          return X(r3, (e4) => new Uint8Array(a3.update(e4)));
        }(e2, t2, r2, i2);
      if (de.isAES(e2))
        return function(e3, t3, r3, i3) {
          if (de.isStream(r3)) {
            const e4 = new ui(t3, i3);
            return X(r3, (t4) => e4.aes.AES_Decrypt_process(t4), () => e4.aes.AES_Decrypt_finish());
          }
          return ui.decrypt(r3, t3, i3);
        }(0, t2, r2, i2);
      const a2 = new (hi(e2))(t2), s2 = a2.blockSize;
      let o2 = i2, c2 = new Uint8Array();
      const u2 = (e3) => {
        e3 && (c2 = de.concatUint8Array([c2, e3]));
        const t3 = new Uint8Array(c2.length);
        let r3, i3 = 0;
        for (; e3 ? c2.length >= s2 : c2.length; ) {
          const e4 = a2.encrypt(o2);
          for (o2 = c2.subarray(0, s2), r3 = 0; r3 < s2; r3++)
            t3[i3++] = o2[r3] ^ e4[r3];
          c2 = c2.subarray(s2);
        }
        return t3.subarray(0, i3);
      };
      return X(r2, u2, u2);
    } });
    var bi = class _bi {
      static encrypt(e2, t2, r2) {
        return new _bi(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2) {
        return new _bi(t2, r2).encrypt(e2);
      }
      constructor(e2, t2, r2) {
        this.aes = r2 || new Oe(e2, void 0, false, "CTR"), delete this.aes.padding, this.AES_CTR_set_options(t2);
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      AES_CTR_set_options(e2, t2, r2) {
        let { asm: i2 } = this.aes.acquire_asm();
        if (void 0 !== r2) {
          if (r2 < 8 || r2 > 48)
            throw new Te("illegal counter size");
          let e3 = Math.pow(2, r2) - 1;
          i2.set_mask(0, 0, e3 / 4294967296 | 0, 0 | e3);
        } else
          r2 = 48, i2.set_mask(0, 0, 65535, 4294967295);
        if (void 0 === e2)
          throw Error("nonce is required");
        {
          let t3 = e2.length;
          if (!t3 || t3 > 16)
            throw new Te("illegal nonce size");
          let r3 = new DataView(new ArrayBuffer(16));
          new Uint8Array(r3.buffer).set(e2), i2.set_nonce(r3.getUint32(0), r3.getUint32(4), r3.getUint32(8), r3.getUint32(12));
        }
        if (void 0 !== t2) {
          if (t2 < 0 || t2 >= Math.pow(2, r2))
            throw new Te("illegal counter value");
          i2.set_counter(0, 0, t2 / 4294967296 | 0, 0 | t2);
        }
      }
    };
    var gi = class _gi {
      static encrypt(e2, t2, r2 = true, i2) {
        return new _gi(t2, i2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2 = true, i2) {
        return new _gi(t2, i2, r2).decrypt(e2);
      }
      constructor(e2, t2, r2 = true, i2) {
        this.aes = i2 || new Oe(e2, t2, r2, "CBC");
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    var mi = de.getWebCrypto();
    var wi = de.getNodeCrypto();
    var vi = 16;
    function _i(e2, t2) {
      const r2 = e2.length - vi;
      for (let i2 = 0; i2 < vi; i2++)
        e2[i2 + r2] ^= t2[i2];
      return e2;
    }
    var ki = new Uint8Array(vi);
    async function Ai(e2) {
      const t2 = await async function(e3) {
        if (de.getWebCrypto() && 24 !== e3.length)
          return e3 = await mi.importKey("raw", e3, { name: "AES-CBC", length: 8 * e3.length }, false, ["encrypt"]), async function(t3) {
            const r3 = await mi.encrypt({ name: "AES-CBC", iv: ki, length: 8 * vi }, e3, t3);
            return new Uint8Array(r3).subarray(0, r3.byteLength - vi);
          };
        if (de.getNodeCrypto())
          return async function(t3) {
            const r3 = new wi.createCipheriv("aes-" + 8 * e3.length + "-cbc", e3, ki).update(t3);
            return new Uint8Array(r3);
          };
        return async function(t3) {
          return gi.encrypt(t3, e3, false, ki);
        };
      }(e2), r2 = de.double(await t2(ki)), i2 = de.double(r2);
      return async function(e3) {
        return (await t2(function(e4, t3, r3) {
          if (e4.length && e4.length % vi == 0)
            return _i(e4, t3);
          const i3 = new Uint8Array(e4.length + (vi - e4.length % vi));
          return i3.set(e4), i3[e4.length] = 128, _i(i3, r3);
        }(e3, r2, i2))).subarray(-vi);
      };
    }
    var Si = de.getWebCrypto();
    var Ei = de.getNodeCrypto();
    var Pi = de.getNodeBuffer();
    var xi = 16;
    var Mi = xi;
    var Ki = xi;
    var Ci = new Uint8Array(xi);
    var Di = new Uint8Array(xi);
    Di[xi - 1] = 1;
    var Ui = new Uint8Array(xi);
    async function Ri(e2) {
      const t2 = await Ai(e2);
      return function(e3, r2) {
        return t2(de.concatUint8Array([e3, r2]));
      };
    }
    async function Ii(e2) {
      return de.getWebCrypto() && 24 !== e2.length ? (e2 = await Si.importKey("raw", e2, { name: "AES-CTR", length: 8 * e2.length }, false, ["encrypt"]), async function(t2, r2) {
        const i2 = await Si.encrypt({ name: "AES-CTR", counter: r2, length: 8 * xi }, e2, t2);
        return new Uint8Array(i2);
      }) : de.getNodeCrypto() ? async function(t2, r2) {
        const i2 = new Ei.createCipheriv("aes-" + 8 * e2.length + "-ctr", e2, r2), n2 = Pi.concat([i2.update(t2), i2.final()]);
        return new Uint8Array(n2);
      } : async function(t2, r2) {
        return bi.encrypt(t2, e2, r2);
      };
    }
    async function Bi(e2, t2) {
      if (e2 !== ue.symmetric.aes128 && e2 !== ue.symmetric.aes192 && e2 !== ue.symmetric.aes256)
        throw Error("EAX mode supports only AES cipher");
      const [r2, i2] = await Promise.all([Ri(t2), Ii(t2)]);
      return { encrypt: async function(e3, t3, n2) {
        const [a2, s2] = await Promise.all([r2(Ci, t3), r2(Di, n2)]), o2 = await i2(e3, a2), c2 = await r2(Ui, o2);
        for (let e4 = 0; e4 < Ki; e4++)
          c2[e4] ^= s2[e4] ^ a2[e4];
        return de.concatUint8Array([o2, c2]);
      }, decrypt: async function(e3, t3, n2) {
        if (e3.length < Ki)
          throw Error("Invalid EAX ciphertext");
        const a2 = e3.subarray(0, -Ki), s2 = e3.subarray(-Ki), [o2, c2, u2] = await Promise.all([r2(Ci, t3), r2(Di, n2), r2(Ui, a2)]), h2 = u2;
        for (let e4 = 0; e4 < Ki; e4++)
          h2[e4] ^= c2[e4] ^ o2[e4];
        if (!de.equalsUint8Array(s2, h2))
          throw Error("Authentication tag mismatch");
        return await i2(a2, o2);
      } };
    }
    Ui[xi - 1] = 2, Bi.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[8 + e3] ^= t2[e3];
      return r2;
    }, Bi.blockLength = xi, Bi.ivLength = Mi, Bi.tagLength = Ki;
    var Ti = 16;
    var zi = 15;
    var qi = 16;
    function Fi(e2) {
      let t2 = 0;
      for (let r2 = 1; 0 == (e2 & r2); r2 <<= 1)
        t2++;
      return t2;
    }
    function Oi(e2, t2) {
      for (let r2 = 0; r2 < e2.length; r2++)
        e2[r2] ^= t2[r2];
      return e2;
    }
    function Li(e2, t2) {
      return Oi(e2.slice(), t2);
    }
    var Ni = new Uint8Array(Ti);
    var ji = new Uint8Array([1]);
    async function Hi(e2, t2) {
      let r2, i2, n2, a2 = 0;
      function s2(e3, t3, i3, s3) {
        const o2 = t3.length / Ti | 0;
        !function(e4, t4) {
          const r3 = de.nbits(Math.max(e4.length, t4.length) / Ti | 0) - 1;
          for (let e5 = a2 + 1; e5 <= r3; e5++)
            n2[e5] = de.double(n2[e5 - 1]);
          a2 = r3;
        }(t3, s3);
        const c2 = de.concatUint8Array([Ni.subarray(0, zi - i3.length), ji, i3]), u2 = 63 & c2[Ti - 1];
        c2[Ti - 1] &= 192;
        const h2 = r2(c2), d2 = de.concatUint8Array([h2, Li(h2.subarray(0, 8), h2.subarray(1, 9))]), f2 = de.shiftRight(d2.subarray(0 + (u2 >> 3), 17 + (u2 >> 3)), 8 - (7 & u2)).subarray(1), l2 = new Uint8Array(Ti), p2 = new Uint8Array(t3.length + qi);
        let y2, b2 = 0;
        for (y2 = 0; y2 < o2; y2++)
          Oi(f2, n2[Fi(y2 + 1)]), p2.set(Oi(e3(Li(f2, t3)), f2), b2), Oi(l2, e3 === r2 ? t3 : p2.subarray(b2)), t3 = t3.subarray(Ti), b2 += Ti;
        if (t3.length) {
          Oi(f2, n2.x);
          const i4 = r2(f2);
          p2.set(Li(t3, i4), b2);
          const a3 = new Uint8Array(Ti);
          a3.set(e3 === r2 ? t3 : p2.subarray(b2, -qi), 0), a3[t3.length] = 128, Oi(l2, a3), b2 += t3.length;
        }
        const g2 = Oi(r2(Oi(Oi(l2, f2), n2.$)), function(e4) {
          if (!e4.length)
            return Ni;
          const t4 = e4.length / Ti | 0, i4 = new Uint8Array(Ti), a3 = new Uint8Array(Ti);
          for (let s4 = 0; s4 < t4; s4++)
            Oi(i4, n2[Fi(s4 + 1)]), Oi(a3, r2(Li(i4, e4))), e4 = e4.subarray(Ti);
          if (e4.length) {
            Oi(i4, n2.x);
            const t5 = new Uint8Array(Ti);
            t5.set(e4, 0), t5[e4.length] = 128, Oi(t5, i4), Oi(a3, r2(t5));
          }
          return a3;
        }(s3));
        return p2.set(g2, b2), p2;
      }
      return function(e3, t3) {
        const a3 = ue.read(ue.symmetric, e3), s3 = new st[a3](t3);
        r2 = s3.encrypt.bind(s3), i2 = s3.decrypt.bind(s3);
        const o2 = r2(Ni), c2 = de.double(o2);
        n2 = [], n2[0] = de.double(c2), n2.x = o2, n2.$ = c2;
      }(e2, t2), { encrypt: async function(e3, t3, i3) {
        return s2(r2, e3, t3, i3);
      }, decrypt: async function(e3, t3, r3) {
        if (e3.length < qi)
          throw Error("Invalid OCB ciphertext");
        const n3 = e3.subarray(-qi);
        e3 = e3.subarray(0, -qi);
        const a3 = s2(i2, e3, t3, r3);
        if (de.equalsUint8Array(n3, a3.subarray(-qi)))
          return a3.subarray(0, -qi);
        throw Error("Authentication tag mismatch");
      } };
    }
    Hi.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[7 + e3] ^= t2[e3];
      return r2;
    }, Hi.blockLength = Ti, Hi.ivLength = zi, Hi.tagLength = qi;
    var Wi = 68719476704;
    var Gi = class _Gi {
      constructor(e2, t2, r2, i2 = 16, n2) {
        this.tagSize = i2, this.gamma0 = 0, this.counter = 1, this.aes = n2 || new Oe(e2, void 0, false, "CTR");
        let { asm: a2, heap: s2 } = this.aes.acquire_asm();
        if (a2.gcm_init(), this.tagSize < 4 || this.tagSize > 16)
          throw new Te("illegal tagSize value");
        const o2 = t2.length || 0, c2 = new Uint8Array(16);
        12 !== o2 ? (this._gcm_mac_process(t2), s2[0] = 0, s2[1] = 0, s2[2] = 0, s2[3] = 0, s2[4] = 0, s2[5] = 0, s2[6] = 0, s2[7] = 0, s2[8] = 0, s2[9] = 0, s2[10] = 0, s2[11] = o2 >>> 29, s2[12] = o2 >>> 21 & 255, s2[13] = o2 >>> 13 & 255, s2[14] = o2 >>> 5 & 255, s2[15] = o2 << 3 & 255, a2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), a2.get_iv(Ce.HEAP_DATA), a2.set_iv(0, 0, 0, 0), c2.set(s2.subarray(0, 16))) : (c2.set(t2), c2[15] = 1);
        const u2 = new DataView(c2.buffer);
        if (this.gamma0 = u2.getUint32(12), a2.set_nonce(u2.getUint32(0), u2.getUint32(4), u2.getUint32(8), 0), a2.set_mask(0, 0, 0, 4294967295), void 0 !== r2) {
          if (r2.length > Wi)
            throw new Te("illegal adata length");
          r2.length ? (this.adata = r2, this._gcm_mac_process(r2)) : this.adata = void 0;
        } else
          this.adata = void 0;
        if (this.counter < 1 || this.counter > 4294967295)
          throw new RangeError("counter must be a positive 32-bit integer");
        a2.set_counter(0, 0, 0, this.gamma0 + this.counter | 0);
      }
      static encrypt(e2, t2, r2, i2, n2) {
        return new _Gi(t2, r2, i2, n2).encrypt(e2);
      }
      static decrypt(e2, t2, r2, i2, n2) {
        return new _Gi(t2, r2, i2, n2).decrypt(e2);
      }
      encrypt(e2) {
        return this.AES_GCM_encrypt(e2);
      }
      decrypt(e2) {
        return this.AES_GCM_decrypt(e2);
      }
      AES_GCM_Encrypt_process(e2) {
        let t2 = 0, r2 = e2.length || 0, { asm: i2, heap: n2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.aes.pos, o2 = this.aes.len, c2 = 0, u2 = o2 + r2 & -16, h2 = 0;
        if ((a2 - 1 << 4) + o2 + r2 > Wi)
          throw new RangeError("counter overflow");
        const d2 = new Uint8Array(u2);
        for (; r2 > 0; )
          h2 = Re(n2, s2 + o2, e2, t2, r2), o2 += h2, t2 += h2, r2 -= h2, h2 = i2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA + s2, o2), h2 = i2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + s2, h2), h2 && d2.set(n2.subarray(s2, s2 + h2), c2), a2 += h2 >>> 4, c2 += h2, h2 < o2 ? (s2 += h2, o2 -= h2) : (s2 = 0, o2 = 0);
        return this.counter = a2, this.aes.pos = s2, this.aes.len = o2, d2;
      }
      AES_GCM_Encrypt_finish() {
        let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.counter, i2 = this.tagSize, n2 = this.adata, a2 = this.aes.pos, s2 = this.aes.len;
        const o2 = new Uint8Array(s2 + i2);
        e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA + a2, s2 + 15 & -16), s2 && o2.set(t2.subarray(a2, a2 + s2));
        let c2 = s2;
        for (; 15 & c2; c2++)
          t2[a2 + c2] = 0;
        e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + a2, c2);
        const u2 = void 0 !== n2 ? n2.length : 0, h2 = (r2 - 1 << 4) + s2;
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = u2 >>> 29, t2[4] = u2 >>> 21, t2[5] = u2 >>> 13 & 255, t2[6] = u2 >>> 5 & 255, t2[7] = u2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = h2 >>> 29, t2[12] = h2 >>> 21 & 255, t2[13] = h2 >>> 13 & 255, t2[14] = h2 >>> 5 & 255, t2[15] = h2 << 3 & 255, e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), e2.get_iv(Ce.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA, 16), o2.set(t2.subarray(0, i2), s2), this.counter = 1, this.aes.pos = 0, this.aes.len = 0, o2;
      }
      AES_GCM_Decrypt_process(e2) {
        let t2 = 0, r2 = e2.length || 0, { asm: i2, heap: n2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.tagSize, o2 = this.aes.pos, c2 = this.aes.len, u2 = 0, h2 = c2 + r2 > s2 ? c2 + r2 - s2 & -16 : 0, d2 = c2 + r2 - h2, f2 = 0;
        if ((a2 - 1 << 4) + c2 + r2 > Wi)
          throw new RangeError("counter overflow");
        const l2 = new Uint8Array(h2);
        for (; r2 > d2; )
          f2 = Re(n2, o2 + c2, e2, t2, r2 - d2), c2 += f2, t2 += f2, r2 -= f2, f2 = i2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + o2, f2), f2 = i2.cipher(Ce.DEC.CTR, Ce.HEAP_DATA + o2, f2), f2 && l2.set(n2.subarray(o2, o2 + f2), u2), a2 += f2 >>> 4, u2 += f2, o2 = 0, c2 = 0;
        return r2 > 0 && (c2 += Re(n2, 0, e2, t2, r2)), this.counter = a2, this.aes.pos = o2, this.aes.len = c2, l2;
      }
      AES_GCM_Decrypt_finish() {
        let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.tagSize, i2 = this.adata, n2 = this.counter, a2 = this.aes.pos, s2 = this.aes.len, o2 = s2 - r2;
        if (s2 < r2)
          throw new Be("authentication tag not found");
        const c2 = new Uint8Array(o2), u2 = new Uint8Array(t2.subarray(a2 + o2, a2 + s2));
        let h2 = o2;
        for (; 15 & h2; h2++)
          t2[a2 + h2] = 0;
        e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + a2, h2), e2.cipher(Ce.DEC.CTR, Ce.HEAP_DATA + a2, h2), o2 && c2.set(t2.subarray(a2, a2 + o2));
        const d2 = void 0 !== i2 ? i2.length : 0, f2 = (n2 - 1 << 4) + s2 - r2;
        t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = d2 >>> 29, t2[4] = d2 >>> 21, t2[5] = d2 >>> 13 & 255, t2[6] = d2 >>> 5 & 255, t2[7] = d2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = f2 >>> 29, t2[12] = f2 >>> 21 & 255, t2[13] = f2 >>> 13 & 255, t2[14] = f2 >>> 5 & 255, t2[15] = f2 << 3 & 255, e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), e2.get_iv(Ce.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA, 16);
        let l2 = 0;
        for (let e3 = 0; e3 < r2; ++e3)
          l2 |= u2[e3] ^ t2[e3];
        if (l2)
          throw new ze("data integrity check failed");
        return this.counter = 1, this.aes.pos = 0, this.aes.len = 0, c2;
      }
      AES_GCM_decrypt(e2) {
        const t2 = this.AES_GCM_Decrypt_process(e2), r2 = this.AES_GCM_Decrypt_finish(), i2 = new Uint8Array(t2.length + r2.length);
        return t2.length && i2.set(t2), r2.length && i2.set(r2, t2.length), i2;
      }
      AES_GCM_encrypt(e2) {
        const t2 = this.AES_GCM_Encrypt_process(e2), r2 = this.AES_GCM_Encrypt_finish(), i2 = new Uint8Array(t2.length + r2.length);
        return t2.length && i2.set(t2), r2.length && i2.set(r2, t2.length), i2;
      }
      _gcm_mac_process(e2) {
        let { asm: t2, heap: r2 } = this.aes.acquire_asm(), i2 = 0, n2 = e2.length || 0, a2 = 0;
        for (; n2 > 0; ) {
          for (a2 = Re(r2, 0, e2, i2, n2), i2 += a2, n2 -= a2; 15 & a2; )
            r2[a2++] = 0;
          t2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, a2);
        }
      }
    };
    var Vi = de.getWebCrypto();
    var $i = de.getNodeCrypto();
    var Zi = de.getNodeBuffer();
    var Xi = 16;
    var Yi = "AES-GCM";
    async function Qi(e2, t2) {
      if (e2 !== ue.symmetric.aes128 && e2 !== ue.symmetric.aes192 && e2 !== ue.symmetric.aes256)
        throw Error("GCM mode supports only AES cipher");
      if (de.getNodeCrypto())
        return { encrypt: async function(e3, r2, i2 = new Uint8Array()) {
          const n2 = new $i.createCipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
          n2.setAAD(i2);
          const a2 = Zi.concat([n2.update(e3), n2.final(), n2.getAuthTag()]);
          return new Uint8Array(a2);
        }, decrypt: async function(e3, r2, i2 = new Uint8Array()) {
          const n2 = new $i.createDecipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
          n2.setAAD(i2), n2.setAuthTag(e3.slice(e3.length - Xi, e3.length));
          const a2 = Zi.concat([n2.update(e3.slice(0, e3.length - Xi)), n2.final()]);
          return new Uint8Array(a2);
        } };
      if (de.getWebCrypto() && 24 !== t2.length) {
        const e3 = await Vi.importKey("raw", t2, { name: Yi }, false, ["encrypt", "decrypt"]);
        return { encrypt: async function(r2, i2, n2 = new Uint8Array()) {
          if (!r2.length)
            return Gi.encrypt(r2, t2, i2, n2);
          const a2 = await Vi.encrypt({ name: Yi, iv: i2, additionalData: n2, tagLength: 8 * Xi }, e3, r2);
          return new Uint8Array(a2);
        }, decrypt: async function(r2, i2, n2 = new Uint8Array()) {
          if (r2.length === Xi)
            return Gi.decrypt(r2, t2, i2, n2);
          const a2 = await Vi.decrypt({ name: Yi, iv: i2, additionalData: n2, tagLength: 8 * Xi }, e3, r2);
          return new Uint8Array(a2);
        } };
      }
      return { encrypt: async function(e3, r2, i2) {
        return Gi.encrypt(e3, t2, r2, i2);
      }, decrypt: async function(e3, r2, i2) {
        return Gi.decrypt(e3, t2, r2, i2);
      } };
    }
    Qi.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[4 + e3] ^= t2[e3];
      return r2;
    }, Qi.blockLength = 16, Qi.ivLength = 12, Qi.tagLength = Xi;
    var Ji = { cfb: yi, gcm: Qi, experimentalGCM: Qi, eax: Bi, ocb: Hi };
    var en = mt(function(e2) {
      !function(e3) {
        var t2 = function(e4) {
          var t3, r3 = new Float64Array(16);
          if (e4)
            for (t3 = 0; t3 < e4.length; t3++)
              r3[t3] = e4[t3];
          return r3;
        }, r2 = function() {
          throw Error("no PRNG");
        }, i2 = new Uint8Array(32);
        i2[0] = 9;
        var n2 = t2(), a2 = t2([1]), s2 = t2([56129, 1]), o2 = t2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), c2 = t2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), u2 = t2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), h2 = t2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), f2 = t2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function l2(e4, t3, r3, i3) {
          return function(e5, t4, r4, i4, n3) {
            var a3, s3 = 0;
            for (a3 = 0; a3 < n3; a3++)
              s3 |= e5[t4 + a3] ^ r4[i4 + a3];
            return (1 & s3 - 1 >>> 8) - 1;
          }(e4, t3, r3, i3, 32);
        }
        function p2(e4, t3) {
          var r3;
          for (r3 = 0; r3 < 16; r3++)
            e4[r3] = 0 | t3[r3];
        }
        function y2(e4) {
          var t3, r3, i3 = 1;
          for (t3 = 0; t3 < 16; t3++)
            r3 = e4[t3] + i3 + 65535, i3 = Math.floor(r3 / 65536), e4[t3] = r3 - 65536 * i3;
          e4[0] += i3 - 1 + 37 * (i3 - 1);
        }
        function b2(e4, t3, r3) {
          for (var i3, n3 = ~(r3 - 1), a3 = 0; a3 < 16; a3++)
            i3 = n3 & (e4[a3] ^ t3[a3]), e4[a3] ^= i3, t3[a3] ^= i3;
        }
        function g2(e4, r3) {
          var i3, n3, a3, s3 = t2(), o3 = t2();
          for (i3 = 0; i3 < 16; i3++)
            o3[i3] = r3[i3];
          for (y2(o3), y2(o3), y2(o3), n3 = 0; n3 < 2; n3++) {
            for (s3[0] = o3[0] - 65517, i3 = 1; i3 < 15; i3++)
              s3[i3] = o3[i3] - 65535 - (s3[i3 - 1] >> 16 & 1), s3[i3 - 1] &= 65535;
            s3[15] = o3[15] - 32767 - (s3[14] >> 16 & 1), a3 = s3[15] >> 16 & 1, s3[14] &= 65535, b2(o3, s3, 1 - a3);
          }
          for (i3 = 0; i3 < 16; i3++)
            e4[2 * i3] = 255 & o3[i3], e4[2 * i3 + 1] = o3[i3] >> 8;
        }
        function m2(e4, t3) {
          var r3 = new Uint8Array(32), i3 = new Uint8Array(32);
          return g2(r3, e4), g2(i3, t3), l2(r3, 0, i3, 0);
        }
        function w2(e4) {
          var t3 = new Uint8Array(32);
          return g2(t3, e4), 1 & t3[0];
        }
        function v2(e4, t3) {
          var r3;
          for (r3 = 0; r3 < 16; r3++)
            e4[r3] = t3[2 * r3] + (t3[2 * r3 + 1] << 8);
          e4[15] &= 32767;
        }
        function _2(e4, t3, r3) {
          for (var i3 = 0; i3 < 16; i3++)
            e4[i3] = t3[i3] + r3[i3];
        }
        function k2(e4, t3, r3) {
          for (var i3 = 0; i3 < 16; i3++)
            e4[i3] = t3[i3] - r3[i3];
        }
        function A2(e4, t3, r3) {
          var i3, n3, a3 = 0, s3 = 0, o3 = 0, c3 = 0, u3 = 0, h3 = 0, d2 = 0, f3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, g3 = 0, m3 = 0, w3 = 0, v6 = 0, _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, K3 = 0, C3 = 0, D3 = 0, U3 = 0, R3 = 0, I3 = 0, B3 = 0, T3 = r3[0], z3 = r3[1], q3 = r3[2], F3 = r3[3], O3 = r3[4], L2 = r3[5], N2 = r3[6], j2 = r3[7], H2 = r3[8], W2 = r3[9], G2 = r3[10], V2 = r3[11], $2 = r3[12], Z2 = r3[13], X2 = r3[14], Y2 = r3[15];
          a3 += (i3 = t3[0]) * T3, s3 += i3 * z3, o3 += i3 * q3, c3 += i3 * F3, u3 += i3 * O3, h3 += i3 * L2, d2 += i3 * N2, f3 += i3 * j2, l3 += i3 * H2, p3 += i3 * W2, y3 += i3 * G2, b3 += i3 * V2, g3 += i3 * $2, m3 += i3 * Z2, w3 += i3 * X2, v6 += i3 * Y2, s3 += (i3 = t3[1]) * T3, o3 += i3 * z3, c3 += i3 * q3, u3 += i3 * F3, h3 += i3 * O3, d2 += i3 * L2, f3 += i3 * N2, l3 += i3 * j2, p3 += i3 * H2, y3 += i3 * W2, b3 += i3 * G2, g3 += i3 * V2, m3 += i3 * $2, w3 += i3 * Z2, v6 += i3 * X2, _3 += i3 * Y2, o3 += (i3 = t3[2]) * T3, c3 += i3 * z3, u3 += i3 * q3, h3 += i3 * F3, d2 += i3 * O3, f3 += i3 * L2, l3 += i3 * N2, p3 += i3 * j2, y3 += i3 * H2, b3 += i3 * W2, g3 += i3 * G2, m3 += i3 * V2, w3 += i3 * $2, v6 += i3 * Z2, _3 += i3 * X2, k3 += i3 * Y2, c3 += (i3 = t3[3]) * T3, u3 += i3 * z3, h3 += i3 * q3, d2 += i3 * F3, f3 += i3 * O3, l3 += i3 * L2, p3 += i3 * N2, y3 += i3 * j2, b3 += i3 * H2, g3 += i3 * W2, m3 += i3 * G2, w3 += i3 * V2, v6 += i3 * $2, _3 += i3 * Z2, k3 += i3 * X2, A3 += i3 * Y2, u3 += (i3 = t3[4]) * T3, h3 += i3 * z3, d2 += i3 * q3, f3 += i3 * F3, l3 += i3 * O3, p3 += i3 * L2, y3 += i3 * N2, b3 += i3 * j2, g3 += i3 * H2, m3 += i3 * W2, w3 += i3 * G2, v6 += i3 * V2, _3 += i3 * $2, k3 += i3 * Z2, A3 += i3 * X2, S3 += i3 * Y2, h3 += (i3 = t3[5]) * T3, d2 += i3 * z3, f3 += i3 * q3, l3 += i3 * F3, p3 += i3 * O3, y3 += i3 * L2, b3 += i3 * N2, g3 += i3 * j2, m3 += i3 * H2, w3 += i3 * W2, v6 += i3 * G2, _3 += i3 * V2, k3 += i3 * $2, A3 += i3 * Z2, S3 += i3 * X2, E3 += i3 * Y2, d2 += (i3 = t3[6]) * T3, f3 += i3 * z3, l3 += i3 * q3, p3 += i3 * F3, y3 += i3 * O3, b3 += i3 * L2, g3 += i3 * N2, m3 += i3 * j2, w3 += i3 * H2, v6 += i3 * W2, _3 += i3 * G2, k3 += i3 * V2, A3 += i3 * $2, S3 += i3 * Z2, E3 += i3 * X2, P3 += i3 * Y2, f3 += (i3 = t3[7]) * T3, l3 += i3 * z3, p3 += i3 * q3, y3 += i3 * F3, b3 += i3 * O3, g3 += i3 * L2, m3 += i3 * N2, w3 += i3 * j2, v6 += i3 * H2, _3 += i3 * W2, k3 += i3 * G2, A3 += i3 * V2, S3 += i3 * $2, E3 += i3 * Z2, P3 += i3 * X2, x3 += i3 * Y2, l3 += (i3 = t3[8]) * T3, p3 += i3 * z3, y3 += i3 * q3, b3 += i3 * F3, g3 += i3 * O3, m3 += i3 * L2, w3 += i3 * N2, v6 += i3 * j2, _3 += i3 * H2, k3 += i3 * W2, A3 += i3 * G2, S3 += i3 * V2, E3 += i3 * $2, P3 += i3 * Z2, x3 += i3 * X2, M3 += i3 * Y2, p3 += (i3 = t3[9]) * T3, y3 += i3 * z3, b3 += i3 * q3, g3 += i3 * F3, m3 += i3 * O3, w3 += i3 * L2, v6 += i3 * N2, _3 += i3 * j2, k3 += i3 * H2, A3 += i3 * W2, S3 += i3 * G2, E3 += i3 * V2, P3 += i3 * $2, x3 += i3 * Z2, M3 += i3 * X2, K3 += i3 * Y2, y3 += (i3 = t3[10]) * T3, b3 += i3 * z3, g3 += i3 * q3, m3 += i3 * F3, w3 += i3 * O3, v6 += i3 * L2, _3 += i3 * N2, k3 += i3 * j2, A3 += i3 * H2, S3 += i3 * W2, E3 += i3 * G2, P3 += i3 * V2, x3 += i3 * $2, M3 += i3 * Z2, K3 += i3 * X2, C3 += i3 * Y2, b3 += (i3 = t3[11]) * T3, g3 += i3 * z3, m3 += i3 * q3, w3 += i3 * F3, v6 += i3 * O3, _3 += i3 * L2, k3 += i3 * N2, A3 += i3 * j2, S3 += i3 * H2, E3 += i3 * W2, P3 += i3 * G2, x3 += i3 * V2, M3 += i3 * $2, K3 += i3 * Z2, C3 += i3 * X2, D3 += i3 * Y2, g3 += (i3 = t3[12]) * T3, m3 += i3 * z3, w3 += i3 * q3, v6 += i3 * F3, _3 += i3 * O3, k3 += i3 * L2, A3 += i3 * N2, S3 += i3 * j2, E3 += i3 * H2, P3 += i3 * W2, x3 += i3 * G2, M3 += i3 * V2, K3 += i3 * $2, C3 += i3 * Z2, D3 += i3 * X2, U3 += i3 * Y2, m3 += (i3 = t3[13]) * T3, w3 += i3 * z3, v6 += i3 * q3, _3 += i3 * F3, k3 += i3 * O3, A3 += i3 * L2, S3 += i3 * N2, E3 += i3 * j2, P3 += i3 * H2, x3 += i3 * W2, M3 += i3 * G2, K3 += i3 * V2, C3 += i3 * $2, D3 += i3 * Z2, U3 += i3 * X2, R3 += i3 * Y2, w3 += (i3 = t3[14]) * T3, v6 += i3 * z3, _3 += i3 * q3, k3 += i3 * F3, A3 += i3 * O3, S3 += i3 * L2, E3 += i3 * N2, P3 += i3 * j2, x3 += i3 * H2, M3 += i3 * W2, K3 += i3 * G2, C3 += i3 * V2, D3 += i3 * $2, U3 += i3 * Z2, R3 += i3 * X2, I3 += i3 * Y2, v6 += (i3 = t3[15]) * T3, s3 += 38 * (k3 += i3 * q3), o3 += 38 * (A3 += i3 * F3), c3 += 38 * (S3 += i3 * O3), u3 += 38 * (E3 += i3 * L2), h3 += 38 * (P3 += i3 * N2), d2 += 38 * (x3 += i3 * j2), f3 += 38 * (M3 += i3 * H2), l3 += 38 * (K3 += i3 * W2), p3 += 38 * (C3 += i3 * G2), y3 += 38 * (D3 += i3 * V2), b3 += 38 * (U3 += i3 * $2), g3 += 38 * (R3 += i3 * Z2), m3 += 38 * (I3 += i3 * X2), w3 += 38 * (B3 += i3 * Y2), a3 = (i3 = (a3 += 38 * (_3 += i3 * z3)) + (n3 = 1) + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), s3 = (i3 = s3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), o3 = (i3 = o3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), c3 = (i3 = c3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), u3 = (i3 = u3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), h3 = (i3 = h3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), d2 = (i3 = d2 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), f3 = (i3 = f3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), l3 = (i3 = l3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), p3 = (i3 = p3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), y3 = (i3 = y3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), b3 = (i3 = b3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), g3 = (i3 = g3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), m3 = (i3 = m3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), w3 = (i3 = w3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), v6 = (i3 = v6 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), a3 = (i3 = (a3 += n3 - 1 + 37 * (n3 - 1)) + (n3 = 1) + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), s3 = (i3 = s3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), o3 = (i3 = o3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), c3 = (i3 = c3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), u3 = (i3 = u3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), h3 = (i3 = h3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), d2 = (i3 = d2 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), f3 = (i3 = f3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), l3 = (i3 = l3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), p3 = (i3 = p3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), y3 = (i3 = y3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), b3 = (i3 = b3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), g3 = (i3 = g3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), m3 = (i3 = m3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), w3 = (i3 = w3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), v6 = (i3 = v6 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), a3 += n3 - 1 + 37 * (n3 - 1), e4[0] = a3, e4[1] = s3, e4[2] = o3, e4[3] = c3, e4[4] = u3, e4[5] = h3, e4[6] = d2, e4[7] = f3, e4[8] = l3, e4[9] = p3, e4[10] = y3, e4[11] = b3, e4[12] = g3, e4[13] = m3, e4[14] = w3, e4[15] = v6;
        }
        function S2(e4, t3) {
          A2(e4, t3, t3);
        }
        function E2(e4, r3) {
          var i3, n3 = t2();
          for (i3 = 0; i3 < 16; i3++)
            n3[i3] = r3[i3];
          for (i3 = 253; i3 >= 0; i3--)
            S2(n3, n3), 2 !== i3 && 4 !== i3 && A2(n3, n3, r3);
          for (i3 = 0; i3 < 16; i3++)
            e4[i3] = n3[i3];
        }
        function P2(e4, r3, i3) {
          var n3, a3, o3 = new Uint8Array(32), c3 = new Float64Array(80), u3 = t2(), h3 = t2(), d2 = t2(), f3 = t2(), l3 = t2(), p3 = t2();
          for (a3 = 0; a3 < 31; a3++)
            o3[a3] = r3[a3];
          for (o3[31] = 127 & r3[31] | 64, o3[0] &= 248, v2(c3, i3), a3 = 0; a3 < 16; a3++)
            h3[a3] = c3[a3], f3[a3] = u3[a3] = d2[a3] = 0;
          for (u3[0] = f3[0] = 1, a3 = 254; a3 >= 0; --a3)
            b2(u3, h3, n3 = o3[a3 >>> 3] >>> (7 & a3) & 1), b2(d2, f3, n3), _2(l3, u3, d2), k2(u3, u3, d2), _2(d2, h3, f3), k2(h3, h3, f3), S2(f3, l3), S2(p3, u3), A2(u3, d2, u3), A2(d2, h3, l3), _2(l3, u3, d2), k2(u3, u3, d2), S2(h3, u3), k2(d2, f3, p3), A2(u3, d2, s2), _2(u3, u3, f3), A2(d2, d2, u3), A2(u3, f3, p3), A2(f3, h3, c3), S2(h3, l3), b2(u3, h3, n3), b2(d2, f3, n3);
          for (a3 = 0; a3 < 16; a3++)
            c3[a3 + 16] = u3[a3], c3[a3 + 32] = d2[a3], c3[a3 + 48] = h3[a3], c3[a3 + 64] = f3[a3];
          var y3 = c3.subarray(32), m3 = c3.subarray(16);
          return E2(y3, y3), A2(m3, m3, y3), g2(e4, m3), 0;
        }
        function x2(e4, t3) {
          return P2(e4, t3, i2);
        }
        function M2(e4, r3) {
          var i3 = t2(), n3 = t2(), a3 = t2(), s3 = t2(), o3 = t2(), u3 = t2(), h3 = t2(), d2 = t2(), f3 = t2();
          k2(i3, e4[1], e4[0]), k2(f3, r3[1], r3[0]), A2(i3, i3, f3), _2(n3, e4[0], e4[1]), _2(f3, r3[0], r3[1]), A2(n3, n3, f3), A2(a3, e4[3], r3[3]), A2(a3, a3, c2), A2(s3, e4[2], r3[2]), _2(s3, s3, s3), k2(o3, n3, i3), k2(u3, s3, a3), _2(h3, s3, a3), _2(d2, n3, i3), A2(e4[0], o3, u3), A2(e4[1], d2, h3), A2(e4[2], h3, u3), A2(e4[3], o3, d2);
        }
        function K2(e4, t3, r3) {
          var i3;
          for (i3 = 0; i3 < 4; i3++)
            b2(e4[i3], t3[i3], r3);
        }
        function C2(e4, r3) {
          var i3 = t2(), n3 = t2(), a3 = t2();
          E2(a3, r3[2]), A2(i3, r3[0], a3), A2(n3, r3[1], a3), g2(e4, n3), e4[31] ^= w2(i3) << 7;
        }
        function D2(e4, t3, r3) {
          var i3, s3;
          for (p2(e4[0], n2), p2(e4[1], a2), p2(e4[2], a2), p2(e4[3], n2), s3 = 255; s3 >= 0; --s3)
            K2(e4, t3, i3 = r3[s3 / 8 | 0] >> (7 & s3) & 1), M2(t3, e4), M2(e4, e4), K2(e4, t3, i3);
        }
        function U2(e4, r3) {
          var i3 = [t2(), t2(), t2(), t2()];
          p2(i3[0], u2), p2(i3[1], h2), p2(i3[2], a2), A2(i3[3], u2, h2), D2(e4, i3, r3);
        }
        function R2(i3, n3, a3) {
          var s3, o3, c3 = [t2(), t2(), t2(), t2()];
          for (a3 || r2(n3, 32), (s3 = e3.hash(n3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64, U2(c3, s3), C2(i3, c3), o3 = 0; o3 < 32; o3++)
            n3[o3 + 32] = i3[o3];
          return 0;
        }
        var I2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function B2(e4, t3) {
          var r3, i3, n3, a3;
          for (i3 = 63; i3 >= 32; --i3) {
            for (r3 = 0, n3 = i3 - 32, a3 = i3 - 12; n3 < a3; ++n3)
              t3[n3] += r3 - 16 * t3[i3] * I2[n3 - (i3 - 32)], r3 = Math.floor((t3[n3] + 128) / 256), t3[n3] -= 256 * r3;
            t3[n3] += r3, t3[i3] = 0;
          }
          for (r3 = 0, n3 = 0; n3 < 32; n3++)
            t3[n3] += r3 - (t3[31] >> 4) * I2[n3], r3 = t3[n3] >> 8, t3[n3] &= 255;
          for (n3 = 0; n3 < 32; n3++)
            t3[n3] -= r3 * I2[n3];
          for (i3 = 0; i3 < 32; i3++)
            t3[i3 + 1] += t3[i3] >> 8, e4[i3] = 255 & t3[i3];
        }
        function T2(e4) {
          var t3, r3 = new Float64Array(64);
          for (t3 = 0; t3 < 64; t3++)
            r3[t3] = e4[t3];
          for (t3 = 0; t3 < 64; t3++)
            e4[t3] = 0;
          B2(e4, r3);
        }
        function z2(e4, r3) {
          var i3 = t2(), s3 = t2(), c3 = t2(), u3 = t2(), h3 = t2(), d2 = t2(), l3 = t2();
          return p2(e4[2], a2), v2(e4[1], r3), S2(c3, e4[1]), A2(u3, c3, o2), k2(c3, c3, e4[2]), _2(u3, e4[2], u3), S2(h3, u3), S2(d2, h3), A2(l3, d2, h3), A2(i3, l3, c3), A2(i3, i3, u3), function(e5, r4) {
            var i4, n3 = t2();
            for (i4 = 0; i4 < 16; i4++)
              n3[i4] = r4[i4];
            for (i4 = 250; i4 >= 0; i4--)
              S2(n3, n3), 1 !== i4 && A2(n3, n3, r4);
            for (i4 = 0; i4 < 16; i4++)
              e5[i4] = n3[i4];
          }(i3, i3), A2(i3, i3, c3), A2(i3, i3, u3), A2(i3, i3, u3), A2(e4[0], i3, u3), S2(s3, e4[0]), A2(s3, s3, u3), m2(s3, c3) && A2(e4[0], e4[0], f2), S2(s3, e4[0]), A2(s3, s3, u3), m2(s3, c3) ? -1 : (w2(e4[0]) === r3[31] >> 7 && k2(e4[0], n2, e4[0]), A2(e4[3], e4[0], e4[1]), 0);
        }
        var q2 = 64;
        function F2() {
          for (var e4 = 0; e4 < arguments.length; e4++)
            if (!(arguments[e4] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
        }
        function O2(e4) {
          for (var t3 = 0; t3 < e4.length; t3++)
            e4[t3] = 0;
        }
        e3.scalarMult = function(e4, t3) {
          if (F2(e4, t3), 32 !== e4.length)
            throw Error("bad n size");
          if (32 !== t3.length)
            throw Error("bad p size");
          var r3 = new Uint8Array(32);
          return P2(r3, e4, t3), r3;
        }, e3.box = {}, e3.box.keyPair = function() {
          var e4, t3, i3 = new Uint8Array(32), n3 = new Uint8Array(32);
          return e4 = i3, r2(t3 = n3, 32), x2(e4, t3), { publicKey: i3, secretKey: n3 };
        }, e3.box.keyPair.fromSecretKey = function(e4) {
          if (F2(e4), 32 !== e4.length)
            throw Error("bad secret key size");
          var t3 = new Uint8Array(32);
          return x2(t3, e4), { publicKey: t3, secretKey: new Uint8Array(e4) };
        }, e3.sign = function(r3, i3) {
          if (F2(r3, i3), 64 !== i3.length)
            throw Error("bad secret key size");
          var n3 = new Uint8Array(q2 + r3.length);
          return function(r4, i4, n4, a3) {
            var s3, o3, c3, u3, h3, d2 = new Float64Array(64), f3 = [t2(), t2(), t2(), t2()];
            (s3 = e3.hash(a3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64;
            var l3 = n4 + 64;
            for (u3 = 0; u3 < n4; u3++)
              r4[64 + u3] = i4[u3];
            for (u3 = 0; u3 < 32; u3++)
              r4[32 + u3] = s3[32 + u3];
            for (T2(c3 = e3.hash(r4.subarray(32, l3))), U2(f3, c3), C2(r4, f3), u3 = 32; u3 < 64; u3++)
              r4[u3] = a3[u3];
            for (T2(o3 = e3.hash(r4.subarray(0, l3))), u3 = 0; u3 < 64; u3++)
              d2[u3] = 0;
            for (u3 = 0; u3 < 32; u3++)
              d2[u3] = c3[u3];
            for (u3 = 0; u3 < 32; u3++)
              for (h3 = 0; h3 < 32; h3++)
                d2[u3 + h3] += o3[u3] * s3[h3];
            B2(r4.subarray(32), d2);
          }(n3, r3, r3.length, i3), n3;
        }, e3.sign.detached = function(t3, r3) {
          for (var i3 = e3.sign(t3, r3), n3 = new Uint8Array(q2), a3 = 0; a3 < n3.length; a3++)
            n3[a3] = i3[a3];
          return n3;
        }, e3.sign.detached.verify = function(r3, i3, n3) {
          if (F2(r3, i3, n3), i3.length !== q2)
            throw Error("bad signature size");
          if (32 !== n3.length)
            throw Error("bad public key size");
          var a3, s3 = new Uint8Array(q2 + r3.length), o3 = new Uint8Array(q2 + r3.length);
          for (a3 = 0; a3 < q2; a3++)
            s3[a3] = i3[a3];
          for (a3 = 0; a3 < r3.length; a3++)
            s3[a3 + q2] = r3[a3];
          return function(r4, i4, n4, a4) {
            var s4, o4, c3 = new Uint8Array(32), u3 = [t2(), t2(), t2(), t2()], h3 = [t2(), t2(), t2(), t2()];
            if (n4 < 64)
              return -1;
            if (z2(h3, a4))
              return -1;
            for (s4 = 0; s4 < n4; s4++)
              r4[s4] = i4[s4];
            for (s4 = 0; s4 < 32; s4++)
              r4[s4 + 32] = a4[s4];
            if (T2(o4 = e3.hash(r4.subarray(0, n4))), D2(u3, h3, o4), U2(h3, i4.subarray(32)), M2(u3, h3), C2(c3, u3), n4 -= 64, l2(i4, 0, c3, 0)) {
              for (s4 = 0; s4 < n4; s4++)
                r4[s4] = 0;
              return -1;
            }
            for (s4 = 0; s4 < n4; s4++)
              r4[s4] = i4[s4 + 64];
            return n4;
          }(o3, s3, s3.length, n3) >= 0;
        }, e3.sign.keyPair = function() {
          var e4 = new Uint8Array(32), t3 = new Uint8Array(64);
          return R2(e4, t3), { publicKey: e4, secretKey: t3 };
        }, e3.sign.keyPair.fromSecretKey = function(e4) {
          if (F2(e4), 64 !== e4.length)
            throw Error("bad secret key size");
          for (var t3 = new Uint8Array(32), r3 = 0; r3 < t3.length; r3++)
            t3[r3] = e4[32 + r3];
          return { publicKey: t3, secretKey: new Uint8Array(e4) };
        }, e3.sign.keyPair.fromSeed = function(e4) {
          if (F2(e4), 32 !== e4.length)
            throw Error("bad seed size");
          for (var t3 = new Uint8Array(32), r3 = new Uint8Array(64), i3 = 0; i3 < 32; i3++)
            r3[i3] = e4[i3];
          return R2(t3, r3, true), { publicKey: t3, secretKey: r3 };
        }, e3.setPRNG = function(e4) {
          r2 = e4;
        }, function() {
          var t3 = "undefined" != typeof self ? self.crypto || self.msCrypto : null;
          if (t3 && t3.getRandomValues) {
            e3.setPRNG(function(e4, r3) {
              var i3, n3 = new Uint8Array(r3);
              for (i3 = 0; i3 < r3; i3 += 65536)
                t3.getRandomValues(n3.subarray(i3, i3 + Math.min(r3 - i3, 65536)));
              for (i3 = 0; i3 < r3; i3++)
                e4[i3] = n3[i3];
              O2(n3);
            });
          } else
            void 0 !== wt && (t3 = d.default) && t3.randomBytes && e3.setPRNG(function(e4, r3) {
              var i3, n3 = t3.randomBytes(r3);
              for (i3 = 0; i3 < r3; i3++)
                e4[i3] = n3[i3];
              O2(n3);
            });
        }();
      }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
    });
    var tn = de.getNodeCrypto();
    function rn(e2) {
      const t2 = new Uint8Array(e2);
      if (tn) {
        const e3 = tn.randomBytes(t2.length);
        t2.set(e3);
      } else {
        if ("undefined" == typeof crypto || !crypto.getRandomValues)
          throw Error("No secure random number generator available.");
        crypto.getRandomValues(t2);
      }
      return t2;
    }
    async function nn(e2, t2) {
      const r2 = await de.getBigInteger();
      if (t2.lt(e2))
        throw Error("Illegal parameter value: max <= min");
      const i2 = t2.sub(e2), n2 = i2.byteLength();
      return new r2(await rn(n2 + 8)).mod(i2).add(e2);
    }
    var an = /* @__PURE__ */ Object.freeze({ __proto__: null, getRandomBytes: rn, getRandomBigInteger: nn });
    async function sn(e2, t2, r2) {
      const i2 = await de.getBigInteger(), n2 = new i2(1), a2 = n2.leftShift(new i2(e2 - 1)), s2 = new i2(30), o2 = [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2], c2 = await nn(a2, a2.leftShift(n2));
      let u2 = c2.mod(s2).toNumber();
      do {
        c2.iadd(new i2(o2[u2])), u2 = (u2 + o2[u2]) % o2.length, c2.bitLength() > e2 && (c2.imod(a2.leftShift(n2)).iadd(a2), u2 = c2.mod(s2).toNumber());
      } while (!await on(c2, t2, r2));
      return c2;
    }
    async function on(e2, t2, r2) {
      return !(t2 && !e2.dec().gcd(t2).isOne()) && (!!await async function(e3) {
        const t3 = await de.getBigInteger();
        return cn.every((r3) => 0 !== e3.mod(new t3(r3)));
      }(e2) && (!!await async function(e3, t3) {
        const r3 = await de.getBigInteger();
        return t3 = t3 || new r3(2), t3.modExp(e3.dec(), e3).isOne();
      }(e2) && !!await async function(e3, t3, r3) {
        const i2 = await de.getBigInteger(), n2 = e3.bitLength();
        t3 || (t3 = Math.max(1, n2 / 48 | 0));
        const a2 = e3.dec();
        let s2 = 0;
        for (; !a2.getBit(s2); )
          s2++;
        const o2 = e3.rightShift(new i2(s2));
        for (; t3 > 0; t3--) {
          let t4, n3 = (r3 ? r3() : await nn(new i2(2), a2)).modExp(o2, e3);
          if (!n3.isOne() && !n3.equal(a2)) {
            for (t4 = 1; t4 < s2; t4++) {
              if (n3 = n3.mul(n3).mod(e3), n3.isOne())
                return false;
              if (n3.equal(a2))
                break;
            }
            if (t4 === s2)
              return false;
          }
        }
        return true;
      }(e2, r2)));
    }
    var cn = [7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999];
    var un = [];
    function hn(e2, t2) {
      const r2 = e2.length;
      if (r2 > t2 - 11)
        throw Error("Message too long");
      const i2 = function(e3) {
        const t3 = new Uint8Array(e3);
        let r3 = 0;
        for (; r3 < e3; ) {
          const i3 = rn(e3 - r3);
          for (let e4 = 0; e4 < i3.length; e4++)
            0 !== i3[e4] && (t3[r3++] = i3[e4]);
        }
        return t3;
      }(t2 - r2 - 3), n2 = new Uint8Array(t2);
      return n2[1] = 2, n2.set(i2, 2), n2.set(e2, t2 - r2), n2;
    }
    function dn(e2, t2) {
      let r2 = 2, i2 = 1;
      for (let t3 = r2; t3 < e2.length; t3++)
        i2 &= 0 !== e2[t3], r2 += i2;
      const n2 = r2 - 2, a2 = e2.subarray(r2 + 1), s2 = 0 === e2[0] & 2 === e2[1] & n2 >= 8 & !i2;
      if (t2)
        return de.selectUint8Array(s2, a2, t2);
      if (s2)
        return a2;
      throw Error("Decryption error");
    }
    async function fn(e2, t2, r2) {
      let i2;
      if (t2.length !== ci.getHashByteLength(e2))
        throw Error("Invalid hash length");
      const n2 = new Uint8Array(un[e2].length);
      for (i2 = 0; i2 < un[e2].length; i2++)
        n2[i2] = un[e2][i2];
      const a2 = n2.length + t2.length;
      if (r2 < a2 + 11)
        throw Error("Intended encoded message length too short");
      const s2 = new Uint8Array(r2 - a2 - 3).fill(255), o2 = new Uint8Array(r2);
      return o2[1] = 1, o2.set(s2, 2), o2.set(n2, r2 - a2), o2.set(t2, r2 - t2.length), o2;
    }
    un[1] = [48, 32, 48, 12, 6, 8, 42, 134, 72, 134, 247, 13, 2, 5, 5, 0, 4, 16], un[2] = [48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20], un[3] = [48, 33, 48, 9, 6, 5, 43, 36, 3, 2, 1, 5, 0, 4, 20], un[8] = [48, 49, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 5, 0, 4, 32], un[9] = [48, 65, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 2, 5, 0, 4, 48], un[10] = [48, 81, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 3, 5, 0, 4, 64], un[11] = [48, 45, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 4, 5, 0, 4, 28];
    var ln = /* @__PURE__ */ Object.freeze({ __proto__: null, emeEncode: hn, emeDecode: dn, emsaEncode: fn });
    var pn = de.getWebCrypto();
    var yn = de.getNodeCrypto();
    var bn = yn ? y.default : void 0;
    var gn = yn ? bn.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    }) : void 0;
    var mn = yn ? bn.define("RSAPubliceKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    }) : void 0;
    var wn = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2, s2, o2, c2) {
      if (t2 && !de.isStream(t2)) {
        if (de.getWebCrypto())
          try {
            return await async function(e3, t3, r3, i3, n3, a3, s3, o3) {
              const c3 = await async function(e4, t4, r4, i4, n4, a4) {
                const s4 = await de.getBigInteger(), o4 = new s4(i4), c4 = new s4(n4), u3 = new s4(r4);
                let h3 = u3.mod(c4.dec()), d2 = u3.mod(o4.dec());
                return d2 = d2.toUint8Array(), h3 = h3.toUint8Array(), { kty: "RSA", n: me(e4, true), e: me(t4, true), d: me(r4, true), p: me(n4, true), q: me(i4, true), dp: me(h3, true), dq: me(d2, true), qi: me(a4, true), ext: true };
              }(r3, i3, n3, a3, s3, o3), u2 = { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, h2 = await pn.importKey("jwk", c3, u2, false, ["sign"]);
              return new Uint8Array(await pn.sign("RSASSA-PKCS1-v1_5", h2, t3));
            }(ue.read(ue.webHash, e2), t2, r2, i2, n2, a2, s2, o2);
          } catch (e3) {
            de.printDebugError(e3);
          }
        else if (de.getNodeCrypto())
          return async function(e3, t3, r3, i3, n3, a3, s3, o3) {
            const { default: c3 } = await Promise.resolve().then(function() {
              return Jp;
            }), u2 = new c3(a3), h2 = new c3(s3), d2 = new c3(n3), f2 = d2.mod(h2.subn(1)), l2 = d2.mod(u2.subn(1)), p2 = yn.createSign(ue.read(ue.hash, e3));
            p2.write(t3), p2.end();
            const y2 = { version: 0, modulus: new c3(r3), publicExponent: new c3(i3), privateExponent: new c3(n3), prime1: new c3(s3), prime2: new c3(a3), exponent1: f2, exponent2: l2, coefficient: new c3(o3) };
            if (void 0 !== yn.createPrivateKey) {
              const e4 = gn.encode(y2, "der");
              return new Uint8Array(p2.sign({ key: e4, format: "der", type: "pkcs1" }));
            }
            const b2 = gn.encode(y2, "pem", { label: "RSA PRIVATE KEY" });
            return new Uint8Array(p2.sign(b2));
          }(e2, t2, r2, i2, n2, a2, s2, o2);
      }
      return async function(e3, t3, r3, i3) {
        const n3 = await de.getBigInteger();
        t3 = new n3(t3);
        const a3 = new n3(await fn(e3, i3, t3.byteLength()));
        if (r3 = new n3(r3), a3.gte(t3))
          throw Error("Message size cannot exceed modulus size");
        return a3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
      }(e2, r2, n2, c2);
    }, verify: async function(e2, t2, r2, i2, n2, a2) {
      if (t2 && !de.isStream(t2)) {
        if (de.getWebCrypto())
          try {
            return await async function(e3, t3, r3, i3, n3) {
              const a3 = function(e4, t4) {
                return { kty: "RSA", n: me(e4, true), e: me(t4, true), ext: true };
              }(i3, n3), s2 = await pn.importKey("jwk", a3, { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, false, ["verify"]);
              return pn.verify("RSASSA-PKCS1-v1_5", s2, r3, t3);
            }(ue.read(ue.webHash, e2), t2, r2, i2, n2);
          } catch (e3) {
            de.printDebugError(e3);
          }
        else if (de.getNodeCrypto())
          return async function(e3, t3, r3, i3, n3) {
            const { default: a3 } = await Promise.resolve().then(function() {
              return Jp;
            }), s2 = yn.createVerify(ue.read(ue.hash, e3));
            s2.write(t3), s2.end();
            const o2 = { modulus: new a3(i3), publicExponent: new a3(n3) };
            let c2;
            if (void 0 !== yn.createPrivateKey) {
              c2 = { key: mn.encode(o2, "der"), format: "der", type: "pkcs1" };
            } else
              c2 = mn.encode(o2, "pem", { label: "RSA PUBLIC KEY" });
            try {
              return await s2.verify(c2, r3);
            } catch (e4) {
              return false;
            }
          }(e2, t2, r2, i2, n2);
      }
      return async function(e3, t3, r3, i3, n3) {
        const a3 = await de.getBigInteger();
        if (r3 = new a3(r3), t3 = new a3(t3), i3 = new a3(i3), t3.gte(r3))
          throw Error("Signature size cannot exceed modulus size");
        const s2 = t3.modExp(i3, r3).toUint8Array("be", r3.byteLength()), o2 = await fn(e3, n3, r3.byteLength());
        return de.equalsUint8Array(s2, o2);
      }(e2, r2, i2, n2, a2);
    }, encrypt: async function(e2, t2, r2) {
      return de.getNodeCrypto() ? async function(e3, t3, r3) {
        const { default: i2 } = await Promise.resolve().then(function() {
          return Jp;
        }), n2 = { modulus: new i2(t3), publicExponent: new i2(r3) };
        let a2;
        if (void 0 !== yn.createPrivateKey) {
          a2 = { key: mn.encode(n2, "der"), format: "der", type: "pkcs1", padding: yn.constants.RSA_PKCS1_PADDING };
        } else {
          a2 = { key: mn.encode(n2, "pem", { label: "RSA PUBLIC KEY" }), padding: yn.constants.RSA_PKCS1_PADDING };
        }
        return new Uint8Array(yn.publicEncrypt(a2, e3));
      }(e2, t2, r2) : async function(e3, t3, r3) {
        const i2 = await de.getBigInteger();
        if (t3 = new i2(t3), e3 = new i2(hn(e3, t3.byteLength())), r3 = new i2(r3), e3.gte(t3))
          throw Error("Message size cannot exceed modulus size");
        return e3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
      }(e2, t2, r2);
    }, decrypt: async function(e2, t2, r2, i2, n2, a2, s2, o2) {
      return de.getNodeCrypto() ? async function(e3, t3, r3, i3, n3, a3, s3, o3) {
        const { default: c2 } = await Promise.resolve().then(function() {
          return Jp;
        }), u2 = new c2(n3), h2 = new c2(a3), d2 = new c2(i3), f2 = d2.mod(h2.subn(1)), l2 = d2.mod(u2.subn(1)), p2 = { version: 0, modulus: new c2(t3), publicExponent: new c2(r3), privateExponent: new c2(i3), prime1: new c2(a3), prime2: new c2(n3), exponent1: f2, exponent2: l2, coefficient: new c2(s3) };
        let y2;
        if (void 0 !== yn.createPrivateKey) {
          y2 = { key: gn.encode(p2, "der"), format: "der", type: "pkcs1", padding: yn.constants.RSA_PKCS1_PADDING };
        } else {
          y2 = { key: gn.encode(p2, "pem", { label: "RSA PRIVATE KEY" }), padding: yn.constants.RSA_PKCS1_PADDING };
        }
        try {
          return new Uint8Array(yn.privateDecrypt(y2, e3));
        } catch (e4) {
          if (o3)
            return o3;
          throw Error("Decryption error");
        }
      }(e2, t2, r2, i2, n2, a2, s2, o2) : async function(e3, t3, r3, i3, n3, a3, s3, o3) {
        const c2 = await de.getBigInteger();
        if (e3 = new c2(e3), t3 = new c2(t3), r3 = new c2(r3), i3 = new c2(i3), n3 = new c2(n3), a3 = new c2(a3), s3 = new c2(s3), e3.gte(t3))
          throw Error("Data too large.");
        const u2 = i3.mod(a3.dec()), h2 = i3.mod(n3.dec()), d2 = (await nn(new c2(2), t3)).mod(t3), f2 = d2.modInv(t3).modExp(r3, t3);
        e3 = e3.mul(f2).mod(t3);
        const l2 = e3.modExp(h2, n3), p2 = e3.modExp(u2, a3), y2 = s3.mul(p2.sub(l2)).mod(a3);
        let b2 = y2.mul(n3).add(l2);
        return b2 = b2.mul(d2).mod(t3), dn(b2.toUint8Array("be", t3.byteLength()), o3);
      }(e2, t2, r2, i2, n2, a2, s2, o2);
    }, generate: async function(e2, t2) {
      if (t2 = new (await de.getBigInteger())(t2), de.getWebCrypto()) {
        const r3 = { name: "RSASSA-PKCS1-v1_5", modulusLength: e2, publicExponent: t2.toUint8Array(), hash: { name: "SHA-1" } }, i3 = await pn.generateKey(r3, true, ["sign", "verify"]), n3 = await pn.exportKey("jwk", i3.privateKey);
        return { n: ge(n3.n), e: t2.toUint8Array(), d: ge(n3.d), p: ge(n3.q), q: ge(n3.p), u: ge(n3.qi) };
      }
      if (de.getNodeCrypto() && yn.generateKeyPair && gn) {
        const r3 = { modulusLength: e2, publicExponent: t2.toNumber(), publicKeyEncoding: { type: "pkcs1", format: "der" }, privateKeyEncoding: { type: "pkcs1", format: "der" } }, i3 = await new Promise((e3, t3) => {
          yn.generateKeyPair("rsa", r3, (r4, i4, n3) => {
            r4 ? t3(r4) : e3(gn.decode(n3, "der"));
          });
        });
        return { n: i3.modulus.toArrayLike(Uint8Array), e: i3.publicExponent.toArrayLike(Uint8Array), d: i3.privateExponent.toArrayLike(Uint8Array), p: i3.prime2.toArrayLike(Uint8Array), q: i3.prime1.toArrayLike(Uint8Array), u: i3.coefficient.toArrayLike(Uint8Array) };
      }
      let r2, i2, n2;
      do {
        i2 = await sn(e2 - (e2 >> 1), t2, 40), r2 = await sn(e2 >> 1, t2, 40), n2 = r2.mul(i2);
      } while (n2.bitLength() !== e2);
      const a2 = r2.dec().imul(i2.dec());
      return i2.lt(r2) && ([r2, i2] = [i2, r2]), { n: n2.toUint8Array(), e: t2.toUint8Array(), d: t2.modInv(a2).toUint8Array(), p: r2.toUint8Array(), q: i2.toUint8Array(), u: r2.modInv(i2).toUint8Array() };
    }, validateParams: async function(e2, t2, r2, i2, n2, a2) {
      const s2 = await de.getBigInteger();
      if (e2 = new s2(e2), i2 = new s2(i2), n2 = new s2(n2), !i2.mul(n2).equal(e2))
        return false;
      const o2 = new s2(2);
      if (a2 = new s2(a2), !i2.mul(a2).mod(n2).isOne())
        return false;
      t2 = new s2(t2), r2 = new s2(r2);
      const c2 = new s2(Math.floor(e2.bitLength() / 3)), u2 = await nn(o2, o2.leftShift(c2)), h2 = u2.mul(r2).mul(t2);
      return !(!h2.mod(i2.dec()).equal(u2) || !h2.mod(n2.dec()).equal(u2));
    } });
    var vn = /* @__PURE__ */ Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, i2) {
      const n2 = await de.getBigInteger();
      t2 = new n2(t2), r2 = new n2(r2), i2 = new n2(i2);
      const a2 = new n2(hn(e2, t2.byteLength())), s2 = await nn(new n2(1), t2.dec());
      return { c1: r2.modExp(s2, t2).toUint8Array(), c2: i2.modExp(s2, t2).imul(a2).imod(t2).toUint8Array() };
    }, decrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = await de.getBigInteger();
      return e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), i2 = new a2(i2), dn(e2.modExp(i2, r2).modInv(r2).imul(t2).imod(r2).toUint8Array("be", r2.byteLength()), n2);
    }, validateParams: async function(e2, t2, r2, i2) {
      const n2 = await de.getBigInteger();
      e2 = new n2(e2), t2 = new n2(t2), r2 = new n2(r2);
      const a2 = new n2(1);
      if (t2.lte(a2) || t2.gte(e2))
        return false;
      const s2 = new n2(e2.bitLength()), o2 = new n2(1023);
      if (s2.lt(o2))
        return false;
      if (!t2.modExp(e2.dec(), e2).isOne())
        return false;
      let c2 = t2;
      const u2 = new n2(1), h2 = new n2(2).leftShift(new n2(17));
      for (; u2.lt(h2); ) {
        if (c2 = c2.mul(t2).imod(e2), c2.isOne())
          return false;
        u2.iinc();
      }
      i2 = new n2(i2);
      const d2 = new n2(2), f2 = await nn(d2.leftShift(s2.dec()), d2.leftShift(s2)), l2 = e2.dec().imul(f2).iadd(i2);
      return !!r2.equal(t2.modExp(l2, e2));
    } });
    var _n = class __n {
      constructor(e2) {
        if (e2 instanceof __n)
          this.oid = e2.oid;
        else if (de.isArray(e2) || de.isUint8Array(e2)) {
          if (6 === (e2 = new Uint8Array(e2))[0]) {
            if (e2[1] !== e2.length - 2)
              throw Error("Length mismatch in DER encoded oid");
            e2 = e2.subarray(2);
          }
          this.oid = e2;
        } else
          this.oid = "";
      }
      read(e2) {
        if (e2.length >= 1) {
          const t2 = e2[0];
          if (e2.length >= 1 + t2)
            return this.oid = e2.subarray(1, 1 + t2), 1 + this.oid.length;
        }
        throw Error("Invalid oid");
      }
      write() {
        return de.concatUint8Array([new Uint8Array([this.oid.length]), this.oid]);
      }
      toHex() {
        return de.uint8ArrayToHex(this.oid);
      }
      getName() {
        const e2 = this.toHex();
        if (ue.curve[e2])
          return ue.write(ue.curve, e2);
        throw Error("Unknown curve object identifier.");
      }
    };
    function kn(e2, t2) {
      return e2.keyPair({ priv: t2 });
    }
    function An(e2, t2) {
      const r2 = e2.keyPair({ pub: t2 });
      if (true !== r2.validate().result)
        throw Error("Invalid elliptic public key");
      return r2;
    }
    async function Sn(e2) {
      if (!we.useIndutnyElliptic)
        throw Error("This curve is only supported in the full build of OpenPGP.js");
      const { default: t2 } = await Promise.resolve().then(function() {
        return mb;
      });
      return new t2.ec(e2);
    }
    function En(e2) {
      let t2, r2 = 0;
      const i2 = e2[0];
      return i2 < 192 ? ([r2] = e2, t2 = 1) : i2 < 255 ? (r2 = (e2[0] - 192 << 8) + e2[1] + 192, t2 = 2) : 255 === i2 && (r2 = de.readNumber(e2.subarray(1, 5)), t2 = 5), { len: r2, offset: t2 };
    }
    function Pn(e2) {
      return e2 < 192 ? new Uint8Array([e2]) : e2 > 191 && e2 < 8384 ? new Uint8Array([192 + (e2 - 192 >> 8), e2 - 192 & 255]) : de.concatUint8Array([new Uint8Array([255]), de.writeNumber(e2, 4)]);
    }
    function xn(e2) {
      if (e2 < 0 || e2 > 30)
        throw Error("Partial Length power must be between 1 and 30");
      return new Uint8Array([224 + e2]);
    }
    function Mn(e2) {
      return new Uint8Array([192 | e2]);
    }
    function Kn(e2, t2) {
      return de.concatUint8Array([Mn(e2), Pn(t2)]);
    }
    function Cn(e2) {
      return [ue.packet.literalData, ue.packet.compressedData, ue.packet.symmetricallyEncryptedData, ue.packet.symEncryptedIntegrityProtectedData, ue.packet.aeadEncryptedData].includes(e2);
    }
    async function Dn(e2, t2) {
      const r2 = W(e2);
      let i2, n2;
      try {
        const a2 = await r2.peekBytes(2);
        if (!a2 || a2.length < 2 || 0 == (128 & a2[0]))
          throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");
        const s2 = await r2.readByte();
        let o2, c2, u2 = -1, h2 = -1;
        h2 = 0, 0 != (64 & s2) && (h2 = 1), h2 ? u2 = 63 & s2 : (u2 = (63 & s2) >> 2, c2 = 3 & s2);
        const d2 = Cn(u2);
        let f2, l2 = null;
        if (d2) {
          if ("array" === de.isStream(e2)) {
            const e3 = new v();
            i2 = G(e3), l2 = e3;
          } else {
            const e3 = new F();
            i2 = G(e3.writable), l2 = e3.readable;
          }
          n2 = t2({ tag: u2, packet: l2 });
        } else
          l2 = [];
        do {
          if (h2) {
            const e3 = await r2.readByte();
            if (f2 = false, e3 < 192)
              o2 = e3;
            else if (e3 >= 192 && e3 < 224)
              o2 = (e3 - 192 << 8) + await r2.readByte() + 192;
            else if (e3 > 223 && e3 < 255) {
              if (o2 = 1 << (31 & e3), f2 = true, !d2)
                throw new TypeError("This packet type does not support partial lengths.");
            } else
              o2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
          } else
            switch (c2) {
              case 0:
                o2 = await r2.readByte();
                break;
              case 1:
                o2 = await r2.readByte() << 8 | await r2.readByte();
                break;
              case 2:
                o2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
                break;
              default:
                o2 = 1 / 0;
            }
          if (o2 > 0) {
            let e3 = 0;
            for (; ; ) {
              i2 && await i2.ready;
              const { done: t3, value: n3 } = await r2.read();
              if (t3) {
                if (o2 === 1 / 0)
                  break;
                throw Error("Unexpected end of packet");
              }
              const a3 = o2 === 1 / 0 ? n3 : n3.subarray(0, o2 - e3);
              if (i2 ? await i2.write(a3) : l2.push(a3), e3 += n3.length, e3 >= o2) {
                r2.unshift(n3.subarray(o2 - e3 + n3.length));
                break;
              }
            }
          }
        } while (f2);
        const p2 = await r2.peekBytes(d2 ? 1 / 0 : 2);
        return i2 ? (await i2.ready, await i2.close()) : (l2 = de.concatUint8Array(l2), await t2({ tag: u2, packet: l2 })), !p2 || !p2.length;
      } catch (e3) {
        if (i2)
          return await i2.abort(e3), true;
        throw e3;
      } finally {
        i2 && await n2, r2.releaseLock();
      }
    }
    var Un = class _Un extends Error {
      constructor(...e2) {
        super(...e2), Error.captureStackTrace && Error.captureStackTrace(this, _Un), this.name = "UnsupportedError";
      }
    };
    var Rn = class {
      constructor(e2, t2) {
        this.tag = e2, this.rawContent = t2;
      }
      write() {
        return this.rawContent;
      }
    };
    var In = de.getWebCrypto();
    var Bn = de.getNodeCrypto();
    var Tn = { p256: "P-256", p384: "P-384", p521: "P-521" };
    var zn = Bn ? Bn.getCurves() : [];
    var qn = Bn ? { secp256k1: zn.includes("secp256k1") ? "secp256k1" : void 0, p256: zn.includes("prime256v1") ? "prime256v1" : void 0, p384: zn.includes("secp384r1") ? "secp384r1" : void 0, p521: zn.includes("secp521r1") ? "secp521r1" : void 0, ed25519: zn.includes("ED25519") ? "ED25519" : void 0, curve25519: zn.includes("X25519") ? "X25519" : void 0, brainpoolP256r1: zn.includes("brainpoolP256r1") ? "brainpoolP256r1" : void 0, brainpoolP384r1: zn.includes("brainpoolP384r1") ? "brainpoolP384r1" : void 0, brainpoolP512r1: zn.includes("brainpoolP512r1") ? "brainpoolP512r1" : void 0 } : {};
    var Fn = { p256: { oid: [6, 8, 42, 134, 72, 206, 61, 3, 1, 7], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha256, cipher: ue.symmetric.aes128, node: qn.p256, web: Tn.p256, payloadSize: 32, sharedSize: 256 }, p384: { oid: [6, 5, 43, 129, 4, 0, 34], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha384, cipher: ue.symmetric.aes192, node: qn.p384, web: Tn.p384, payloadSize: 48, sharedSize: 384 }, p521: { oid: [6, 5, 43, 129, 4, 0, 35], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha512, cipher: ue.symmetric.aes256, node: qn.p521, web: Tn.p521, payloadSize: 66, sharedSize: 528 }, secp256k1: { oid: [6, 5, 43, 129, 4, 0, 10], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha256, cipher: ue.symmetric.aes128, node: qn.secp256k1, payloadSize: 32 }, ed25519: { oid: [6, 9, 43, 6, 1, 4, 1, 218, 71, 15, 1], keyType: ue.publicKey.eddsaLegacy, hash: ue.hash.sha512, node: false, payloadSize: 32 }, curve25519: { oid: [6, 10, 43, 6, 1, 4, 1, 151, 85, 1, 5, 1], keyType: ue.publicKey.ecdh, hash: ue.hash.sha256, cipher: ue.symmetric.aes128, node: false, payloadSize: 32 }, brainpoolP256r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 7], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha256, cipher: ue.symmetric.aes128, node: qn.brainpoolP256r1, payloadSize: 32 }, brainpoolP384r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 11], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha384, cipher: ue.symmetric.aes192, node: qn.brainpoolP384r1, payloadSize: 48 }, brainpoolP512r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 13], keyType: ue.publicKey.ecdsa, hash: ue.hash.sha512, cipher: ue.symmetric.aes256, node: qn.brainpoolP512r1, payloadSize: 64 } };
    var On = class {
      constructor(e2, t2) {
        try {
          (de.isArray(e2) || de.isUint8Array(e2)) && (e2 = new _n(e2)), e2 instanceof _n && (e2 = e2.getName()), this.name = ue.write(ue.curve, e2);
        } catch (e3) {
          throw new Un("Unknown curve");
        }
        t2 = t2 || Fn[this.name], this.keyType = t2.keyType, this.oid = t2.oid, this.hash = t2.hash, this.cipher = t2.cipher, this.node = t2.node && Fn[this.name], this.web = t2.web && Fn[this.name], this.payloadSize = t2.payloadSize, this.web && de.getWebCrypto() ? this.type = "web" : this.node && de.getNodeCrypto() ? this.type = "node" : "curve25519" === this.name ? this.type = "curve25519" : "ed25519" === this.name && (this.type = "ed25519");
      }
      async genKeyPair() {
        let e2;
        switch (this.type) {
          case "web":
            try {
              return await async function(e3) {
                const t3 = await In.generateKey({ name: "ECDSA", namedCurve: Tn[e3] }, true, ["sign", "verify"]), r2 = await In.exportKey("jwk", t3.privateKey), i2 = await In.exportKey("jwk", t3.publicKey);
                return { publicKey: Nn(i2), privateKey: ge(r2.d) };
              }(this.name);
            } catch (e3) {
              de.printDebugError("Browser did not support generating ec key " + e3.message);
              break;
            }
          case "node":
            return async function(e3) {
              const t3 = Bn.createECDH(qn[e3]);
              return await t3.generateKeys(), { publicKey: new Uint8Array(t3.getPublicKey()), privateKey: new Uint8Array(t3.getPrivateKey()) };
            }(this.name);
          case "curve25519": {
            const t3 = rn(32);
            t3[0] = 127 & t3[0] | 64, t3[31] &= 248;
            const r2 = t3.slice().reverse();
            e2 = en.box.keyPair.fromSecretKey(r2);
            return { publicKey: de.concatUint8Array([new Uint8Array([64]), e2.publicKey]), privateKey: t3 };
          }
          case "ed25519": {
            const e3 = rn(32), t3 = en.sign.keyPair.fromSeed(e3);
            return { publicKey: de.concatUint8Array([new Uint8Array([64]), t3.publicKey]), privateKey: e3 };
          }
        }
        const t2 = await Sn(this.name);
        return e2 = await t2.genKeyPair({ entropy: de.uint8ArrayToString(rn(32)) }), { publicKey: new Uint8Array(e2.getPublic("array", false)), privateKey: e2.getPrivate().toArrayLike(Uint8Array) };
      }
    };
    async function Ln(e2, t2, r2, i2) {
      const n2 = { p256: true, p384: true, p521: true, secp256k1: true, curve25519: e2 === ue.publicKey.ecdh, brainpoolP256r1: true, brainpoolP384r1: true, brainpoolP512r1: true }, a2 = t2.getName();
      if (!n2[a2])
        return false;
      if ("curve25519" === a2) {
        i2 = i2.slice().reverse();
        const { publicKey: e3 } = en.box.keyPair.fromSecretKey(i2);
        r2 = new Uint8Array(r2);
        const t3 = new Uint8Array([64, ...e3]);
        return !!de.equalsUint8Array(t3, r2);
      }
      const s2 = await Sn(a2);
      try {
        r2 = An(s2, r2).getPublic();
      } catch (e3) {
        return false;
      }
      return !!kn(s2, i2).getPublic().eq(r2);
    }
    function Nn(e2) {
      const t2 = ge(e2.x), r2 = ge(e2.y), i2 = new Uint8Array(t2.length + r2.length + 1);
      return i2[0] = 4, i2.set(t2, 1), i2.set(r2, t2.length + 1), i2;
    }
    function jn(e2, t2, r2) {
      const i2 = e2, n2 = r2.slice(1, i2 + 1), a2 = r2.slice(i2 + 1, 2 * i2 + 1);
      return { kty: "EC", crv: t2, x: me(n2, true), y: me(a2, true), ext: true };
    }
    function Hn(e2, t2, r2, i2) {
      const n2 = jn(e2, t2, r2);
      return n2.d = me(i2, true), n2;
    }
    var Wn = de.getWebCrypto();
    var Gn = de.getNodeCrypto();
    async function Vn(e2, t2, r2, i2, n2, a2) {
      const s2 = new On(e2);
      if (r2 && !de.isStream(r2)) {
        const e3 = { publicKey: i2, privateKey: n2 };
        switch (s2.type) {
          case "web":
            try {
              return await async function(e4, t3, r3, i3) {
                const n3 = e4.payloadSize, a3 = Hn(e4.payloadSize, Tn[e4.name], i3.publicKey, i3.privateKey), s3 = await Wn.importKey("jwk", a3, { name: "ECDSA", namedCurve: Tn[e4.name], hash: { name: ue.read(ue.webHash, e4.hash) } }, false, ["sign"]), o2 = new Uint8Array(await Wn.sign({ name: "ECDSA", namedCurve: Tn[e4.name], hash: { name: ue.read(ue.webHash, t3) } }, s3, r3));
                return { r: o2.slice(0, n3), s: o2.slice(n3, n3 << 1) };
              }(s2, t2, r2, e3);
            } catch (e4) {
              if ("p521" !== s2.name && ("DataError" === e4.name || "OperationError" === e4.name))
                throw e4;
              de.printDebugError("Browser did not support signing: " + e4.message);
            }
            break;
          case "node": {
            const i3 = await async function(e4, t3, r3, i4) {
              const n3 = Gn.createSign(ue.read(ue.hash, t3));
              n3.write(r3), n3.end();
              const a3 = Yn.encode({ version: 1, parameters: e4.oid, privateKey: Array.from(i4.privateKey), publicKey: { unused: 0, data: Array.from(i4.publicKey) } }, "pem", { label: "EC PRIVATE KEY" });
              return Xn.decode(n3.sign(a3), "der");
            }(s2, t2, r2, e3);
            return { r: i3.r.toArrayLike(Uint8Array), s: i3.s.toArrayLike(Uint8Array) };
          }
        }
      }
      return async function(e3, t3, r3) {
        const i3 = await Sn(e3.name), n3 = kn(i3, r3), a3 = n3.sign(t3);
        return { r: a3.r.toArrayLike(Uint8Array), s: a3.s.toArrayLike(Uint8Array) };
      }(s2, a2, n2);
    }
    async function $n(e2, t2, r2, i2, n2, a2) {
      const s2 = new On(e2);
      if (i2 && !de.isStream(i2))
        switch (s2.type) {
          case "web":
            try {
              return await async function(e3, t3, { r: r3, s: i3 }, n3, a3) {
                const s3 = jn(e3.payloadSize, Tn[e3.name], a3), o2 = await Wn.importKey("jwk", s3, { name: "ECDSA", namedCurve: Tn[e3.name], hash: { name: ue.read(ue.webHash, e3.hash) } }, false, ["verify"]), c2 = de.concatUint8Array([r3, i3]).buffer;
                return Wn.verify({ name: "ECDSA", namedCurve: Tn[e3.name], hash: { name: ue.read(ue.webHash, t3) } }, o2, c2, n3);
              }(s2, t2, r2, i2, n2);
            } catch (e3) {
              if ("p521" !== s2.name && ("DataError" === e3.name || "OperationError" === e3.name))
                throw e3;
              de.printDebugError("Browser did not support verifying: " + e3.message);
            }
            break;
          case "node":
            return async function(e3, t3, { r: r3, s: i3 }, n3, a3) {
              const { default: s3 } = await Promise.resolve().then(function() {
                return Jp;
              }), o2 = Gn.createVerify(ue.read(ue.hash, t3));
              o2.write(n3), o2.end();
              const c2 = Jn.encode({ algorithm: { algorithm: [1, 2, 840, 10045, 2, 1], parameters: e3.oid }, subjectPublicKey: { unused: 0, data: Array.from(a3) } }, "pem", { label: "PUBLIC KEY" }), u2 = Xn.encode({ r: new s3(r3), s: new s3(i3) }, "der");
              try {
                return o2.verify(c2, u2);
              } catch (e4) {
                return false;
              }
            }(s2, t2, r2, i2, n2);
        }
      return async function(e3, t3, r3, i3) {
        const n3 = await Sn(e3.name), a3 = An(n3, i3);
        return a3.verify(r3, t3);
      }(s2, r2, void 0 === t2 ? i2 : a2, n2);
    }
    var Zn = Gn ? y.default : void 0;
    var Xn = Gn ? Zn.define("ECDSASignature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    }) : void 0;
    var Yn = Gn ? Zn.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).optional().any(), this.key("publicKey").explicit(1).optional().bitstr());
    }) : void 0;
    var Qn = Gn ? Zn.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
    }) : void 0;
    var Jn = Gn ? Zn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(Qn), this.key("subjectPublicKey").bitstr());
    }) : void 0;
    var ea = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: Vn, verify: $n, validateParams: async function(e2, t2, r2) {
      const i2 = new On(e2);
      if (i2.keyType !== ue.publicKey.ecdsa)
        return false;
      switch (i2.type) {
        case "web":
        case "node": {
          const i3 = rn(8), n2 = ue.hash.sha256, a2 = await ci.digest(n2, i3);
          try {
            const s2 = await Vn(e2, n2, i3, t2, r2, a2);
            return await $n(e2, n2, s2, i3, t2, a2);
          } catch (e3) {
            return false;
          }
        }
        default:
          return Ln(ue.publicKey.ecdsa, e2, t2, r2);
      }
    } });
    en.hash = (e2) => new Uint8Array(yr().update(e2).digest());
    var ta = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2) {
      if (ci.getHashByteLength(t2) < ci.getHashByteLength(ue.hash.sha256))
        throw Error("Hash algorithm too weak for EdDSA.");
      const s2 = de.concatUint8Array([n2, i2.subarray(1)]), o2 = en.sign.detached(a2, s2);
      return { r: o2.subarray(0, 32), s: o2.subarray(32) };
    }, verify: async function(e2, t2, { r: r2, s: i2 }, n2, a2, s2) {
      if (ci.getHashByteLength(t2) < ci.getHashByteLength(ue.hash.sha256))
        throw Error("Hash algorithm too weak for EdDSA.");
      const o2 = de.concatUint8Array([r2, i2]);
      return en.sign.detached.verify(s2, o2, a2.subarray(1));
    }, validateParams: async function(e2, t2, r2) {
      if ("ed25519" !== e2.getName())
        return false;
      const { publicKey: i2 } = en.sign.keyPair.fromSeed(r2), n2 = new Uint8Array([64, ...i2]);
      return de.equalsUint8Array(t2, n2);
    } });
    function ra(e2) {
      if (e2 === ue.publicKey.ed25519)
        return ue.hash.sha256;
      throw Error("Unknown EdDSA algo");
    }
    en.hash = (e2) => new Uint8Array(yr().update(e2).digest());
    var ia = /* @__PURE__ */ Object.freeze({ __proto__: null, generate: async function(e2) {
      if (e2 === ue.publicKey.ed25519) {
        const e3 = rn(32), { publicKey: t2 } = en.sign.keyPair.fromSeed(e3);
        return { A: t2, seed: e3 };
      }
      throw Error("Unsupported EdDSA algorithm");
    }, sign: async function(e2, t2, r2, i2, n2, a2) {
      if (ci.getHashByteLength(t2) < ci.getHashByteLength(ra(e2)))
        throw Error("Hash algorithm too weak for EdDSA.");
      switch (e2) {
        case ue.publicKey.ed25519: {
          const e3 = de.concatUint8Array([n2, i2]);
          return { RS: en.sign.detached(a2, e3) };
        }
        case ue.publicKey.ed448:
        default:
          throw Error("Unsupported EdDSA algorithm");
      }
    }, verify: async function(e2, t2, { RS: r2 }, i2, n2, a2) {
      if (ci.getHashByteLength(t2) < ci.getHashByteLength(ra(e2)))
        throw Error("Hash algorithm too weak for EdDSA.");
      switch (e2) {
        case ue.publicKey.ed25519:
          return en.sign.detached.verify(a2, r2, n2);
        case ue.publicKey.ed448:
        default:
          throw Error("Unsupported EdDSA algorithm");
      }
    }, validateParams: async function(e2, t2, r2) {
      switch (e2) {
        case ue.publicKey.ed25519: {
          const { publicKey: e3 } = en.sign.keyPair.fromSeed(r2);
          return de.equalsUint8Array(t2, e3);
        }
        case ue.publicKey.ed448:
        default:
          return false;
      }
    }, getPreferredHashAlgo: ra });
    function na(e2, t2) {
      const r2 = new st["aes" + 8 * e2.length](e2), i2 = new Uint32Array([2795939494, 2795939494]), n2 = sa(t2);
      let a2 = i2;
      const s2 = n2, o2 = n2.length / 2, c2 = new Uint32Array([0, 0]);
      let u2 = new Uint32Array(4);
      for (let e3 = 0; e3 <= 5; ++e3)
        for (let t3 = 0; t3 < o2; ++t3)
          c2[1] = o2 * e3 + (1 + t3), u2[0] = a2[0], u2[1] = a2[1], u2[2] = s2[2 * t3], u2[3] = s2[2 * t3 + 1], u2 = sa(r2.encrypt(oa(u2))), a2 = u2.subarray(0, 2), a2[0] ^= c2[0], a2[1] ^= c2[1], s2[2 * t3] = u2[2], s2[2 * t3 + 1] = u2[3];
      return oa(a2, s2);
    }
    function aa(e2, t2) {
      const r2 = new st["aes" + 8 * e2.length](e2), i2 = new Uint32Array([2795939494, 2795939494]), n2 = sa(t2);
      let a2 = n2.subarray(0, 2);
      const s2 = n2.subarray(2), o2 = n2.length / 2 - 1, c2 = new Uint32Array([0, 0]);
      let u2 = new Uint32Array(4);
      for (let e3 = 5; e3 >= 0; --e3)
        for (let t3 = o2 - 1; t3 >= 0; --t3)
          c2[1] = o2 * e3 + (t3 + 1), u2[0] = a2[0] ^ c2[0], u2[1] = a2[1] ^ c2[1], u2[2] = s2[2 * t3], u2[3] = s2[2 * t3 + 1], u2 = sa(r2.decrypt(oa(u2))), a2 = u2.subarray(0, 2), s2[2 * t3] = u2[2], s2[2 * t3 + 1] = u2[3];
      if (a2[0] === i2[0] && a2[1] === i2[1])
        return oa(s2);
      throw Error("Key Data Integrity failed");
    }
    function sa(e2) {
      const { length: t2 } = e2, r2 = function(e3) {
        if (de.isString(e3)) {
          const { length: t3 } = e3, r3 = new ArrayBuffer(t3), i3 = new Uint8Array(r3);
          for (let r4 = 0; r4 < t3; ++r4)
            i3[r4] = e3.charCodeAt(r4);
          return r3;
        }
        return new Uint8Array(e3).buffer;
      }(e2), i2 = new DataView(r2), n2 = new Uint32Array(t2 / 4);
      for (let e3 = 0; e3 < t2 / 4; ++e3)
        n2[e3] = i2.getUint32(4 * e3);
      return n2;
    }
    function oa() {
      let e2 = 0;
      for (let t3 = 0; t3 < arguments.length; ++t3)
        e2 += 4 * arguments[t3].length;
      const t2 = new ArrayBuffer(e2), r2 = new DataView(t2);
      let i2 = 0;
      for (let e3 = 0; e3 < arguments.length; ++e3) {
        for (let t3 = 0; t3 < arguments[e3].length; ++t3)
          r2.setUint32(i2 + 4 * t3, arguments[e3][t3]);
        i2 += 4 * arguments[e3].length;
      }
      return new Uint8Array(t2);
    }
    var ca = /* @__PURE__ */ Object.freeze({ __proto__: null, wrap: na, unwrap: aa });
    function ua(e2) {
      const t2 = 8 - e2.length % 8, r2 = new Uint8Array(e2.length + t2).fill(t2);
      return r2.set(e2), r2;
    }
    function ha(e2) {
      const t2 = e2.length;
      if (t2 > 0) {
        const r2 = e2[t2 - 1];
        if (r2 >= 1) {
          const i2 = e2.subarray(t2 - r2), n2 = new Uint8Array(r2).fill(r2);
          if (de.equalsUint8Array(i2, n2))
            return e2.subarray(0, t2 - r2);
        }
      }
      throw Error("Invalid padding");
    }
    var da = /* @__PURE__ */ Object.freeze({ __proto__: null, encode: ua, decode: ha });
    var fa = de.getWebCrypto();
    var la = de.getNodeCrypto();
    function pa(e2, t2, r2, i2) {
      return de.concatUint8Array([t2.write(), new Uint8Array([e2]), r2.write(), de.stringToUint8Array("Anonymous Sender    "), i2.subarray(0, 20)]);
    }
    async function ya(e2, t2, r2, i2, n2 = false, a2 = false) {
      let s2;
      if (n2) {
        for (s2 = 0; s2 < t2.length && 0 === t2[s2]; s2++)
          ;
        t2 = t2.subarray(s2);
      }
      if (a2) {
        for (s2 = t2.length - 1; s2 >= 0 && 0 === t2[s2]; s2--)
          ;
        t2 = t2.subarray(0, s2 + 1);
      }
      return (await ci.digest(e2, de.concatUint8Array([new Uint8Array([0, 0, 0, 1]), t2, i2]))).subarray(0, r2);
    }
    async function ba(e2, t2) {
      switch (e2.type) {
        case "curve25519": {
          const r2 = rn(32), { secretKey: i2, sharedKey: n2 } = await ga(e2, t2, null, r2);
          let { publicKey: a2 } = en.box.keyPair.fromSecretKey(i2);
          return a2 = de.concatUint8Array([new Uint8Array([64]), a2]), { publicKey: a2, sharedKey: n2 };
        }
        case "web":
          if (e2.web && de.getWebCrypto())
            try {
              return await async function(e3, t3) {
                const r2 = jn(e3.payloadSize, e3.web.web, t3);
                let i2 = fa.generateKey({ name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]), n2 = fa.importKey("jwk", r2, { name: "ECDH", namedCurve: e3.web.web }, false, []);
                [i2, n2] = await Promise.all([i2, n2]);
                let a2 = fa.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: n2 }, i2.privateKey, e3.web.sharedSize), s2 = fa.exportKey("jwk", i2.publicKey);
                [a2, s2] = await Promise.all([a2, s2]);
                const o2 = new Uint8Array(a2), c2 = new Uint8Array(Nn(s2));
                return { publicKey: c2, sharedKey: o2 };
              }(e2, t2);
            } catch (e3) {
              de.printDebugError(e3);
            }
          break;
        case "node":
          return async function(e3, t3) {
            const r2 = la.createECDH(e3.node.node);
            r2.generateKeys();
            const i2 = new Uint8Array(r2.computeSecret(t3)), n2 = new Uint8Array(r2.getPublicKey());
            return { publicKey: n2, sharedKey: i2 };
          }(e2, t2);
      }
      return async function(e3, t3) {
        const r2 = await Sn(e3.name), i2 = await e3.genKeyPair();
        t3 = An(r2, t3);
        const n2 = kn(r2, i2.privateKey), a2 = i2.publicKey, s2 = n2.derive(t3.getPublic()), o2 = r2.curve.p.byteLength(), c2 = s2.toArrayLike(Uint8Array, "be", o2);
        return { publicKey: a2, sharedKey: c2 };
      }(e2, t2);
    }
    async function ga(e2, t2, r2, i2) {
      if (i2.length !== e2.payloadSize) {
        const t3 = new Uint8Array(e2.payloadSize);
        t3.set(i2, e2.payloadSize - i2.length), i2 = t3;
      }
      switch (e2.type) {
        case "curve25519": {
          const e3 = i2.slice().reverse();
          return { secretKey: e3, sharedKey: en.scalarMult(e3, t2.subarray(1)) };
        }
        case "web":
          if (e2.web && de.getWebCrypto())
            try {
              return await async function(e3, t3, r3, i3) {
                const n2 = Hn(e3.payloadSize, e3.web.web, r3, i3);
                let a2 = fa.importKey("jwk", n2, { name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]);
                const s2 = jn(e3.payloadSize, e3.web.web, t3);
                let o2 = fa.importKey("jwk", s2, { name: "ECDH", namedCurve: e3.web.web }, true, []);
                [a2, o2] = await Promise.all([a2, o2]);
                let c2 = fa.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: o2 }, a2, e3.web.sharedSize), u2 = fa.exportKey("jwk", a2);
                [c2, u2] = await Promise.all([c2, u2]);
                const h2 = new Uint8Array(c2);
                return { secretKey: ge(u2.d), sharedKey: h2 };
              }(e2, t2, r2, i2);
            } catch (e3) {
              de.printDebugError(e3);
            }
          break;
        case "node":
          return async function(e3, t3, r3) {
            const i3 = la.createECDH(e3.node.node);
            i3.setPrivateKey(r3);
            const n2 = new Uint8Array(i3.computeSecret(t3));
            return { secretKey: new Uint8Array(i3.getPrivateKey()), sharedKey: n2 };
          }(e2, t2, i2);
      }
      return async function(e3, t3, r3) {
        const i3 = await Sn(e3.name);
        t3 = An(i3, t3), r3 = kn(i3, r3);
        const n2 = new Uint8Array(r3.getPrivate()), a2 = r3.derive(t3.getPublic()), s2 = i3.curve.p.byteLength(), o2 = a2.toArrayLike(Uint8Array, "be", s2);
        return { secretKey: n2, sharedKey: o2 };
      }(e2, t2, i2);
    }
    var ma = /* @__PURE__ */ Object.freeze({ __proto__: null, validateParams: async function(e2, t2, r2) {
      return Ln(ue.publicKey.ecdh, e2, t2, r2);
    }, encrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = ua(r2), s2 = new On(e2), { publicKey: o2, sharedKey: c2 } = await ba(s2, i2), u2 = pa(ue.publicKey.ecdh, e2, t2, n2), { keySize: h2 } = hi(t2.cipher);
      return { publicKey: o2, wrappedKey: na(await ya(t2.hash, c2, h2, u2), a2) };
    }, decrypt: async function(e2, t2, r2, i2, n2, a2, s2) {
      const o2 = new On(e2), { sharedKey: c2 } = await ga(o2, r2, n2, a2), u2 = pa(ue.publicKey.ecdh, e2, t2, s2), { keySize: h2 } = hi(t2.cipher);
      let d2;
      for (let e3 = 0; e3 < 3; e3++)
        try {
          return ha(aa(await ya(t2.hash, c2, h2, u2, 1 === e3, 2 === e3), i2));
        } catch (e4) {
          d2 = e4;
        }
      throw d2;
    } });
    var wa = de.getWebCrypto();
    var va = de.getNodeCrypto();
    var _a = va && va.webcrypto && va.webcrypto.subtle;
    async function ka(e2, t2, r2, i2, n2) {
      const a2 = ue.read(ue.webHash, e2);
      if (!a2)
        throw Error("Hash algo not supported with HKDF");
      if (wa || _a) {
        const e3 = wa || _a, s2 = await e3.importKey("raw", t2, "HKDF", false, ["deriveBits"]), o2 = await e3.deriveBits({ name: "HKDF", hash: a2, salt: r2, info: i2 }, s2, 8 * n2);
        return new Uint8Array(o2);
      }
      if (va) {
        const a3 = ue.read(ue.hash, e2), s2 = (e3, t3) => va.createHmac(a3, e3).update(t3).digest(), o2 = s2(r2, t2), c2 = o2.length, u2 = Math.ceil(n2 / c2), h2 = new Uint8Array(u2 * c2), d2 = new Uint8Array(c2 + i2.length + 1);
        d2.set(i2, c2);
        for (let e3 = 0; e3 < u2; e3++) {
          d2[d2.length - 1] = e3 + 1;
          const t3 = s2(o2, e3 > 0 ? d2 : d2.subarray(c2));
          d2.set(t3, 0), h2.set(t3, e3 * c2);
        }
        return h2.subarray(0, n2);
      }
      throw Error("No HKDF implementation available");
    }
    var Aa = { x25519: de.encodeUTF8("OpenPGP X25519") };
    var Sa = /* @__PURE__ */ Object.freeze({ __proto__: null, generate: async function(e2) {
      if (e2 === ue.publicKey.x25519) {
        const e3 = rn(32), { publicKey: t2 } = en.box.keyPair.fromSecretKey(e3);
        return { A: t2, k: e3 };
      }
      throw Error("Unsupported ECDH algorithm");
    }, validateParams: async function(e2, t2, r2) {
      if (e2 === ue.publicKey.x25519) {
        const { publicKey: e3 } = en.box.keyPair.fromSecretKey(r2);
        return de.equalsUint8Array(t2, e3);
      }
      return false;
    }, encrypt: async function(e2, t2, r2) {
      if (e2 === ue.publicKey.x25519) {
        const e3 = rn(32), i2 = en.scalarMult(e3, r2), { publicKey: n2 } = en.box.keyPair.fromSecretKey(e3), a2 = de.concatUint8Array([n2, r2, i2]), { keySize: s2 } = hi(ue.symmetric.aes128);
        return { ephemeralPublicKey: n2, wrappedKey: na(await ka(ue.hash.sha256, a2, new Uint8Array(), Aa.x25519, s2), t2) };
      }
      throw Error("Unsupported ECDH algorithm");
    }, decrypt: async function(e2, t2, r2, i2, n2) {
      if (e2 === ue.publicKey.x25519) {
        const e3 = en.scalarMult(n2, t2), a2 = de.concatUint8Array([t2, i2, e3]), { keySize: s2 } = hi(ue.symmetric.aes128);
        return aa(await ka(ue.hash.sha256, a2, new Uint8Array(), Aa.x25519, s2), r2);
      }
      throw Error("Unsupported ECDH algorithm");
    } });
    var Ea = /* @__PURE__ */ Object.freeze({ __proto__: null, CurveWithOID: On, ecdh: ma, ecdhX: Sa, ecdsa: ea, eddsaLegacy: ta, eddsa: ia, generate: async function(e2) {
      const t2 = await de.getBigInteger();
      e2 = new On(e2);
      const r2 = await e2.genKeyPair(), i2 = new t2(r2.publicKey).toUint8Array(), n2 = new t2(r2.privateKey).toUint8Array("be", e2.payloadSize);
      return { oid: e2.oid, Q: i2, secret: n2, hash: e2.hash, cipher: e2.cipher };
    }, getPreferredHashAlgo: function(e2) {
      return Fn[ue.write(ue.curve, e2.toHex())].hash;
    } });
    var Pa = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2) {
      const s2 = await de.getBigInteger(), o2 = new s2(1);
      let c2, u2, h2, d2;
      i2 = new s2(i2), n2 = new s2(n2), r2 = new s2(r2), a2 = new s2(a2), r2 = r2.mod(i2), a2 = a2.mod(n2);
      const f2 = new s2(t2.subarray(0, n2.byteLength())).mod(n2);
      for (; ; ) {
        if (c2 = await nn(o2, n2), u2 = r2.modExp(c2, i2).imod(n2), u2.isZero())
          continue;
        const e3 = a2.mul(u2).imod(n2);
        if (d2 = f2.add(e3).imod(n2), h2 = c2.modInv(n2).imul(d2).imod(n2), !h2.isZero())
          break;
      }
      return { r: u2.toUint8Array("be", n2.byteLength()), s: h2.toUint8Array("be", n2.byteLength()) };
    }, verify: async function(e2, t2, r2, i2, n2, a2, s2, o2) {
      const c2 = await de.getBigInteger(), u2 = new c2(0);
      if (t2 = new c2(t2), r2 = new c2(r2), a2 = new c2(a2), s2 = new c2(s2), n2 = new c2(n2), o2 = new c2(o2), t2.lte(u2) || t2.gte(s2) || r2.lte(u2) || r2.gte(s2))
        return de.printDebug("invalid DSA Signature"), false;
      const h2 = new c2(i2.subarray(0, s2.byteLength())).imod(s2), d2 = r2.modInv(s2);
      if (d2.isZero())
        return de.printDebug("invalid DSA Signature"), false;
      n2 = n2.mod(a2), o2 = o2.mod(a2);
      const f2 = h2.mul(d2).imod(s2), l2 = t2.mul(d2).imod(s2), p2 = n2.modExp(f2, a2), y2 = o2.modExp(l2, a2);
      return p2.mul(y2).imod(a2).imod(s2).equal(t2);
    }, validateParams: async function(e2, t2, r2, i2, n2) {
      const a2 = await de.getBigInteger();
      e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), i2 = new a2(i2);
      const s2 = new a2(1);
      if (r2.lte(s2) || r2.gte(e2))
        return false;
      if (!e2.dec().mod(t2).isZero())
        return false;
      if (!r2.modExp(t2, e2).isOne())
        return false;
      const o2 = new a2(t2.bitLength()), c2 = new a2(150);
      if (o2.lt(c2) || !await on(t2, null, 32))
        return false;
      n2 = new a2(n2);
      const u2 = new a2(2), h2 = await nn(u2.leftShift(o2.dec()), u2.leftShift(o2)), d2 = t2.mul(h2).add(n2);
      return !!i2.equal(r2.modExp(d2, e2));
    } });
    var xa = { rsa: wn, elgamal: vn, elliptic: Ea, dsa: Pa, nacl: en };
    var Ma = /* @__PURE__ */ Object.freeze({ __proto__: null, parseSignatureParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaSign:
          return { s: de.readMPI(t2.subarray(r2)) };
        case ue.publicKey.dsa:
        case ue.publicKey.ecdsa: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          return { r: e3, s: de.readMPI(t2.subarray(r2)) };
        }
        case ue.publicKey.eddsaLegacy: {
          let e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2, e3 = de.leftPad(e3, 32);
          let i2 = de.readMPI(t2.subarray(r2));
          return i2 = de.leftPad(i2, 32), { r: e3, s: i2 };
        }
        case ue.publicKey.ed25519: {
          const e3 = t2.subarray(r2, r2 + 64);
          return r2 += e3.length, { RS: e3 };
        }
        default:
          throw new Un("Unknown signature algorithm.");
      }
    }, verify: async function(e2, t2, r2, i2, n2, a2) {
      switch (e2) {
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaSign: {
          const { n: e3, e: s2 } = i2, o2 = de.leftPad(r2.s, e3.length);
          return xa.rsa.verify(t2, n2, o2, e3, s2, a2);
        }
        case ue.publicKey.dsa: {
          const { g: e3, p: n3, q: s2, y: o2 } = i2, { r: c2, s: u2 } = r2;
          return xa.dsa.verify(t2, c2, u2, a2, e3, n3, s2, o2);
        }
        case ue.publicKey.ecdsa: {
          const { oid: e3, Q: s2 } = i2, o2 = new xa.elliptic.CurveWithOID(e3).payloadSize, c2 = de.leftPad(r2.r, o2), u2 = de.leftPad(r2.s, o2);
          return xa.elliptic.ecdsa.verify(e3, t2, { r: c2, s: u2 }, n2, s2, a2);
        }
        case ue.publicKey.eddsaLegacy: {
          const { oid: e3, Q: s2 } = i2;
          return xa.elliptic.eddsaLegacy.verify(e3, t2, r2, n2, s2, a2);
        }
        case ue.publicKey.ed25519: {
          const { A: s2 } = i2;
          return xa.elliptic.eddsa.verify(e2, t2, r2, n2, s2, a2);
        }
        default:
          throw Error("Unknown signature algorithm.");
      }
    }, sign: async function(e2, t2, r2, i2, n2, a2) {
      if (!r2 || !i2)
        throw Error("Missing key parameters");
      switch (e2) {
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaSign: {
          const { n: e3, e: s2 } = r2, { d: o2, p: c2, q: u2, u: h2 } = i2;
          return { s: await xa.rsa.sign(t2, n2, e3, s2, o2, c2, u2, h2, a2) };
        }
        case ue.publicKey.dsa: {
          const { g: e3, p: n3, q: s2 } = r2, { x: o2 } = i2;
          return xa.dsa.sign(t2, a2, e3, n3, s2, o2);
        }
        case ue.publicKey.elgamal:
          throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");
        case ue.publicKey.ecdsa: {
          const { oid: e3, Q: s2 } = r2, { d: o2 } = i2;
          return xa.elliptic.ecdsa.sign(e3, t2, n2, s2, o2, a2);
        }
        case ue.publicKey.eddsaLegacy: {
          const { oid: e3, Q: s2 } = r2, { seed: o2 } = i2;
          return xa.elliptic.eddsaLegacy.sign(e3, t2, n2, s2, o2, a2);
        }
        case ue.publicKey.ed25519: {
          const { A: s2 } = r2, { seed: o2 } = i2;
          return xa.elliptic.eddsa.sign(e2, t2, n2, s2, o2, a2);
        }
        default:
          throw Error("Unknown signature algorithm.");
      }
    } });
    var Ka = class {
      constructor(e2) {
        e2 && (this.data = e2);
      }
      read(e2) {
        if (e2.length >= 1) {
          const t2 = e2[0];
          if (e2.length >= 1 + t2)
            return this.data = e2.subarray(1, 1 + t2), 1 + this.data.length;
        }
        throw Error("Invalid symmetric key");
      }
      write() {
        return de.concatUint8Array([new Uint8Array([this.data.length]), this.data]);
      }
    };
    var Ca = class {
      constructor(e2) {
        if (e2) {
          const { hash: t2, cipher: r2 } = e2;
          this.hash = t2, this.cipher = r2;
        } else
          this.hash = null, this.cipher = null;
      }
      read(e2) {
        if (e2.length < 4 || 3 !== e2[0] || 1 !== e2[1])
          throw new Un("Cannot read KDFParams");
        return this.hash = e2[2], this.cipher = e2[3], 4;
      }
      write() {
        return new Uint8Array([3, 1, this.hash, this.cipher]);
      }
    };
    var Da = class _Da {
      static fromObject({ wrappedKey: e2, algorithm: t2 }) {
        const r2 = new _Da();
        return r2.wrappedKey = e2, r2.algorithm = t2, r2;
      }
      read(e2) {
        let t2 = 0, r2 = e2[t2++];
        this.algorithm = r2 % 2 ? e2[t2++] : null, r2 -= r2 % 2, this.wrappedKey = e2.subarray(t2, t2 + r2), t2 += r2;
      }
      write() {
        return de.concatUint8Array([this.algorithm ? new Uint8Array([this.wrappedKey.length + 1, this.algorithm]) : new Uint8Array([this.wrappedKey.length]), this.wrappedKey]);
      }
    };
    function Ua(e2) {
      try {
        e2.getName();
      } catch (e3) {
        throw new Un("Unknown curve OID");
      }
    }
    var Ra = /* @__PURE__ */ Object.freeze({ __proto__: null, publicKeyEncrypt: async function(e2, t2, r2, i2, n2) {
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign: {
          const { n: e3, e: t3 } = r2;
          return { c: await xa.rsa.encrypt(i2, e3, t3) };
        }
        case ue.publicKey.elgamal: {
          const { p: e3, g: t3, y: n3 } = r2;
          return xa.elgamal.encrypt(i2, e3, t3, n3);
        }
        case ue.publicKey.ecdh: {
          const { oid: e3, Q: t3, kdfParams: a2 } = r2, { publicKey: s2, wrappedKey: o2 } = await xa.elliptic.ecdh.encrypt(e3, a2, i2, t3, n2);
          return { V: s2, C: new Ka(o2) };
        }
        case ue.publicKey.x25519: {
          if (!de.isAES(t2))
            throw Error("X25519 keys can only encrypt AES session keys");
          const { A: n3 } = r2, { ephemeralPublicKey: a2, wrappedKey: s2 } = await xa.elliptic.ecdhX.encrypt(e2, i2, n3);
          return { ephemeralPublicKey: a2, C: Da.fromObject({ algorithm: t2, wrappedKey: s2 }) };
        }
        default:
          return [];
      }
    }, publicKeyDecrypt: async function(e2, t2, r2, i2, n2, a2) {
      switch (e2) {
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaEncrypt: {
          const { c: e3 } = i2, { n: n3, e: s2 } = t2, { d: o2, p: c2, q: u2, u: h2 } = r2;
          return xa.rsa.decrypt(e3, n3, s2, o2, c2, u2, h2, a2);
        }
        case ue.publicKey.elgamal: {
          const { c1: e3, c2: n3 } = i2, s2 = t2.p, o2 = r2.x;
          return xa.elgamal.decrypt(e3, n3, s2, o2, a2);
        }
        case ue.publicKey.ecdh: {
          const { oid: e3, Q: a3, kdfParams: s2 } = t2, { d: o2 } = r2, { V: c2, C: u2 } = i2;
          return xa.elliptic.ecdh.decrypt(e3, s2, c2, u2.data, a3, o2, n2);
        }
        case ue.publicKey.x25519: {
          const { A: n3 } = t2, { k: a3 } = r2, { ephemeralPublicKey: s2, C: o2 } = i2;
          if (!de.isAES(o2.algorithm))
            throw Error("AES session key expected");
          return xa.elliptic.ecdhX.decrypt(e2, s2, o2.wrappedKey, n3, a3);
        }
        default:
          throw Error("Unknown public key encryption algorithm.");
      }
    }, parsePublicKeyParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaSign: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = de.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, { read: r2, publicParams: { n: e3, e: i2 } };
        }
        case ue.publicKey.dsa: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = de.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = de.readMPI(t2.subarray(r2));
          r2 += n2.length + 2;
          const a2 = de.readMPI(t2.subarray(r2));
          return r2 += a2.length + 2, { read: r2, publicParams: { p: e3, q: i2, g: n2, y: a2 } };
        }
        case ue.publicKey.elgamal: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = de.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = de.readMPI(t2.subarray(r2));
          return r2 += n2.length + 2, { read: r2, publicParams: { p: e3, g: i2, y: n2 } };
        }
        case ue.publicKey.ecdsa: {
          const e3 = new _n();
          r2 += e3.read(t2), Ua(e3);
          const i2 = de.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, { read: r2, publicParams: { oid: e3, Q: i2 } };
        }
        case ue.publicKey.eddsaLegacy: {
          const e3 = new _n();
          r2 += e3.read(t2), Ua(e3);
          let i2 = de.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, i2 = de.leftPad(i2, 33), { read: r2, publicParams: { oid: e3, Q: i2 } };
        }
        case ue.publicKey.ecdh: {
          const e3 = new _n();
          r2 += e3.read(t2), Ua(e3);
          const i2 = de.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = new Ca();
          return r2 += n2.read(t2.subarray(r2)), { read: r2, publicParams: { oid: e3, Q: i2, kdfParams: n2 } };
        }
        case ue.publicKey.ed25519:
        case ue.publicKey.x25519: {
          const e3 = t2.subarray(r2, r2 + 32);
          return r2 += e3.length, { read: r2, publicParams: { A: e3 } };
        }
        default:
          throw new Un("Unknown public key encryption algorithm.");
      }
    }, parsePrivateKeyParams: function(e2, t2, r2) {
      let i2 = 0;
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaSign: {
          const e3 = de.readMPI(t2.subarray(i2));
          i2 += e3.length + 2;
          const r3 = de.readMPI(t2.subarray(i2));
          i2 += r3.length + 2;
          const n2 = de.readMPI(t2.subarray(i2));
          i2 += n2.length + 2;
          const a2 = de.readMPI(t2.subarray(i2));
          return i2 += a2.length + 2, { read: i2, privateParams: { d: e3, p: r3, q: n2, u: a2 } };
        }
        case ue.publicKey.dsa:
        case ue.publicKey.elgamal: {
          const e3 = de.readMPI(t2.subarray(i2));
          return i2 += e3.length + 2, { read: i2, privateParams: { x: e3 } };
        }
        case ue.publicKey.ecdsa:
        case ue.publicKey.ecdh: {
          const e3 = new On(r2.oid);
          let n2 = de.readMPI(t2.subarray(i2));
          return i2 += n2.length + 2, n2 = de.leftPad(n2, e3.payloadSize), { read: i2, privateParams: { d: n2 } };
        }
        case ue.publicKey.eddsaLegacy: {
          const e3 = new On(r2.oid);
          let n2 = de.readMPI(t2.subarray(i2));
          return i2 += n2.length + 2, n2 = de.leftPad(n2, e3.payloadSize), { read: i2, privateParams: { seed: n2 } };
        }
        case ue.publicKey.ed25519: {
          const e3 = t2.subarray(i2, i2 + 32);
          return i2 += e3.length, { read: i2, privateParams: { seed: e3 } };
        }
        case ue.publicKey.x25519: {
          const e3 = t2.subarray(i2, i2 + 32);
          return i2 += e3.length, { read: i2, privateParams: { k: e3 } };
        }
        default:
          throw new Un("Unknown public key encryption algorithm.");
      }
    }, parseEncSessionKeyParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
          return { c: de.readMPI(t2.subarray(r2)) };
        case ue.publicKey.elgamal: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          return { c1: e3, c2: de.readMPI(t2.subarray(r2)) };
        }
        case ue.publicKey.ecdh: {
          const e3 = de.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = new Ka();
          return i2.read(t2.subarray(r2)), { V: e3, C: i2 };
        }
        case ue.publicKey.x25519: {
          const e3 = t2.subarray(r2, r2 + 32);
          r2 += e3.length;
          const i2 = new Da();
          return i2.read(t2.subarray(r2)), { ephemeralPublicKey: e3, C: i2 };
        }
        default:
          throw new Un("Unknown public key encryption algorithm.");
      }
    }, serializeParams: function(e2, t2) {
      const r2 = /* @__PURE__ */ new Set([ue.publicKey.ed25519, ue.publicKey.x25519]), i2 = Object.keys(t2).map((i3) => {
        const n2 = t2[i3];
        return de.isUint8Array(n2) ? r2.has(e2) ? n2 : de.uint8ArrayToMPI(n2) : n2.write();
      });
      return de.concatUint8Array(i2);
    }, generateParams: function(e2, t2, r2) {
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaSign:
          return xa.rsa.generate(t2, 65537).then(({ n: e3, e: t3, d: r3, p: i2, q: n2, u: a2 }) => ({ privateParams: { d: r3, p: i2, q: n2, u: a2 }, publicParams: { n: e3, e: t3 } }));
        case ue.publicKey.ecdsa:
          return xa.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new _n(e3), Q: t3 } }));
        case ue.publicKey.eddsaLegacy:
          return xa.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { seed: r3 }, publicParams: { oid: new _n(e3), Q: t3 } }));
        case ue.publicKey.ecdh:
          return xa.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3, hash: i2, cipher: n2 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new _n(e3), Q: t3, kdfParams: new Ca({ hash: i2, cipher: n2 }) } }));
        case ue.publicKey.ed25519:
          return xa.elliptic.eddsa.generate(e2).then(({ A: e3, seed: t3 }) => ({ privateParams: { seed: t3 }, publicParams: { A: e3 } }));
        case ue.publicKey.x25519:
          return xa.elliptic.ecdhX.generate(e2).then(({ A: e3, k: t3 }) => ({ privateParams: { k: t3 }, publicParams: { A: e3 } }));
        case ue.publicKey.dsa:
        case ue.publicKey.elgamal:
          throw Error("Unsupported algorithm for key generation.");
        default:
          throw Error("Unknown public key algorithm.");
      }
    }, validateParams: async function(e2, t2, r2) {
      if (!t2 || !r2)
        throw Error("Missing key parameters");
      switch (e2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaSign: {
          const { n: e3, e: i2 } = t2, { d: n2, p: a2, q: s2, u: o2 } = r2;
          return xa.rsa.validateParams(e3, i2, n2, a2, s2, o2);
        }
        case ue.publicKey.dsa: {
          const { p: e3, q: i2, g: n2, y: a2 } = t2, { x: s2 } = r2;
          return xa.dsa.validateParams(e3, i2, n2, a2, s2);
        }
        case ue.publicKey.elgamal: {
          const { p: e3, g: i2, y: n2 } = t2, { x: a2 } = r2;
          return xa.elgamal.validateParams(e3, i2, n2, a2);
        }
        case ue.publicKey.ecdsa:
        case ue.publicKey.ecdh: {
          const i2 = xa.elliptic[ue.read(ue.publicKey, e2)], { oid: n2, Q: a2 } = t2, { d: s2 } = r2;
          return i2.validateParams(n2, a2, s2);
        }
        case ue.publicKey.eddsaLegacy: {
          const { Q: e3, oid: i2 } = t2, { seed: n2 } = r2;
          return xa.elliptic.eddsaLegacy.validateParams(i2, e3, n2);
        }
        case ue.publicKey.ed25519: {
          const { A: i2 } = t2, { seed: n2 } = r2;
          return xa.elliptic.eddsa.validateParams(e2, i2, n2);
        }
        case ue.publicKey.x25519: {
          const { A: i2 } = t2, { k: n2 } = r2;
          return xa.elliptic.ecdhX.validateParams(e2, i2, n2);
        }
        default:
          throw Error("Unknown public key algorithm.");
      }
    }, getPrefixRandom: async function(e2) {
      const { blockSize: t2 } = hi(e2), r2 = await rn(t2), i2 = new Uint8Array([r2[r2.length - 2], r2[r2.length - 1]]);
      return de.concat([r2, i2]);
    }, generateSessionKey: function(e2) {
      const { keySize: t2 } = hi(e2);
      return rn(t2);
    }, getAEADMode: function(e2) {
      const t2 = ue.read(ue.aead, e2);
      return Ji[t2];
    }, getCipher: hi, getPreferredCurveHashAlgo: function(e2, t2) {
      switch (e2) {
        case ue.publicKey.ecdsa:
        case ue.publicKey.eddsaLegacy:
          return xa.elliptic.getPreferredHashAlgo(t2);
        case ue.publicKey.ed25519:
          return xa.elliptic.eddsa.getPreferredHashAlgo(e2);
        default:
          throw Error("Unknown elliptic signing algo");
      }
    } });
    var Ia = { cipher: st, hash: ci, mode: Ji, publicKey: xa, signature: Ma, random: an, pkcs1: ln, pkcs5: da, aesKW: ca };
    Object.assign(Ia, Ra);
    var Ba = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function Ta(e2, t2) {
      return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
    }
    var za = { arraySet: function(e2, t2, r2, i2, n2) {
      if (t2.subarray && e2.subarray)
        e2.set(t2.subarray(r2, r2 + i2), n2);
      else
        for (let a2 = 0; a2 < i2; a2++)
          e2[n2 + a2] = t2[r2 + a2];
    }, flattenChunks: function(e2) {
      let t2, r2, i2, n2, a2;
      for (i2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++)
        i2 += e2[t2].length;
      const s2 = new Uint8Array(i2);
      for (n2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++)
        a2 = e2[t2], s2.set(a2, n2), n2 += a2.length;
      return s2;
    } };
    var qa = { arraySet: function(e2, t2, r2, i2, n2) {
      for (let a2 = 0; a2 < i2; a2++)
        e2[n2 + a2] = t2[r2 + a2];
    }, flattenChunks: function(e2) {
      return [].concat.apply([], e2);
    } };
    var Fa = Ba ? Uint8Array : Array;
    var Oa = Ba ? Uint16Array : Array;
    var La = Ba ? Int32Array : Array;
    var Na = Ba ? za.flattenChunks : qa.flattenChunks;
    var ja = Ba ? za.arraySet : qa.arraySet;
    var Ha = 0;
    var Wa = 1;
    var Ga = 2;
    var Va = 3;
    var $a = 4;
    var Za = 5;
    var Xa = 6;
    var Ya = 0;
    var Qa = 1;
    var Ja = 2;
    var es = -2;
    var ts = -3;
    var rs = -5;
    var is = -1;
    var ns = 1;
    var as = 2;
    var ss = 3;
    var os2 = 4;
    var cs = 0;
    var us = 1;
    var hs = 2;
    var ds = 8;
    function fs(e2) {
      let t2 = e2.length;
      for (; --t2 >= 0; )
        e2[t2] = 0;
    }
    var ls = 0;
    var ps = 1;
    var ys = 2;
    var bs = 29;
    var gs = 256;
    var ms = gs + 1 + bs;
    var ws = 30;
    var vs = 19;
    var _s = 2 * ms + 1;
    var ks = 15;
    var As = 16;
    var Ss = 7;
    var Es = 256;
    var Ps = 16;
    var xs = 17;
    var Ms = 18;
    var Ks = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var Cs = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var Ds = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var Us = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var Rs = Array(2 * (ms + 2));
    fs(Rs);
    var Is = Array(2 * ws);
    fs(Is);
    var Bs = Array(512);
    fs(Bs);
    var Ts = Array(256);
    fs(Ts);
    var zs = Array(bs);
    fs(zs);
    var qs = Array(ws);
    function Fs(e2, t2, r2, i2, n2) {
      this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = e2 && e2.length;
    }
    var Os;
    var Ls;
    var Ns;
    function js(e2, t2) {
      this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
    }
    function Hs(e2) {
      return e2 < 256 ? Bs[e2] : Bs[256 + (e2 >>> 7)];
    }
    function Ws(e2, t2) {
      e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
    }
    function Gs(e2, t2, r2) {
      e2.bi_valid > As - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, Ws(e2, e2.bi_buf), e2.bi_buf = t2 >> As - e2.bi_valid, e2.bi_valid += r2 - As) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
    }
    function Vs(e2, t2, r2) {
      Gs(e2, r2[2 * t2], r2[2 * t2 + 1]);
    }
    function $s(e2, t2) {
      let r2 = 0;
      do {
        r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1;
      } while (--t2 > 0);
      return r2 >>> 1;
    }
    function Zs(e2, t2, r2) {
      const i2 = Array(ks + 1);
      let n2, a2, s2 = 0;
      for (n2 = 1; n2 <= ks; n2++)
        i2[n2] = s2 = s2 + r2[n2 - 1] << 1;
      for (a2 = 0; a2 <= t2; a2++) {
        const t3 = e2[2 * a2 + 1];
        0 !== t3 && (e2[2 * a2] = $s(i2[t3]++, t3));
      }
    }
    function Xs(e2) {
      let t2;
      for (t2 = 0; t2 < ms; t2++)
        e2.dyn_ltree[2 * t2] = 0;
      for (t2 = 0; t2 < ws; t2++)
        e2.dyn_dtree[2 * t2] = 0;
      for (t2 = 0; t2 < vs; t2++)
        e2.bl_tree[2 * t2] = 0;
      e2.dyn_ltree[2 * Es] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
    }
    function Ys(e2) {
      e2.bi_valid > 8 ? Ws(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
    }
    function Qs(e2, t2, r2, i2) {
      const n2 = 2 * t2, a2 = 2 * r2;
      return e2[n2] < e2[a2] || e2[n2] === e2[a2] && i2[t2] <= i2[r2];
    }
    function Js(e2, t2, r2) {
      const i2 = e2.heap[r2];
      let n2 = r2 << 1;
      for (; n2 <= e2.heap_len && (n2 < e2.heap_len && Qs(t2, e2.heap[n2 + 1], e2.heap[n2], e2.depth) && n2++, !Qs(t2, i2, e2.heap[n2], e2.depth)); )
        e2.heap[r2] = e2.heap[n2], r2 = n2, n2 <<= 1;
      e2.heap[r2] = i2;
    }
    function eo(e2, t2, r2) {
      let i2, n2, a2, s2, o2 = 0;
      if (0 !== e2.last_lit)
        do {
          i2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], n2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === i2 ? Vs(e2, n2, t2) : (a2 = Ts[n2], Vs(e2, a2 + gs + 1, t2), s2 = Ks[a2], 0 !== s2 && (n2 -= zs[a2], Gs(e2, n2, s2)), i2--, a2 = Hs(i2), Vs(e2, a2, r2), s2 = Cs[a2], 0 !== s2 && (i2 -= qs[a2], Gs(e2, i2, s2)));
        } while (o2 < e2.last_lit);
      Vs(e2, Es, t2);
    }
    function to(e2, t2) {
      const r2 = t2.dyn_tree, i2 = t2.stat_desc.static_tree, n2 = t2.stat_desc.has_stree, a2 = t2.stat_desc.elems;
      let s2, o2, c2, u2 = -1;
      for (e2.heap_len = 0, e2.heap_max = _s, s2 = 0; s2 < a2; s2++)
        0 !== r2[2 * s2] ? (e2.heap[++e2.heap_len] = u2 = s2, e2.depth[s2] = 0) : r2[2 * s2 + 1] = 0;
      for (; e2.heap_len < 2; )
        c2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0, r2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, n2 && (e2.static_len -= i2[2 * c2 + 1]);
      for (t2.max_code = u2, s2 = e2.heap_len >> 1; s2 >= 1; s2--)
        Js(e2, r2, s2);
      c2 = a2;
      do {
        s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], Js(e2, r2, 1), o2 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = o2, r2[2 * c2] = r2[2 * s2] + r2[2 * o2], e2.depth[c2] = (e2.depth[s2] >= e2.depth[o2] ? e2.depth[s2] : e2.depth[o2]) + 1, r2[2 * s2 + 1] = r2[2 * o2 + 1] = c2, e2.heap[1] = c2++, Js(e2, r2, 1);
      } while (e2.heap_len >= 2);
      e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
        const r3 = t3.dyn_tree, i3 = t3.max_code, n3 = t3.stat_desc.static_tree, a3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, o3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
        let u3, h2, d2, f2, l2, p2, y2 = 0;
        for (f2 = 0; f2 <= ks; f2++)
          e3.bl_count[f2] = 0;
        for (r3[2 * e3.heap[e3.heap_max] + 1] = 0, u3 = e3.heap_max + 1; u3 < _s; u3++)
          h2 = e3.heap[u3], f2 = r3[2 * r3[2 * h2 + 1] + 1] + 1, f2 > c3 && (f2 = c3, y2++), r3[2 * h2 + 1] = f2, h2 > i3 || (e3.bl_count[f2]++, l2 = 0, h2 >= o3 && (l2 = s3[h2 - o3]), p2 = r3[2 * h2], e3.opt_len += p2 * (f2 + l2), a3 && (e3.static_len += p2 * (n3[2 * h2 + 1] + l2)));
        if (0 !== y2) {
          do {
            for (f2 = c3 - 1; 0 === e3.bl_count[f2]; )
              f2--;
            e3.bl_count[f2]--, e3.bl_count[f2 + 1] += 2, e3.bl_count[c3]--, y2 -= 2;
          } while (y2 > 0);
          for (f2 = c3; 0 !== f2; f2--)
            for (h2 = e3.bl_count[f2]; 0 !== h2; )
              d2 = e3.heap[--u3], d2 > i3 || (r3[2 * d2 + 1] !== f2 && (e3.opt_len += (f2 - r3[2 * d2 + 1]) * r3[2 * d2], r3[2 * d2 + 1] = f2), h2--);
        }
      }(e2, t2), Zs(r2, u2, e2.bl_count);
    }
    function ro(e2, t2, r2) {
      let i2, n2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, u2 = 4;
      for (0 === s2 && (c2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++)
        n2 = s2, s2 = t2[2 * (i2 + 1) + 1], ++o2 < c2 && n2 === s2 || (o2 < u2 ? e2.bl_tree[2 * n2] += o2 : 0 !== n2 ? (n2 !== a2 && e2.bl_tree[2 * n2]++, e2.bl_tree[2 * Ps]++) : o2 <= 10 ? e2.bl_tree[2 * xs]++ : e2.bl_tree[2 * Ms]++, o2 = 0, a2 = n2, 0 === s2 ? (c2 = 138, u2 = 3) : n2 === s2 ? (c2 = 6, u2 = 3) : (c2 = 7, u2 = 4));
    }
    function io(e2, t2, r2) {
      let i2, n2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, u2 = 4;
      for (0 === s2 && (c2 = 138, u2 = 3), i2 = 0; i2 <= r2; i2++)
        if (n2 = s2, s2 = t2[2 * (i2 + 1) + 1], !(++o2 < c2 && n2 === s2)) {
          if (o2 < u2)
            do {
              Vs(e2, n2, e2.bl_tree);
            } while (0 != --o2);
          else
            0 !== n2 ? (n2 !== a2 && (Vs(e2, n2, e2.bl_tree), o2--), Vs(e2, Ps, e2.bl_tree), Gs(e2, o2 - 3, 2)) : o2 <= 10 ? (Vs(e2, xs, e2.bl_tree), Gs(e2, o2 - 3, 3)) : (Vs(e2, Ms, e2.bl_tree), Gs(e2, o2 - 11, 7));
          o2 = 0, a2 = n2, 0 === s2 ? (c2 = 138, u2 = 3) : n2 === s2 ? (c2 = 6, u2 = 3) : (c2 = 7, u2 = 4);
        }
    }
    fs(qs);
    var no = false;
    function ao(e2) {
      no || (!function() {
        let e3, t2, r2, i2, n2;
        const a2 = Array(ks + 1);
        for (r2 = 0, i2 = 0; i2 < bs - 1; i2++)
          for (zs[i2] = r2, e3 = 0; e3 < 1 << Ks[i2]; e3++)
            Ts[r2++] = i2;
        for (Ts[r2 - 1] = i2, n2 = 0, i2 = 0; i2 < 16; i2++)
          for (qs[i2] = n2, e3 = 0; e3 < 1 << Cs[i2]; e3++)
            Bs[n2++] = i2;
        for (n2 >>= 7; i2 < ws; i2++)
          for (qs[i2] = n2 << 7, e3 = 0; e3 < 1 << Cs[i2] - 7; e3++)
            Bs[256 + n2++] = i2;
        for (t2 = 0; t2 <= ks; t2++)
          a2[t2] = 0;
        for (e3 = 0; e3 <= 143; )
          Rs[2 * e3 + 1] = 8, e3++, a2[8]++;
        for (; e3 <= 255; )
          Rs[2 * e3 + 1] = 9, e3++, a2[9]++;
        for (; e3 <= 279; )
          Rs[2 * e3 + 1] = 7, e3++, a2[7]++;
        for (; e3 <= 287; )
          Rs[2 * e3 + 1] = 8, e3++, a2[8]++;
        for (Zs(Rs, ms + 1, a2), e3 = 0; e3 < ws; e3++)
          Is[2 * e3 + 1] = 5, Is[2 * e3] = $s(e3, 5);
        Os = new Fs(Rs, Ks, gs + 1, ms, ks), Ls = new Fs(Is, Cs, 0, ws, ks), Ns = new Fs([], Ds, 0, vs, Ss);
      }(), no = true), e2.l_desc = new js(e2.dyn_ltree, Os), e2.d_desc = new js(e2.dyn_dtree, Ls), e2.bl_desc = new js(e2.bl_tree, Ns), e2.bi_buf = 0, e2.bi_valid = 0, Xs(e2);
    }
    function so(e2, t2, r2, i2) {
      Gs(e2, (ls << 1) + (i2 ? 1 : 0), 3), function(e3, t3, r3, i3) {
        Ys(e3), i3 && (Ws(e3, r3), Ws(e3, ~r3)), ja(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
      }(e2, t2, r2, true);
    }
    function oo(e2) {
      Gs(e2, ps << 1, 3), Vs(e2, Es, Rs), function(e3) {
        16 === e3.bi_valid ? (Ws(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
      }(e2);
    }
    function co(e2, t2, r2, i2) {
      let n2, a2, s2 = 0;
      e2.level > 0 ? (e2.strm.data_type === hs && (e2.strm.data_type = function(e3) {
        let t3, r3 = 4093624447;
        for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
          if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
            return cs;
        if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
          return us;
        for (t3 = 32; t3 < gs; t3++)
          if (0 !== e3.dyn_ltree[2 * t3])
            return us;
        return cs;
      }(e2)), to(e2, e2.l_desc), to(e2, e2.d_desc), s2 = function(e3) {
        let t3;
        for (ro(e3, e3.dyn_ltree, e3.l_desc.max_code), ro(e3, e3.dyn_dtree, e3.d_desc.max_code), to(e3, e3.bl_desc), t3 = vs - 1; t3 >= 3 && 0 === e3.bl_tree[2 * Us[t3] + 1]; t3--)
          ;
        return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
      }(e2), n2 = e2.opt_len + 3 + 7 >>> 3, a2 = e2.static_len + 3 + 7 >>> 3, a2 <= n2 && (n2 = a2)) : n2 = a2 = r2 + 5, r2 + 4 <= n2 && -1 !== t2 ? so(e2, t2, r2, i2) : e2.strategy === os2 || a2 === n2 ? (Gs(e2, (ps << 1) + (i2 ? 1 : 0), 3), eo(e2, Rs, Is)) : (Gs(e2, (ys << 1) + (i2 ? 1 : 0), 3), function(e3, t3, r3, i3) {
        let n3;
        for (Gs(e3, t3 - 257, 5), Gs(e3, r3 - 1, 5), Gs(e3, i3 - 4, 4), n3 = 0; n3 < i3; n3++)
          Gs(e3, e3.bl_tree[2 * Us[n3] + 1], 3);
        io(e3, e3.dyn_ltree, t3 - 1), io(e3, e3.dyn_dtree, r3 - 1);
      }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), eo(e2, e2.dyn_ltree, e2.dyn_dtree)), Xs(e2), i2 && Ys(e2);
    }
    function uo(e2, t2, r2) {
      return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (Ts[r2] + gs + 1)]++, e2.dyn_dtree[2 * Hs(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
    }
    function ho(e2, t2, r2, i2) {
      let n2 = 65535 & e2 | 0, a2 = e2 >>> 16 & 65535 | 0, s2 = 0;
      for (; 0 !== r2; ) {
        s2 = r2 > 2e3 ? 2e3 : r2, r2 -= s2;
        do {
          n2 = n2 + t2[i2++] | 0, a2 = a2 + n2 | 0;
        } while (--s2);
        n2 %= 65521, a2 %= 65521;
      }
      return n2 | a2 << 16 | 0;
    }
    var fo = function() {
      let e2;
      const t2 = [];
      for (let r2 = 0; r2 < 256; r2++) {
        e2 = r2;
        for (let t3 = 0; t3 < 8; t3++)
          e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
        t2[r2] = e2;
      }
      return t2;
    }();
    function lo(e2, t2, r2, i2) {
      const n2 = fo, a2 = i2 + r2;
      e2 ^= -1;
      for (let r3 = i2; r3 < a2; r3++)
        e2 = e2 >>> 8 ^ n2[255 & (e2 ^ t2[r3])];
      return -1 ^ e2;
    }
    var po = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    var yo = 9;
    var bo = 3;
    var go = 258;
    var mo = go + bo + 1;
    var wo = 32;
    var vo = 42;
    var _o = 69;
    var ko = 73;
    var Ao = 91;
    var So = 103;
    var Eo = 113;
    var Po = 666;
    var xo = 1;
    var Mo = 2;
    var Ko = 3;
    var Co = 4;
    var Do = 3;
    function Uo(e2, t2) {
      return e2.msg = po[t2], t2;
    }
    function Ro(e2) {
      return (e2 << 1) - (e2 > 4 ? 9 : 0);
    }
    function Io(e2) {
      let t2 = e2.length;
      for (; --t2 >= 0; )
        e2[t2] = 0;
    }
    function Bo(e2) {
      const t2 = e2.state;
      let r2 = t2.pending;
      r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (ja(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
    }
    function To(e2, t2) {
      co(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, Bo(e2.strm);
    }
    function zo(e2, t2) {
      e2.pending_buf[e2.pending++] = t2;
    }
    function qo(e2, t2) {
      e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
    }
    function Fo(e2, t2, r2, i2) {
      let n2 = e2.avail_in;
      return n2 > i2 && (n2 = i2), 0 === n2 ? 0 : (e2.avail_in -= n2, ja(t2, e2.input, e2.next_in, n2, r2), 1 === e2.state.wrap ? e2.adler = ho(e2.adler, t2, n2, r2) : 2 === e2.state.wrap && (e2.adler = lo(e2.adler, t2, n2, r2)), e2.next_in += n2, e2.total_in += n2, n2);
    }
    function Oo(e2, t2) {
      let r2, i2, n2 = e2.max_chain_length, a2 = e2.strstart, s2 = e2.prev_length, o2 = e2.nice_match;
      const c2 = e2.strstart > e2.w_size - mo ? e2.strstart - (e2.w_size - mo) : 0, u2 = e2.window, h2 = e2.w_mask, d2 = e2.prev, f2 = e2.strstart + go;
      let l2 = u2[a2 + s2 - 1], p2 = u2[a2 + s2];
      e2.prev_length >= e2.good_match && (n2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
      do {
        if (r2 = t2, u2[r2 + s2] === p2 && u2[r2 + s2 - 1] === l2 && u2[r2] === u2[a2] && u2[++r2] === u2[a2 + 1]) {
          a2 += 2, r2++;
          do {
          } while (u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && a2 < f2);
          if (i2 = go - (f2 - a2), a2 = f2 - go, i2 > s2) {
            if (e2.match_start = t2, s2 = i2, i2 >= o2)
              break;
            l2 = u2[a2 + s2 - 1], p2 = u2[a2 + s2];
          }
        }
      } while ((t2 = d2[t2 & h2]) > c2 && 0 != --n2);
      return s2 <= e2.lookahead ? s2 : e2.lookahead;
    }
    function Lo(e2) {
      const t2 = e2.w_size;
      let r2, i2, n2, a2, s2;
      do {
        if (a2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - mo)) {
          ja(e2.window, e2.window, t2, t2, 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, i2 = e2.hash_size, r2 = i2;
          do {
            n2 = e2.head[--r2], e2.head[r2] = n2 >= t2 ? n2 - t2 : 0;
          } while (--i2);
          i2 = t2, r2 = i2;
          do {
            n2 = e2.prev[--r2], e2.prev[r2] = n2 >= t2 ? n2 - t2 : 0;
          } while (--i2);
          a2 += t2;
        }
        if (0 === e2.strm.avail_in)
          break;
        if (i2 = Fo(e2.strm, e2.window, e2.strstart + e2.lookahead, a2), e2.lookahead += i2, e2.lookahead + e2.insert >= bo)
          for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + bo - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < bo)); )
            ;
      } while (e2.lookahead < mo && 0 !== e2.strm.avail_in);
    }
    function No(e2, t2) {
      let r2, i2;
      for (; ; ) {
        if (e2.lookahead < mo) {
          if (Lo(e2), e2.lookahead < mo && t2 === Ha)
            return xo;
          if (0 === e2.lookahead)
            break;
        }
        if (r2 = 0, e2.lookahead >= bo && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + bo - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - mo && (e2.match_length = Oo(e2, r2)), e2.match_length >= bo)
          if (i2 = uo(e2, e2.strstart - e2.match_start, e2.match_length - bo), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= bo) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + bo - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (0 != --e2.match_length);
            e2.strstart++;
          } else
            e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
        else
          i2 = uo(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
        if (i2 && (To(e2, false), 0 === e2.strm.avail_out))
          return xo;
      }
      return e2.insert = e2.strstart < bo - 1 ? e2.strstart : bo - 1, t2 === $a ? (To(e2, true), 0 === e2.strm.avail_out ? Ko : Co) : e2.last_lit && (To(e2, false), 0 === e2.strm.avail_out) ? xo : Mo;
    }
    function jo(e2, t2) {
      let r2, i2, n2;
      for (; ; ) {
        if (e2.lookahead < mo) {
          if (Lo(e2), e2.lookahead < mo && t2 === Ha)
            return xo;
          if (0 === e2.lookahead)
            break;
        }
        if (r2 = 0, e2.lookahead >= bo && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + bo - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = bo - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - mo && (e2.match_length = Oo(e2, r2), e2.match_length <= 5 && (e2.strategy === ns || e2.match_length === bo && e2.strstart - e2.match_start > 4096) && (e2.match_length = bo - 1)), e2.prev_length >= bo && e2.match_length <= e2.prev_length) {
          n2 = e2.strstart + e2.lookahead - bo, i2 = uo(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - bo), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
          do {
            ++e2.strstart <= n2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + bo - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
          } while (0 != --e2.prev_length);
          if (e2.match_available = 0, e2.match_length = bo - 1, e2.strstart++, i2 && (To(e2, false), 0 === e2.strm.avail_out))
            return xo;
        } else if (e2.match_available) {
          if (i2 = uo(e2, 0, e2.window[e2.strstart - 1]), i2 && To(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
            return xo;
        } else
          e2.match_available = 1, e2.strstart++, e2.lookahead--;
      }
      return e2.match_available && (i2 = uo(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < bo - 1 ? e2.strstart : bo - 1, t2 === $a ? (To(e2, true), 0 === e2.strm.avail_out ? Ko : Co) : e2.last_lit && (To(e2, false), 0 === e2.strm.avail_out) ? xo : Mo;
    }
    var Ho = class {
      constructor(e2, t2, r2, i2, n2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
      }
    };
    var Wo = [new Ho(0, 0, 0, 0, function(e2, t2) {
      let r2 = 65535;
      for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
        if (e2.lookahead <= 1) {
          if (Lo(e2), 0 === e2.lookahead && t2 === Ha)
            return xo;
          if (0 === e2.lookahead)
            break;
        }
        e2.strstart += e2.lookahead, e2.lookahead = 0;
        const i2 = e2.block_start + r2;
        if ((0 === e2.strstart || e2.strstart >= i2) && (e2.lookahead = e2.strstart - i2, e2.strstart = i2, To(e2, false), 0 === e2.strm.avail_out))
          return xo;
        if (e2.strstart - e2.block_start >= e2.w_size - mo && (To(e2, false), 0 === e2.strm.avail_out))
          return xo;
      }
      return e2.insert = 0, t2 === $a ? (To(e2, true), 0 === e2.strm.avail_out ? Ko : Co) : (e2.strstart > e2.block_start && (To(e2, false), e2.strm.avail_out), xo);
    }), new Ho(4, 4, 8, 4, No), new Ho(4, 5, 16, 8, No), new Ho(4, 6, 32, 32, No), new Ho(4, 4, 16, 16, jo), new Ho(8, 16, 32, 32, jo), new Ho(8, 16, 128, 128, jo), new Ho(8, 32, 128, 256, jo), new Ho(32, 128, 258, 1024, jo), new Ho(32, 258, 258, 4096, jo)];
    var Go = class {
      constructor() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = ds, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Oa(1146), this.dyn_dtree = new Oa(122), this.bl_tree = new Oa(78), Io(this.dyn_ltree), Io(this.dyn_dtree), Io(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Oa(16), this.heap = new Oa(573), Io(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Oa(573), Io(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
    };
    function Vo(e2) {
      const t2 = function(e3) {
        let t3;
        return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = hs, t3 = e3.state, t3.pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? vo : Eo, e3.adler = 2 === t3.wrap ? 0 : 1, t3.last_flush = Ha, ao(t3), Ya) : Uo(e3, es);
      }(e2);
      return t2 === Ya && function(e3) {
        e3.window_size = 2 * e3.w_size, Io(e3.head), e3.max_lazy_match = Wo[e3.level].max_lazy, e3.good_match = Wo[e3.level].good_length, e3.nice_match = Wo[e3.level].nice_length, e3.max_chain_length = Wo[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = bo - 1, e3.match_available = 0, e3.ins_h = 0;
      }(e2.state), t2;
    }
    function $o(e2, t2) {
      let r2, i2, n2, a2;
      if (!e2 || !e2.state || t2 > Za || t2 < 0)
        return e2 ? Uo(e2, es) : es;
      if (i2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || i2.status === Po && t2 !== $a)
        return Uo(e2, 0 === e2.avail_out ? rs : es);
      if (i2.strm = e2, r2 = i2.last_flush, i2.last_flush = t2, i2.status === vo)
        if (2 === i2.wrap)
          e2.adler = 0, zo(i2, 31), zo(i2, 139), zo(i2, 8), i2.gzhead ? (zo(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), zo(i2, 255 & i2.gzhead.time), zo(i2, i2.gzhead.time >> 8 & 255), zo(i2, i2.gzhead.time >> 16 & 255), zo(i2, i2.gzhead.time >> 24 & 255), zo(i2, 9 === i2.level ? 2 : i2.strategy >= as || i2.level < 2 ? 4 : 0), zo(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (zo(i2, 255 & i2.gzhead.extra.length), zo(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = _o) : (zo(i2, 0), zo(i2, 0), zo(i2, 0), zo(i2, 0), zo(i2, 0), zo(i2, 9 === i2.level ? 2 : i2.strategy >= as || i2.level < 2 ? 4 : 0), zo(i2, Do), i2.status = Eo);
        else {
          let t3 = ds + (i2.w_bits - 8 << 4) << 8, r3 = -1;
          r3 = i2.strategy >= as || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3, t3 |= r3 << 6, 0 !== i2.strstart && (t3 |= wo), t3 += 31 - t3 % 31, i2.status = Eo, qo(i2, t3), 0 !== i2.strstart && (qo(i2, e2.adler >>> 16), qo(i2, 65535 & e2.adler)), e2.adler = 1;
        }
      if (i2.status === _o)
        if (i2.gzhead.extra) {
          for (n2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Bo(e2), n2 = i2.pending, i2.pending !== i2.pending_buf_size)); )
            zo(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = ko);
        } else
          i2.status = ko;
      if (i2.status === ko)
        if (i2.gzhead.name) {
          n2 = i2.pending;
          do {
            if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Bo(e2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
              a2 = 1;
              break;
            }
            a2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, zo(i2, a2);
          } while (0 !== a2);
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === a2 && (i2.gzindex = 0, i2.status = Ao);
        } else
          i2.status = Ao;
      if (i2.status === Ao)
        if (i2.gzhead.comment) {
          n2 = i2.pending;
          do {
            if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Bo(e2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
              a2 = 1;
              break;
            }
            a2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, zo(i2, a2);
          } while (0 !== a2);
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = lo(e2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === a2 && (i2.status = So);
        } else
          i2.status = So;
      if (i2.status === So && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && Bo(e2), i2.pending + 2 <= i2.pending_buf_size && (zo(i2, 255 & e2.adler), zo(i2, e2.adler >> 8 & 255), e2.adler = 0, i2.status = Eo)) : i2.status = Eo), 0 !== i2.pending) {
        if (Bo(e2), 0 === e2.avail_out)
          return i2.last_flush = -1, Ya;
      } else if (0 === e2.avail_in && Ro(t2) <= Ro(r2) && t2 !== $a)
        return Uo(e2, rs);
      if (i2.status === Po && 0 !== e2.avail_in)
        return Uo(e2, rs);
      if (0 !== e2.avail_in || 0 !== i2.lookahead || t2 !== Ha && i2.status !== Po) {
        var s2 = i2.strategy === as ? function(e3, t3) {
          let r3;
          for (; ; ) {
            if (0 === e3.lookahead && (Lo(e3), 0 === e3.lookahead)) {
              if (t3 === Ha)
                return xo;
              break;
            }
            if (e3.match_length = 0, r3 = uo(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (To(e3, false), 0 === e3.strm.avail_out))
              return xo;
          }
          return e3.insert = 0, t3 === $a ? (To(e3, true), 0 === e3.strm.avail_out ? Ko : Co) : e3.last_lit && (To(e3, false), 0 === e3.strm.avail_out) ? xo : Mo;
        }(i2, t2) : i2.strategy === ss ? function(e3, t3) {
          let r3, i3, n3, a3;
          const s3 = e3.window;
          for (; ; ) {
            if (e3.lookahead <= go) {
              if (Lo(e3), e3.lookahead <= go && t3 === Ha)
                return xo;
              if (0 === e3.lookahead)
                break;
            }
            if (e3.match_length = 0, e3.lookahead >= bo && e3.strstart > 0 && (n3 = e3.strstart - 1, i3 = s3[n3], i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3])) {
              a3 = e3.strstart + go;
              do {
              } while (i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && n3 < a3);
              e3.match_length = go - (a3 - n3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
            }
            if (e3.match_length >= bo ? (r3 = uo(e3, 1, e3.match_length - bo), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = uo(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (To(e3, false), 0 === e3.strm.avail_out))
              return xo;
          }
          return e3.insert = 0, t3 === $a ? (To(e3, true), 0 === e3.strm.avail_out ? Ko : Co) : e3.last_lit && (To(e3, false), 0 === e3.strm.avail_out) ? xo : Mo;
        }(i2, t2) : Wo[i2.level].func(i2, t2);
        if (s2 !== Ko && s2 !== Co || (i2.status = Po), s2 === xo || s2 === Ko)
          return 0 === e2.avail_out && (i2.last_flush = -1), Ya;
        if (s2 === Mo && (t2 === Wa ? oo(i2) : t2 !== Za && (so(i2, 0, 0, false), t2 === Va && (Io(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), Bo(e2), 0 === e2.avail_out))
          return i2.last_flush = -1, Ya;
      }
      return t2 !== $a ? Ya : i2.wrap <= 0 ? Qa : (2 === i2.wrap ? (zo(i2, 255 & e2.adler), zo(i2, e2.adler >> 8 & 255), zo(i2, e2.adler >> 16 & 255), zo(i2, e2.adler >> 24 & 255), zo(i2, 255 & e2.total_in), zo(i2, e2.total_in >> 8 & 255), zo(i2, e2.total_in >> 16 & 255), zo(i2, e2.total_in >> 24 & 255)) : (qo(i2, e2.adler >>> 16), qo(i2, 65535 & e2.adler)), Bo(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? Ya : Qa);
    }
    try {
      String.fromCharCode.call(null, 0);
    } catch (e2) {
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e2) {
    }
    var Zo = new Fa(256);
    for (let e2 = 0; e2 < 256; e2++)
      Zo[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
    function Xo(e2) {
      let t2, r2, i2, n2, a2 = 0;
      const s2 = e2.length;
      for (i2 = 0; i2 < s2; i2++)
        t2 = e2.charCodeAt(i2), 55296 == (64512 & t2) && i2 + 1 < s2 && (r2 = e2.charCodeAt(i2 + 1), 56320 == (64512 & r2) && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), i2++)), a2 += t2 < 128 ? 1 : t2 < 2048 ? 2 : t2 < 65536 ? 3 : 4;
      const o2 = new Fa(a2);
      for (n2 = 0, i2 = 0; n2 < a2; i2++)
        t2 = e2.charCodeAt(i2), 55296 == (64512 & t2) && i2 + 1 < s2 && (r2 = e2.charCodeAt(i2 + 1), 56320 == (64512 & r2) && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), i2++)), t2 < 128 ? o2[n2++] = t2 : t2 < 2048 ? (o2[n2++] = 192 | t2 >>> 6, o2[n2++] = 128 | 63 & t2) : t2 < 65536 ? (o2[n2++] = 224 | t2 >>> 12, o2[n2++] = 128 | t2 >>> 6 & 63, o2[n2++] = 128 | 63 & t2) : (o2[n2++] = 240 | t2 >>> 18, o2[n2++] = 128 | t2 >>> 12 & 63, o2[n2++] = 128 | t2 >>> 6 & 63, o2[n2++] = 128 | 63 & t2);
      return o2;
    }
    Zo[254] = Zo[254] = 1;
    var Yo = class {
      constructor() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
    };
    var Qo = class {
      constructor(e2) {
        this.options = { level: is, method: ds, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, ...e2 || {} };
        const t2 = this.options;
        t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Yo(), this.strm.avail_out = 0;
        var r2, i2, n2 = function(e3, t3, r3, i3, n3, a2) {
          if (!e3)
            return es;
          let s2 = 1;
          if (t3 === is && (t3 = 6), i3 < 0 ? (s2 = 0, i3 = -i3) : i3 > 15 && (s2 = 2, i3 -= 16), n3 < 1 || n3 > yo || r3 !== ds || i3 < 8 || i3 > 15 || t3 < 0 || t3 > 9 || a2 < 0 || a2 > os2)
            return Uo(e3, es);
          8 === i3 && (i3 = 9);
          const o2 = new Go();
          return e3.state = o2, o2.strm = e3, o2.wrap = s2, o2.gzhead = null, o2.w_bits = i3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n3 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + bo - 1) / bo), o2.window = new Fa(2 * o2.w_size), o2.head = new Oa(o2.hash_size), o2.prev = new Oa(o2.w_size), o2.lit_bufsize = 1 << n3 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new Fa(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = a2, o2.method = r3, Vo(e3);
        }(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (n2 !== Ya)
          throw Error(po[n2]);
        if (t2.header && (r2 = this.strm, i2 = t2.header, r2 && r2.state && (2 !== r2.state.wrap || (r2.state.gzhead = i2))), t2.dictionary) {
          let e3;
          if (e3 = "string" == typeof t2.dictionary ? Xo(t2.dictionary) : t2.dictionary instanceof ArrayBuffer ? new Uint8Array(t2.dictionary) : t2.dictionary, n2 = function(e4, t3) {
            let r3, i3, n3, a2, s2, o2, c2, u2, h2 = t3.length;
            if (!e4 || !e4.state)
              return es;
            if (r3 = e4.state, a2 = r3.wrap, 2 === a2 || 1 === a2 && r3.status !== vo || r3.lookahead)
              return es;
            for (1 === a2 && (e4.adler = ho(e4.adler, t3, h2, 0)), r3.wrap = 0, h2 >= r3.w_size && (0 === a2 && (Io(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u2 = new Fa(r3.w_size), ja(u2, t3, h2 - r3.w_size, r3.w_size, 0), t3 = u2, h2 = r3.w_size), s2 = e4.avail_in, o2 = e4.next_in, c2 = e4.input, e4.avail_in = h2, e4.next_in = 0, e4.input = t3, Lo(r3); r3.lookahead >= bo; ) {
              i3 = r3.strstart, n3 = r3.lookahead - (bo - 1);
              do {
                r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[i3 + bo - 1]) & r3.hash_mask, r3.prev[i3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = i3, i3++;
              } while (--n3);
              r3.strstart = i3, r3.lookahead = bo - 1, Lo(r3);
            }
            return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = bo - 1, r3.match_available = 0, e4.next_in = o2, e4.input = c2, e4.avail_in = s2, r3.wrap = a2, Ya;
          }(this.strm, e3), n2 !== Ya)
            throw Error(po[n2]);
          this._dict_set = true;
        }
      }
      push(e2, t2) {
        const { strm: r2, options: { chunkSize: i2 } } = this;
        var n2, a2;
        if (this.ended)
          return false;
        a2 = t2 === ~~t2 ? t2 : true === t2 ? $a : Ha, "string" == typeof e2 ? r2.input = Xo(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
        do {
          if (0 === r2.avail_out && (r2.output = new Fa(i2), r2.next_out = 0, r2.avail_out = i2), (n2 = $o(r2, a2)) !== Qa && n2 !== Ya)
            return this.onEnd(n2), this.ended = true, false;
          0 !== r2.avail_out && (0 !== r2.avail_in || a2 !== $a && a2 !== Ga) || this.onData(Ta(r2.output, r2.next_out));
        } while ((r2.avail_in > 0 || 0 === r2.avail_out) && n2 !== Qa);
        return a2 === $a ? (n2 = function(e3) {
          let t3;
          return e3 && e3.state ? (t3 = e3.state.status, t3 !== vo && t3 !== _o && t3 !== ko && t3 !== Ao && t3 !== So && t3 !== Eo && t3 !== Po ? Uo(e3, es) : (e3.state = null, t3 === Eo ? Uo(e3, ts) : Ya)) : es;
        }(this.strm), this.onEnd(n2), this.ended = true, n2 === Ya) : a2 !== Ga || (this.onEnd(Ya), r2.avail_out = 0, true);
      }
      onData(e2) {
        this.chunks.push(e2);
      }
      onEnd(e2) {
        e2 === Ya && (this.result = Na(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }
    };
    var Jo = 30;
    var ec = 12;
    function tc(e2, t2) {
      let r2, i2, n2, a2, s2, o2, c2, u2, h2, d2;
      const f2 = e2.state;
      r2 = e2.next_in;
      const l2 = e2.input, p2 = r2 + (e2.avail_in - 5);
      i2 = e2.next_out;
      const y2 = e2.output, b2 = i2 - (t2 - e2.avail_out), g2 = i2 + (e2.avail_out - 257), m2 = f2.dmax, w2 = f2.wsize, v2 = f2.whave, _2 = f2.wnext, k2 = f2.window;
      n2 = f2.hold, a2 = f2.bits;
      const A2 = f2.lencode, S2 = f2.distcode, E2 = (1 << f2.lenbits) - 1, P2 = (1 << f2.distbits) - 1;
      e:
        do {
          a2 < 15 && (n2 += l2[r2++] << a2, a2 += 8, n2 += l2[r2++] << a2, a2 += 8), s2 = A2[n2 & E2];
          t:
            for (; ; ) {
              if (o2 = s2 >>> 24, n2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, 0 === o2)
                y2[i2++] = 65535 & s2;
              else {
                if (!(16 & o2)) {
                  if (0 == (64 & o2)) {
                    s2 = A2[(65535 & s2) + (n2 & (1 << o2) - 1)];
                    continue t;
                  }
                  if (32 & o2) {
                    f2.mode = ec;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", f2.mode = Jo;
                  break e;
                }
                c2 = 65535 & s2, o2 &= 15, o2 && (a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8), c2 += n2 & (1 << o2) - 1, n2 >>>= o2, a2 -= o2), a2 < 15 && (n2 += l2[r2++] << a2, a2 += 8, n2 += l2[r2++] << a2, a2 += 8), s2 = S2[n2 & P2];
                r:
                  for (; ; ) {
                    if (o2 = s2 >>> 24, n2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, !(16 & o2)) {
                      if (0 == (64 & o2)) {
                        s2 = S2[(65535 & s2) + (n2 & (1 << o2) - 1)];
                        continue r;
                      }
                      e2.msg = "invalid distance code", f2.mode = Jo;
                      break e;
                    }
                    if (u2 = 65535 & s2, o2 &= 15, a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8, a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8)), u2 += n2 & (1 << o2) - 1, u2 > m2) {
                      e2.msg = "invalid distance too far back", f2.mode = Jo;
                      break e;
                    }
                    if (n2 >>>= o2, a2 -= o2, o2 = i2 - b2, u2 > o2) {
                      if (o2 = u2 - o2, o2 > v2 && f2.sane) {
                        e2.msg = "invalid distance too far back", f2.mode = Jo;
                        break e;
                      }
                      if (h2 = 0, d2 = k2, 0 === _2) {
                        if (h2 += w2 - o2, o2 < c2) {
                          c2 -= o2;
                          do {
                            y2[i2++] = k2[h2++];
                          } while (--o2);
                          h2 = i2 - u2, d2 = y2;
                        }
                      } else if (_2 < o2) {
                        if (h2 += w2 + _2 - o2, o2 -= _2, o2 < c2) {
                          c2 -= o2;
                          do {
                            y2[i2++] = k2[h2++];
                          } while (--o2);
                          if (h2 = 0, _2 < c2) {
                            o2 = _2, c2 -= o2;
                            do {
                              y2[i2++] = k2[h2++];
                            } while (--o2);
                            h2 = i2 - u2, d2 = y2;
                          }
                        }
                      } else if (h2 += _2 - o2, o2 < c2) {
                        c2 -= o2;
                        do {
                          y2[i2++] = k2[h2++];
                        } while (--o2);
                        h2 = i2 - u2, d2 = y2;
                      }
                      for (; c2 > 2; )
                        y2[i2++] = d2[h2++], y2[i2++] = d2[h2++], y2[i2++] = d2[h2++], c2 -= 3;
                      c2 && (y2[i2++] = d2[h2++], c2 > 1 && (y2[i2++] = d2[h2++]));
                    } else {
                      h2 = i2 - u2;
                      do {
                        y2[i2++] = y2[h2++], y2[i2++] = y2[h2++], y2[i2++] = y2[h2++], c2 -= 3;
                      } while (c2 > 2);
                      c2 && (y2[i2++] = y2[h2++], c2 > 1 && (y2[i2++] = y2[h2++]));
                    }
                    break;
                  }
              }
              break;
            }
        } while (r2 < p2 && i2 < g2);
      c2 = a2 >> 3, r2 -= c2, a2 -= c2 << 3, n2 &= (1 << a2) - 1, e2.next_in = r2, e2.next_out = i2, e2.avail_in = r2 < p2 ? p2 - r2 + 5 : 5 - (r2 - p2), e2.avail_out = i2 < g2 ? g2 - i2 + 257 : 257 - (i2 - g2), f2.hold = n2, f2.bits = a2;
    }
    var rc = 15;
    var ic = 852;
    var nc = 592;
    var ac = 0;
    var sc = 1;
    var oc = 2;
    var cc = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var uc = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var hc = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var dc = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    function fc(e2, t2, r2, i2, n2, a2, s2, o2) {
      const c2 = o2.bits;
      let u2, h2, d2, f2, l2, p2 = 0, y2 = 0, b2 = 0, g2 = 0, m2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0, S2 = null, E2 = 0;
      const P2 = new Oa(rc + 1), x2 = new Oa(rc + 1);
      let M2, K2, C2, D2 = null, U2 = 0;
      for (p2 = 0; p2 <= rc; p2++)
        P2[p2] = 0;
      for (y2 = 0; y2 < i2; y2++)
        P2[t2[r2 + y2]]++;
      for (m2 = c2, g2 = rc; g2 >= 1 && 0 === P2[g2]; g2--)
        ;
      if (m2 > g2 && (m2 = g2), 0 === g2)
        return n2[a2++] = 20971520, n2[a2++] = 20971520, o2.bits = 1, 0;
      for (b2 = 1; b2 < g2 && 0 === P2[b2]; b2++)
        ;
      for (m2 < b2 && (m2 = b2), _2 = 1, p2 = 1; p2 <= rc; p2++)
        if (_2 <<= 1, _2 -= P2[p2], _2 < 0)
          return -1;
      if (_2 > 0 && (e2 === ac || 1 !== g2))
        return -1;
      for (x2[1] = 0, p2 = 1; p2 < rc; p2++)
        x2[p2 + 1] = x2[p2] + P2[p2];
      for (y2 = 0; y2 < i2; y2++)
        0 !== t2[r2 + y2] && (s2[x2[t2[r2 + y2]]++] = y2);
      e2 === ac ? (S2 = D2 = s2, l2 = 19) : e2 === sc ? (S2 = cc, E2 -= 257, D2 = uc, U2 -= 257, l2 = 256) : (S2 = hc, D2 = dc, l2 = -1), A2 = 0, y2 = 0, p2 = b2, f2 = a2, w2 = m2, v2 = 0, d2 = -1, k2 = 1 << m2;
      const R2 = k2 - 1;
      if (e2 === sc && k2 > ic || e2 === oc && k2 > nc)
        return 1;
      for (; ; ) {
        M2 = p2 - v2, s2[y2] < l2 ? (K2 = 0, C2 = s2[y2]) : s2[y2] > l2 ? (K2 = D2[U2 + s2[y2]], C2 = S2[E2 + s2[y2]]) : (K2 = 96, C2 = 0), u2 = 1 << p2 - v2, h2 = 1 << w2, b2 = h2;
        do {
          h2 -= u2, n2[f2 + (A2 >> v2) + h2] = M2 << 24 | K2 << 16 | C2 | 0;
        } while (0 !== h2);
        for (u2 = 1 << p2 - 1; A2 & u2; )
          u2 >>= 1;
        if (0 !== u2 ? (A2 &= u2 - 1, A2 += u2) : A2 = 0, y2++, 0 == --P2[p2]) {
          if (p2 === g2)
            break;
          p2 = t2[r2 + s2[y2]];
        }
        if (p2 > m2 && (A2 & R2) !== d2) {
          for (0 === v2 && (v2 = m2), f2 += b2, w2 = p2 - v2, _2 = 1 << w2; w2 + v2 < g2 && (_2 -= P2[w2 + v2], !(_2 <= 0)); )
            w2++, _2 <<= 1;
          if (k2 += 1 << w2, e2 === sc && k2 > ic || e2 === oc && k2 > nc)
            return 1;
          d2 = A2 & R2, n2[d2] = m2 << 24 | w2 << 16 | f2 - a2 | 0;
        }
      }
      return 0 !== A2 && (n2[f2 + A2] = p2 - v2 << 24 | 64 << 16 | 0), o2.bits = m2, 0;
    }
    var lc = 0;
    var pc = 1;
    var yc = 2;
    var bc = 1;
    var gc = 2;
    var mc = 3;
    var wc = 4;
    var vc = 5;
    var _c = 6;
    var kc = 7;
    var Ac = 8;
    var Sc = 9;
    var Ec = 10;
    var Pc = 11;
    var xc = 12;
    var Mc = 13;
    var Kc = 14;
    var Cc = 15;
    var Dc = 16;
    var Uc = 17;
    var Rc = 18;
    var Ic = 19;
    var Bc = 20;
    var Tc = 21;
    var zc = 22;
    var qc = 23;
    var Fc = 24;
    var Oc = 25;
    var Lc = 26;
    var Nc = 27;
    var jc = 28;
    var Hc = 29;
    var Wc = 30;
    var Gc = 852;
    var Vc = 592;
    function $c(e2) {
      return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
    }
    var Zc = class {
      constructor() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Oa(320), this.work = new Oa(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
    };
    function Xc(e2) {
      let t2;
      return e2 && e2.state ? (t2 = e2.state, t2.wsize = 0, t2.whave = 0, t2.wnext = 0, function(e3) {
        let t3;
        return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = bc, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new La(Gc), t3.distcode = t3.distdyn = new La(Vc), t3.sane = 1, t3.back = -1, Ya) : es;
      }(e2)) : es;
    }
    function Yc(e2, t2) {
      let r2, i2;
      return e2 ? (i2 = new Zc(), e2.state = i2, i2.window = null, r2 = function(e3, t3) {
        let r3, i3;
        return e3 && e3.state ? (i3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? es : (null !== i3.window && i3.wbits !== t3 && (i3.window = null), i3.wrap = r3, i3.wbits = t3, Xc(e3))) : es;
      }(e2, t2), r2 !== Ya && (e2.state = null), r2) : es;
    }
    var Qc;
    var Jc;
    var eu = true;
    function tu(e2) {
      if (eu) {
        let t2;
        for (Qc = new La(512), Jc = new La(32), t2 = 0; t2 < 144; )
          e2.lens[t2++] = 8;
        for (; t2 < 256; )
          e2.lens[t2++] = 9;
        for (; t2 < 280; )
          e2.lens[t2++] = 7;
        for (; t2 < 288; )
          e2.lens[t2++] = 8;
        for (fc(pc, e2.lens, 0, 288, Qc, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
          e2.lens[t2++] = 5;
        fc(yc, e2.lens, 0, 32, Jc, 0, e2.work, { bits: 5 }), eu = false;
      }
      e2.lencode = Qc, e2.lenbits = 9, e2.distcode = Jc, e2.distbits = 5;
    }
    function ru(e2, t2, r2, i2) {
      let n2;
      const a2 = e2.state;
      return null === a2.window && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new Fa(a2.wsize)), i2 >= a2.wsize ? (ja(a2.window, t2, r2 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : (n2 = a2.wsize - a2.wnext, n2 > i2 && (n2 = i2), ja(a2.window, t2, r2 - i2, n2, a2.wnext), (i2 -= n2) ? (ja(a2.window, t2, r2 - i2, i2, 0), a2.wnext = i2, a2.whave = a2.wsize) : (a2.wnext += n2, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += n2))), 0;
    }
    function iu(e2, t2) {
      let r2, i2, n2, a2, s2, o2, c2, u2, h2, d2, f2, l2, p2, y2, b2, g2, m2, w2, v2, _2, k2, A2, S2, E2, P2 = 0, x2 = new Fa(4);
      const M2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
        return es;
      r2 = e2.state, r2.mode === xc && (r2.mode = Mc), s2 = e2.next_out, n2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, i2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, h2 = r2.bits, d2 = o2, f2 = c2, A2 = Ya;
      e:
        for (; ; )
          switch (r2.mode) {
            case bc:
              if (0 === r2.wrap) {
                r2.mode = Mc;
                break;
              }
              for (; h2 < 16; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (2 & r2.wrap && 35615 === u2) {
                r2.check = 0, x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = lo(r2.check, x2, 2, 0), u2 = 0, h2 = 0, r2.mode = gc;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r2.mode = Wc;
                break;
              }
              if ((15 & u2) !== ds) {
                e2.msg = "unknown compression method", r2.mode = Wc;
                break;
              }
              if (u2 >>>= 4, h2 -= 4, k2 = 8 + (15 & u2), 0 === r2.wbits)
                r2.wbits = k2;
              else if (k2 > r2.wbits) {
                e2.msg = "invalid window size", r2.mode = Wc;
                break;
              }
              r2.dmax = 1 << k2, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? Ec : xc, u2 = 0, h2 = 0;
              break;
            case gc:
              for (; h2 < 16; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (r2.flags = u2, (255 & r2.flags) !== ds) {
                e2.msg = "unknown compression method", r2.mode = Wc;
                break;
              }
              if (57344 & r2.flags) {
                e2.msg = "unknown header flags set", r2.mode = Wc;
                break;
              }
              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = lo(r2.check, x2, 2, 0)), u2 = 0, h2 = 0, r2.mode = mc;
            case mc:
              for (; h2 < 32; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              r2.head && (r2.head.time = u2), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, x2[2] = u2 >>> 16 & 255, x2[3] = u2 >>> 24 & 255, r2.check = lo(r2.check, x2, 4, 0)), u2 = 0, h2 = 0, r2.mode = wc;
            case wc:
              for (; h2 < 16; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = lo(r2.check, x2, 2, 0)), u2 = 0, h2 = 0, r2.mode = vc;
            case vc:
              if (1024 & r2.flags) {
                for (; h2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = lo(r2.check, x2, 2, 0)), u2 = 0, h2 = 0;
              } else
                r2.head && (r2.head.extra = null);
              r2.mode = _c;
            case _c:
              if (1024 & r2.flags && (l2 = r2.length, l2 > o2 && (l2 = o2), l2 && (r2.head && (k2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = Array(r2.head.extra_len)), ja(r2.head.extra, i2, a2, l2, k2)), 512 & r2.flags && (r2.check = lo(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, r2.length -= l2), r2.length))
                break e;
              r2.length = 0, r2.mode = kc;
            case kc:
              if (2048 & r2.flags) {
                if (0 === o2)
                  break e;
                l2 = 0;
                do {
                  k2 = i2[a2 + l2++], r2.head && k2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(k2));
                } while (k2 && l2 < o2);
                if (512 & r2.flags && (r2.check = lo(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, k2)
                  break e;
              } else
                r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = Ac;
            case Ac:
              if (4096 & r2.flags) {
                if (0 === o2)
                  break e;
                l2 = 0;
                do {
                  k2 = i2[a2 + l2++], r2.head && k2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k2));
                } while (k2 && l2 < o2);
                if (512 & r2.flags && (r2.check = lo(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, k2)
                  break e;
              } else
                r2.head && (r2.head.comment = null);
              r2.mode = Sc;
            case Sc:
              if (512 & r2.flags) {
                for (; h2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (u2 !== (65535 & r2.check)) {
                  e2.msg = "header crc mismatch", r2.mode = Wc;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = xc;
              break;
            case Ec:
              for (; h2 < 32; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              e2.adler = r2.check = $c(u2), u2 = 0, h2 = 0, r2.mode = Pc;
            case Pc:
              if (0 === r2.havedict)
                return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, Ja;
              e2.adler = r2.check = 1, r2.mode = xc;
            case xc:
              if (t2 === Za || t2 === Xa)
                break e;
            case Mc:
              if (r2.last) {
                u2 >>>= 7 & h2, h2 -= 7 & h2, r2.mode = Nc;
                break;
              }
              for (; h2 < 3; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              switch (r2.last = 1 & u2, u2 >>>= 1, h2 -= 1, 3 & u2) {
                case 0:
                  r2.mode = Kc;
                  break;
                case 1:
                  if (tu(r2), r2.mode = Bc, t2 === Xa) {
                    u2 >>>= 2, h2 -= 2;
                    break e;
                  }
                  break;
                case 2:
                  r2.mode = Uc;
                  break;
                case 3:
                  e2.msg = "invalid block type", r2.mode = Wc;
              }
              u2 >>>= 2, h2 -= 2;
              break;
            case Kc:
              for (u2 >>>= 7 & h2, h2 -= 7 & h2; h2 < 32; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r2.mode = Wc;
                break;
              }
              if (r2.length = 65535 & u2, u2 = 0, h2 = 0, r2.mode = Cc, t2 === Xa)
                break e;
            case Cc:
              r2.mode = Dc;
            case Dc:
              if (l2 = r2.length, l2) {
                if (l2 > o2 && (l2 = o2), l2 > c2 && (l2 = c2), 0 === l2)
                  break e;
                ja(n2, i2, a2, l2, s2), o2 -= l2, a2 += l2, c2 -= l2, s2 += l2, r2.length -= l2;
                break;
              }
              r2.mode = xc;
              break;
            case Uc:
              for (; h2 < 14; ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, h2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, h2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, h2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
                e2.msg = "too many length or distance symbols", r2.mode = Wc;
                break;
              }
              r2.have = 0, r2.mode = Rc;
            case Rc:
              for (; r2.have < r2.ncode; ) {
                for (; h2 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.lens[M2[r2.have++]] = 7 & u2, u2 >>>= 3, h2 -= 3;
              }
              for (; r2.have < 19; )
                r2.lens[M2[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S2 = { bits: r2.lenbits }, A2 = fc(lc, r2.lens, 0, 19, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, A2) {
                e2.msg = "invalid code lengths set", r2.mode = Wc;
                break;
              }
              r2.have = 0, r2.mode = Ic;
            case Ic:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; P2 = r2.lencode[u2 & (1 << r2.lenbits) - 1], b2 = P2 >>> 24, g2 = P2 >>> 16 & 255, m2 = 65535 & P2, !(b2 <= h2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (m2 < 16)
                  u2 >>>= b2, h2 -= b2, r2.lens[r2.have++] = m2;
                else {
                  if (16 === m2) {
                    for (E2 = b2 + 2; h2 < E2; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    if (u2 >>>= b2, h2 -= b2, 0 === r2.have) {
                      e2.msg = "invalid bit length repeat", r2.mode = Wc;
                      break;
                    }
                    k2 = r2.lens[r2.have - 1], l2 = 3 + (3 & u2), u2 >>>= 2, h2 -= 2;
                  } else if (17 === m2) {
                    for (E2 = b2 + 3; h2 < E2; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    u2 >>>= b2, h2 -= b2, k2 = 0, l2 = 3 + (7 & u2), u2 >>>= 3, h2 -= 3;
                  } else {
                    for (E2 = b2 + 7; h2 < E2; ) {
                      if (0 === o2)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    u2 >>>= b2, h2 -= b2, k2 = 0, l2 = 11 + (127 & u2), u2 >>>= 7, h2 -= 7;
                  }
                  if (r2.have + l2 > r2.nlen + r2.ndist) {
                    e2.msg = "invalid bit length repeat", r2.mode = Wc;
                    break;
                  }
                  for (; l2--; )
                    r2.lens[r2.have++] = k2;
                }
              }
              if (r2.mode === Wc)
                break;
              if (0 === r2.lens[256]) {
                e2.msg = "invalid code -- missing end-of-block", r2.mode = Wc;
                break;
              }
              if (r2.lenbits = 9, S2 = { bits: r2.lenbits }, A2 = fc(pc, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, A2) {
                e2.msg = "invalid literal/lengths set", r2.mode = Wc;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S2 = { bits: r2.distbits }, A2 = fc(yc, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S2), r2.distbits = S2.bits, A2) {
                e2.msg = "invalid distances set", r2.mode = Wc;
                break;
              }
              if (r2.mode = Bc, t2 === Xa)
                break e;
            case Bc:
              r2.mode = Tc;
            case Tc:
              if (o2 >= 6 && c2 >= 258) {
                e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, tc(e2, f2), s2 = e2.next_out, n2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, i2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, h2 = r2.bits, r2.mode === xc && (r2.back = -1);
                break;
              }
              for (r2.back = 0; P2 = r2.lencode[u2 & (1 << r2.lenbits) - 1], b2 = P2 >>> 24, g2 = P2 >>> 16 & 255, m2 = 65535 & P2, !(b2 <= h2); ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (g2 && 0 == (240 & g2)) {
                for (w2 = b2, v2 = g2, _2 = m2; P2 = r2.lencode[_2 + ((u2 & (1 << w2 + v2) - 1) >> w2)], b2 = P2 >>> 24, g2 = P2 >>> 16 & 255, m2 = 65535 & P2, !(w2 + b2 <= h2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                u2 >>>= w2, h2 -= w2, r2.back += w2;
              }
              if (u2 >>>= b2, h2 -= b2, r2.back += b2, r2.length = m2, 0 === g2) {
                r2.mode = Lc;
                break;
              }
              if (32 & g2) {
                r2.back = -1, r2.mode = xc;
                break;
              }
              if (64 & g2) {
                e2.msg = "invalid literal/length code", r2.mode = Wc;
                break;
              }
              r2.extra = 15 & g2, r2.mode = zc;
            case zc:
              if (r2.extra) {
                for (E2 = r2.extra; h2 < E2; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, h2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = qc;
            case qc:
              for (; P2 = r2.distcode[u2 & (1 << r2.distbits) - 1], b2 = P2 >>> 24, g2 = P2 >>> 16 & 255, m2 = 65535 & P2, !(b2 <= h2); ) {
                if (0 === o2)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (0 == (240 & g2)) {
                for (w2 = b2, v2 = g2, _2 = m2; P2 = r2.distcode[_2 + ((u2 & (1 << w2 + v2) - 1) >> w2)], b2 = P2 >>> 24, g2 = P2 >>> 16 & 255, m2 = 65535 & P2, !(w2 + b2 <= h2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                u2 >>>= w2, h2 -= w2, r2.back += w2;
              }
              if (u2 >>>= b2, h2 -= b2, r2.back += b2, 64 & g2) {
                e2.msg = "invalid distance code", r2.mode = Wc;
                break;
              }
              r2.offset = m2, r2.extra = 15 & g2, r2.mode = Fc;
            case Fc:
              if (r2.extra) {
                for (E2 = r2.extra; h2 < E2; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, h2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e2.msg = "invalid distance too far back", r2.mode = Wc;
                break;
              }
              r2.mode = Oc;
            case Oc:
              if (0 === c2)
                break e;
              if (l2 = f2 - c2, r2.offset > l2) {
                if (l2 = r2.offset - l2, l2 > r2.whave && r2.sane) {
                  e2.msg = "invalid distance too far back", r2.mode = Wc;
                  break;
                }
                l2 > r2.wnext ? (l2 -= r2.wnext, p2 = r2.wsize - l2) : p2 = r2.wnext - l2, l2 > r2.length && (l2 = r2.length), y2 = r2.window;
              } else
                y2 = n2, p2 = s2 - r2.offset, l2 = r2.length;
              l2 > c2 && (l2 = c2), c2 -= l2, r2.length -= l2;
              do {
                n2[s2++] = y2[p2++];
              } while (--l2);
              0 === r2.length && (r2.mode = Tc);
              break;
            case Lc:
              if (0 === c2)
                break e;
              n2[s2++] = r2.length, c2--, r2.mode = Tc;
              break;
            case Nc:
              if (r2.wrap) {
                for (; h2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 |= i2[a2++] << h2, h2 += 8;
                }
                if (f2 -= c2, e2.total_out += f2, r2.total += f2, f2 && (e2.adler = r2.check = r2.flags ? lo(r2.check, n2, f2, s2 - f2) : ho(r2.check, n2, f2, s2 - f2)), f2 = c2, (r2.flags ? u2 : $c(u2)) !== r2.check) {
                  e2.msg = "incorrect data check", r2.mode = Wc;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.mode = jc;
            case jc:
              if (r2.wrap && r2.flags) {
                for (; h2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (u2 !== (4294967295 & r2.total)) {
                  e2.msg = "incorrect length check", r2.mode = Wc;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.mode = Hc;
            case Hc:
              A2 = Qa;
              break e;
            case Wc:
              A2 = ts;
              break e;
            default:
              return es;
          }
      return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, (r2.wsize || f2 !== e2.avail_out && r2.mode < Wc && (r2.mode < Nc || t2 !== $a)) && ru(e2, e2.output, e2.next_out, f2 - e2.avail_out), d2 -= e2.avail_in, f2 -= e2.avail_out, e2.total_in += d2, e2.total_out += f2, r2.total += f2, r2.wrap && f2 && (e2.adler = r2.check = r2.flags ? lo(r2.check, n2, f2, e2.next_out - f2) : ho(r2.check, n2, f2, e2.next_out - f2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === xc ? 128 : 0) + (r2.mode === Bc || r2.mode === Cc ? 256 : 0), (0 === d2 && 0 === f2 || t2 === $a) && A2 === Ya && (A2 = rs), A2;
    }
    function nu(e2, t2) {
      const r2 = t2.length;
      let i2, n2;
      return e2 && e2.state ? (i2 = e2.state, 0 !== i2.wrap && i2.mode !== Pc ? es : i2.mode === Pc && (n2 = 1, n2 = ho(n2, t2, r2, 0), n2 !== i2.check) ? ts : (ru(e2, t2, r2, r2), i2.havedict = 1, Ya)) : es;
    }
    var au = class {
      constructor() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      }
    };
    var su = class {
      constructor(e2) {
        this.options = { chunkSize: 16384, windowBits: 0, ...e2 || {} };
        const t2 = this.options;
        t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Yo(), this.strm.avail_out = 0;
        let r2 = Yc(this.strm, t2.windowBits);
        if (r2 !== Ya)
          throw Error(po[r2]);
        if (this.header = new au(), function(e3, t3) {
          let r3;
          e3 && e3.state && (r3 = e3.state, 0 == (2 & r3.wrap) || (r3.head = t3, t3.done = false));
        }(this.strm, this.header), t2.dictionary && ("string" == typeof t2.dictionary ? t2.dictionary = Xo(t2.dictionary) : t2.dictionary instanceof ArrayBuffer && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (r2 = nu(this.strm, t2.dictionary), r2 !== Ya)))
          throw Error(po[r2]);
      }
      push(e2, t2) {
        const { strm: r2, options: { chunkSize: i2, dictionary: n2 } } = this;
        let a2, s2, o2 = false;
        if (this.ended)
          return false;
        s2 = t2 === ~~t2 ? t2 : true === t2 ? $a : Ha, "string" == typeof e2 ? r2.input = function(e3) {
          const t3 = new Fa(e3.length);
          for (let r3 = 0, i3 = t3.length; r3 < i3; r3++)
            t3[r3] = e3.charCodeAt(r3);
          return t3;
        }(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
        do {
          if (0 === r2.avail_out && (r2.output = new Fa(i2), r2.next_out = 0, r2.avail_out = i2), a2 = iu(r2, Ha), a2 === Ja && n2 && (a2 = nu(this.strm, n2)), a2 === rs && true === o2 && (a2 = Ya, o2 = false), a2 !== Qa && a2 !== Ya)
            return this.onEnd(a2), this.ended = true, false;
          r2.next_out && (0 !== r2.avail_out && a2 !== Qa && (0 !== r2.avail_in || s2 !== $a && s2 !== Ga) || this.onData(Ta(r2.output, r2.next_out))), 0 === r2.avail_in && 0 === r2.avail_out && (o2 = true);
        } while ((r2.avail_in > 0 || 0 === r2.avail_out) && a2 !== Qa);
        return a2 === Qa && (s2 = $a), s2 === $a ? (a2 = function(e3) {
          if (!e3 || !e3.state)
            return es;
          const t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, Ya;
        }(this.strm), this.onEnd(a2), this.ended = true, a2 === Ya) : s2 !== Ga || (this.onEnd(Ya), r2.avail_out = 0, true);
      }
      onData(e2) {
        this.chunks.push(e2);
      }
      onEnd(e2) {
        e2 === Ya && (this.result = Na(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }
    };
    var ou = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    var cu = function(e2) {
      this.stream = e2, this.bitOffset = 0, this.curByte = 0, this.hasByte = false;
    };
    cu.prototype._ensureByte = function() {
      this.hasByte || (this.curByte = this.stream.readByte(), this.hasByte = true);
    }, cu.prototype.read = function(e2) {
      for (var t2 = 0; e2 > 0; ) {
        this._ensureByte();
        var r2 = 8 - this.bitOffset;
        if (e2 >= r2)
          t2 <<= r2, t2 |= ou[r2] & this.curByte, this.hasByte = false, this.bitOffset = 0, e2 -= r2;
        else {
          t2 <<= e2;
          var i2 = r2 - e2;
          t2 |= (this.curByte & ou[e2] << i2) >> i2, this.bitOffset += e2, e2 = 0;
        }
      }
      return t2;
    }, cu.prototype.seek = function(e2) {
      var t2 = e2 % 8, r2 = (e2 - t2) / 8;
      this.bitOffset = t2, this.stream.seek(r2), this.hasByte = false;
    }, cu.prototype.pi = function() {
      var e2, t2 = new Uint8Array(6);
      for (e2 = 0; e2 < t2.length; e2++)
        t2[e2] = this.read(8);
      return function(e3) {
        return Array.prototype.map.call(e3, (e4) => ("00" + e4.toString(16)).slice(-2)).join("");
      }(t2);
    };
    var uu = cu;
    var hu = function() {
    };
    hu.prototype.readByte = function() {
      throw Error("abstract method readByte() not implemented");
    }, hu.prototype.read = function(e2, t2, r2) {
      for (var i2 = 0; i2 < r2; ) {
        var n2 = this.readByte();
        if (n2 < 0)
          return 0 === i2 ? -1 : i2;
        e2[t2++] = n2, i2++;
      }
      return i2;
    }, hu.prototype.seek = function(e2) {
      throw Error("abstract method seek() not implemented");
    }, hu.prototype.writeByte = function(e2) {
      throw Error("abstract method readByte() not implemented");
    }, hu.prototype.write = function(e2, t2, r2) {
      var i2;
      for (i2 = 0; i2 < r2; i2++)
        this.writeByte(e2[t2++]);
      return r2;
    }, hu.prototype.flush = function() {
    };
    var du;
    var fu = hu;
    var lu = (du = new Uint32Array([0, 79764919, 159529838, 222504665, 319059676, 398814059, 445009330, 507990021, 638119352, 583659535, 797628118, 726387553, 890018660, 835552979, 1015980042, 944750013, 1276238704, 1221641927, 1167319070, 1095957929, 1595256236, 1540665371, 1452775106, 1381403509, 1780037320, 1859660671, 1671105958, 1733955601, 2031960084, 2111593891, 1889500026, 1952343757, 2552477408, 2632100695, 2443283854, 2506133561, 2334638140, 2414271883, 2191915858, 2254759653, 3190512472, 3135915759, 3081330742, 3009969537, 2905550212, 2850959411, 2762807018, 2691435357, 3560074640, 3505614887, 3719321342, 3648080713, 3342211916, 3287746299, 3467911202, 3396681109, 4063920168, 4143685023, 4223187782, 4286162673, 3779000052, 3858754371, 3904687514, 3967668269, 881225847, 809987520, 1023691545, 969234094, 662832811, 591600412, 771767749, 717299826, 311336399, 374308984, 453813921, 533576470, 25881363, 88864420, 134795389, 214552010, 2023205639, 2086057648, 1897238633, 1976864222, 1804852699, 1867694188, 1645340341, 1724971778, 1587496639, 1516133128, 1461550545, 1406951526, 1302016099, 1230646740, 1142491917, 1087903418, 2896545431, 2825181984, 2770861561, 2716262478, 3215044683, 3143675388, 3055782693, 3001194130, 2326604591, 2389456536, 2200899649, 2280525302, 2578013683, 2640855108, 2418763421, 2498394922, 3769900519, 3832873040, 3912640137, 3992402750, 4088425275, 4151408268, 4197601365, 4277358050, 3334271071, 3263032808, 3476998961, 3422541446, 3585640067, 3514407732, 3694837229, 3640369242, 1762451694, 1842216281, 1619975040, 1682949687, 2047383090, 2127137669, 1938468188, 2001449195, 1325665622, 1271206113, 1183200824, 1111960463, 1543535498, 1489069629, 1434599652, 1363369299, 622672798, 568075817, 748617968, 677256519, 907627842, 853037301, 1067152940, 995781531, 51762726, 131386257, 177728840, 240578815, 269590778, 349224269, 429104020, 491947555, 4046411278, 4126034873, 4172115296, 4234965207, 3794477266, 3874110821, 3953728444, 4016571915, 3609705398, 3555108353, 3735388376, 3664026991, 3290680682, 3236090077, 3449943556, 3378572211, 3174993278, 3120533705, 3032266256, 2961025959, 2923101090, 2868635157, 2813903052, 2742672763, 2604032198, 2683796849, 2461293480, 2524268063, 2284983834, 2364738477, 2175806836, 2238787779, 1569362073, 1498123566, 1409854455, 1355396672, 1317987909, 1246755826, 1192025387, 1137557660, 2072149281, 2135122070, 1912620623, 1992383480, 1753615357, 1816598090, 1627664531, 1707420964, 295390185, 358241886, 404320391, 483945776, 43990325, 106832002, 186451547, 266083308, 932423249, 861060070, 1041341759, 986742920, 613929101, 542559546, 756411363, 701822548, 3316196985, 3244833742, 3425377559, 3370778784, 3601682597, 3530312978, 3744426955, 3689838204, 3819031489, 3881883254, 3928223919, 4007849240, 4037393693, 4100235434, 4180117107, 4259748804, 2310601993, 2373574846, 2151335527, 2231098320, 2596047829, 2659030626, 2470359227, 2550115596, 2947551409, 2876312838, 2788305887, 2733848168, 3165939309, 3094707162, 3040238851, 2985771188]), function() {
      var e2 = 4294967295;
      this.getCRC = function() {
        return ~e2 >>> 0;
      }, this.updateCRC = function(t2) {
        e2 = e2 << 8 ^ du[255 & (e2 >>> 24 ^ t2)];
      }, this.updateCRCRun = function(t2, r2) {
        for (; r2-- > 0; )
          e2 = e2 << 8 ^ du[255 & (e2 >>> 24 ^ t2)];
      };
    });
    var pu = function(e2, t2) {
      var r2, i2 = e2[t2];
      for (r2 = t2; r2 > 0; r2--)
        e2[r2] = e2[r2 - 1];
      return e2[0] = i2, i2;
    };
    var yu = { OK: 0, LAST_BLOCK: -1, NOT_BZIP_DATA: -2, UNEXPECTED_INPUT_EOF: -3, UNEXPECTED_OUTPUT_EOF: -4, DATA_ERROR: -5, OUT_OF_MEMORY: -6, OBSOLETE_INPUT: -7, END_OF_BLOCK: -8 };
    var bu = {};
    bu[yu.LAST_BLOCK] = "Bad file checksum", bu[yu.NOT_BZIP_DATA] = "Not bzip data", bu[yu.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF", bu[yu.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF", bu[yu.DATA_ERROR] = "Data error", bu[yu.OUT_OF_MEMORY] = "Out of memory", bu[yu.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
    var gu = function(e2, t2) {
      var r2 = bu[e2] || "unknown error";
      t2 && (r2 += ": " + t2);
      var i2 = new TypeError(r2);
      throw i2.errorCode = e2, i2;
    };
    var mu = function(e2, t2) {
      this.writePos = this.writeCurrent = this.writeCount = 0, this._start_bunzip(e2, t2);
    };
    mu.prototype._init_block = function() {
      return this._get_next_block() ? (this.blockCRC = new lu(), true) : (this.writeCount = -1, false);
    }, mu.prototype._start_bunzip = function(e2, t2) {
      var r2 = new Uint8Array(4);
      4 === e2.read(r2, 0, 4) && "BZh" === String.fromCharCode(r2[0], r2[1], r2[2]) || gu(yu.NOT_BZIP_DATA, "bad magic");
      var i2 = r2[3] - 48;
      (i2 < 1 || i2 > 9) && gu(yu.NOT_BZIP_DATA, "level out of range"), this.reader = new uu(e2), this.dbufSize = 1e5 * i2, this.nextoutput = 0, this.outputStream = t2, this.streamCRC = 0;
    }, mu.prototype._get_next_block = function() {
      var e2, t2, r2, i2 = this.reader, n2 = i2.pi();
      if ("177245385090" === n2)
        return false;
      "314159265359" !== n2 && gu(yu.NOT_BZIP_DATA), this.targetBlockCRC = i2.read(32) >>> 0, this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0, i2.read(1) && gu(yu.OBSOLETE_INPUT);
      var a2 = i2.read(24);
      a2 > this.dbufSize && gu(yu.DATA_ERROR, "initial position out of bounds");
      var s2 = i2.read(16), o2 = new Uint8Array(256), c2 = 0;
      for (e2 = 0; e2 < 16; e2++)
        if (s2 & 1 << 15 - e2) {
          var u2 = 16 * e2;
          for (r2 = i2.read(16), t2 = 0; t2 < 16; t2++)
            r2 & 1 << 15 - t2 && (o2[c2++] = u2 + t2);
        }
      var h2 = i2.read(3);
      (h2 < 2 || h2 > 6) && gu(yu.DATA_ERROR);
      var d2 = i2.read(15);
      0 === d2 && gu(yu.DATA_ERROR);
      var f2 = new Uint8Array(256);
      for (e2 = 0; e2 < h2; e2++)
        f2[e2] = e2;
      var l2 = new Uint8Array(d2);
      for (e2 = 0; e2 < d2; e2++) {
        for (t2 = 0; i2.read(1); t2++)
          t2 >= h2 && gu(yu.DATA_ERROR);
        l2[e2] = pu(f2, t2);
      }
      var p2, y2 = c2 + 2, b2 = [];
      for (t2 = 0; t2 < h2; t2++) {
        var g2, m2, w2 = new Uint8Array(y2), v2 = new Uint16Array(21);
        for (s2 = i2.read(5), e2 = 0; e2 < y2; e2++) {
          for (; (s2 < 1 || s2 > 20) && gu(yu.DATA_ERROR), i2.read(1); )
            i2.read(1) ? s2-- : s2++;
          w2[e2] = s2;
        }
        for (g2 = m2 = w2[0], e2 = 1; e2 < y2; e2++)
          w2[e2] > m2 ? m2 = w2[e2] : w2[e2] < g2 && (g2 = w2[e2]);
        p2 = {}, b2.push(p2), p2.permute = new Uint16Array(258), p2.limit = new Uint32Array(22), p2.base = new Uint32Array(21), p2.minLen = g2, p2.maxLen = m2;
        var _2 = 0;
        for (e2 = g2; e2 <= m2; e2++)
          for (v2[e2] = p2.limit[e2] = 0, s2 = 0; s2 < y2; s2++)
            w2[s2] === e2 && (p2.permute[_2++] = s2);
        for (e2 = 0; e2 < y2; e2++)
          v2[w2[e2]]++;
        for (_2 = s2 = 0, e2 = g2; e2 < m2; e2++)
          _2 += v2[e2], p2.limit[e2] = _2 - 1, _2 <<= 1, s2 += v2[e2], p2.base[e2 + 1] = _2 - s2;
        p2.limit[m2 + 1] = Number.MAX_VALUE, p2.limit[m2] = _2 + v2[m2] - 1, p2.base[g2] = 0;
      }
      var k2 = new Uint32Array(256);
      for (e2 = 0; e2 < 256; e2++)
        f2[e2] = e2;
      var A2, S2 = 0, E2 = 0, P2 = 0, x2 = this.dbuf = new Uint32Array(this.dbufSize);
      for (y2 = 0; ; ) {
        for (y2-- || (y2 = 49, P2 >= d2 && gu(yu.DATA_ERROR), p2 = b2[l2[P2++]]), e2 = p2.minLen, t2 = i2.read(e2); e2 > p2.maxLen && gu(yu.DATA_ERROR), !(t2 <= p2.limit[e2]); e2++)
          t2 = t2 << 1 | i2.read(1);
        ((t2 -= p2.base[e2]) < 0 || t2 >= 258) && gu(yu.DATA_ERROR);
        var M2 = p2.permute[t2];
        if (0 !== M2 && 1 !== M2) {
          if (S2)
            for (S2 = 0, E2 + s2 > this.dbufSize && gu(yu.DATA_ERROR), k2[A2 = o2[f2[0]]] += s2; s2--; )
              x2[E2++] = A2;
          if (M2 > c2)
            break;
          E2 >= this.dbufSize && gu(yu.DATA_ERROR), k2[A2 = o2[A2 = pu(f2, e2 = M2 - 1)]]++, x2[E2++] = A2;
        } else
          S2 || (S2 = 1, s2 = 0), s2 += 0 === M2 ? S2 : 2 * S2, S2 <<= 1;
      }
      for ((a2 < 0 || a2 >= E2) && gu(yu.DATA_ERROR), t2 = 0, e2 = 0; e2 < 256; e2++)
        r2 = t2 + k2[e2], k2[e2] = t2, t2 = r2;
      for (e2 = 0; e2 < E2; e2++)
        x2[k2[A2 = 255 & x2[e2]]] |= e2 << 8, k2[A2]++;
      var K2 = 0, C2 = 0, D2 = 0;
      return E2 && (C2 = 255 & (K2 = x2[a2]), K2 >>= 8, D2 = -1), this.writePos = K2, this.writeCurrent = C2, this.writeCount = E2, this.writeRun = D2, true;
    }, mu.prototype._read_bunzip = function(e2, t2) {
      var r2, i2, n2;
      if (this.writeCount < 0)
        return 0;
      var a2 = this.dbuf, s2 = this.writePos, o2 = this.writeCurrent, c2 = this.writeCount;
      this.outputsize;
      for (var u2 = this.writeRun; c2; ) {
        for (c2--, i2 = o2, o2 = 255 & (s2 = a2[s2]), s2 >>= 8, 3 == u2++ ? (r2 = o2, n2 = i2, o2 = -1) : (r2 = 1, n2 = o2), this.blockCRC.updateCRCRun(n2, r2); r2--; )
          this.outputStream.writeByte(n2), this.nextoutput++;
        o2 != i2 && (u2 = 0);
      }
      return this.writeCount = c2, this.blockCRC.getCRC() !== this.targetBlockCRC && gu(yu.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")"), this.nextoutput;
    };
    var wu = function(e2) {
      if ("readByte" in e2)
        return e2;
      var t2 = new fu();
      return t2.pos = 0, t2.readByte = function() {
        return e2[this.pos++];
      }, t2.seek = function(e3) {
        this.pos = e3;
      }, t2.eof = function() {
        return this.pos >= e2.length;
      }, t2;
    };
    var vu = function(e2) {
      var t2 = new fu(), r2 = true;
      if (e2)
        if ("number" == typeof e2)
          t2.buffer = new Uint8Array(e2), r2 = false;
        else {
          if ("writeByte" in e2)
            return e2;
          t2.buffer = e2, r2 = false;
        }
      else
        t2.buffer = new Uint8Array(16384);
      return t2.pos = 0, t2.writeByte = function(e3) {
        if (r2 && this.pos >= this.buffer.length) {
          var t3 = new Uint8Array(2 * this.buffer.length);
          t3.set(this.buffer), this.buffer = t3;
        }
        this.buffer[this.pos++] = e3;
      }, t2.getBuffer = function() {
        if (this.pos !== this.buffer.length) {
          if (!r2)
            throw new TypeError("outputsize does not match decoded input");
          var e3 = new Uint8Array(this.pos);
          e3.set(this.buffer.subarray(0, this.pos)), this.buffer = e3;
        }
        return this.buffer;
      }, t2._coerced = true, t2;
    };
    var _u = function(e2, t2, r2) {
      for (var i2 = wu(e2), n2 = vu(t2), a2 = new mu(i2, n2); !("eof" in i2) || !i2.eof(); )
        if (a2._init_block())
          a2._read_bunzip();
        else {
          var s2 = a2.reader.read(32) >>> 0;
          if (s2 !== a2.streamCRC && gu(yu.DATA_ERROR, "Bad stream CRC (got " + a2.streamCRC.toString(16) + " expected " + s2.toString(16) + ")"), !r2 || !("eof" in i2) || i2.eof())
            break;
          a2._start_bunzip(i2, n2);
        }
      if ("getBuffer" in n2)
        return n2.getBuffer();
    };
    var ku = class {
      static get tag() {
        return ue.packet.literalData;
      }
      constructor(e2 = /* @__PURE__ */ new Date()) {
        this.format = ue.literal.utf8, this.date = de.normalizeDate(e2), this.text = null, this.data = null, this.filename = "";
      }
      setText(e2, t2 = ue.literal.utf8) {
        this.format = t2, this.text = e2, this.data = null;
      }
      getText(e2 = false) {
        return (null === this.text || de.isStream(this.text)) && (this.text = de.decodeUTF8(de.nativeEOL(this.getBytes(e2)))), this.text;
      }
      setBytes(e2, t2) {
        this.format = t2, this.data = e2, this.text = null;
      }
      getBytes(e2 = false) {
        return null === this.data && (this.data = de.canonicalizeEOL(de.encodeUTF8(this.text))), e2 ? ee(this.data) : this.data;
      }
      setFilename(e2) {
        this.filename = e2;
      }
      getFilename() {
        return this.filename;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte(), r2 = await e3.readByte();
          this.filename = de.decodeUTF8(await e3.readBytes(r2)), this.date = de.readDate(await e3.readBytes(4));
          let i2 = e3.remainder();
          _(i2) && (i2 = await ie(i2)), this.setBytes(i2, t2);
        });
      }
      writeHeader() {
        const e2 = de.encodeUTF8(this.filename), t2 = new Uint8Array([e2.length]), r2 = new Uint8Array([this.format]), i2 = de.writeDate(this.date);
        return de.concatUint8Array([r2, t2, e2, i2]);
      }
      write() {
        const e2 = this.writeHeader(), t2 = this.getBytes();
        return de.concat([e2, t2]);
      }
    };
    var Au = Symbol("verified");
    var Su = /* @__PURE__ */ new Set([ue.signatureSubpacket.issuer, ue.signatureSubpacket.issuerFingerprint, ue.signatureSubpacket.embeddedSignature]);
    var Eu = class _Eu {
      static get tag() {
        return ue.packet.signature;
      }
      constructor() {
        this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.signatureData = null, this.unhashedSubpackets = [], this.signedHashValue = null, this.created = null, this.signatureExpirationTime = null, this.signatureNeverExpires = true, this.exportable = null, this.trustLevel = null, this.trustAmount = null, this.regularExpression = null, this.revocable = null, this.keyExpirationTime = null, this.keyNeverExpires = null, this.preferredSymmetricAlgorithms = null, this.revocationKeyClass = null, this.revocationKeyAlgorithm = null, this.revocationKeyFingerprint = null, this.issuerKeyID = new Ke(), this.rawNotations = [], this.notations = {}, this.preferredHashAlgorithms = null, this.preferredCompressionAlgorithms = null, this.keyServerPreferences = null, this.preferredKeyServer = null, this.isPrimaryUserID = null, this.policyURI = null, this.keyFlags = null, this.signersUserID = null, this.reasonForRevocationFlag = null, this.reasonForRevocationString = null, this.features = null, this.signatureTargetPublicKeyAlgorithm = null, this.signatureTargetHashAlgorithm = null, this.signatureTargetHash = null, this.embeddedSignature = null, this.issuerKeyVersion = null, this.issuerFingerprint = null, this.preferredAEADAlgorithms = null, this.revoked = null, this[Au] = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], 4 !== this.version && 5 !== this.version)
          throw new Un(`Version ${this.version} of the signature packet is unsupported.`);
        if (this.signatureType = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.hashAlgorithm = e2[t2++], t2 += this.readSubPackets(e2.subarray(t2, e2.length), true), !this.created)
          throw Error("Missing signature creation time subpacket.");
        this.signatureData = e2.subarray(0, t2), t2 += this.readSubPackets(e2.subarray(t2, e2.length), false), this.signedHashValue = e2.subarray(t2, t2 + 2), t2 += 2, this.params = Ia.signature.parseSignatureParams(this.publicKeyAlgorithm, e2.subarray(t2, e2.length));
      }
      writeParams() {
        return this.params instanceof Promise ? ae(async () => Ia.serializeParams(this.publicKeyAlgorithm, await this.params)) : Ia.serializeParams(this.publicKeyAlgorithm, this.params);
      }
      write() {
        const e2 = [];
        return e2.push(this.signatureData), e2.push(this.writeUnhashedSubPackets()), e2.push(this.signedHashValue), e2.push(this.writeParams()), de.concat(e2);
      }
      async sign(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = false) {
        5 === e2.version ? this.version = 5 : this.version = 4;
        const n2 = [new Uint8Array([this.version, this.signatureType, this.publicKeyAlgorithm, this.hashAlgorithm])];
        this.created = de.normalizeDate(r2), this.issuerKeyVersion = e2.version, this.issuerFingerprint = e2.getFingerprintBytes(), this.issuerKeyID = e2.getKeyID(), n2.push(this.writeHashedSubPackets()), this.unhashedSubpackets = [], this.signatureData = de.concat(n2);
        const a2 = this.toHash(this.signatureType, t2, i2), s2 = await this.hash(this.signatureType, t2, a2, i2);
        this.signedHashValue = re(J(s2), 0, 2);
        const o2 = async () => Ia.signature.sign(this.publicKeyAlgorithm, this.hashAlgorithm, e2.publicParams, e2.privateParams, a2, await ie(s2));
        de.isStream(s2) ? this.params = o2() : (this.params = await o2(), this[Au] = true);
      }
      writeHashedSubPackets() {
        const e2 = ue.signatureSubpacket, t2 = [];
        let r2;
        if (null === this.created)
          throw Error("Missing signature creation time");
        t2.push(Pu(e2.signatureCreationTime, true, de.writeDate(this.created))), null !== this.signatureExpirationTime && t2.push(Pu(e2.signatureExpirationTime, true, de.writeNumber(this.signatureExpirationTime, 4))), null !== this.exportable && t2.push(Pu(e2.exportableCertification, true, new Uint8Array([this.exportable ? 1 : 0]))), null !== this.trustLevel && (r2 = new Uint8Array([this.trustLevel, this.trustAmount]), t2.push(Pu(e2.trustSignature, true, r2))), null !== this.regularExpression && t2.push(Pu(e2.regularExpression, true, this.regularExpression)), null !== this.revocable && t2.push(Pu(e2.revocable, true, new Uint8Array([this.revocable ? 1 : 0]))), null !== this.keyExpirationTime && t2.push(Pu(e2.keyExpirationTime, true, de.writeNumber(this.keyExpirationTime, 4))), null !== this.preferredSymmetricAlgorithms && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.preferredSymmetricAlgorithms)), t2.push(Pu(e2.preferredSymmetricAlgorithms, false, r2))), null !== this.revocationKeyClass && (r2 = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]), r2 = de.concat([r2, this.revocationKeyFingerprint]), t2.push(Pu(e2.revocationKey, false, r2))), this.issuerKeyID.isNull() || 5 === this.issuerKeyVersion || t2.push(Pu(e2.issuer, true, this.issuerKeyID.write())), this.rawNotations.forEach(({ name: i3, value: n3, humanReadable: a2, critical: s2 }) => {
          r2 = [new Uint8Array([a2 ? 128 : 0, 0, 0, 0])];
          const o2 = de.encodeUTF8(i3);
          r2.push(de.writeNumber(o2.length, 2)), r2.push(de.writeNumber(n3.length, 2)), r2.push(o2), r2.push(n3), r2 = de.concat(r2), t2.push(Pu(e2.notationData, s2, r2));
        }), null !== this.preferredHashAlgorithms && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.preferredHashAlgorithms)), t2.push(Pu(e2.preferredHashAlgorithms, false, r2))), null !== this.preferredCompressionAlgorithms && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.preferredCompressionAlgorithms)), t2.push(Pu(e2.preferredCompressionAlgorithms, false, r2))), null !== this.keyServerPreferences && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.keyServerPreferences)), t2.push(Pu(e2.keyServerPreferences, false, r2))), null !== this.preferredKeyServer && t2.push(Pu(e2.preferredKeyServer, false, de.encodeUTF8(this.preferredKeyServer))), null !== this.isPrimaryUserID && t2.push(Pu(e2.primaryUserID, false, new Uint8Array([this.isPrimaryUserID ? 1 : 0]))), null !== this.policyURI && t2.push(Pu(e2.policyURI, false, de.encodeUTF8(this.policyURI))), null !== this.keyFlags && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.keyFlags)), t2.push(Pu(e2.keyFlags, true, r2))), null !== this.signersUserID && t2.push(Pu(e2.signersUserID, false, de.encodeUTF8(this.signersUserID))), null !== this.reasonForRevocationFlag && (r2 = de.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString), t2.push(Pu(e2.reasonForRevocation, true, r2))), null !== this.features && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.features)), t2.push(Pu(e2.features, false, r2))), null !== this.signatureTargetPublicKeyAlgorithm && (r2 = [new Uint8Array([this.signatureTargetPublicKeyAlgorithm, this.signatureTargetHashAlgorithm])], r2.push(de.stringToUint8Array(this.signatureTargetHash)), r2 = de.concat(r2), t2.push(Pu(e2.signatureTarget, true, r2))), null !== this.embeddedSignature && t2.push(Pu(e2.embeddedSignature, true, this.embeddedSignature.write())), null !== this.issuerFingerprint && (r2 = [new Uint8Array([this.issuerKeyVersion]), this.issuerFingerprint], r2 = de.concat(r2), t2.push(Pu(e2.issuerFingerprint, 5 === this.version, r2))), null !== this.preferredAEADAlgorithms && (r2 = de.stringToUint8Array(de.uint8ArrayToString(this.preferredAEADAlgorithms)), t2.push(Pu(e2.preferredAEADAlgorithms, false, r2)));
        const i2 = de.concat(t2), n2 = de.writeNumber(i2.length, 2);
        return de.concat([n2, i2]);
      }
      writeUnhashedSubPackets() {
        const e2 = [];
        this.unhashedSubpackets.forEach((t3) => {
          e2.push(Pn(t3.length)), e2.push(t3);
        });
        const t2 = de.concat(e2), r2 = de.writeNumber(t2.length, 2);
        return de.concat([r2, t2]);
      }
      readSubPacket(e2, t2 = true) {
        let r2 = 0;
        const i2 = !!(128 & e2[r2]), n2 = 127 & e2[r2];
        if (t2 || (this.unhashedSubpackets.push(e2.subarray(r2, e2.length)), Su.has(n2)))
          switch (r2++, n2) {
            case ue.signatureSubpacket.signatureCreationTime:
              this.created = de.readDate(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.signatureExpirationTime: {
              const t3 = de.readNumber(e2.subarray(r2, e2.length));
              this.signatureNeverExpires = 0 === t3, this.signatureExpirationTime = t3;
              break;
            }
            case ue.signatureSubpacket.exportableCertification:
              this.exportable = 1 === e2[r2++];
              break;
            case ue.signatureSubpacket.trustSignature:
              this.trustLevel = e2[r2++], this.trustAmount = e2[r2++];
              break;
            case ue.signatureSubpacket.regularExpression:
              this.regularExpression = e2[r2];
              break;
            case ue.signatureSubpacket.revocable:
              this.revocable = 1 === e2[r2++];
              break;
            case ue.signatureSubpacket.keyExpirationTime: {
              const t3 = de.readNumber(e2.subarray(r2, e2.length));
              this.keyExpirationTime = t3, this.keyNeverExpires = 0 === t3;
              break;
            }
            case ue.signatureSubpacket.preferredSymmetricAlgorithms:
              this.preferredSymmetricAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.revocationKey:
              this.revocationKeyClass = e2[r2++], this.revocationKeyAlgorithm = e2[r2++], this.revocationKeyFingerprint = e2.subarray(r2, r2 + 20);
              break;
            case ue.signatureSubpacket.issuer:
              this.issuerKeyID.read(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.notationData: {
              const t3 = !!(128 & e2[r2]);
              r2 += 4;
              const n3 = de.readNumber(e2.subarray(r2, r2 + 2));
              r2 += 2;
              const a2 = de.readNumber(e2.subarray(r2, r2 + 2));
              r2 += 2;
              const s2 = de.decodeUTF8(e2.subarray(r2, r2 + n3)), o2 = e2.subarray(r2 + n3, r2 + n3 + a2);
              this.rawNotations.push({ name: s2, humanReadable: t3, value: o2, critical: i2 }), t3 && (this.notations[s2] = de.decodeUTF8(o2));
              break;
            }
            case ue.signatureSubpacket.preferredHashAlgorithms:
              this.preferredHashAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.preferredCompressionAlgorithms:
              this.preferredCompressionAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.keyServerPreferences:
              this.keyServerPreferences = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.preferredKeyServer:
              this.preferredKeyServer = de.decodeUTF8(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.primaryUserID:
              this.isPrimaryUserID = 0 !== e2[r2++];
              break;
            case ue.signatureSubpacket.policyURI:
              this.policyURI = de.decodeUTF8(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.keyFlags:
              this.keyFlags = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.signersUserID:
              this.signersUserID = de.decodeUTF8(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.reasonForRevocation:
              this.reasonForRevocationFlag = e2[r2++], this.reasonForRevocationString = de.decodeUTF8(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.features:
              this.features = [...e2.subarray(r2, e2.length)];
              break;
            case ue.signatureSubpacket.signatureTarget: {
              this.signatureTargetPublicKeyAlgorithm = e2[r2++], this.signatureTargetHashAlgorithm = e2[r2++];
              const t3 = Ia.getHashByteLength(this.signatureTargetHashAlgorithm);
              this.signatureTargetHash = de.uint8ArrayToString(e2.subarray(r2, r2 + t3));
              break;
            }
            case ue.signatureSubpacket.embeddedSignature:
              this.embeddedSignature = new _Eu(), this.embeddedSignature.read(e2.subarray(r2, e2.length));
              break;
            case ue.signatureSubpacket.issuerFingerprint:
              this.issuerKeyVersion = e2[r2++], this.issuerFingerprint = e2.subarray(r2, e2.length), 5 === this.issuerKeyVersion ? this.issuerKeyID.read(this.issuerFingerprint) : this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));
              break;
            case ue.signatureSubpacket.preferredAEADAlgorithms:
              this.preferredAEADAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            default: {
              const e3 = Error("Unknown signature subpacket type " + n2);
              if (i2)
                throw e3;
              de.printDebug(e3);
            }
          }
      }
      readSubPackets(e2, t2 = true, r2) {
        const i2 = de.readNumber(e2.subarray(0, 2));
        let n2 = 2;
        for (; n2 < 2 + i2; ) {
          const i3 = En(e2.subarray(n2, e2.length));
          n2 += i3.offset, this.readSubPacket(e2.subarray(n2, n2 + i3.len), t2, r2), n2 += i3.len;
        }
        return n2;
      }
      toSign(e2, t2) {
        const r2 = ue.signature;
        switch (e2) {
          case r2.binary:
            return null !== t2.text ? de.encodeUTF8(t2.getText(true)) : t2.getBytes(true);
          case r2.text: {
            const e3 = t2.getBytes(true);
            return de.canonicalizeEOL(e3);
          }
          case r2.standalone:
            return new Uint8Array(0);
          case r2.certGeneric:
          case r2.certPersona:
          case r2.certCasual:
          case r2.certPositive:
          case r2.certRevocation: {
            let e3, i2;
            if (t2.userID)
              i2 = 180, e3 = t2.userID;
            else {
              if (!t2.userAttribute)
                throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");
              i2 = 209, e3 = t2.userAttribute;
            }
            const n2 = e3.write();
            return de.concat([this.toSign(r2.key, t2), new Uint8Array([i2]), de.writeNumber(n2.length, 4), n2]);
          }
          case r2.subkeyBinding:
          case r2.subkeyRevocation:
          case r2.keyBinding:
            return de.concat([this.toSign(r2.key, t2), this.toSign(r2.key, { key: t2.bind })]);
          case r2.key:
            if (void 0 === t2.key)
              throw Error("Key packet is required for this signature.");
            return t2.key.writeForHash(this.version);
          case r2.keyRevocation:
            return this.toSign(r2.key, t2);
          case r2.timestamp:
            return new Uint8Array(0);
          case r2.thirdParty:
            throw Error("Not implemented");
          default:
            throw Error("Unknown signature type.");
        }
      }
      calculateTrailer(e2, t2) {
        let r2 = 0;
        return X(J(this.signatureData), (e3) => {
          r2 += e3.length;
        }, () => {
          const i2 = [];
          return 5 !== this.version || this.signatureType !== ue.signature.binary && this.signatureType !== ue.signature.text || (t2 ? i2.push(new Uint8Array(6)) : i2.push(e2.writeHeader())), i2.push(new Uint8Array([this.version, 255])), 5 === this.version && i2.push(new Uint8Array(4)), i2.push(de.writeNumber(r2, 4)), de.concat(i2);
        });
      }
      toHash(e2, t2, r2 = false) {
        const i2 = this.toSign(e2, t2);
        return de.concat([i2, this.signatureData, this.calculateTrailer(t2, r2)]);
      }
      async hash(e2, t2, r2, i2 = false) {
        return r2 || (r2 = this.toHash(e2, t2, i2)), Ia.hash.digest(this.hashAlgorithm, r2);
      }
      async verify(e2, t2, r2, i2 = /* @__PURE__ */ new Date(), n2 = false, a2 = we) {
        if (!this.issuerKeyID.equals(e2.getKeyID()))
          throw Error("Signature was not issued by the given public key");
        if (this.publicKeyAlgorithm !== e2.algorithm)
          throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");
        const s2 = t2 === ue.signature.binary || t2 === ue.signature.text;
        if (!(this[Au] && !s2)) {
          let i3, a3;
          if (this.hashed ? a3 = await this.hashed : (i3 = this.toHash(t2, r2, n2), a3 = await this.hash(t2, r2, i3)), a3 = await ie(a3), this.signedHashValue[0] !== a3[0] || this.signedHashValue[1] !== a3[1])
            throw Error("Signed digest did not match");
          if (this.params = await this.params, this[Au] = await Ia.signature.verify(this.publicKeyAlgorithm, this.hashAlgorithm, this.params, e2.publicParams, i3, a3), !this[Au])
            throw Error("Signature verification failed");
        }
        const o2 = de.normalizeDate(i2);
        if (o2 && this.created > o2)
          throw Error("Signature creation time is in the future");
        if (o2 && o2 >= this.getExpirationTime())
          throw Error("Signature is expired");
        if (a2.rejectHashAlgorithms.has(this.hashAlgorithm))
          throw Error("Insecure hash algorithm: " + ue.read(ue.hash, this.hashAlgorithm).toUpperCase());
        if (a2.rejectMessageHashAlgorithms.has(this.hashAlgorithm) && [ue.signature.binary, ue.signature.text].includes(this.signatureType))
          throw Error("Insecure message hash algorithm: " + ue.read(ue.hash, this.hashAlgorithm).toUpperCase());
        if (this.rawNotations.forEach(({ name: e3, critical: t3 }) => {
          if (t3 && a2.knownNotations.indexOf(e3) < 0)
            throw Error("Unknown critical notation: " + e3);
        }), null !== this.revocationKeyClass)
          throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.");
      }
      isExpired(e2 = /* @__PURE__ */ new Date()) {
        const t2 = de.normalizeDate(e2);
        return null !== t2 && !(this.created <= t2 && t2 < this.getExpirationTime());
      }
      getExpirationTime() {
        return this.signatureNeverExpires ? 1 / 0 : new Date(this.created.getTime() + 1e3 * this.signatureExpirationTime);
      }
    };
    function Pu(e2, t2, r2) {
      const i2 = [];
      return i2.push(Pn(r2.length + 1)), i2.push(new Uint8Array([(t2 ? 128 : 0) | e2])), i2.push(r2), de.concat(i2);
    }
    var xu = class {
      static get tag() {
        return ue.packet.onePassSignature;
      }
      constructor() {
        this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.issuerKeyID = null, this.flags = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], 3 !== this.version)
          throw new Un(`Version ${this.version} of the one-pass signature packet is unsupported.`);
        return this.signatureType = e2[t2++], this.hashAlgorithm = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.issuerKeyID = new Ke(), this.issuerKeyID.read(e2.subarray(t2, t2 + 8)), t2 += 8, this.flags = e2[t2++], this;
      }
      write() {
        const e2 = new Uint8Array([3, this.signatureType, this.hashAlgorithm, this.publicKeyAlgorithm]), t2 = new Uint8Array([this.flags]);
        return de.concatUint8Array([e2, this.issuerKeyID.write(), t2]);
      }
      calculateTrailer(...e2) {
        return ae(async () => Eu.prototype.calculateTrailer.apply(await this.correspondingSig, e2));
      }
      async verify() {
        const e2 = await this.correspondingSig;
        if (!e2 || e2.constructor.tag !== ue.packet.signature)
          throw Error("Corresponding signature packet missing");
        if (e2.signatureType !== this.signatureType || e2.hashAlgorithm !== this.hashAlgorithm || e2.publicKeyAlgorithm !== this.publicKeyAlgorithm || !e2.issuerKeyID.equals(this.issuerKeyID))
          throw Error("Corresponding signature packet does not match one-pass signature packet");
        return e2.hashed = this.hashed, e2.verify.apply(e2, arguments);
      }
    };
    function Mu(e2, t2) {
      if (!t2[e2]) {
        let t3;
        try {
          t3 = ue.read(ue.packet, e2);
        } catch (t4) {
          throw new Un("Unknown packet type with tag: " + e2);
        }
        throw Error("Packet not allowed in this context: " + t3);
      }
      return new t2[e2]();
    }
    xu.prototype.hash = Eu.prototype.hash, xu.prototype.toHash = Eu.prototype.toHash, xu.prototype.toSign = Eu.prototype.toSign;
    var Ku = class _Ku extends Array {
      static async fromBinary(e2, t2, r2 = we) {
        const i2 = new _Ku();
        return await i2.read(e2, t2, r2), i2;
      }
      async read(e2, t2, r2 = we) {
        r2.additionalAllowedPackets.length && (t2 = { ...t2, ...de.constructAllowedPackets(r2.additionalAllowedPackets) }), this.stream = Y(e2, async (e3, i3) => {
          const n2 = G(i3);
          try {
            for (; ; ) {
              await n2.ready;
              if (await Dn(e3, async (e4) => {
                try {
                  if (e4.tag === ue.packet.marker || e4.tag === ue.packet.trust)
                    return;
                  const i4 = Mu(e4.tag, t2);
                  i4.packets = new _Ku(), i4.fromStream = de.isStream(e4.packet), await i4.read(e4.packet, r2), await n2.write(i4);
                } catch (t3) {
                  const i4 = !r2.ignoreUnsupportedPackets && t3 instanceof Un, a2 = !(r2.ignoreMalformedPackets || t3 instanceof Un);
                  if (i4 || a2 || Cn(e4.tag))
                    await n2.abort(t3);
                  else {
                    const t4 = new Rn(e4.tag, e4.packet);
                    await n2.write(t4);
                  }
                  de.printDebugError(t3);
                }
              }))
                return await n2.ready, void await n2.close();
            }
          } catch (e4) {
            await n2.abort(e4);
          }
        });
        const i2 = W(this.stream);
        for (; ; ) {
          const { done: e3, value: t3 } = await i2.read();
          if (e3 ? this.stream = null : this.push(t3), e3 || Cn(t3.constructor.tag))
            break;
        }
        i2.releaseLock();
      }
      write() {
        const e2 = [];
        for (let t2 = 0; t2 < this.length; t2++) {
          const r2 = this[t2] instanceof Rn ? this[t2].tag : this[t2].constructor.tag, i2 = this[t2].write();
          if (de.isStream(i2) && Cn(this[t2].constructor.tag)) {
            let t3 = [], n2 = 0;
            const a2 = 512;
            e2.push(Mn(r2)), e2.push(X(i2, (e3) => {
              if (t3.push(e3), n2 += e3.length, n2 >= a2) {
                const e4 = Math.min(Math.log(n2) / Math.LN2 | 0, 30), r3 = 2 ** e4, i3 = de.concat([xn(e4)].concat(t3));
                return t3 = [i3.subarray(1 + r3)], n2 = t3[0].length, i3.subarray(0, 1 + r3);
              }
            }, () => de.concat([Pn(n2)].concat(t3))));
          } else {
            if (de.isStream(i2)) {
              let t3 = 0;
              e2.push(X(J(i2), (e3) => {
                t3 += e3.length;
              }, () => Kn(r2, t3)));
            } else
              e2.push(Kn(r2, i2.length));
            e2.push(i2);
          }
        }
        return de.concat(e2);
      }
      filterByTag(...e2) {
        const t2 = new _Ku(), r2 = (e3) => (t3) => e3 === t3;
        for (let i2 = 0; i2 < this.length; i2++)
          e2.some(r2(this[i2].constructor.tag)) && t2.push(this[i2]);
        return t2;
      }
      findPacket(e2) {
        return this.find((t2) => t2.constructor.tag === e2);
      }
      indexOfTag(...e2) {
        const t2 = [], r2 = this, i2 = (e3) => (t3) => e3 === t3;
        for (let n2 = 0; n2 < this.length; n2++)
          e2.some(i2(r2[n2].constructor.tag)) && t2.push(n2);
        return t2;
      }
    };
    var Cu = /* @__PURE__ */ de.constructAllowedPackets([ku, xu, Eu]);
    var Du = class {
      static get tag() {
        return ue.packet.compressedData;
      }
      constructor(e2 = we) {
        this.packets = null, this.algorithm = e2.preferredCompressionAlgorithm, this.compressed = null, this.deflateLevel = e2.deflateLevel;
      }
      async read(e2, t2 = we) {
        await Q(e2, async (e3) => {
          this.algorithm = await e3.readByte(), this.compressed = e3.remainder(), await this.decompress(t2);
        });
      }
      write() {
        return null === this.compressed && this.compress(), de.concat([new Uint8Array([this.algorithm]), this.compressed]);
      }
      async decompress(e2 = we) {
        const t2 = ue.read(ue.compression, this.algorithm), r2 = qu[t2];
        if (!r2)
          throw Error(t2 + " decompression not supported");
        this.packets = await Ku.fromBinary(r2(this.compressed), Cu, e2);
      }
      compress() {
        const e2 = ue.read(ue.compression, this.algorithm), t2 = zu[e2];
        if (!t2)
          throw Error(e2 + " compression not supported");
        this.compressed = t2(this.packets.write(), this.deflateLevel);
      }
    };
    var Uu = de.getNodeZlib();
    function Ru(e2) {
      return e2;
    }
    function Iu(e2, t2, r2 = {}) {
      return function(i2) {
        return !de.isStream(i2) || _(i2) ? ae(() => ie(i2).then((t3) => new Promise((i3, n2) => {
          e2(t3, r2, (e3, t4) => {
            if (e3)
              return n2(e3);
            i3(t4);
          });
        }))) : C(D(i2).pipe(t2(r2)));
      };
    }
    function Bu(e2, t2 = {}) {
      return function(r2) {
        const i2 = new e2(t2);
        return X(r2, (e3) => {
          if (e3.length)
            return i2.push(e3, Ga), i2.result;
        }, () => {
          if (e2 === Qo)
            return i2.push([], $a), i2.result;
        });
      };
    }
    function Tu(e2) {
      return function(t2) {
        return ae(async () => e2(await ie(t2)));
      };
    }
    var zu = Uu ? { zip: (e2, t2) => Iu(Uu.deflateRaw, Uu.createDeflateRaw, { level: t2 })(e2), zlib: (e2, t2) => Iu(Uu.deflate, Uu.createDeflate, { level: t2 })(e2) } : { zip: (e2, t2) => Bu(Qo, { raw: true, level: t2 })(e2), zlib: (e2, t2) => Bu(Qo, { level: t2 })(e2) };
    var qu = Uu ? { uncompressed: Ru, zip: /* @__PURE__ */ Iu(Uu.inflateRaw, Uu.createInflateRaw), zlib: /* @__PURE__ */ Iu(Uu.inflate, Uu.createInflate), bzip2: /* @__PURE__ */ Tu(_u) } : { uncompressed: Ru, zip: /* @__PURE__ */ Bu(su, { raw: true }), zlib: /* @__PURE__ */ Bu(su), bzip2: /* @__PURE__ */ Tu(_u) };
    var Fu = /* @__PURE__ */ de.constructAllowedPackets([ku, Du, xu, Eu]);
    var Ou = class {
      static get tag() {
        return ue.packet.symEncryptedIntegrityProtectedData;
      }
      constructor() {
        this.version = 1, this.encrypted = null, this.packets = null;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte();
          if (1 !== t2)
            throw new Un(`Version ${t2} of the SEIP packet is unsupported.`);
          this.encrypted = e3.remainder();
        });
      }
      write() {
        return de.concat([new Uint8Array([1]), this.encrypted]);
      }
      async encrypt(e2, t2, r2 = we) {
        const { blockSize: i2 } = Ia.getCipher(e2);
        let n2 = this.packets.write();
        _(n2) && (n2 = await ie(n2));
        const a2 = await Ia.getPrefixRandom(e2), s2 = new Uint8Array([211, 20]), o2 = de.concat([a2, n2, s2]), c2 = await Ia.hash.sha1(ee(o2)), u2 = de.concat([o2, c2]);
        return this.encrypted = await Ia.mode.cfb.encrypt(e2, t2, u2, new Uint8Array(i2), r2), true;
      }
      async decrypt(e2, t2, r2 = we) {
        const { blockSize: i2 } = Ia.getCipher(e2);
        let n2 = J(this.encrypted);
        _(n2) && (n2 = await ie(n2));
        const a2 = await Ia.mode.cfb.decrypt(e2, t2, n2, new Uint8Array(i2)), s2 = re(ee(a2), -20), o2 = re(a2, 0, -20), c2 = Promise.all([ie(await Ia.hash.sha1(ee(o2))), ie(s2)]).then(([e3, t3]) => {
          if (!de.equalsUint8Array(e3, t3))
            throw Error("Modification detected.");
          return new Uint8Array();
        }), u2 = re(o2, i2 + 2);
        let h2 = re(u2, 0, -2);
        return h2 = H([h2, ae(() => c2)]), de.isStream(n2) && r2.allowUnauthenticatedStream || (h2 = await ie(h2)), this.packets = await Ku.fromBinary(h2, Fu, r2), true;
      }
    };
    var Lu = /* @__PURE__ */ de.constructAllowedPackets([ku, Du, xu, Eu]);
    var Nu = class _Nu {
      static get tag() {
        return ue.packet.aeadEncryptedData;
      }
      constructor() {
        this.version = 1, this.cipherAlgorithm = null, this.aeadAlgorithm = ue.aead.eax, this.chunkSizeByte = null, this.iv = null, this.encrypted = null, this.packets = null;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte();
          if (1 !== t2)
            throw new Un(`Version ${t2} of the AEAD-encrypted data packet is not supported.`);
          this.cipherAlgorithm = await e3.readByte(), this.aeadAlgorithm = await e3.readByte(), this.chunkSizeByte = await e3.readByte();
          const r2 = Ia.getAEADMode(this.aeadAlgorithm);
          this.iv = await e3.readBytes(r2.ivLength), this.encrypted = e3.remainder();
        });
      }
      write() {
        return de.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.iv, this.encrypted]);
      }
      async decrypt(e2, t2, r2 = we) {
        this.packets = await Ku.fromBinary(await this.crypt("decrypt", t2, J(this.encrypted)), Lu, r2);
      }
      async encrypt(e2, t2, r2 = we) {
        this.cipherAlgorithm = e2;
        const { ivLength: i2 } = Ia.getAEADMode(this.aeadAlgorithm);
        this.iv = Ia.random.getRandomBytes(i2), this.chunkSizeByte = r2.aeadChunkSizeByte;
        const n2 = this.packets.write();
        this.encrypted = await this.crypt("encrypt", t2, n2);
      }
      async crypt(e2, t2, r2) {
        const i2 = Ia.getAEADMode(this.aeadAlgorithm), n2 = await i2(this.cipherAlgorithm, t2), a2 = "decrypt" === e2 ? i2.tagLength : 0, s2 = "encrypt" === e2 ? i2.tagLength : 0, o2 = 2 ** (this.chunkSizeByte + 6) + a2, c2 = new ArrayBuffer(21), u2 = new Uint8Array(c2, 0, 13), h2 = new Uint8Array(c2), d2 = new DataView(c2), f2 = new Uint8Array(c2, 5, 8);
        u2.set([192 | _Nu.tag, this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte], 0);
        let l2 = 0, p2 = Promise.resolve(), y2 = 0, b2 = 0;
        const g2 = this.iv;
        return Y(r2, async (t3, r3) => {
          if ("array" !== de.isStream(t3)) {
            const e3 = new F({}, { highWaterMark: de.getHardwareConcurrency() * 2 ** (this.chunkSizeByte + 6), size: (e4) => e4.length });
            V(e3.readable, r3), r3 = e3.writable;
          }
          const c3 = W(t3), m2 = G(r3);
          try {
            for (; ; ) {
              let t4 = await c3.readBytes(o2 + a2) || new Uint8Array();
              const r4 = t4.subarray(t4.length - a2);
              let w2, v2;
              if (t4 = t4.subarray(0, t4.length - a2), !l2 || t4.length ? (c3.unshift(r4), w2 = n2[e2](t4, i2.getNonce(g2, f2), u2), b2 += t4.length - a2 + s2) : (d2.setInt32(17, y2), w2 = n2[e2](r4, i2.getNonce(g2, f2), h2), b2 += s2, v2 = true), y2 += t4.length - a2, p2 = p2.then(() => w2).then(async (e3) => {
                await m2.ready, await m2.write(e3), b2 -= e3.length;
              }).catch((e3) => m2.abort(e3)), (v2 || b2 > m2.desiredSize) && await p2, v2) {
                await m2.close();
                break;
              }
              d2.setInt32(9, ++l2);
            }
          } catch (e3) {
            await m2.abort(e3);
          }
        });
      }
    };
    var ju = class {
      static get tag() {
        return ue.packet.publicKeyEncryptedSessionKey;
      }
      constructor() {
        this.version = 3, this.publicKeyID = new Ke(), this.publicKeyAlgorithm = null, this.sessionKey = null, this.sessionKeyAlgorithm = null, this.encrypted = {};
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], 3 !== this.version)
          throw new Un(`Version ${this.version} of the PKESK packet is unsupported.`);
        t2 += this.publicKeyID.read(e2.subarray(t2)), this.publicKeyAlgorithm = e2[t2++], this.encrypted = Ia.parseEncSessionKeyParams(this.publicKeyAlgorithm, e2.subarray(t2), this.version), this.publicKeyAlgorithm === ue.publicKey.x25519 && (this.sessionKeyAlgorithm = ue.write(ue.symmetric, this.encrypted.C.algorithm));
      }
      write() {
        const e2 = [new Uint8Array([this.version]), this.publicKeyID.write(), new Uint8Array([this.publicKeyAlgorithm]), Ia.serializeParams(this.publicKeyAlgorithm, this.encrypted)];
        return de.concatUint8Array(e2);
      }
      async encrypt(e2) {
        const t2 = ue.write(ue.publicKey, this.publicKeyAlgorithm), r2 = Hu(this.version, t2, this.sessionKeyAlgorithm, this.sessionKey);
        this.encrypted = await Ia.publicKeyEncrypt(t2, this.sessionKeyAlgorithm, e2.publicParams, r2, e2.getFingerprintBytes());
      }
      async decrypt(e2, t2) {
        if (this.publicKeyAlgorithm !== e2.algorithm)
          throw Error("Decryption error");
        const r2 = t2 ? Hu(this.version, this.publicKeyAlgorithm, t2.sessionKeyAlgorithm, t2.sessionKey) : null, i2 = await Ia.publicKeyDecrypt(this.publicKeyAlgorithm, e2.publicParams, e2.privateParams, this.encrypted, e2.getFingerprintBytes(), r2), { sessionKey: n2, sessionKeyAlgorithm: a2 } = function(e3, t3, r3, i3) {
          switch (t3) {
            case ue.publicKey.rsaEncrypt:
            case ue.publicKey.rsaEncryptSign:
            case ue.publicKey.elgamal:
            case ue.publicKey.ecdh: {
              const e4 = r3.subarray(0, r3.length - 2), t4 = r3.subarray(r3.length - 2), n3 = de.writeChecksum(e4.subarray(e4.length % 8)), a3 = n3[0] === t4[0] & n3[1] === t4[1], s2 = { sessionKeyAlgorithm: e4[0], sessionKey: e4.subarray(1) };
              if (i3) {
                const e5 = a3 & s2.sessionKeyAlgorithm === i3.sessionKeyAlgorithm & s2.sessionKey.length === i3.sessionKey.length;
                return { sessionKey: de.selectUint8Array(e5, s2.sessionKey, i3.sessionKey), sessionKeyAlgorithm: de.selectUint8(e5, s2.sessionKeyAlgorithm, i3.sessionKeyAlgorithm) };
              }
              if (a3 && ue.read(ue.symmetric, s2.sessionKeyAlgorithm))
                return s2;
              throw Error("Decryption error");
            }
            case ue.publicKey.x25519:
              return { sessionKey: r3 };
            default:
              throw Error("Unsupported public key algorithm");
          }
        }(this.version, this.publicKeyAlgorithm, i2, t2);
        this.publicKeyAlgorithm !== ue.publicKey.x25519 && (this.sessionKeyAlgorithm = a2), this.sessionKey = n2;
      }
    };
    function Hu(e2, t2, r2, i2) {
      switch (t2) {
        case ue.publicKey.rsaEncrypt:
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.elgamal:
        case ue.publicKey.ecdh:
          return de.concatUint8Array([new Uint8Array([r2]), i2, de.writeChecksum(i2.subarray(i2.length % 8))]);
        case ue.publicKey.x25519:
          return i2;
        default:
          throw Error("Unsupported public key algorithm");
      }
    }
    var Wu = class {
      constructor(e2 = we) {
        this.algorithm = ue.hash.sha256, this.type = "iterated", this.c = e2.s2kIterationCountByte, this.salt = null;
      }
      getCount() {
        return 16 + (15 & this.c) << 6 + (this.c >> 4);
      }
      read(e2) {
        let t2 = 0;
        try {
          this.type = ue.read(ue.s2k, e2[t2++]);
        } catch (e3) {
          throw new Un("Unknown S2K type.");
        }
        switch (this.algorithm = e2[t2++], this.type) {
          case "simple":
            break;
          case "salted":
            this.salt = e2.subarray(t2, t2 + 8), t2 += 8;
            break;
          case "iterated":
            this.salt = e2.subarray(t2, t2 + 8), t2 += 8, this.c = e2[t2++];
            break;
          case "gnu":
            if ("GNU" !== de.uint8ArrayToString(e2.subarray(t2, t2 + 3)))
              throw new Un("Unknown s2k type.");
            t2 += 3;
            if (1001 !== 1e3 + e2[t2++])
              throw new Un("Unknown s2k gnu protection mode.");
            this.type = "gnu-dummy";
            break;
          default:
            throw new Un("Unknown s2k type.");
        }
        return t2;
      }
      write() {
        if ("gnu-dummy" === this.type)
          return new Uint8Array([101, 0, ...de.stringToUint8Array("GNU"), 1]);
        const e2 = [new Uint8Array([ue.write(ue.s2k, this.type), this.algorithm])];
        switch (this.type) {
          case "simple":
            break;
          case "salted":
            e2.push(this.salt);
            break;
          case "iterated":
            e2.push(this.salt), e2.push(new Uint8Array([this.c]));
            break;
          case "gnu":
            throw Error("GNU s2k type not supported.");
          default:
            throw Error("Unknown s2k type.");
        }
        return de.concatUint8Array(e2);
      }
      async produceKey(e2, t2) {
        e2 = de.encodeUTF8(e2);
        const r2 = [];
        let i2 = 0, n2 = 0;
        for (; i2 < t2; ) {
          let t3;
          switch (this.type) {
            case "simple":
              t3 = de.concatUint8Array([new Uint8Array(n2), e2]);
              break;
            case "salted":
              t3 = de.concatUint8Array([new Uint8Array(n2), this.salt, e2]);
              break;
            case "iterated": {
              const r3 = de.concatUint8Array([this.salt, e2]);
              let i3 = r3.length;
              const a3 = Math.max(this.getCount(), i3);
              t3 = new Uint8Array(n2 + a3), t3.set(r3, n2);
              for (let e3 = n2 + i3; e3 < a3; e3 += i3, i3 *= 2)
                t3.copyWithin(e3, n2, e3);
              break;
            }
            case "gnu":
              throw Error("GNU s2k type not supported.");
            default:
              throw Error("Unknown s2k type.");
          }
          const a2 = await Ia.hash.digest(this.algorithm, t3);
          r2.push(a2), i2 += a2.length, n2++;
        }
        return de.concatUint8Array(r2).subarray(0, t2);
      }
    };
    var Gu = class _Gu {
      static get tag() {
        return ue.packet.symEncryptedSessionKey;
      }
      constructor(e2 = we) {
        this.version = e2.aeadProtect ? 5 : 4, this.sessionKey = null, this.sessionKeyEncryptionAlgorithm = null, this.sessionKeyAlgorithm = ue.symmetric.aes256, this.aeadAlgorithm = ue.write(ue.aead, e2.preferredAEADAlgorithm), this.encrypted = null, this.s2k = null, this.iv = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], 4 !== this.version && 5 !== this.version)
          throw new Un(`Version ${this.version} of the SKESK packet is unsupported.`);
        const r2 = e2[t2++];
        if (5 === this.version && (this.aeadAlgorithm = e2[t2++]), this.s2k = new Wu(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), 5 === this.version) {
          const r3 = Ia.getAEADMode(this.aeadAlgorithm);
          this.iv = e2.subarray(t2, t2 += r3.ivLength);
        }
        5 === this.version || t2 < e2.length ? (this.encrypted = e2.subarray(t2, e2.length), this.sessionKeyEncryptionAlgorithm = r2) : this.sessionKeyAlgorithm = r2;
      }
      write() {
        const e2 = null === this.encrypted ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;
        let t2;
        return 5 === this.version ? t2 = de.concatUint8Array([new Uint8Array([this.version, e2, this.aeadAlgorithm]), this.s2k.write(), this.iv, this.encrypted]) : (t2 = de.concatUint8Array([new Uint8Array([this.version, e2]), this.s2k.write()]), null !== this.encrypted && (t2 = de.concatUint8Array([t2, this.encrypted]))), t2;
      }
      async decrypt(e2) {
        const t2 = null !== this.sessionKeyEncryptionAlgorithm ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm, { blockSize: r2, keySize: i2 } = Ia.getCipher(t2), n2 = await this.s2k.produceKey(e2, i2);
        if (5 === this.version) {
          const e3 = Ia.getAEADMode(this.aeadAlgorithm), r3 = new Uint8Array([192 | _Gu.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), i3 = await e3(t2, n2);
          this.sessionKey = await i3.decrypt(this.encrypted, this.iv, r3);
        } else if (null !== this.encrypted) {
          const e3 = await Ia.mode.cfb.decrypt(t2, n2, this.encrypted, new Uint8Array(r2));
          this.sessionKeyAlgorithm = ue.write(ue.symmetric, e3[0]), this.sessionKey = e3.subarray(1, e3.length);
        } else
          this.sessionKey = n2;
      }
      async encrypt(e2, t2 = we) {
        const r2 = null !== this.sessionKeyEncryptionAlgorithm ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;
        this.sessionKeyEncryptionAlgorithm = r2, this.s2k = new Wu(t2), this.s2k.salt = Ia.random.getRandomBytes(8);
        const { blockSize: i2, keySize: n2 } = Ia.getCipher(r2), a2 = await this.s2k.produceKey(e2, n2);
        if (null === this.sessionKey && (this.sessionKey = Ia.generateSessionKey(this.sessionKeyAlgorithm)), 5 === this.version) {
          const e3 = Ia.getAEADMode(this.aeadAlgorithm);
          this.iv = Ia.random.getRandomBytes(e3.ivLength);
          const t3 = new Uint8Array([192 | _Gu.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), i3 = await e3(r2, a2);
          this.encrypted = await i3.encrypt(this.sessionKey, this.iv, t3);
        } else {
          const e3 = de.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]), this.sessionKey]);
          this.encrypted = await Ia.mode.cfb.encrypt(r2, a2, e3, new Uint8Array(i2), t2);
        }
      }
    };
    var Vu = class _Vu {
      static get tag() {
        return ue.packet.publicKey;
      }
      constructor(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        this.version = t2.v5Keys ? 5 : 4, this.created = de.normalizeDate(e2), this.algorithm = null, this.publicParams = null, this.expirationTimeV3 = 0, this.fingerprint = null, this.keyID = null;
      }
      static fromSecretKeyPacket(e2) {
        const t2 = new _Vu(), { version: r2, created: i2, algorithm: n2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
        return t2.version = r2, t2.created = i2, t2.algorithm = n2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
      }
      async read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], 4 === this.version || 5 === this.version) {
          this.created = de.readDate(e2.subarray(t2, t2 + 4)), t2 += 4, this.algorithm = e2[t2++], 5 === this.version && (t2 += 4);
          const { read: r2, publicParams: i2 } = Ia.parsePublicKeyParams(this.algorithm, e2.subarray(t2));
          return this.publicParams = i2, t2 += r2, await this.computeFingerprintAndKeyID(), t2;
        }
        throw new Un(`Version ${this.version} of the key packet is unsupported.`);
      }
      write() {
        const e2 = [];
        e2.push(new Uint8Array([this.version])), e2.push(de.writeDate(this.created)), e2.push(new Uint8Array([this.algorithm]));
        const t2 = Ia.serializeParams(this.algorithm, this.publicParams);
        return 5 === this.version && e2.push(de.writeNumber(t2.length, 4)), e2.push(t2), de.concatUint8Array(e2);
      }
      writeForHash(e2) {
        const t2 = this.writePublicKey();
        return 5 === e2 ? de.concatUint8Array([new Uint8Array([154]), de.writeNumber(t2.length, 4), t2]) : de.concatUint8Array([new Uint8Array([153]), de.writeNumber(t2.length, 2), t2]);
      }
      isDecrypted() {
        return null;
      }
      getCreationTime() {
        return this.created;
      }
      getKeyID() {
        return this.keyID;
      }
      async computeFingerprintAndKeyID() {
        if (await this.computeFingerprint(), this.keyID = new Ke(), 5 === this.version)
          this.keyID.read(this.fingerprint.subarray(0, 8));
        else {
          if (4 !== this.version)
            throw Error("Unsupported key version");
          this.keyID.read(this.fingerprint.subarray(12, 20));
        }
      }
      async computeFingerprint() {
        const e2 = this.writeForHash(this.version);
        if (5 === this.version)
          this.fingerprint = await Ia.hash.sha256(e2);
        else {
          if (4 !== this.version)
            throw Error("Unsupported key version");
          this.fingerprint = await Ia.hash.sha1(e2);
        }
      }
      getFingerprintBytes() {
        return this.fingerprint;
      }
      getFingerprint() {
        return de.uint8ArrayToHex(this.getFingerprintBytes());
      }
      hasSameFingerprintAs(e2) {
        return this.version === e2.version && de.equalsUint8Array(this.writePublicKey(), e2.writePublicKey());
      }
      getAlgorithmInfo() {
        const e2 = {};
        e2.algorithm = ue.read(ue.publicKey, this.algorithm);
        const t2 = this.publicParams.n || this.publicParams.p;
        return t2 ? e2.bits = de.uint8ArrayBitLength(t2) : this.publicParams.oid && (e2.curve = this.publicParams.oid.getName()), e2;
      }
    };
    Vu.prototype.readPublicKey = Vu.prototype.read, Vu.prototype.writePublicKey = Vu.prototype.write;
    var $u = /* @__PURE__ */ de.constructAllowedPackets([ku, Du, xu, Eu]);
    var Zu = class {
      static get tag() {
        return ue.packet.symmetricallyEncryptedData;
      }
      constructor() {
        this.encrypted = null, this.packets = null;
      }
      read(e2) {
        this.encrypted = e2;
      }
      write() {
        return this.encrypted;
      }
      async decrypt(e2, t2, r2 = we) {
        if (!r2.allowUnauthenticatedMessages)
          throw Error("Message is not authenticated.");
        const { blockSize: i2 } = Ia.getCipher(e2), n2 = await ie(J(this.encrypted)), a2 = await Ia.mode.cfb.decrypt(e2, t2, n2.subarray(i2 + 2), n2.subarray(2, i2 + 2));
        this.packets = await Ku.fromBinary(a2, $u, r2);
      }
      async encrypt(e2, t2, r2 = we) {
        const i2 = this.packets.write(), { blockSize: n2 } = Ia.getCipher(e2), a2 = await Ia.getPrefixRandom(e2), s2 = await Ia.mode.cfb.encrypt(e2, t2, a2, new Uint8Array(n2), r2), o2 = await Ia.mode.cfb.encrypt(e2, t2, i2, s2.subarray(2), r2);
        this.encrypted = de.concat([s2, o2]);
      }
    };
    var Xu = class _Xu extends Vu {
      static get tag() {
        return ue.packet.publicSubkey;
      }
      constructor(e2, t2) {
        super(e2, t2);
      }
      static fromSecretSubkeyPacket(e2) {
        const t2 = new _Xu(), { version: r2, created: i2, algorithm: n2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
        return t2.version = r2, t2.created = i2, t2.algorithm = n2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
      }
    };
    var Yu = class _Yu {
      static get tag() {
        return ue.packet.userAttribute;
      }
      constructor() {
        this.attributes = [];
      }
      read(e2) {
        let t2 = 0;
        for (; t2 < e2.length; ) {
          const r2 = En(e2.subarray(t2, e2.length));
          t2 += r2.offset, this.attributes.push(de.uint8ArrayToString(e2.subarray(t2, t2 + r2.len))), t2 += r2.len;
        }
      }
      write() {
        const e2 = [];
        for (let t2 = 0; t2 < this.attributes.length; t2++)
          e2.push(Pn(this.attributes[t2].length)), e2.push(de.stringToUint8Array(this.attributes[t2]));
        return de.concatUint8Array(e2);
      }
      equals(e2) {
        return !!(e2 && e2 instanceof _Yu) && this.attributes.every(function(t2, r2) {
          return t2 === e2.attributes[r2];
        });
      }
    };
    var Qu = class extends Vu {
      static get tag() {
        return ue.packet.secretKey;
      }
      constructor(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        super(e2, t2), this.keyMaterial = null, this.isEncrypted = null, this.s2kUsage = 0, this.s2k = null, this.symmetric = null, this.aead = null, this.privateParams = null;
      }
      async read(e2) {
        let t2 = await this.readPublicKey(e2);
        const r2 = t2;
        this.s2kUsage = e2[t2++], 5 === this.version && t2++;
        try {
          if (255 === this.s2kUsage || 254 === this.s2kUsage || 253 === this.s2kUsage) {
            if (this.symmetric = e2[t2++], 253 === this.s2kUsage && (this.aead = e2[t2++]), this.s2k = new Wu(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), "gnu-dummy" === this.s2k.type)
              return;
          } else
            this.s2kUsage && (this.symmetric = this.s2kUsage);
          this.s2kUsage && (this.iv = e2.subarray(t2, t2 + Ia.getCipher(this.symmetric).blockSize), t2 += this.iv.length);
        } catch (t3) {
          if (!this.s2kUsage)
            throw t3;
          this.unparseableKeyMaterial = e2.subarray(r2), this.isEncrypted = true;
        }
        if (5 === this.version && (t2 += 4), this.keyMaterial = e2.subarray(t2), this.isEncrypted = !!this.s2kUsage, !this.isEncrypted) {
          const e3 = this.keyMaterial.subarray(0, -2);
          if (!de.equalsUint8Array(de.writeChecksum(e3), this.keyMaterial.subarray(-2)))
            throw Error("Key checksum mismatch");
          try {
            const { privateParams: t3 } = Ia.parsePrivateKeyParams(this.algorithm, e3, this.publicParams);
            this.privateParams = t3;
          } catch (e4) {
            if (e4 instanceof Un)
              throw e4;
            throw Error("Error reading MPIs");
          }
        }
      }
      write() {
        const e2 = this.writePublicKey();
        if (this.unparseableKeyMaterial)
          return de.concatUint8Array([e2, this.unparseableKeyMaterial]);
        const t2 = [e2];
        t2.push(new Uint8Array([this.s2kUsage]));
        const r2 = [];
        return 255 !== this.s2kUsage && 254 !== this.s2kUsage && 253 !== this.s2kUsage || (r2.push(this.symmetric), 253 === this.s2kUsage && r2.push(this.aead), r2.push(...this.s2k.write())), this.s2kUsage && "gnu-dummy" !== this.s2k.type && r2.push(...this.iv), 5 === this.version && t2.push(new Uint8Array([r2.length])), t2.push(new Uint8Array(r2)), this.isDummy() || (this.s2kUsage || (this.keyMaterial = Ia.serializeParams(this.algorithm, this.privateParams)), 5 === this.version && t2.push(de.writeNumber(this.keyMaterial.length, 4)), t2.push(this.keyMaterial), this.s2kUsage || t2.push(de.writeChecksum(this.keyMaterial))), de.concatUint8Array(t2);
      }
      isDecrypted() {
        return false === this.isEncrypted;
      }
      isMissingSecretKeyMaterial() {
        return void 0 !== this.unparseableKeyMaterial || this.isDummy();
      }
      isDummy() {
        return !(!this.s2k || "gnu-dummy" !== this.s2k.type);
      }
      makeDummy(e2 = we) {
        this.isDummy() || (this.isDecrypted() && this.clearPrivateParams(), delete this.unparseableKeyMaterial, this.isEncrypted = null, this.keyMaterial = null, this.s2k = new Wu(e2), this.s2k.algorithm = 0, this.s2k.c = 0, this.s2k.type = "gnu-dummy", this.s2kUsage = 254, this.symmetric = ue.symmetric.aes256);
      }
      async encrypt(e2, t2 = we) {
        if (this.isDummy())
          return;
        if (!this.isDecrypted())
          throw Error("Key packet is already encrypted");
        if (!e2)
          throw Error("A non-empty passphrase is required for key encryption.");
        this.s2k = new Wu(t2), this.s2k.salt = Ia.random.getRandomBytes(8);
        const r2 = Ia.serializeParams(this.algorithm, this.privateParams);
        this.symmetric = ue.symmetric.aes256;
        const i2 = await Ju(this.s2k, e2, this.symmetric), { blockSize: n2 } = Ia.getCipher(this.symmetric);
        if (this.iv = Ia.random.getRandomBytes(n2), t2.aeadProtect) {
          this.s2kUsage = 253, this.aead = ue.aead.eax;
          const e3 = Ia.getAEADMode(this.aead), t3 = await e3(this.symmetric, i2);
          this.keyMaterial = await t3.encrypt(r2, this.iv.subarray(0, e3.ivLength), new Uint8Array());
        } else
          this.s2kUsage = 254, this.keyMaterial = await Ia.mode.cfb.encrypt(this.symmetric, i2, de.concatUint8Array([r2, await Ia.hash.sha1(r2, t2)]), this.iv, t2);
      }
      async decrypt(e2) {
        if (this.isDummy())
          return false;
        if (this.unparseableKeyMaterial)
          throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");
        if (this.isDecrypted())
          throw Error("Key packet is already decrypted.");
        let t2, r2;
        if (254 !== this.s2kUsage && 253 !== this.s2kUsage)
          throw 255 === this.s2kUsage ? Error("Encrypted private key is authenticated using an insecure two-byte hash") : Error("Private key is encrypted using an insecure S2K function: unsalted MD5");
        if (t2 = await Ju(this.s2k, e2, this.symmetric), 253 === this.s2kUsage) {
          const e3 = Ia.getAEADMode(this.aead), i2 = await e3(this.symmetric, t2);
          try {
            r2 = await i2.decrypt(this.keyMaterial, this.iv.subarray(0, e3.ivLength), new Uint8Array());
          } catch (e4) {
            if ("Authentication tag mismatch" === e4.message)
              throw Error("Incorrect key passphrase: " + e4.message);
            throw e4;
          }
        } else {
          const e3 = await Ia.mode.cfb.decrypt(this.symmetric, t2, this.keyMaterial, this.iv);
          r2 = e3.subarray(0, -20);
          const i2 = await Ia.hash.sha1(r2);
          if (!de.equalsUint8Array(i2, e3.subarray(-20)))
            throw Error("Incorrect key passphrase");
        }
        try {
          const { privateParams: e3 } = Ia.parsePrivateKeyParams(this.algorithm, r2, this.publicParams);
          this.privateParams = e3;
        } catch (e3) {
          throw Error("Error reading MPIs");
        }
        this.isEncrypted = false, this.keyMaterial = null, this.s2kUsage = 0;
      }
      async validate() {
        if (this.isDummy())
          return;
        if (!this.isDecrypted())
          throw Error("Key is not decrypted");
        let e2;
        try {
          e2 = await Ia.validateParams(this.algorithm, this.publicParams, this.privateParams);
        } catch (t2) {
          e2 = false;
        }
        if (!e2)
          throw Error("Key is invalid");
      }
      async generate(e2, t2) {
        const { privateParams: r2, publicParams: i2 } = await Ia.generateParams(this.algorithm, e2, t2);
        this.privateParams = r2, this.publicParams = i2, this.isEncrypted = false;
      }
      clearPrivateParams() {
        this.isMissingSecretKeyMaterial() || (Object.keys(this.privateParams).forEach((e2) => {
          this.privateParams[e2].fill(0), delete this.privateParams[e2];
        }), this.privateParams = null, this.isEncrypted = true);
      }
    };
    async function Ju(e2, t2, r2) {
      const { keySize: i2 } = Ia.getCipher(r2);
      return e2.produceKey(t2, i2);
    }
    var eh = mt(function(e2) {
      !function(t2) {
        function r2(e3) {
          function t3() {
            return Ae2 < Se2;
          }
          function r3() {
            return Ae2;
          }
          function n2(e4) {
            Ae2 = e4;
          }
          function a2() {
            Ae2 = 0, Se2 = ke2.length;
          }
          function s2(e4, t4) {
            return { name: e4, tokens: t4 || "", semantic: t4 || "", children: [] };
          }
          function o2(e4, t4) {
            var r4;
            return null === t4 ? null : ((r4 = s2(e4)).tokens = t4.tokens, r4.semantic = t4.semantic, r4.children.push(t4), r4);
          }
          function c2(e4, t4) {
            return null !== t4 && (e4.tokens += t4.tokens, e4.semantic += t4.semantic), e4.children.push(t4), e4;
          }
          function u2(e4) {
            var r4;
            return t3() && e4(r4 = ke2[Ae2]) ? (Ae2 += 1, s2("token", r4)) : null;
          }
          function h2(e4) {
            return function() {
              return o2("literal", u2(function(t4) {
                return t4 === e4;
              }));
            };
          }
          function d2() {
            var e4 = arguments;
            return function() {
              var t4, i3, a3, o3;
              for (o3 = r3(), i3 = s2("and"), t4 = 0; t4 < e4.length; t4 += 1) {
                if (null === (a3 = e4[t4]()))
                  return n2(o3), null;
                c2(i3, a3);
              }
              return i3;
            };
          }
          function f2() {
            var e4 = arguments;
            return function() {
              var t4, i3, a3;
              for (a3 = r3(), t4 = 0; t4 < e4.length; t4 += 1) {
                if (null !== (i3 = e4[t4]()))
                  return i3;
                n2(a3);
              }
              return null;
            };
          }
          function l2(e4) {
            return function() {
              var t4, i3;
              return i3 = r3(), null !== (t4 = e4()) ? t4 : (n2(i3), s2("opt"));
            };
          }
          function p2(e4) {
            return function() {
              var t4 = e4();
              return null !== t4 && (t4.semantic = ""), t4;
            };
          }
          function y2(e4) {
            return function() {
              var t4 = e4();
              return null !== t4 && t4.semantic.length > 0 && (t4.semantic = " "), t4;
            };
          }
          function b2(e4, t4) {
            return function() {
              var i3, a3, o3, u3, h3;
              for (u3 = r3(), i3 = s2("star"), o3 = 0, h3 = void 0 === t4 ? 0 : t4; null !== (a3 = e4()); )
                o3 += 1, c2(i3, a3);
              return o3 >= h3 ? i3 : (n2(u3), null);
            };
          }
          function g2(e4) {
            return e4.charCodeAt(0) >= 128;
          }
          function m2() {
            return o2("cr", h2("\r")());
          }
          function w2() {
            return o2("crlf", d2(m2, k2)());
          }
          function v2() {
            return o2("dquote", h2('"')());
          }
          function _2() {
            return o2("htab", h2("	")());
          }
          function k2() {
            return o2("lf", h2("\n")());
          }
          function A2() {
            return o2("sp", h2(" ")());
          }
          function S2() {
            return o2("vchar", u2(function(t4) {
              var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 126;
              return e3.rfc6532 && (i3 = i3 || g2(t4)), i3;
            }));
          }
          function E2() {
            return o2("wsp", f2(A2, _2)());
          }
          function P2() {
            var e4 = o2("quoted-pair", f2(d2(h2("\\"), f2(S2, E2)), ie2)());
            return null === e4 ? null : (e4.semantic = e4.semantic[1], e4);
          }
          function x2() {
            return o2("fws", f2(ae2, d2(l2(d2(b2(E2), p2(w2))), b2(E2, 1)))());
          }
          function M2() {
            return o2("ctext", f2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 39 || 42 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || g2(t4)), i3;
              });
            }, te2)());
          }
          function K2() {
            return o2("ccontent", f2(M2, P2, C2)());
          }
          function C2() {
            return o2("comment", d2(h2("("), b2(d2(l2(x2), K2)), l2(x2), h2(")"))());
          }
          function D2() {
            return o2("cfws", f2(d2(b2(d2(l2(x2), C2), 1), l2(x2)), x2)());
          }
          function U2() {
            return o2("atext", u2(function(t4) {
              var r4 = "a" <= t4 && t4 <= "z" || "A" <= t4 && t4 <= "Z" || "0" <= t4 && t4 <= "9" || ["!", "#", "$", "%", "&", "'", "*", "+", "-", "/", "=", "?", "^", "_", "`", "{", "|", "}", "~"].indexOf(t4) >= 0;
              return e3.rfc6532 && (r4 = r4 || g2(t4)), r4;
            }));
          }
          function R2() {
            return o2("atom", d2(y2(l2(D2)), b2(U2, 1), y2(l2(D2)))());
          }
          function I2() {
            var e4, t4;
            return null === (e4 = o2("dot-atom-text", b2(U2, 1)())) || null !== (t4 = b2(d2(h2("."), b2(U2, 1)))()) && c2(e4, t4), e4;
          }
          function B2() {
            return o2("dot-atom", d2(p2(l2(D2)), I2, p2(l2(D2)))());
          }
          function T2() {
            return o2("qtext", f2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = 33 === r4 || 35 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || g2(t4)), i3;
              });
            }, re2)());
          }
          function z2() {
            return o2("qcontent", f2(T2, P2)());
          }
          function q2() {
            return o2("quoted-string", d2(p2(l2(D2)), p2(v2), b2(d2(l2(y2(x2)), z2)), l2(p2(x2)), p2(v2), p2(l2(D2)))());
          }
          function F2() {
            return o2("word", f2(R2, q2)());
          }
          function O2() {
            return o2("address", f2(L2, H2)());
          }
          function L2() {
            return o2("mailbox", f2(N2, J2)());
          }
          function N2() {
            return o2("name-addr", d2(l2(W2), j2)());
          }
          function j2() {
            return o2("angle-addr", f2(d2(p2(l2(D2)), h2("<"), J2, h2(">"), p2(l2(D2))), se2)());
          }
          function H2() {
            return o2("group", d2(W2, h2(":"), l2($2), h2(";"), p2(l2(D2)))());
          }
          function W2() {
            return o2("display-name", (null !== (e4 = o2("phrase", f2(ne2, b2(F2, 1))())) && (e4.semantic = function(e5) {
              return e5.replace(/([ \t]|\r\n)+/g, " ").replace(/^\s*/, "").replace(/\s*$/, "");
            }(e4.semantic)), e4));
            var e4;
          }
          function G2() {
            return o2("mailbox-list", f2(d2(L2, b2(d2(h2(","), L2))), ue2)());
          }
          function V2() {
            return o2("address-list", f2(d2(O2, b2(d2(h2(","), O2))), he2)());
          }
          function $2() {
            return o2("group-list", f2(G2, p2(D2), de2)());
          }
          function Z2() {
            return o2("local-part", f2(fe2, B2, q2)());
          }
          function X2() {
            return o2("dtext", f2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 90 || 94 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || g2(t4)), i3;
              });
            }, pe2)());
          }
          function Y2() {
            return o2("domain-literal", d2(p2(l2(D2)), h2("["), b2(d2(l2(x2), X2)), l2(x2), h2("]"), p2(l2(D2)))());
          }
          function Q2() {
            return o2("domain", (t4 = f2(le2, B2, Y2)(), e3.rejectTLD && t4 && t4.semantic && t4.semantic.indexOf(".") < 0 ? null : (t4 && (t4.semantic = t4.semantic.replace(/\s+/g, "")), t4)));
            var t4;
          }
          function J2() {
            return o2("addr-spec", d2(Z2, h2("@"), Q2)());
          }
          function ee2() {
            return e3.strict ? null : o2("obs-NO-WS-CTL", u2(function(e4) {
              var t4 = e4.charCodeAt(0);
              return 1 <= t4 && t4 <= 8 || 11 === t4 || 12 === t4 || 14 <= t4 && t4 <= 31 || 127 === t4;
            }));
          }
          function te2() {
            return e3.strict ? null : o2("obs-ctext", ee2());
          }
          function re2() {
            return e3.strict ? null : o2("obs-qtext", ee2());
          }
          function ie2() {
            return e3.strict ? null : o2("obs-qp", d2(h2("\\"), f2(h2("\0"), ee2, k2, m2))());
          }
          function ne2() {
            return e3.strict ? null : e3.atInDisplayName ? o2("obs-phrase", d2(F2, b2(f2(F2, h2("."), h2("@"), y2(D2))))()) : o2("obs-phrase", d2(F2, b2(f2(F2, h2("."), y2(D2))))());
          }
          function ae2() {
            return e3.strict ? null : o2("obs-FWS", b2(d2(p2(l2(w2)), E2), 1)());
          }
          function se2() {
            return e3.strict ? null : o2("obs-angle-addr", d2(p2(l2(D2)), h2("<"), oe2, J2, h2(">"), p2(l2(D2)))());
          }
          function oe2() {
            return e3.strict ? null : o2("obs-route", d2(ce2, h2(":"))());
          }
          function ce2() {
            return e3.strict ? null : o2("obs-domain-list", d2(b2(f2(p2(D2), h2(","))), h2("@"), Q2, b2(d2(h2(","), p2(l2(D2)), l2(d2(h2("@"), Q2)))))());
          }
          function ue2() {
            return e3.strict ? null : o2("obs-mbox-list", d2(b2(d2(p2(l2(D2)), h2(","))), L2, b2(d2(h2(","), l2(d2(L2, p2(D2))))))());
          }
          function he2() {
            return e3.strict ? null : o2("obs-addr-list", d2(b2(d2(p2(l2(D2)), h2(","))), O2, b2(d2(h2(","), l2(d2(O2, p2(D2))))))());
          }
          function de2() {
            return e3.strict ? null : o2("obs-group-list", d2(b2(d2(p2(l2(D2)), h2(",")), 1), p2(l2(D2)))());
          }
          function fe2() {
            return e3.strict ? null : o2("obs-local-part", d2(F2, b2(d2(h2("."), F2)))());
          }
          function le2() {
            return e3.strict ? null : o2("obs-domain", d2(R2, b2(d2(h2("."), R2)))());
          }
          function pe2() {
            return e3.strict ? null : o2("obs-dtext", f2(ee2, P2)());
          }
          function ye2(e4, t4) {
            var r4, i3, n3;
            if (null == t4)
              return null;
            for (i3 = [t4]; i3.length > 0; ) {
              if ((n3 = i3.pop()).name === e4)
                return n3;
              for (r4 = n3.children.length - 1; r4 >= 0; r4 -= 1)
                i3.push(n3.children[r4]);
            }
            return null;
          }
          function be2(e4, t4) {
            var r4, i3, n3, a3, s3;
            if (null == t4)
              return null;
            for (i3 = [t4], a3 = [], s3 = {}, r4 = 0; r4 < e4.length; r4 += 1)
              s3[e4[r4]] = true;
            for (; i3.length > 0; )
              if ((n3 = i3.pop()).name in s3)
                a3.push(n3);
              else
                for (r4 = n3.children.length - 1; r4 >= 0; r4 -= 1)
                  i3.push(n3.children[r4]);
            return a3;
          }
          function ge2(t4) {
            var r4, i3, n3, a3, s3;
            if (null === t4)
              return null;
            for (r4 = [], i3 = be2(["group", "mailbox"], t4), n3 = 0; n3 < i3.length; n3 += 1)
              "group" === (a3 = i3[n3]).name ? r4.push(me2(a3)) : "mailbox" === a3.name && r4.push(we2(a3));
            return s3 = { ast: t4, addresses: r4 }, e3.simple && (s3 = function(e4) {
              var t5;
              if (e4 && e4.addresses)
                for (t5 = 0; t5 < e4.addresses.length; t5 += 1)
                  delete e4.addresses[t5].node;
              return e4;
            }(s3)), e3.oneResult ? function(t5) {
              if (!t5)
                return null;
              if (!e3.partial && t5.addresses.length > 1)
                return null;
              return t5.addresses && t5.addresses[0];
            }(s3) : e3.simple ? s3 && s3.addresses : s3;
          }
          function me2(e4) {
            var t4, r4 = ye2("display-name", e4), i3 = [], n3 = be2(["mailbox"], e4);
            for (t4 = 0; t4 < n3.length; t4 += 1)
              i3.push(we2(n3[t4]));
            return { node: e4, parts: { name: r4 }, type: e4.name, name: ve2(r4), addresses: i3 };
          }
          function we2(e4) {
            var t4 = ye2("display-name", e4), r4 = ye2("addr-spec", e4), i3 = function(e5, t5) {
              var r5, i4, n4, a4;
              if (null == t5)
                return null;
              for (i4 = [t5], a4 = []; i4.length > 0; )
                for ((n4 = i4.pop()).name === e5 && a4.push(n4), r5 = n4.children.length - 1; r5 >= 0; r5 -= 1)
                  i4.push(n4.children[r5]);
              return a4;
            }("cfws", e4), n3 = be2(["comment"], e4), a3 = ye2("local-part", r4), s3 = ye2("domain", r4);
            return { node: e4, parts: { name: t4, address: r4, local: a3, domain: s3, comments: i3 }, type: e4.name, name: ve2(t4), address: ve2(r4), local: ve2(a3), domain: ve2(s3), comments: _e2(n3), groupName: ve2(e4.groupName) };
          }
          function ve2(e4) {
            return null != e4 ? e4.semantic : null;
          }
          function _e2(e4) {
            var t4 = "";
            if (e4)
              for (var r4 = 0; r4 < e4.length; r4 += 1)
                t4 += ve2(e4[r4]);
            return t4;
          }
          var ke2, Ae2, Se2, Ee2, Pe2;
          if (null === (e3 = i2(e3, {})))
            return null;
          if (ke2 = e3.input, Pe2 = { address: O2, "address-list": V2, "angle-addr": j2, from: function() {
            return o2("from", f2(G2, V2)());
          }, group: H2, mailbox: L2, "mailbox-list": G2, "reply-to": function() {
            return o2("reply-to", V2());
          }, sender: function() {
            return o2("sender", f2(L2, O2)());
          } }[e3.startAt] || V2, !e3.strict) {
            if (a2(), e3.strict = true, Ee2 = Pe2(ke2), e3.partial || !t3())
              return ge2(Ee2);
            e3.strict = false;
          }
          return a2(), Ee2 = Pe2(ke2), !e3.partial && t3() ? null : ge2(Ee2);
        }
        function i2(e3, t3) {
          function r3(e4) {
            return "[object String]" === Object.prototype.toString.call(e4);
          }
          function i3(e4) {
            return null == e4;
          }
          var n2, a2;
          if (r3(e3))
            e3 = { input: e3 };
          else if (!function(e4) {
            return e4 === Object(e4);
          }(e3))
            return null;
          if (!r3(e3.input))
            return null;
          if (!t3)
            return null;
          for (a2 in n2 = { oneResult: false, partial: false, rejectTLD: false, rfc6532: false, simple: false, startAt: "address-list", strict: false, atInDisplayName: false })
            i3(e3[a2]) && (e3[a2] = i3(t3[a2]) ? n2[a2] : t3[a2]);
          return e3;
        }
        r2.parseOneAddress = function(e3) {
          return r2(i2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "address-list" }));
        }, r2.parseAddressList = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "address-list" }));
        }, r2.parseFrom = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "from" }));
        }, r2.parseSender = function(e3) {
          return r2(i2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "sender" }));
        }, r2.parseReplyTo = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "reply-to" }));
        }, e2.exports = r2;
      }();
    });
    var th = class _th {
      static get tag() {
        return ue.packet.userID;
      }
      constructor() {
        this.userID = "", this.name = "", this.email = "", this.comment = "";
      }
      static fromObject(e2) {
        if (de.isString(e2) || e2.name && !de.isString(e2.name) || e2.email && !de.isEmailAddress(e2.email) || e2.comment && !de.isString(e2.comment))
          throw Error("Invalid user ID format");
        const t2 = new _th();
        Object.assign(t2, e2);
        const r2 = [];
        return t2.name && r2.push(t2.name), t2.comment && r2.push(`(${t2.comment})`), t2.email && r2.push(`<${t2.email}>`), t2.userID = r2.join(" "), t2;
      }
      read(e2, t2 = we) {
        const r2 = de.decodeUTF8(e2);
        if (r2.length > t2.maxUserIDLength)
          throw Error("User ID string is too long");
        try {
          const { name: e3, address: t3, comments: i2 } = eh.parseOneAddress({ input: r2, atInDisplayName: true });
          this.comment = i2.replace(/^\(|\)$/g, ""), this.name = e3, this.email = t3;
        } catch (e3) {
        }
        this.userID = r2;
      }
      write() {
        return de.encodeUTF8(this.userID);
      }
      equals(e2) {
        return e2 && e2.userID === this.userID;
      }
    };
    var rh = class extends Qu {
      static get tag() {
        return ue.packet.secretSubkey;
      }
      constructor(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        super(e2, t2);
      }
    };
    var ih = /* @__PURE__ */ de.constructAllowedPackets([Eu]);
    var nh = class {
      constructor(e2) {
        this.packets = e2 || new Ku();
      }
      write() {
        return this.packets.write();
      }
      armor(e2 = we) {
        return Me(ue.armor.signature, this.write(), void 0, void 0, void 0, e2);
      }
      getSigningKeyIDs() {
        return this.packets.map((e2) => e2.issuerKeyID);
      }
    };
    async function ah(e2, t2) {
      const r2 = new rh(e2.date, t2);
      return r2.packets = null, r2.algorithm = ue.write(ue.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve), await r2.computeFingerprintAndKeyID(), r2;
    }
    async function sh(e2, t2) {
      const r2 = new Qu(e2.date, t2);
      return r2.packets = null, r2.algorithm = ue.write(ue.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve, e2.config), await r2.computeFingerprintAndKeyID(), r2;
    }
    async function oh(e2, t2, r2, i2, n2 = /* @__PURE__ */ new Date(), a2) {
      let s2, o2;
      for (let c2 = e2.length - 1; c2 >= 0; c2--)
        try {
          (!s2 || e2[c2].created >= s2.created) && (await e2[c2].verify(t2, r2, i2, n2, void 0, a2), s2 = e2[c2]);
        } catch (e3) {
          o2 = e3;
        }
      if (!s2)
        throw de.wrapError(`Could not find valid ${ue.read(ue.signature, r2)} signature in key ${t2.getKeyID().toHex()}`.replace("certGeneric ", "self-").replace(/([a-z])([A-Z])/g, (e3, t3, r3) => t3 + " " + r3.toLowerCase()), o2);
      return s2;
    }
    function ch(e2, t2, r2 = /* @__PURE__ */ new Date()) {
      const i2 = de.normalizeDate(r2);
      if (null !== i2) {
        const r3 = yh(e2, t2);
        return !(e2.created <= i2 && i2 < r3);
      }
      return false;
    }
    async function uh(e2, t2, r2, i2) {
      const n2 = {};
      n2.key = t2, n2.bind = e2;
      const a2 = { signatureType: ue.signature.subkeyBinding };
      r2.sign ? (a2.keyFlags = [ue.keyFlags.signData], a2.embeddedSignature = await fh(n2, null, e2, { signatureType: ue.signature.keyBinding }, r2.date, void 0, void 0, void 0, i2)) : a2.keyFlags = [ue.keyFlags.encryptCommunication | ue.keyFlags.encryptStorage], r2.keyExpirationTime > 0 && (a2.keyExpirationTime = r2.keyExpirationTime, a2.keyNeverExpires = false);
      return await fh(n2, null, t2, a2, r2.date, void 0, void 0, void 0, i2);
    }
    async function hh(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = {}, n2) {
      let a2 = n2.preferredHashAlgorithm, s2 = a2;
      if (e2) {
        const t3 = await e2.getPrimaryUser(r2, i2, n2);
        t3.selfCertification.preferredHashAlgorithms && ([s2] = t3.selfCertification.preferredHashAlgorithms, a2 = Ia.hash.getHashByteLength(a2) <= Ia.hash.getHashByteLength(s2) ? s2 : a2);
      }
      switch (t2.algorithm) {
        case ue.publicKey.ecdsa:
        case ue.publicKey.eddsaLegacy:
        case ue.publicKey.ed25519:
          s2 = Ia.getPreferredCurveHashAlgo(t2.algorithm, t2.publicParams.oid);
      }
      return Ia.hash.getHashByteLength(a2) <= Ia.hash.getHashByteLength(s2) ? s2 : a2;
    }
    async function dh(e2, t2 = [], r2 = /* @__PURE__ */ new Date(), i2 = [], n2 = we) {
      const a2 = { symmetric: ue.symmetric.aes128, aead: ue.aead.eax, compression: ue.compression.uncompressed }[e2], s2 = { symmetric: n2.preferredSymmetricAlgorithm, aead: n2.preferredAEADAlgorithm, compression: n2.preferredCompressionAlgorithm }[e2], o2 = { symmetric: "preferredSymmetricAlgorithms", aead: "preferredAEADAlgorithms", compression: "preferredCompressionAlgorithms" }[e2], c2 = await Promise.all(t2.map(async function(e3, t3) {
        const a3 = (await e3.getPrimaryUser(r2, i2[t3], n2)).selfCertification[o2];
        return !!a3 && a3.indexOf(s2) >= 0;
      }));
      return c2.every(Boolean) ? s2 : a2;
    }
    async function fh(e2, t2, r2, i2, n2, a2, s2 = [], o2 = false, c2) {
      if (r2.isDummy())
        throw Error("Cannot sign with a gnu-dummy key.");
      if (!r2.isDecrypted())
        throw Error("Signing key is not decrypted.");
      const u2 = new Eu();
      return Object.assign(u2, i2), u2.publicKeyAlgorithm = r2.algorithm, u2.hashAlgorithm = await hh(t2, r2, n2, a2, c2), u2.rawNotations = s2, await u2.sign(r2, e2, n2, o2), u2;
    }
    async function lh(e2, t2, r2, i2 = /* @__PURE__ */ new Date(), n2) {
      (e2 = e2[r2]) && (t2[r2].length ? await Promise.all(e2.map(async function(e3) {
        e3.isExpired(i2) || n2 && !await n2(e3) || t2[r2].some(function(t3) {
          return de.equalsUint8Array(t3.writeParams(), e3.writeParams());
        }) || t2[r2].push(e3);
      })) : t2[r2] = e2);
    }
    async function ph(e2, t2, r2, i2, n2, a2, s2 = /* @__PURE__ */ new Date(), o2) {
      a2 = a2 || e2;
      const c2 = [];
      return await Promise.all(i2.map(async function(e3) {
        try {
          n2 && !e3.issuerKeyID.equals(n2.issuerKeyID) || (await e3.verify(a2, t2, r2, o2.revocationsExpire ? s2 : null, false, o2), c2.push(e3.issuerKeyID));
        } catch (e4) {
        }
      })), n2 ? (n2.revoked = !!c2.some((e3) => e3.equals(n2.issuerKeyID)) || (n2.revoked || false), n2.revoked) : c2.length > 0;
    }
    function yh(e2, t2) {
      let r2;
      return false === t2.keyNeverExpires && (r2 = e2.created.getTime() + 1e3 * t2.keyExpirationTime), r2 ? new Date(r2) : 1 / 0;
    }
    function bh(e2, t2 = {}) {
      switch (e2.type = e2.type || t2.type, e2.curve = e2.curve || t2.curve, e2.rsaBits = e2.rsaBits || t2.rsaBits, e2.keyExpirationTime = void 0 !== e2.keyExpirationTime ? e2.keyExpirationTime : t2.keyExpirationTime, e2.passphrase = de.isString(e2.passphrase) ? e2.passphrase : t2.passphrase, e2.date = e2.date || t2.date, e2.sign = e2.sign || false, e2.type) {
        case "ecc":
          try {
            e2.curve = ue.write(ue.curve, e2.curve);
          } catch (e3) {
            throw Error("Unknown curve");
          }
          e2.curve !== ue.curve.ed25519Legacy && e2.curve !== ue.curve.curve25519Legacy || (e2.curve = e2.sign ? ue.curve.ed25519Legacy : ue.curve.curve25519Legacy), e2.sign ? e2.algorithm = e2.curve === ue.curve.ed25519Legacy ? ue.publicKey.eddsaLegacy : ue.publicKey.ecdsa : e2.algorithm = ue.publicKey.ecdh;
          break;
        case "rsa":
          e2.algorithm = ue.publicKey.rsaEncryptSign;
          break;
        default:
          throw Error("Unsupported key type " + e2.type);
      }
      return e2;
    }
    function gh(e2, t2) {
      const r2 = e2.algorithm;
      return r2 !== ue.publicKey.rsaEncrypt && r2 !== ue.publicKey.elgamal && r2 !== ue.publicKey.ecdh && r2 !== ue.publicKey.x25519 && (!t2.keyFlags || 0 != (t2.keyFlags[0] & ue.keyFlags.signData));
    }
    function mh(e2, t2) {
      const r2 = e2.algorithm;
      return r2 !== ue.publicKey.dsa && r2 !== ue.publicKey.rsaSign && r2 !== ue.publicKey.ecdsa && r2 !== ue.publicKey.eddsaLegacy && r2 !== ue.publicKey.ed25519 && (!t2.keyFlags || 0 != (t2.keyFlags[0] & ue.keyFlags.encryptCommunication) || 0 != (t2.keyFlags[0] & ue.keyFlags.encryptStorage));
    }
    function wh(e2, t2) {
      return !!t2.allowInsecureDecryptionWithSigningKeys || (!e2.keyFlags || 0 != (e2.keyFlags[0] & ue.keyFlags.encryptCommunication) || 0 != (e2.keyFlags[0] & ue.keyFlags.encryptStorage));
    }
    function vh(e2, t2) {
      const r2 = ue.write(ue.publicKey, e2.algorithm), i2 = e2.getAlgorithmInfo();
      if (t2.rejectPublicKeyAlgorithms.has(r2))
        throw Error(i2.algorithm + " keys are considered too weak.");
      switch (r2) {
        case ue.publicKey.rsaEncryptSign:
        case ue.publicKey.rsaSign:
        case ue.publicKey.rsaEncrypt:
          if (i2.bits < t2.minRSABits)
            throw Error(`RSA keys shorter than ${t2.minRSABits} bits are considered too weak.`);
          break;
        case ue.publicKey.ecdsa:
        case ue.publicKey.eddsaLegacy:
        case ue.publicKey.ecdh:
          if (t2.rejectCurves.has(i2.curve))
            throw Error(`Support for ${i2.algorithm} keys using curve ${i2.curve} is disabled.`);
      }
    }
    var _h = class __h {
      constructor(e2, t2) {
        this.userID = e2.constructor.tag === ue.packet.userID ? e2 : null, this.userAttribute = e2.constructor.tag === ue.packet.userAttribute ? e2 : null, this.selfCertifications = [], this.otherCertifications = [], this.revocationSignatures = [], this.mainKey = t2;
      }
      toPacketList() {
        const e2 = new Ku();
        return e2.push(this.userID || this.userAttribute), e2.push(...this.revocationSignatures), e2.push(...this.selfCertifications), e2.push(...this.otherCertifications), e2;
      }
      clone() {
        const e2 = new __h(this.userID || this.userAttribute, this.mainKey);
        return e2.selfCertifications = [...this.selfCertifications], e2.otherCertifications = [...this.otherCertifications], e2.revocationSignatures = [...this.revocationSignatures], e2;
      }
      async certify(e2, t2, r2) {
        const i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 }, a2 = new __h(n2.userID || n2.userAttribute, this.mainKey);
        return a2.otherCertifications = await Promise.all(e2.map(async function(e3) {
          if (!e3.isPrivate())
            throw Error("Need private key for signing");
          if (e3.hasSameFingerprintAs(i2))
            throw Error("The user's own key can only be used for self-certifications");
          const a3 = await e3.getSigningKey(void 0, t2, void 0, r2);
          return fh(n2, e3, a3.keyPacket, { signatureType: ue.signature.certGeneric, keyFlags: [ue.keyFlags.certifyKeys | ue.keyFlags.signData] }, t2, void 0, void 0, void 0, r2);
        })), await a2.update(this, t2, r2), a2;
      }
      async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        const n2 = this.mainKey.keyPacket;
        return ph(n2, ue.signature.certRevocation, { key: n2, userID: this.userID, userAttribute: this.userAttribute }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verifyCertificate(e2, t2, r2 = /* @__PURE__ */ new Date(), i2) {
        const n2 = this, a2 = this.mainKey.keyPacket, s2 = { userID: this.userID, userAttribute: this.userAttribute, key: a2 }, { issuerKeyID: o2 } = e2, c2 = t2.filter((e3) => e3.getKeys(o2).length > 0);
        return 0 === c2.length ? null : (await Promise.all(c2.map(async (t3) => {
          const a3 = await t3.getSigningKey(o2, e2.created, void 0, i2);
          if (e2.revoked || await n2.isRevoked(e2, a3.keyPacket, r2, i2))
            throw Error("User certificate is revoked");
          try {
            await e2.verify(a3.keyPacket, ue.signature.certGeneric, s2, r2, void 0, i2);
          } catch (e3) {
            throw de.wrapError("User certificate is invalid", e3);
          }
        })), true);
      }
      async verifyAllCertifications(e2, t2 = /* @__PURE__ */ new Date(), r2) {
        const i2 = this, n2 = this.selfCertifications.concat(this.otherCertifications);
        return Promise.all(n2.map(async (n3) => ({ keyID: n3.issuerKeyID, valid: await i2.verifyCertificate(n3, e2, t2, r2).catch(() => false) })));
      }
      async verify(e2 = /* @__PURE__ */ new Date(), t2) {
        if (!this.selfCertifications.length)
          throw Error("No self-certifications found");
        const r2 = this, i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 };
        let a2;
        for (let s2 = this.selfCertifications.length - 1; s2 >= 0; s2--)
          try {
            const a3 = this.selfCertifications[s2];
            if (a3.revoked || await r2.isRevoked(a3, void 0, e2, t2))
              throw Error("Self-certification is revoked");
            try {
              await a3.verify(i2, ue.signature.certGeneric, n2, e2, void 0, t2);
            } catch (e3) {
              throw de.wrapError("Self-certification is invalid", e3);
            }
            return true;
          } catch (e3) {
            a2 = e3;
          }
        throw a2;
      }
      async update(e2, t2, r2) {
        const i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 };
        await lh(e2, this, "selfCertifications", t2, async function(e3) {
          try {
            return await e3.verify(i2, ue.signature.certGeneric, n2, t2, false, r2), true;
          } catch (e4) {
            return false;
          }
        }), await lh(e2, this, "otherCertifications", t2), await lh(e2, this, "revocationSignatures", t2, function(e3) {
          return ph(i2, ue.signature.certRevocation, n2, [e3], void 0, void 0, t2, r2);
        });
      }
      async revoke(e2, { flag: t2 = ue.reasonForRevocation.noReason, string: r2 = "" } = {}, i2 = /* @__PURE__ */ new Date(), n2 = we) {
        const a2 = { userID: this.userID, userAttribute: this.userAttribute, key: e2 }, s2 = new __h(a2.userID || a2.userAttribute, this.mainKey);
        return s2.revocationSignatures.push(await fh(a2, null, e2, { signatureType: ue.signature.certRevocation, reasonForRevocationFlag: ue.write(ue.reasonForRevocation, t2), reasonForRevocationString: r2 }, i2, void 0, void 0, false, n2)), await s2.update(this), s2;
      }
    };
    var kh = class _kh {
      constructor(e2, t2) {
        this.keyPacket = e2, this.bindingSignatures = [], this.revocationSignatures = [], this.mainKey = t2;
      }
      toPacketList() {
        const e2 = new Ku();
        return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.bindingSignatures), e2;
      }
      clone() {
        const e2 = new _kh(this.keyPacket, this.mainKey);
        return e2.bindingSignatures = [...this.bindingSignatures], e2.revocationSignatures = [...this.revocationSignatures], e2;
      }
      async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        const n2 = this.mainKey.keyPacket;
        return ph(n2, ue.signature.subkeyRevocation, { key: n2, bind: this.keyPacket }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verify(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        const r2 = this.mainKey.keyPacket, i2 = { key: r2, bind: this.keyPacket }, n2 = await oh(this.bindingSignatures, r2, ue.signature.subkeyBinding, i2, e2, t2);
        if (n2.revoked || await this.isRevoked(n2, null, e2, t2))
          throw Error("Subkey is revoked");
        if (ch(this.keyPacket, n2, e2))
          throw Error("Subkey is expired");
        return n2;
      }
      async getExpirationTime(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        const r2 = this.mainKey.keyPacket, i2 = { key: r2, bind: this.keyPacket };
        let n2;
        try {
          n2 = await oh(this.bindingSignatures, r2, ue.signature.subkeyBinding, i2, e2, t2);
        } catch (e3) {
          return null;
        }
        const a2 = yh(this.keyPacket, n2), s2 = n2.getExpirationTime();
        return a2 < s2 ? a2 : s2;
      }
      async update(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = this.mainKey.keyPacket;
        if (!this.hasSameFingerprintAs(e2))
          throw Error("Subkey update method: fingerprints of subkeys not equal");
        this.keyPacket.constructor.tag === ue.packet.publicSubkey && e2.keyPacket.constructor.tag === ue.packet.secretSubkey && (this.keyPacket = e2.keyPacket);
        const n2 = this, a2 = { key: i2, bind: n2.keyPacket };
        await lh(e2, this, "bindingSignatures", t2, async function(e3) {
          for (let t3 = 0; t3 < n2.bindingSignatures.length; t3++)
            if (n2.bindingSignatures[t3].issuerKeyID.equals(e3.issuerKeyID))
              return e3.created > n2.bindingSignatures[t3].created && (n2.bindingSignatures[t3] = e3), false;
          try {
            return await e3.verify(i2, ue.signature.subkeyBinding, a2, t2, void 0, r2), true;
          } catch (e4) {
            return false;
          }
        }), await lh(e2, this, "revocationSignatures", t2, function(e3) {
          return ph(i2, ue.signature.subkeyRevocation, a2, [e3], void 0, void 0, t2, r2);
        });
      }
      async revoke(e2, { flag: t2 = ue.reasonForRevocation.noReason, string: r2 = "" } = {}, i2 = /* @__PURE__ */ new Date(), n2 = we) {
        const a2 = { key: e2, bind: this.keyPacket }, s2 = new _kh(this.keyPacket, this.mainKey);
        return s2.revocationSignatures.push(await fh(a2, null, e2, { signatureType: ue.signature.subkeyRevocation, reasonForRevocationFlag: ue.write(ue.reasonForRevocation, t2), reasonForRevocationString: r2 }, i2, void 0, void 0, false, n2)), await s2.update(this), s2;
      }
      hasSameFingerprintAs(e2) {
        return this.keyPacket.hasSameFingerprintAs(e2.keyPacket || e2);
      }
    };
    ["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "isDecrypted"].forEach((e2) => {
      kh.prototype[e2] = function() {
        return this.keyPacket[e2]();
      };
    });
    var Ah = /* @__PURE__ */ de.constructAllowedPackets([Eu]);
    var Sh = /* @__PURE__ */ new Set([ue.packet.publicKey, ue.packet.privateKey]);
    var Eh = /* @__PURE__ */ new Set([ue.packet.publicKey, ue.packet.privateKey, ue.packet.publicSubkey, ue.packet.privateSubkey]);
    var Ph = class {
      packetListToStructure(e2, t2 = /* @__PURE__ */ new Set()) {
        let r2, i2, n2, a2;
        for (const s2 of e2) {
          if (s2 instanceof Rn) {
            Eh.has(s2.tag) && !a2 && (a2 = Sh.has(s2.tag) ? Sh : Eh);
            continue;
          }
          const e3 = s2.constructor.tag;
          if (a2) {
            if (!a2.has(e3))
              continue;
            a2 = null;
          }
          if (t2.has(e3))
            throw Error("Unexpected packet type: " + e3);
          switch (e3) {
            case ue.packet.publicKey:
            case ue.packet.secretKey:
              if (this.keyPacket)
                throw Error("Key block contains multiple keys");
              if (this.keyPacket = s2, i2 = this.getKeyID(), !i2)
                throw Error("Missing Key ID");
              break;
            case ue.packet.userID:
            case ue.packet.userAttribute:
              r2 = new _h(s2, this), this.users.push(r2);
              break;
            case ue.packet.publicSubkey:
            case ue.packet.secretSubkey:
              r2 = null, n2 = new kh(s2, this), this.subkeys.push(n2);
              break;
            case ue.packet.signature:
              switch (s2.signatureType) {
                case ue.signature.certGeneric:
                case ue.signature.certPersona:
                case ue.signature.certCasual:
                case ue.signature.certPositive:
                  if (!r2) {
                    de.printDebug("Dropping certification signatures without preceding user packet");
                    continue;
                  }
                  s2.issuerKeyID.equals(i2) ? r2.selfCertifications.push(s2) : r2.otherCertifications.push(s2);
                  break;
                case ue.signature.certRevocation:
                  r2 ? r2.revocationSignatures.push(s2) : this.directSignatures.push(s2);
                  break;
                case ue.signature.key:
                  this.directSignatures.push(s2);
                  break;
                case ue.signature.subkeyBinding:
                  if (!n2) {
                    de.printDebug("Dropping subkey binding signature without preceding subkey packet");
                    continue;
                  }
                  n2.bindingSignatures.push(s2);
                  break;
                case ue.signature.keyRevocation:
                  this.revocationSignatures.push(s2);
                  break;
                case ue.signature.subkeyRevocation:
                  if (!n2) {
                    de.printDebug("Dropping subkey revocation signature without preceding subkey packet");
                    continue;
                  }
                  n2.revocationSignatures.push(s2);
              }
          }
        }
      }
      toPacketList() {
        const e2 = new Ku();
        return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.directSignatures), this.users.map((t2) => e2.push(...t2.toPacketList())), this.subkeys.map((t2) => e2.push(...t2.toPacketList())), e2;
      }
      clone(e2 = false) {
        const t2 = new this.constructor(this.toPacketList());
        return e2 && t2.getKeys().forEach((e3) => {
          if (e3.keyPacket = Object.create(Object.getPrototypeOf(e3.keyPacket), Object.getOwnPropertyDescriptors(e3.keyPacket)), !e3.keyPacket.isDecrypted())
            return;
          const t3 = {};
          Object.keys(e3.keyPacket.privateParams).forEach((r2) => {
            t3[r2] = new Uint8Array(e3.keyPacket.privateParams[r2]);
          }), e3.keyPacket.privateParams = t3;
        }), t2;
      }
      getSubkeys(e2 = null) {
        return this.subkeys.filter((t2) => !e2 || t2.getKeyID().equals(e2, true));
      }
      getKeys(e2 = null) {
        const t2 = [];
        return e2 && !this.getKeyID().equals(e2, true) || t2.push(this), t2.concat(this.getSubkeys(e2));
      }
      getKeyIDs() {
        return this.getKeys().map((e2) => e2.getKeyID());
      }
      getUserIDs() {
        return this.users.map((e2) => e2.userID ? e2.userID.userID : null).filter((e2) => null !== e2);
      }
      write() {
        return this.toPacketList().write();
      }
      async getSigningKey(e2 = null, t2 = /* @__PURE__ */ new Date(), r2 = {}, i2 = we) {
        await this.verifyPrimaryKey(t2, r2, i2);
        const n2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
        let s2;
        for (const r3 of a2)
          if (!e2 || r3.getKeyID().equals(e2))
            try {
              await r3.verify(t2, i2);
              const e3 = { key: n2, bind: r3.keyPacket }, a3 = await oh(r3.bindingSignatures, n2, ue.signature.subkeyBinding, e3, t2, i2);
              if (!gh(r3.keyPacket, a3))
                continue;
              if (!a3.embeddedSignature)
                throw Error("Missing embedded signature");
              return await oh([a3.embeddedSignature], r3.keyPacket, ue.signature.keyBinding, e3, t2, i2), vh(r3.keyPacket, i2), r3;
            } catch (e3) {
              s2 = e3;
            }
        try {
          const a3 = await this.getPrimaryUser(t2, r2, i2);
          if ((!e2 || n2.getKeyID().equals(e2)) && gh(n2, a3.selfCertification))
            return vh(n2, i2), this;
        } catch (e3) {
          s2 = e3;
        }
        throw de.wrapError("Could not find valid signing key packet in key " + this.getKeyID().toHex(), s2);
      }
      async getEncryptionKey(e2, t2 = /* @__PURE__ */ new Date(), r2 = {}, i2 = we) {
        await this.verifyPrimaryKey(t2, r2, i2);
        const n2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
        let s2;
        for (const r3 of a2)
          if (!e2 || r3.getKeyID().equals(e2))
            try {
              await r3.verify(t2, i2);
              const e3 = { key: n2, bind: r3.keyPacket }, a3 = await oh(r3.bindingSignatures, n2, ue.signature.subkeyBinding, e3, t2, i2);
              if (mh(r3.keyPacket, a3))
                return vh(r3.keyPacket, i2), r3;
            } catch (e3) {
              s2 = e3;
            }
        try {
          const a3 = await this.getPrimaryUser(t2, r2, i2);
          if ((!e2 || n2.getKeyID().equals(e2)) && mh(n2, a3.selfCertification))
            return vh(n2, i2), this;
        } catch (e3) {
          s2 = e3;
        }
        throw de.wrapError("Could not find valid encryption key packet in key " + this.getKeyID().toHex(), s2);
      }
      async isRevoked(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        return ph(this.keyPacket, ue.signature.keyRevocation, { key: this.keyPacket }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verifyPrimaryKey(e2 = /* @__PURE__ */ new Date(), t2 = {}, r2 = we) {
        const i2 = this.keyPacket;
        if (await this.isRevoked(null, null, e2, r2))
          throw Error("Primary key is revoked");
        const { selfCertification: n2 } = await this.getPrimaryUser(e2, t2, r2);
        if (ch(i2, n2, e2))
          throw Error("Primary key is expired");
        const a2 = await oh(this.directSignatures, i2, ue.signature.key, { key: i2 }, e2, r2).catch(() => {
        });
        if (a2 && ch(i2, a2, e2))
          throw Error("Primary key is expired");
      }
      async getExpirationTime(e2, t2 = we) {
        let r2;
        try {
          const { selfCertification: i2 } = await this.getPrimaryUser(null, e2, t2), n2 = yh(this.keyPacket, i2), a2 = i2.getExpirationTime(), s2 = await oh(this.directSignatures, this.keyPacket, ue.signature.key, { key: this.keyPacket }, null, t2).catch(() => {
          });
          if (s2) {
            const e3 = yh(this.keyPacket, s2);
            r2 = Math.min(n2, a2, e3);
          } else
            r2 = n2 < a2 ? n2 : a2;
        } catch (e3) {
          r2 = null;
        }
        return de.normalizeDate(r2);
      }
      async getPrimaryUser(e2 = /* @__PURE__ */ new Date(), t2 = {}, r2 = we) {
        const i2 = this.keyPacket, n2 = [];
        let a2;
        for (let s3 = 0; s3 < this.users.length; s3++)
          try {
            const a3 = this.users[s3];
            if (!a3.userID)
              continue;
            if (void 0 !== t2.name && a3.userID.name !== t2.name || void 0 !== t2.email && a3.userID.email !== t2.email || void 0 !== t2.comment && a3.userID.comment !== t2.comment)
              throw Error("Could not find user that matches that user ID");
            const o3 = { userID: a3.userID, key: i2 }, c3 = await oh(a3.selfCertifications, i2, ue.signature.certGeneric, o3, e2, r2);
            n2.push({ index: s3, user: a3, selfCertification: c3 });
          } catch (e3) {
            a2 = e3;
          }
        if (!n2.length)
          throw a2 || Error("Could not find primary user");
        await Promise.all(n2.map(async function(t3) {
          return t3.selfCertification.revoked || t3.user.isRevoked(t3.selfCertification, null, e2, r2);
        }));
        const s2 = n2.sort(function(e3, t3) {
          const r3 = e3.selfCertification, i3 = t3.selfCertification;
          return i3.revoked - r3.revoked || r3.isPrimaryUserID - i3.isPrimaryUserID || r3.created - i3.created;
        }).pop(), { user: o2, selfCertification: c2 } = s2;
        if (c2.revoked || await o2.isRevoked(c2, null, e2, r2))
          throw Error("Primary user is revoked");
        return s2;
      }
      async update(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        if (!this.hasSameFingerprintAs(e2))
          throw Error("Primary key fingerprints must be equal to update the key");
        if (!this.isPrivate() && e2.isPrivate()) {
          if (!(this.subkeys.length === e2.subkeys.length && this.subkeys.every((t3) => e2.subkeys.some((e3) => t3.hasSameFingerprintAs(e3)))))
            throw Error("Cannot update public key with private key if subkeys mismatch");
          return e2.update(this, r2);
        }
        const i2 = this.clone();
        return await lh(e2, i2, "revocationSignatures", t2, (n2) => ph(i2.keyPacket, ue.signature.keyRevocation, i2, [n2], null, e2.keyPacket, t2, r2)), await lh(e2, i2, "directSignatures", t2), await Promise.all(e2.users.map(async (e3) => {
          const n2 = i2.users.filter((t3) => e3.userID && e3.userID.equals(t3.userID) || e3.userAttribute && e3.userAttribute.equals(t3.userAttribute));
          if (n2.length > 0)
            await Promise.all(n2.map((i3) => i3.update(e3, t2, r2)));
          else {
            const t3 = e3.clone();
            t3.mainKey = i2, i2.users.push(t3);
          }
        })), await Promise.all(e2.subkeys.map(async (e3) => {
          const n2 = i2.subkeys.filter((t3) => t3.hasSameFingerprintAs(e3));
          if (n2.length > 0)
            await Promise.all(n2.map((i3) => i3.update(e3, t2, r2)));
          else {
            const t3 = e3.clone();
            t3.mainKey = i2, i2.subkeys.push(t3);
          }
        })), i2;
      }
      async getRevocationCertificate(e2 = /* @__PURE__ */ new Date(), t2 = we) {
        const r2 = { key: this.keyPacket }, i2 = await oh(this.revocationSignatures, this.keyPacket, ue.signature.keyRevocation, r2, e2, t2), n2 = new Ku();
        return n2.push(i2), Me(ue.armor.publicKey, n2.write(), null, null, "This is a revocation certificate");
      }
      async applyRevocationCertificate(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = await xe(e2, r2), n2 = (await Ku.fromBinary(i2.data, Ah, r2)).findPacket(ue.packet.signature);
        if (!n2 || n2.signatureType !== ue.signature.keyRevocation)
          throw Error("Could not find revocation signature packet");
        if (!n2.issuerKeyID.equals(this.getKeyID()))
          throw Error("Revocation signature does not match key");
        try {
          await n2.verify(this.keyPacket, ue.signature.keyRevocation, { key: this.keyPacket }, t2, void 0, r2);
        } catch (e3) {
          throw de.wrapError("Could not verify revocation signature", e3);
        }
        const a2 = this.clone();
        return a2.revocationSignatures.push(n2), a2;
      }
      async signPrimaryUser(e2, t2, r2, i2 = we) {
        const { index: n2, user: a2 } = await this.getPrimaryUser(t2, r2, i2), s2 = await a2.certify(e2, t2, i2), o2 = this.clone();
        return o2.users[n2] = s2, o2;
      }
      async signAllUsers(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = this.clone();
        return i2.users = await Promise.all(this.users.map(function(i3) {
          return i3.certify(e2, t2, r2);
        })), i2;
      }
      async verifyPrimaryUser(e2, t2 = /* @__PURE__ */ new Date(), r2, i2 = we) {
        const n2 = this.keyPacket, { user: a2 } = await this.getPrimaryUser(t2, r2, i2);
        return e2 ? await a2.verifyAllCertifications(e2, t2, i2) : [{ keyID: n2.getKeyID(), valid: await a2.verify(t2, i2).catch(() => false) }];
      }
      async verifyAllUsers(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = this.keyPacket, n2 = [];
        return await Promise.all(this.users.map(async (a2) => {
          const s2 = e2 ? await a2.verifyAllCertifications(e2, t2, r2) : [{ keyID: i2.getKeyID(), valid: await a2.verify(t2, r2).catch(() => false) }];
          n2.push(...s2.map((e3) => ({ userID: a2.userID ? a2.userID.userID : null, userAttribute: a2.userAttribute, keyID: e3.keyID, valid: e3.valid })));
        })), n2;
      }
    };
    ["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "hasSameFingerprintAs"].forEach((e2) => {
      Ph.prototype[e2] = kh.prototype[e2];
    });
    var xh = class extends Ph {
      constructor(e2) {
        if (super(), this.keyPacket = null, this.revocationSignatures = [], this.directSignatures = [], this.users = [], this.subkeys = [], e2 && (this.packetListToStructure(e2, /* @__PURE__ */ new Set([ue.packet.secretKey, ue.packet.secretSubkey])), !this.keyPacket))
          throw Error("Invalid key: missing public-key packet");
      }
      isPrivate() {
        return false;
      }
      toPublic() {
        return this;
      }
      armor(e2 = we) {
        return Me(ue.armor.publicKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
      }
    };
    var Mh = class _Mh extends xh {
      constructor(e2) {
        if (super(), this.packetListToStructure(e2, /* @__PURE__ */ new Set([ue.packet.publicKey, ue.packet.publicSubkey])), !this.keyPacket)
          throw Error("Invalid key: missing private-key packet");
      }
      isPrivate() {
        return true;
      }
      toPublic() {
        const e2 = new Ku(), t2 = this.toPacketList();
        for (const r2 of t2)
          switch (r2.constructor.tag) {
            case ue.packet.secretKey: {
              const t3 = Vu.fromSecretKeyPacket(r2);
              e2.push(t3);
              break;
            }
            case ue.packet.secretSubkey: {
              const t3 = Xu.fromSecretSubkeyPacket(r2);
              e2.push(t3);
              break;
            }
            default:
              e2.push(r2);
          }
        return new xh(e2);
      }
      armor(e2 = we) {
        return Me(ue.armor.privateKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
      }
      async getDecryptionKeys(e2, t2 = /* @__PURE__ */ new Date(), r2 = {}, i2 = we) {
        const n2 = this.keyPacket, a2 = [];
        for (let r3 = 0; r3 < this.subkeys.length; r3++)
          if (!e2 || this.subkeys[r3].getKeyID().equals(e2, true))
            try {
              const e3 = { key: n2, bind: this.subkeys[r3].keyPacket };
              wh(await oh(this.subkeys[r3].bindingSignatures, n2, ue.signature.subkeyBinding, e3, t2, i2), i2) && a2.push(this.subkeys[r3]);
            } catch (e3) {
            }
        const s2 = await this.getPrimaryUser(t2, r2, i2);
        return e2 && !n2.getKeyID().equals(e2, true) || !wh(s2.selfCertification, i2) || a2.push(this), a2;
      }
      isDecrypted() {
        return this.getKeys().some(({ keyPacket: e2 }) => e2.isDecrypted());
      }
      async validate(e2 = we) {
        if (!this.isPrivate())
          throw Error("Cannot validate a public key");
        let t2;
        if (this.keyPacket.isDummy()) {
          const r2 = await this.getSigningKey(null, null, void 0, { ...e2, rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set(), minRSABits: 0 });
          r2 && !r2.keyPacket.isDummy() && (t2 = r2.keyPacket);
        } else
          t2 = this.keyPacket;
        if (t2)
          return t2.validate();
        {
          const e3 = this.getKeys(), t3 = e3.map((e4) => e4.keyPacket.isDummy()).every(Boolean);
          if (t3)
            throw Error("Cannot validate an all-gnu-dummy key");
          return Promise.all(e3.map(async (e4) => e4.keyPacket.validate()));
        }
      }
      clearPrivateParams() {
        this.getKeys().forEach(({ keyPacket: e2 }) => {
          e2.isDecrypted() && e2.clearPrivateParams();
        });
      }
      async revoke({ flag: e2 = ue.reasonForRevocation.noReason, string: t2 = "" } = {}, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        if (!this.isPrivate())
          throw Error("Need private key for revoking");
        const n2 = { key: this.keyPacket }, a2 = this.clone();
        return a2.revocationSignatures.push(await fh(n2, null, this.keyPacket, { signatureType: ue.signature.keyRevocation, reasonForRevocationFlag: ue.write(ue.reasonForRevocation, e2), reasonForRevocationString: t2 }, r2, void 0, void 0, void 0, i2)), a2;
      }
      async addSubkey(e2 = {}) {
        const t2 = { ...we, ...e2.config };
        if (e2.passphrase)
          throw Error("Subkey could not be encrypted here, please encrypt whole key");
        if (e2.rsaBits < t2.minRSABits)
          throw Error(`rsaBits should be at least ${t2.minRSABits}, got: ${e2.rsaBits}`);
        const r2 = this.keyPacket;
        if (r2.isDummy())
          throw Error("Cannot add subkey to gnu-dummy primary key");
        if (!r2.isDecrypted())
          throw Error("Key is not decrypted");
        const i2 = r2.getAlgorithmInfo();
        i2.type = i2.curve ? "ecc" : "rsa", i2.rsaBits = i2.bits || 4096, i2.curve = i2.curve || "curve25519", e2 = bh(e2, i2);
        const n2 = await ah(e2);
        vh(n2, t2);
        const a2 = await uh(n2, r2, e2, t2), s2 = this.toPacketList();
        return s2.push(n2, a2), new _Mh(s2);
      }
    };
    var Kh = /* @__PURE__ */ de.constructAllowedPackets([Vu, Xu, Qu, rh, th, Yu, Eu]);
    function Ch(e2) {
      for (const t2 of e2)
        switch (t2.constructor.tag) {
          case ue.packet.secretKey:
            return new Mh(e2);
          case ue.packet.publicKey:
            return new xh(e2);
        }
      throw Error("No key packet found");
    }
    async function Dh(e2, t2, r2, i2) {
      r2.passphrase && await e2.encrypt(r2.passphrase, i2), await Promise.all(t2.map(async function(e3, t3) {
        const n3 = r2.subkeys[t3].passphrase;
        n3 && await e3.encrypt(n3, i2);
      }));
      const n2 = new Ku();
      n2.push(e2), await Promise.all(r2.userIDs.map(async function(t3, n3) {
        function a3(e3, t4) {
          return [t4, ...e3.filter((e4) => e4 !== t4)];
        }
        const s2 = th.fromObject(t3), o2 = {};
        o2.userID = s2, o2.key = e2;
        const c2 = {};
        c2.signatureType = ue.signature.certGeneric, c2.keyFlags = [ue.keyFlags.certifyKeys | ue.keyFlags.signData], c2.preferredSymmetricAlgorithms = a3([ue.symmetric.aes256, ue.symmetric.aes128, ue.symmetric.aes192], i2.preferredSymmetricAlgorithm), i2.aeadProtect && (c2.preferredAEADAlgorithms = a3([ue.aead.eax, ue.aead.ocb], i2.preferredAEADAlgorithm)), c2.preferredHashAlgorithms = a3([ue.hash.sha256, ue.hash.sha512], i2.preferredHashAlgorithm), c2.preferredCompressionAlgorithms = a3([ue.compression.zlib, ue.compression.zip, ue.compression.uncompressed], i2.preferredCompressionAlgorithm), 0 === n3 && (c2.isPrimaryUserID = true), c2.features = [0], c2.features[0] |= ue.features.modificationDetection, i2.aeadProtect && (c2.features[0] |= ue.features.aead), i2.v5Keys && (c2.features[0] |= ue.features.v5Keys), r2.keyExpirationTime > 0 && (c2.keyExpirationTime = r2.keyExpirationTime, c2.keyNeverExpires = false);
        return { userIDPacket: s2, signaturePacket: await fh(o2, null, e2, c2, r2.date, void 0, void 0, void 0, i2) };
      })).then((e3) => {
        e3.forEach(({ userIDPacket: e4, signaturePacket: t3 }) => {
          n2.push(e4), n2.push(t3);
        });
      }), await Promise.all(t2.map(async function(t3, n3) {
        const a3 = r2.subkeys[n3];
        return { secretSubkeyPacket: t3, subkeySignaturePacket: await uh(t3, e2, a3, i2) };
      })).then((e3) => {
        e3.forEach(({ secretSubkeyPacket: e4, subkeySignaturePacket: t3 }) => {
          n2.push(e4), n2.push(t3);
        });
      });
      const a2 = { key: e2 };
      return n2.push(await fh(a2, null, e2, { signatureType: ue.signature.keyRevocation, reasonForRevocationFlag: ue.reasonForRevocation.noReason, reasonForRevocationString: "" }, r2.date, void 0, void 0, void 0, i2)), r2.passphrase && e2.clearPrivateParams(), await Promise.all(t2.map(async function(e3, t3) {
        r2.subkeys[t3].passphrase && e3.clearPrivateParams();
      })), new Mh(n2);
    }
    var Uh = /* @__PURE__ */ de.constructAllowedPackets([ku, Du, Nu, Ou, Zu, ju, Gu, xu, Eu]);
    var Rh = /* @__PURE__ */ de.constructAllowedPackets([Gu]);
    var Ih = /* @__PURE__ */ de.constructAllowedPackets([Eu]);
    var Bh = class _Bh {
      constructor(e2) {
        this.packets = e2 || new Ku();
      }
      getEncryptionKeyIDs() {
        const e2 = [];
        return this.packets.filterByTag(ue.packet.publicKeyEncryptedSessionKey).forEach(function(t2) {
          e2.push(t2.publicKeyID);
        }), e2;
      }
      getSigningKeyIDs() {
        const e2 = this.unwrapCompressed(), t2 = e2.packets.filterByTag(ue.packet.onePassSignature);
        if (t2.length > 0)
          return t2.map((e3) => e3.issuerKeyID);
        return e2.packets.filterByTag(ue.packet.signature).map((e3) => e3.issuerKeyID);
      }
      async decrypt(e2, t2, r2, i2 = /* @__PURE__ */ new Date(), n2 = we) {
        const a2 = r2 || await this.decryptSessionKeys(e2, t2, i2, n2), s2 = this.packets.filterByTag(ue.packet.symmetricallyEncryptedData, ue.packet.symEncryptedIntegrityProtectedData, ue.packet.aeadEncryptedData);
        if (0 === s2.length)
          throw Error("No encrypted data found");
        const o2 = s2[0];
        let c2 = null;
        const u2 = Promise.all(a2.map(async ({ algorithm: e3, data: t3 }) => {
          if (!de.isUint8Array(t3) || !de.isString(e3))
            throw Error("Invalid session key for decryption.");
          try {
            const r3 = ue.write(ue.symmetric, e3);
            await o2.decrypt(r3, t3, n2);
          } catch (e4) {
            de.printDebugError(e4), c2 = e4;
          }
        }));
        if (ne(o2.encrypted), o2.encrypted = null, await u2, !o2.packets || !o2.packets.length)
          throw c2 || Error("Decryption failed.");
        const h2 = new _Bh(o2.packets);
        return o2.packets = new Ku(), h2;
      }
      async decryptSessionKeys(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        let n2, a2 = [];
        if (t2) {
          const e3 = this.packets.filterByTag(ue.packet.symEncryptedSessionKey);
          if (0 === e3.length)
            throw Error("No symmetrically encrypted session key packet found.");
          await Promise.all(t2.map(async function(t3, r3) {
            let n3;
            n3 = r3 ? await Ku.fromBinary(e3.write(), Rh, i2) : e3, await Promise.all(n3.map(async function(e4) {
              try {
                await e4.decrypt(t3), a2.push(e4);
              } catch (e5) {
                de.printDebugError(e5);
              }
            }));
          }));
        } else {
          if (!e2)
            throw Error("No key or password specified.");
          {
            const t3 = this.packets.filterByTag(ue.packet.publicKeyEncryptedSessionKey);
            if (0 === t3.length)
              throw Error("No public key encrypted session key packet found.");
            await Promise.all(t3.map(async function(t4) {
              await Promise.all(e2.map(async function(e3) {
                let s2 = [ue.symmetric.aes256, ue.symmetric.aes128, ue.symmetric.tripledes, ue.symmetric.cast5];
                try {
                  const t5 = await e3.getPrimaryUser(r2, void 0, i2);
                  t5.selfCertification.preferredSymmetricAlgorithms && (s2 = s2.concat(t5.selfCertification.preferredSymmetricAlgorithms));
                } catch (e4) {
                }
                const o2 = (await e3.getDecryptionKeys(t4.publicKeyID, null, void 0, i2)).map((e4) => e4.keyPacket);
                await Promise.all(o2.map(async function(e4) {
                  if (!e4 || e4.isDummy())
                    return;
                  if (!e4.isDecrypted())
                    throw Error("Decryption key is not decrypted.");
                  if (i2.constantTimePKCS1Decryption && (t4.publicKeyAlgorithm === ue.publicKey.rsaEncrypt || t4.publicKeyAlgorithm === ue.publicKey.rsaEncryptSign || t4.publicKeyAlgorithm === ue.publicKey.rsaSign || t4.publicKeyAlgorithm === ue.publicKey.elgamal)) {
                    const r3 = t4.write();
                    await Promise.all(Array.from(i2.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms).map(async (t5) => {
                      const i3 = new ju();
                      i3.read(r3);
                      const s3 = { sessionKeyAlgorithm: t5, sessionKey: Ia.generateSessionKey(t5) };
                      try {
                        await i3.decrypt(e4, s3), a2.push(i3);
                      } catch (e5) {
                        de.printDebugError(e5), n2 = e5;
                      }
                    }));
                  } else
                    try {
                      if (await t4.decrypt(e4), !s2.includes(ue.write(ue.symmetric, t4.sessionKeyAlgorithm)))
                        throw Error("A non-preferred symmetric algorithm was used.");
                      a2.push(t4);
                    } catch (e5) {
                      de.printDebugError(e5), n2 = e5;
                    }
                }));
              })), ne(t4.encrypted), t4.encrypted = null;
            }));
          }
        }
        if (a2.length > 0) {
          if (a2.length > 1) {
            const e3 = /* @__PURE__ */ new Set();
            a2 = a2.filter((t3) => {
              const r3 = t3.sessionKeyAlgorithm + de.uint8ArrayToString(t3.sessionKey);
              return !e3.has(r3) && (e3.add(r3), true);
            });
          }
          return a2.map((e3) => ({ data: e3.sessionKey, algorithm: ue.read(ue.symmetric, e3.sessionKeyAlgorithm) }));
        }
        throw n2 || Error("Session key decryption failed.");
      }
      getLiteralData() {
        const e2 = this.unwrapCompressed().packets.findPacket(ue.packet.literalData);
        return e2 && e2.getBytes() || null;
      }
      getFilename() {
        const e2 = this.unwrapCompressed().packets.findPacket(ue.packet.literalData);
        return e2 && e2.getFilename() || null;
      }
      getText() {
        const e2 = this.unwrapCompressed().packets.findPacket(ue.packet.literalData);
        return e2 ? e2.getText() : null;
      }
      static async generateSessionKey(e2 = [], t2 = /* @__PURE__ */ new Date(), r2 = [], i2 = we) {
        const n2 = await dh("symmetric", e2, t2, r2, i2), a2 = ue.read(ue.symmetric, n2), s2 = i2.aeadProtect && await async function(e3, t3 = /* @__PURE__ */ new Date(), r3 = [], i3 = we) {
          let n3 = true;
          return await Promise.all(e3.map(async function(e4, a3) {
            const s3 = await e4.getPrimaryUser(t3, r3[a3], i3);
            s3.selfCertification.features && s3.selfCertification.features[0] & ue.features.aead || (n3 = false);
          })), n3;
        }(e2, t2, r2, i2) ? ue.read(ue.aead, await dh("aead", e2, t2, r2, i2)) : void 0;
        await Promise.all(e2.map((e3) => e3.getEncryptionKey().catch(() => null).then((e4) => {
          if (e4 && e4.keyPacket.algorithm === ue.publicKey.x25519 && !de.isAES(n2))
            throw Error("Could not generate a session key compatible with the given `encryptionKeys`: X22519 keys can only be used to encrypt AES session keys; change `config.preferredSymmetricAlgorithm` accordingly.");
        })));
        return { data: Ia.generateSessionKey(n2), algorithm: a2, aeadAlgorithm: s2 };
      }
      async encrypt(e2, t2, r2, i2 = false, n2 = [], a2 = /* @__PURE__ */ new Date(), s2 = [], o2 = we) {
        if (r2) {
          if (!de.isUint8Array(r2.data) || !de.isString(r2.algorithm))
            throw Error("Invalid session key for encryption.");
        } else if (e2 && e2.length)
          r2 = await _Bh.generateSessionKey(e2, a2, s2, o2);
        else {
          if (!t2 || !t2.length)
            throw Error("No keys, passwords, or session key provided.");
          r2 = await _Bh.generateSessionKey(void 0, void 0, void 0, o2);
        }
        const { data: c2, algorithm: u2, aeadAlgorithm: h2 } = r2, d2 = await _Bh.encryptSessionKey(c2, u2, h2, e2, t2, i2, n2, a2, s2, o2);
        let f2;
        h2 ? (f2 = new Nu(), f2.aeadAlgorithm = ue.write(ue.aead, h2)) : f2 = new Ou(), f2.packets = this.packets;
        const l2 = ue.write(ue.symmetric, u2);
        return await f2.encrypt(l2, c2, o2), d2.packets.push(f2), f2.packets = new Ku(), d2;
      }
      static async encryptSessionKey(e2, t2, r2, i2, n2, a2 = false, s2 = [], o2 = /* @__PURE__ */ new Date(), c2 = [], u2 = we) {
        const h2 = new Ku(), d2 = ue.write(ue.symmetric, t2), f2 = r2 && ue.write(ue.aead, r2);
        if (i2) {
          const t3 = await Promise.all(i2.map(async function(t4, r3) {
            const i3 = await t4.getEncryptionKey(s2[r3], o2, c2, u2), n3 = new ju();
            return n3.publicKeyID = a2 ? Ke.wildcard() : i3.getKeyID(), n3.publicKeyAlgorithm = i3.keyPacket.algorithm, n3.sessionKey = e2, n3.sessionKeyAlgorithm = d2, await n3.encrypt(i3.keyPacket), delete n3.sessionKey, n3;
          }));
          h2.push(...t3);
        }
        if (n2) {
          const t3 = async function(e3, t4) {
            try {
              return await e3.decrypt(t4), 1;
            } catch (e4) {
              return 0;
            }
          }, r3 = (e3, t4) => e3 + t4, i3 = async function(e3, a4, s3, o3) {
            const c3 = new Gu(u2);
            if (c3.sessionKey = e3, c3.sessionKeyAlgorithm = a4, s3 && (c3.aeadAlgorithm = s3), await c3.encrypt(o3, u2), u2.passwordCollisionCheck) {
              if (1 !== (await Promise.all(n2.map((e4) => t3(c3, e4)))).reduce(r3))
                return i3(e3, a4, o3);
            }
            return delete c3.sessionKey, c3;
          }, a3 = await Promise.all(n2.map((t4) => i3(e2, d2, f2, t4)));
          h2.push(...a3);
        }
        return new _Bh(h2);
      }
      async sign(e2 = [], t2 = null, r2 = [], i2 = /* @__PURE__ */ new Date(), n2 = [], a2 = [], s2 = we) {
        const o2 = new Ku(), c2 = this.packets.findPacket(ue.packet.literalData);
        if (!c2)
          throw Error("No literal data packet to sign.");
        let u2, h2;
        const d2 = null === c2.text ? ue.signature.binary : ue.signature.text;
        if (t2)
          for (h2 = t2.packets.filterByTag(ue.packet.signature), u2 = h2.length - 1; u2 >= 0; u2--) {
            const t3 = h2[u2], r3 = new xu();
            r3.signatureType = t3.signatureType, r3.hashAlgorithm = t3.hashAlgorithm, r3.publicKeyAlgorithm = t3.publicKeyAlgorithm, r3.issuerKeyID = t3.issuerKeyID, e2.length || 0 !== u2 || (r3.flags = 1), o2.push(r3);
          }
        return await Promise.all(Array.from(e2).reverse().map(async function(t3, a3) {
          if (!t3.isPrivate())
            throw Error("Need private key for signing");
          const o3 = r2[e2.length - 1 - a3], c3 = await t3.getSigningKey(o3, i2, n2, s2), u3 = new xu();
          return u3.signatureType = d2, u3.hashAlgorithm = await hh(t3, c3.keyPacket, i2, n2, s2), u3.publicKeyAlgorithm = c3.keyPacket.algorithm, u3.issuerKeyID = c3.getKeyID(), a3 === e2.length - 1 && (u3.flags = 1), u3;
        })).then((e3) => {
          e3.forEach((e4) => o2.push(e4));
        }), o2.push(c2), o2.push(...await Th(c2, e2, t2, r2, i2, n2, a2, false, s2)), new _Bh(o2);
      }
      compress(e2, t2 = we) {
        if (e2 === ue.compression.uncompressed)
          return this;
        const r2 = new Du(t2);
        r2.algorithm = e2, r2.packets = this.packets;
        const i2 = new Ku();
        return i2.push(r2), new _Bh(i2);
      }
      async signDetached(e2 = [], t2 = null, r2 = [], i2 = /* @__PURE__ */ new Date(), n2 = [], a2 = [], s2 = we) {
        const o2 = this.packets.findPacket(ue.packet.literalData);
        if (!o2)
          throw Error("No literal data packet to sign.");
        return new nh(await Th(o2, e2, t2, r2, i2, n2, a2, true, s2));
      }
      async verify(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = this.unwrapCompressed(), n2 = i2.packets.filterByTag(ue.packet.literalData);
        if (1 !== n2.length)
          throw Error("Can only verify message with one literal data packet.");
        _(i2.packets.stream) && i2.packets.push(...await ie(i2.packets.stream, (e3) => e3 || []));
        const a2 = i2.packets.filterByTag(ue.packet.onePassSignature).reverse(), s2 = i2.packets.filterByTag(ue.packet.signature);
        return a2.length && !s2.length && de.isStream(i2.packets.stream) && !_(i2.packets.stream) ? (await Promise.all(a2.map(async (e3) => {
          e3.correspondingSig = new Promise((t3, r3) => {
            e3.correspondingSigResolve = t3, e3.correspondingSigReject = r3;
          }), e3.signatureData = ae(async () => (await e3.correspondingSig).signatureData), e3.hashed = ie(await e3.hash(e3.signatureType, n2[0], void 0, false)), e3.hashed.catch(() => {
          });
        })), i2.packets.stream = Y(i2.packets.stream, async (e3, t3) => {
          const r3 = W(e3), i3 = G(t3);
          try {
            for (let e4 = 0; e4 < a2.length; e4++) {
              const { value: t4 } = await r3.read();
              a2[e4].correspondingSigResolve(t4);
            }
            await r3.readToEnd(), await i3.ready, await i3.close();
          } catch (e4) {
            a2.forEach((t4) => {
              t4.correspondingSigReject(e4);
            }), await i3.abort(e4);
          }
        }), zh(a2, n2, e2, t2, false, r2)) : zh(s2, n2, e2, t2, false, r2);
      }
      verifyDetached(e2, t2, r2 = /* @__PURE__ */ new Date(), i2 = we) {
        const n2 = this.unwrapCompressed().packets.filterByTag(ue.packet.literalData);
        if (1 !== n2.length)
          throw Error("Can only verify message with one literal data packet.");
        return zh(e2.packets.filterByTag(ue.packet.signature), n2, t2, r2, true, i2);
      }
      unwrapCompressed() {
        const e2 = this.packets.filterByTag(ue.packet.compressedData);
        return e2.length ? new _Bh(e2[0].packets) : this;
      }
      async appendSignature(e2, t2 = we) {
        await this.packets.read(de.isUint8Array(e2) ? e2 : (await xe(e2)).data, Ih, t2);
      }
      write() {
        return this.packets.write();
      }
      armor(e2 = we) {
        return Me(ue.armor.message, this.write(), null, null, null, e2);
      }
    };
    async function Th(e2, t2, r2 = null, i2 = [], n2 = /* @__PURE__ */ new Date(), a2 = [], s2 = [], o2 = false, c2 = we) {
      const u2 = new Ku(), h2 = null === e2.text ? ue.signature.binary : ue.signature.text;
      if (await Promise.all(t2.map(async (t3, r3) => {
        const u3 = a2[r3];
        if (!t3.isPrivate())
          throw Error("Need private key for signing");
        const d2 = await t3.getSigningKey(i2[r3], n2, u3, c2);
        return fh(e2, t3, d2.keyPacket, { signatureType: h2 }, n2, u3, s2, o2, c2);
      })).then((e3) => {
        u2.push(...e3);
      }), r2) {
        const e3 = r2.packets.filterByTag(ue.packet.signature);
        u2.push(...e3);
      }
      return u2;
    }
    async function zh(e2, t2, r2, i2 = /* @__PURE__ */ new Date(), n2 = false, a2 = we) {
      return Promise.all(e2.filter(function(e3) {
        return ["text", "binary"].includes(ue.read(ue.signature, e3.signatureType));
      }).map(async function(e3) {
        return async function(e4, t3, r3, i3 = /* @__PURE__ */ new Date(), n3 = false, a3 = we) {
          let s2, o2;
          for (const t4 of r3) {
            const r4 = t4.getKeys(e4.issuerKeyID);
            if (r4.length > 0) {
              s2 = t4, o2 = r4[0];
              break;
            }
          }
          const c2 = e4 instanceof xu ? e4.correspondingSig : e4, u2 = { keyID: e4.issuerKeyID, verified: (async () => {
            if (!o2)
              throw Error("Could not find signing key with key ID " + e4.issuerKeyID.toHex());
            await e4.verify(o2.keyPacket, e4.signatureType, t3[0], i3, n3, a3);
            const r4 = await c2;
            if (o2.getCreationTime() > r4.created)
              throw Error("Key is newer than the signature");
            try {
              await s2.getSigningKey(o2.getKeyID(), r4.created, void 0, a3);
            } catch (e5) {
              if (!a3.allowInsecureVerificationWithReformattedKeys || !e5.message.match(/Signature creation time is in the future/))
                throw e5;
              await s2.getSigningKey(o2.getKeyID(), i3, void 0, a3);
            }
            return true;
          })(), signature: (async () => {
            const e5 = await c2, t4 = new Ku();
            return e5 && t4.push(e5), new nh(t4);
          })() };
          return u2.signature.catch(() => {
          }), u2.verified.catch(() => {
          }), u2;
        }(e3, t2, r2, i2, n2, a2);
      }));
    }
    var qh = /* @__PURE__ */ de.constructAllowedPackets([Eu]);
    var Fh = class _Fh {
      constructor(e2, t2) {
        if (this.text = de.removeTrailingSpaces(e2).replace(/\r?\n/g, "\r\n"), t2 && !(t2 instanceof nh))
          throw Error("Invalid signature input");
        this.signature = t2 || new nh(new Ku());
      }
      getSigningKeyIDs() {
        const e2 = [];
        return this.signature.packets.forEach(function(t2) {
          e2.push(t2.issuerKeyID);
        }), e2;
      }
      async sign(e2, t2 = null, r2 = [], i2 = /* @__PURE__ */ new Date(), n2 = [], a2 = [], s2 = we) {
        const o2 = new ku();
        o2.setText(this.text);
        const c2 = new nh(await Th(o2, e2, t2, r2, i2, n2, a2, true, s2));
        return new _Fh(this.text, c2);
      }
      verify(e2, t2 = /* @__PURE__ */ new Date(), r2 = we) {
        const i2 = this.signature.packets.filterByTag(ue.packet.signature), n2 = new ku();
        return n2.setText(this.text), zh(i2, [n2], e2, t2, true, r2);
      }
      getText() {
        return this.text.replace(/\r\n/g, "\n");
      }
      armor(e2 = we) {
        let t2 = this.signature.packets.map(function(e3) {
          return ue.read(ue.hash, e3.hashAlgorithm).toUpperCase();
        });
        t2 = t2.filter(function(e3, t3, r3) {
          return r3.indexOf(e3) === t3;
        });
        const r2 = { hash: t2.join(), text: this.text, data: this.signature.packets.write() };
        return Me(ue.armor.signed, r2, void 0, void 0, void 0, e2);
      }
    };
    function Oh(e2) {
      if (!(e2 instanceof Bh))
        throw Error("Parameter [message] needs to be of type Message");
    }
    function Lh(e2) {
      if (!(e2 instanceof Fh || e2 instanceof Bh))
        throw Error("Parameter [message] needs to be of type Message or CleartextMessage");
    }
    function Nh(e2) {
      if ("armored" !== e2 && "binary" !== e2 && "object" !== e2)
        throw Error("Unsupported format " + e2);
    }
    var jh = Object.keys(we).length;
    function Hh(e2) {
      const t2 = Object.keys(e2);
      if (t2.length !== jh) {
        for (const e3 of t2)
          if (void 0 === we[e3])
            throw Error("Unknown config property: " + e3);
      }
    }
    function Wh(e2) {
      return e2 && !de.isArray(e2) && (e2 = [e2]), e2;
    }
    async function Gh(e2, t2, r2 = "utf8") {
      const i2 = de.isStream(e2);
      return "array" === i2 ? ie(e2) : "node" === t2 ? (e2 = D(e2), "binary" !== r2 && e2.setEncoding(r2), e2) : "web" === t2 && "ponyfill" === i2 ? T(e2) : e2;
    }
    function Vh(e2, t2) {
      e2.data = Y(t2.packets.stream, async (t3, r2) => {
        await V(e2.data, r2, { preventClose: true });
        const i2 = G(r2);
        try {
          await ie(t3, (e3) => e3), await i2.close();
        } catch (e3) {
          await i2.abort(e3);
        }
      });
    }
    function $h(e2, t2, r2) {
      switch (t2) {
        case "object":
          return e2;
        case "armored":
          return e2.armor(r2);
        case "binary":
          return e2.write();
        default:
          throw Error("Unsupported format " + t2);
      }
    }
    var Zh = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol : (e2) => `Symbol(${e2})`;
    function Xh() {
    }
    var Yh = "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : void 0;
    function Qh(e2) {
      return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
    }
    var Jh = Xh;
    var ed = Promise;
    var td = Promise.prototype.then;
    var rd = Promise.resolve.bind(ed);
    var id = Promise.reject.bind(ed);
    function nd(e2) {
      return new ed(e2);
    }
    function ad(e2) {
      return rd(e2);
    }
    function sd(e2) {
      return id(e2);
    }
    function od(e2, t2, r2) {
      return td.call(e2, t2, r2);
    }
    function cd(e2, t2, r2) {
      od(od(e2, t2, r2), void 0, Jh);
    }
    function ud(e2, t2) {
      cd(e2, t2);
    }
    function hd(e2, t2) {
      cd(e2, void 0, t2);
    }
    function dd(e2, t2, r2) {
      return od(e2, t2, r2);
    }
    function fd(e2) {
      od(e2, void 0, Jh);
    }
    var ld = (() => {
      const e2 = Yh && Yh.queueMicrotask;
      if ("function" == typeof e2)
        return e2;
      const t2 = ad(void 0);
      return (e3) => od(t2, e3);
    })();
    function pd(e2, t2, r2) {
      if ("function" != typeof e2)
        throw new TypeError("Argument is not a function");
      return Function.prototype.apply.call(e2, t2, r2);
    }
    function yd(e2, t2, r2) {
      try {
        return ad(pd(e2, t2, r2));
      } catch (e3) {
        return sd(e3);
      }
    }
    var bd = class {
      constructor() {
        this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(e2) {
        const t2 = this._back;
        let r2 = t2;
        16383 === t2._elements.length && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
      }
      shift() {
        const e2 = this._front;
        let t2 = e2;
        const r2 = this._cursor;
        let i2 = r2 + 1;
        const n2 = e2._elements, a2 = n2[r2];
        return 16384 === i2 && (t2 = e2._next, i2 = 0), --this._size, this._cursor = i2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
      }
      forEach(e2) {
        let t2 = this._cursor, r2 = this._front, i2 = r2._elements;
        for (; !(t2 === i2.length && void 0 === r2._next || t2 === i2.length && (r2 = r2._next, i2 = r2._elements, t2 = 0, 0 === i2.length)); )
          e2(i2[t2]), ++t2;
      }
      peek() {
        const e2 = this._front, t2 = this._cursor;
        return e2._elements[t2];
      }
    };
    function gd(e2, t2) {
      e2._ownerReadableStream = t2, t2._reader = e2, "readable" === t2._state ? _d(e2) : "closed" === t2._state ? function(e3) {
        _d(e3), Sd(e3);
      }(e2) : kd(e2, t2._storedError);
    }
    function md(e2, t2) {
      return rp(e2._ownerReadableStream, t2);
    }
    function wd(e2) {
      "readable" === e2._ownerReadableStream._state ? Ad(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t2) {
        kd(e3, t2);
      }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e2._ownerReadableStream._reader = void 0, e2._ownerReadableStream = void 0;
    }
    function vd(e2) {
      return new TypeError("Cannot " + e2 + " a stream using a released reader");
    }
    function _d(e2) {
      e2._closedPromise = nd((t2, r2) => {
        e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
      });
    }
    function kd(e2, t2) {
      _d(e2), Ad(e2, t2);
    }
    function Ad(e2, t2) {
      void 0 !== e2._closedPromise_reject && (fd(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
    }
    function Sd(e2) {
      void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
    }
    var Ed = Zh("[[AbortSteps]]");
    var Pd = Zh("[[ErrorSteps]]");
    var xd = Zh("[[CancelSteps]]");
    var Md = Zh("[[PullSteps]]");
    var Kd = Number.isFinite || function(e2) {
      return "number" == typeof e2 && isFinite(e2);
    };
    var Cd = Math.trunc || function(e2) {
      return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
    };
    function Dd(e2, t2) {
      if (void 0 !== e2 && ("object" != typeof (r2 = e2) && "function" != typeof r2))
        throw new TypeError(t2 + " is not an object.");
      var r2;
    }
    function Ud(e2, t2) {
      if ("function" != typeof e2)
        throw new TypeError(t2 + " is not a function.");
    }
    function Rd(e2, t2) {
      if (!/* @__PURE__ */ function(e3) {
        return "object" == typeof e3 && null !== e3 || "function" == typeof e3;
      }(e2))
        throw new TypeError(t2 + " is not an object.");
    }
    function Id(e2, t2, r2) {
      if (void 0 === e2)
        throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
    }
    function Bd(e2, t2, r2) {
      if (void 0 === e2)
        throw new TypeError(`${t2} is required in '${r2}'.`);
    }
    function Td(e2) {
      return Number(e2);
    }
    function zd(e2) {
      return 0 === e2 ? 0 : e2;
    }
    function qd(e2, t2) {
      const r2 = Number.MAX_SAFE_INTEGER;
      let i2 = Number(e2);
      if (i2 = zd(i2), !Kd(i2))
        throw new TypeError(t2 + " is not a finite number");
      if (i2 = function(e3) {
        return zd(Cd(e3));
      }(i2), i2 < 0 || i2 > r2)
        throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
      return Kd(i2) && 0 !== i2 ? i2 : 0;
    }
    function Fd(e2, t2) {
      if (!ep(e2))
        throw new TypeError(t2 + " is not a ReadableStream.");
    }
    function Od(e2) {
      return new Wd(e2);
    }
    function Ld(e2, t2) {
      e2._reader._readRequests.push(t2);
    }
    function Nd(e2, t2, r2) {
      const i2 = e2._reader._readRequests.shift();
      r2 ? i2._closeSteps() : i2._chunkSteps(t2);
    }
    function jd(e2) {
      return e2._reader._readRequests.length;
    }
    function Hd(e2) {
      const t2 = e2._reader;
      return void 0 !== t2 && !!Gd(t2);
    }
    var Wd = class {
      constructor(e2) {
        if (Id(e2, 1, "ReadableStreamDefaultReader"), Fd(e2, "First parameter"), tp(e2))
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        gd(this, e2), this._readRequests = new bd();
      }
      get closed() {
        return Gd(this) ? this._closedPromise : sd($d("closed"));
      }
      cancel(e2 = void 0) {
        return Gd(this) ? void 0 === this._ownerReadableStream ? sd(vd("cancel")) : md(this, e2) : sd($d("cancel"));
      }
      read() {
        if (!Gd(this))
          return sd($d("read"));
        if (void 0 === this._ownerReadableStream)
          return sd(vd("read from"));
        let e2, t2;
        const r2 = nd((r3, i2) => {
          e2 = r3, t2 = i2;
        });
        return Vd(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
      }
      releaseLock() {
        if (!Gd(this))
          throw $d("releaseLock");
        if (void 0 !== this._ownerReadableStream) {
          if (this._readRequests.length > 0)
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          wd(this);
        }
      }
    };
    function Gd(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readRequests");
    }
    function Vd(e2, t2) {
      const r2 = e2._ownerReadableStream;
      r2._disturbed = true, "closed" === r2._state ? t2._closeSteps() : "errored" === r2._state ? t2._errorSteps(r2._storedError) : r2._readableStreamController[Md](t2);
    }
    function $d(e2) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
    }
    var Zd;
    Object.defineProperties(Wd.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(Wd.prototype, Zh.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true }), "symbol" == typeof Zh.asyncIterator && (Zd = { [Zh.asyncIterator]() {
      return this;
    } }, Object.defineProperty(Zd, Zh.asyncIterator, { enumerable: false }));
    var Xd = class {
      constructor(e2, t2) {
        this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
      }
      next() {
        const e2 = () => this._nextSteps();
        return this._ongoingPromise = this._ongoingPromise ? dd(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
      }
      return(e2) {
        const t2 = () => this._returnSteps(e2);
        return this._ongoingPromise ? dd(this._ongoingPromise, t2, t2) : t2();
      }
      _nextSteps() {
        if (this._isFinished)
          return Promise.resolve({ value: void 0, done: true });
        const e2 = this._reader;
        if (void 0 === e2._ownerReadableStream)
          return sd(vd("iterate"));
        let t2, r2;
        const i2 = nd((e3, i3) => {
          t2 = e3, r2 = i3;
        });
        return Vd(e2, { _chunkSteps: (e3) => {
          this._ongoingPromise = void 0, ld(() => t2({ value: e3, done: false }));
        }, _closeSteps: () => {
          this._ongoingPromise = void 0, this._isFinished = true, wd(e2), t2({ value: void 0, done: true });
        }, _errorSteps: (t3) => {
          this._ongoingPromise = void 0, this._isFinished = true, wd(e2), r2(t3);
        } }), i2;
      }
      _returnSteps(e2) {
        if (this._isFinished)
          return Promise.resolve({ value: e2, done: true });
        this._isFinished = true;
        const t2 = this._reader;
        if (void 0 === t2._ownerReadableStream)
          return sd(vd("finish iterating"));
        if (!this._preventCancel) {
          const r2 = md(t2, e2);
          return wd(t2), dd(r2, () => ({ value: e2, done: true }));
        }
        return wd(t2), ad({ value: e2, done: true });
      }
    };
    var Yd = { next() {
      return Qd(this) ? this._asyncIteratorImpl.next() : sd(Jd("next"));
    }, return(e2) {
      return Qd(this) ? this._asyncIteratorImpl.return(e2) : sd(Jd("return"));
    } };
    function Qd(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl");
    }
    function Jd(e2) {
      return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
    }
    void 0 !== Zd && Object.setPrototypeOf(Yd, Zd);
    var ef = Number.isNaN || function(e2) {
      return e2 != e2;
    };
    function tf(e2) {
      return !!function(e3) {
        if ("number" != typeof e3)
          return false;
        if (ef(e3))
          return false;
        if (e3 < 0)
          return false;
        return true;
      }(e2) && e2 !== 1 / 0;
    }
    function rf(e2) {
      const t2 = e2._queue.shift();
      return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
    }
    function nf(e2, t2, r2) {
      if (!tf(r2 = Number(r2)))
        throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
    }
    function af(e2) {
      e2._queue = new bd(), e2._queueTotalSize = 0;
    }
    function sf(e2) {
      return e2.slice();
    }
    var of = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!hf(this))
          throw Pf("view");
        return this._view;
      }
      respond(e2) {
        if (!hf(this))
          throw Pf("respond");
        if (Id(e2, 1, "respond"), e2 = qd(e2, "First parameter"), void 0 === this._associatedReadableByteStreamController)
          throw new TypeError("This BYOB request has been invalidated");
        this._view.buffer, function(e3, t2) {
          if (t2 = Number(t2), !tf(t2))
            throw new RangeError("bytesWritten must be a finite");
          vf(e3, t2);
        }(this._associatedReadableByteStreamController, e2);
      }
      respondWithNewView(e2) {
        if (!hf(this))
          throw Pf("respondWithNewView");
        if (Id(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2))
          throw new TypeError("You can only respond with array buffer views");
        if (0 === e2.byteLength)
          throw new TypeError("chunk must have non-zero byteLength");
        if (0 === e2.buffer.byteLength)
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (void 0 === this._associatedReadableByteStreamController)
          throw new TypeError("This BYOB request has been invalidated");
        !function(e3, t2) {
          const r2 = e3._pendingPullIntos.peek();
          if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)
            throw new RangeError("The region specified by view does not match byobRequest");
          if (r2.byteLength !== t2.byteLength)
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          r2.buffer = t2.buffer, vf(e3, t2.byteLength);
        }(this._associatedReadableByteStreamController, e2);
      }
    };
    Object.defineProperties(of.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(of.prototype, Zh.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
    var cf = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!uf(this))
          throw xf("byobRequest");
        if (null === this._byobRequest && this._pendingPullIntos.length > 0) {
          const e2 = this._pendingPullIntos.peek(), t2 = new Uint8Array(e2.buffer, e2.byteOffset + e2.bytesFilled, e2.byteLength - e2.bytesFilled), r2 = Object.create(of.prototype);
          !function(e3, t3, r3) {
            e3._associatedReadableByteStreamController = t3, e3._view = r3;
          }(r2, this, t2), this._byobRequest = r2;
        }
        return this._byobRequest;
      }
      get desiredSize() {
        if (!uf(this))
          throw xf("desiredSize");
        return Sf(this);
      }
      close() {
        if (!uf(this))
          throw xf("close");
        if (this._closeRequested)
          throw new TypeError("The stream has already been closed; do not close it again!");
        const e2 = this._controlledReadableByteStream._state;
        if ("readable" !== e2)
          throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
        !function(e3) {
          const t2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || "readable" !== t2._state)
            return;
          if (e3._queueTotalSize > 0)
            return void (e3._closeRequested = true);
          if (e3._pendingPullIntos.length > 0) {
            if (e3._pendingPullIntos.peek().bytesFilled > 0) {
              const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw Af(e3, t3), t3;
            }
          }
          kf(e3), ip(t2);
        }(this);
      }
      enqueue(e2) {
        if (!uf(this))
          throw xf("enqueue");
        if (Id(e2, 1, "enqueue"), !ArrayBuffer.isView(e2))
          throw new TypeError("chunk must be an array buffer view");
        if (0 === e2.byteLength)
          throw new TypeError("chunk must have non-zero byteLength");
        if (0 === e2.buffer.byteLength)
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested)
          throw new TypeError("stream is closed or draining");
        const t2 = this._controlledReadableByteStream._state;
        if ("readable" !== t2)
          throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
        !function(e3, t3) {
          const r2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || "readable" !== r2._state)
            return;
          const i2 = t3.buffer, n2 = t3.byteOffset, a2 = t3.byteLength, s2 = i2;
          if (Hd(r2))
            if (0 === jd(r2))
              pf(e3, s2, n2, a2);
            else {
              Nd(r2, new Uint8Array(s2, n2, a2), false);
            }
          else
            Cf(r2) ? (pf(e3, s2, n2, a2), wf(e3)) : pf(e3, s2, n2, a2);
          df(e3);
        }(this, e2);
      }
      error(e2 = void 0) {
        if (!uf(this))
          throw xf("error");
        Af(this, e2);
      }
      [xd](e2) {
        if (this._pendingPullIntos.length > 0) {
          this._pendingPullIntos.peek().bytesFilled = 0;
        }
        af(this);
        const t2 = this._cancelAlgorithm(e2);
        return kf(this), t2;
      }
      [Md](e2) {
        const t2 = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          const t3 = this._queue.shift();
          this._queueTotalSize -= t3.byteLength, gf(this);
          const r3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
          return void e2._chunkSteps(r3);
        }
        const r2 = this._autoAllocateChunkSize;
        if (void 0 !== r2) {
          let t3;
          try {
            t3 = new ArrayBuffer(r2);
          } catch (t4) {
            return void e2._errorSteps(t4);
          }
          const i2 = { buffer: t3, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
          this._pendingPullIntos.push(i2);
        }
        Ld(t2, e2), df(this);
      }
    };
    function uf(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream");
    }
    function hf(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController");
    }
    function df(e2) {
      const t2 = function(e3) {
        const t3 = e3._controlledReadableByteStream;
        if ("readable" !== t3._state)
          return false;
        if (e3._closeRequested)
          return false;
        if (!e3._started)
          return false;
        if (Hd(t3) && jd(t3) > 0)
          return true;
        if (Cf(t3) && Kf(t3) > 0)
          return true;
        const r2 = Sf(e3);
        if (r2 > 0)
          return true;
        return false;
      }(e2);
      if (!t2)
        return;
      if (e2._pulling)
        return void (e2._pullAgain = true);
      e2._pulling = true;
      cd(e2._pullAlgorithm(), () => {
        e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, df(e2));
      }, (t3) => {
        Af(e2, t3);
      });
    }
    function ff(e2, t2) {
      let r2 = false;
      "closed" === e2._state && (r2 = true);
      const i2 = lf(t2);
      "default" === t2.readerType ? Nd(e2, i2, r2) : function(e3, t3, r3) {
        const i3 = e3._reader, n2 = i3._readIntoRequests.shift();
        r3 ? n2._closeSteps(t3) : n2._chunkSteps(t3);
      }(e2, i2, r2);
    }
    function lf(e2) {
      const t2 = e2.bytesFilled, r2 = e2.elementSize;
      return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
    }
    function pf(e2, t2, r2, i2) {
      e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: i2 }), e2._queueTotalSize += i2;
    }
    function yf(e2, t2) {
      const r2 = t2.elementSize, i2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), a2 = t2.bytesFilled + n2, s2 = a2 - a2 % r2;
      let o2 = n2, c2 = false;
      s2 > i2 && (o2 = s2 - t2.bytesFilled, c2 = true);
      const u2 = e2._queue;
      for (; o2 > 0; ) {
        const r3 = u2.peek(), i3 = Math.min(o2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
        h2 = t2.buffer, d2 = n3, f2 = r3.buffer, l2 = r3.byteOffset, p2 = i3, new Uint8Array(h2).set(new Uint8Array(f2, l2, p2), d2), r3.byteLength === i3 ? u2.shift() : (r3.byteOffset += i3, r3.byteLength -= i3), e2._queueTotalSize -= i3, bf(e2, i3, t2), o2 -= i3;
      }
      var h2, d2, f2, l2, p2;
      return c2;
    }
    function bf(e2, t2, r2) {
      mf(e2), r2.bytesFilled += t2;
    }
    function gf(e2) {
      0 === e2._queueTotalSize && e2._closeRequested ? (kf(e2), ip(e2._controlledReadableByteStream)) : df(e2);
    }
    function mf(e2) {
      null !== e2._byobRequest && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
    }
    function wf(e2) {
      for (; e2._pendingPullIntos.length > 0; ) {
        if (0 === e2._queueTotalSize)
          return;
        const t2 = e2._pendingPullIntos.peek();
        yf(e2, t2) && (_f(e2), ff(e2._controlledReadableByteStream, t2));
      }
    }
    function vf(e2, t2) {
      const r2 = e2._pendingPullIntos.peek();
      if ("closed" === e2._controlledReadableByteStream._state) {
        if (0 !== t2)
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        !function(e3, t3) {
          t3.buffer = t3.buffer;
          const r3 = e3._controlledReadableByteStream;
          if (Cf(r3))
            for (; Kf(r3) > 0; )
              ff(r3, _f(e3));
        }(e2, r2);
      } else
        !function(e3, t3, r3) {
          if (r3.bytesFilled + t3 > r3.byteLength)
            throw new RangeError("bytesWritten out of range");
          if (bf(e3, t3, r3), r3.bytesFilled < r3.elementSize)
            return;
          _f(e3);
          const i2 = r3.bytesFilled % r3.elementSize;
          if (i2 > 0) {
            const t4 = r3.byteOffset + r3.bytesFilled, n2 = r3.buffer.slice(t4 - i2, t4);
            pf(e3, n2, 0, n2.byteLength);
          }
          r3.buffer = r3.buffer, r3.bytesFilled -= i2, ff(e3._controlledReadableByteStream, r3), wf(e3);
        }(e2, t2, r2);
      df(e2);
    }
    function _f(e2) {
      const t2 = e2._pendingPullIntos.shift();
      return mf(e2), t2;
    }
    function kf(e2) {
      e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
    }
    function Af(e2, t2) {
      const r2 = e2._controlledReadableByteStream;
      "readable" === r2._state && (!function(e3) {
        mf(e3), e3._pendingPullIntos = new bd();
      }(e2), af(e2), kf(e2), np(r2, t2));
    }
    function Sf(e2) {
      const t2 = e2._controlledReadableByteStream._state;
      return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
    }
    function Ef(e2, t2, r2) {
      const i2 = Object.create(cf.prototype);
      let n2 = () => {
      }, a2 = () => ad(void 0), s2 = () => ad(void 0);
      void 0 !== t2.start && (n2 = () => t2.start(i2)), void 0 !== t2.pull && (a2 = () => t2.pull(i2)), void 0 !== t2.cancel && (s2 = (e3) => t2.cancel(e3));
      const o2 = t2.autoAllocateChunkSize;
      if (0 === o2)
        throw new TypeError("autoAllocateChunkSize must be greater than 0");
      !function(e3, t3, r3, i3, n3, a3, s3) {
        t3._controlledReadableByteStream = e3, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = void 0, af(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = a3, t3._pullAlgorithm = i3, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = s3, t3._pendingPullIntos = new bd(), e3._readableStreamController = t3, cd(ad(r3()), () => {
          t3._started = true, df(t3);
        }, (e4) => {
          Af(t3, e4);
        });
      }(e2, i2, n2, a2, s2, r2, o2);
    }
    function Pf(e2) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
    }
    function xf(e2) {
      return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
    }
    function Mf(e2, t2) {
      e2._reader._readIntoRequests.push(t2);
    }
    function Kf(e2) {
      return e2._reader._readIntoRequests.length;
    }
    function Cf(e2) {
      const t2 = e2._reader;
      return void 0 !== t2 && !!Uf(t2);
    }
    Object.defineProperties(cf.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(cf.prototype, Zh.toStringTag, { value: "ReadableByteStreamController", configurable: true });
    var Df = class {
      constructor(e2) {
        if (Id(e2, 1, "ReadableStreamBYOBReader"), Fd(e2, "First parameter"), tp(e2))
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        if (!uf(e2._readableStreamController))
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        gd(this, e2), this._readIntoRequests = new bd();
      }
      get closed() {
        return Uf(this) ? this._closedPromise : sd(Rf("closed"));
      }
      cancel(e2 = void 0) {
        return Uf(this) ? void 0 === this._ownerReadableStream ? sd(vd("cancel")) : md(this, e2) : sd(Rf("cancel"));
      }
      read(e2) {
        if (!Uf(this))
          return sd(Rf("read"));
        if (!ArrayBuffer.isView(e2))
          return sd(new TypeError("view must be an array buffer view"));
        if (0 === e2.byteLength)
          return sd(new TypeError("view must have non-zero byteLength"));
        if (0 === e2.buffer.byteLength)
          return sd(new TypeError("view's buffer must have non-zero byteLength"));
        if (void 0 === this._ownerReadableStream)
          return sd(vd("read from"));
        let t2, r2;
        const i2 = nd((e3, i3) => {
          t2 = e3, r2 = i3;
        });
        return function(e3, t3, r3) {
          const i3 = e3._ownerReadableStream;
          i3._disturbed = true, "errored" === i3._state ? r3._errorSteps(i3._storedError) : function(e4, t4, r4) {
            const i4 = e4._controlledReadableByteStream;
            let n2 = 1;
            t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);
            const a2 = t4.constructor, s2 = { buffer: t4.buffer, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: "byob" };
            if (e4._pendingPullIntos.length > 0)
              return e4._pendingPullIntos.push(s2), void Mf(i4, r4);
            if ("closed" !== i4._state) {
              if (e4._queueTotalSize > 0) {
                if (yf(e4, s2)) {
                  const t5 = lf(s2);
                  return gf(e4), void r4._chunkSteps(t5);
                }
                if (e4._closeRequested) {
                  const t5 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  return Af(e4, t5), void r4._errorSteps(t5);
                }
              }
              e4._pendingPullIntos.push(s2), Mf(i4, r4), df(e4);
            } else {
              const e5 = new a2(s2.buffer, s2.byteOffset, 0);
              r4._closeSteps(e5);
            }
          }(i3._readableStreamController, t3, r3);
        }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), i2;
      }
      releaseLock() {
        if (!Uf(this))
          throw Rf("releaseLock");
        if (void 0 !== this._ownerReadableStream) {
          if (this._readIntoRequests.length > 0)
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          wd(this);
        }
      }
    };
    function Uf(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests");
    }
    function Rf(e2) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
    }
    function If(e2, t2) {
      const { highWaterMark: r2 } = e2;
      if (void 0 === r2)
        return t2;
      if (ef(r2) || r2 < 0)
        throw new RangeError("Invalid highWaterMark");
      return r2;
    }
    function Bf(e2) {
      const { size: t2 } = e2;
      return t2 || (() => 1);
    }
    function Tf(e2, t2) {
      Dd(e2, t2);
      const r2 = null == e2 ? void 0 : e2.highWaterMark, i2 = null == e2 ? void 0 : e2.size;
      return { highWaterMark: void 0 === r2 ? void 0 : Td(r2), size: void 0 === i2 ? void 0 : zf(i2, t2 + " has member 'size' that") };
    }
    function zf(e2, t2) {
      return Ud(e2, t2), (t3) => Td(e2(t3));
    }
    function qf(e2, t2, r2) {
      return Ud(e2, r2), (r3) => yd(e2, t2, [r3]);
    }
    function Ff(e2, t2, r2) {
      return Ud(e2, r2), () => yd(e2, t2, []);
    }
    function Of(e2, t2, r2) {
      return Ud(e2, r2), (r3) => pd(e2, t2, [r3]);
    }
    function Lf(e2, t2, r2) {
      return Ud(e2, r2), (r3, i2) => yd(e2, t2, [r3, i2]);
    }
    function Nf(e2, t2) {
      if (!Gf(e2))
        throw new TypeError(t2 + " is not a WritableStream.");
    }
    Object.defineProperties(Df.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(Df.prototype, Zh.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
    var jf = class {
      constructor(e2 = {}, t2 = {}) {
        void 0 === e2 ? e2 = null : Rd(e2, "First parameter");
        const r2 = Tf(t2, "Second parameter"), i2 = function(e3, t3) {
          Dd(e3, t3);
          const r3 = null == e3 ? void 0 : e3.abort, i3 = null == e3 ? void 0 : e3.close, n3 = null == e3 ? void 0 : e3.start, a2 = null == e3 ? void 0 : e3.type, s2 = null == e3 ? void 0 : e3.write;
          return { abort: void 0 === r3 ? void 0 : qf(r3, e3, t3 + " has member 'abort' that"), close: void 0 === i3 ? void 0 : Ff(i3, e3, t3 + " has member 'close' that"), start: void 0 === n3 ? void 0 : Of(n3, e3, t3 + " has member 'start' that"), write: void 0 === s2 ? void 0 : Lf(s2, e3, t3 + " has member 'write' that"), type: a2 };
        }(e2, "First parameter");
        Wf(this);
        if (void 0 !== i2.type)
          throw new RangeError("Invalid type is specified");
        const n2 = Bf(r2);
        !function(e3, t3, r3, i3) {
          const n3 = Object.create(hl.prototype);
          let a2 = () => {
          }, s2 = () => ad(void 0), o2 = () => ad(void 0), c2 = () => ad(void 0);
          void 0 !== t3.start && (a2 = () => t3.start(n3));
          void 0 !== t3.write && (s2 = (e4) => t3.write(e4, n3));
          void 0 !== t3.close && (o2 = () => t3.close());
          void 0 !== t3.abort && (c2 = (e4) => t3.abort(e4));
          dl(e3, n3, a2, s2, o2, c2, r3, i3);
        }(this, i2, If(r2, 1), n2);
      }
      get locked() {
        if (!Gf(this))
          throw ml("locked");
        return Vf(this);
      }
      abort(e2 = void 0) {
        return Gf(this) ? Vf(this) ? sd(new TypeError("Cannot abort a stream that already has a writer")) : $f(this, e2) : sd(ml("abort"));
      }
      close() {
        return Gf(this) ? Vf(this) ? sd(new TypeError("Cannot close a stream that already has a writer")) : Jf(this) ? sd(new TypeError("Cannot close an already-closing stream")) : Zf(this) : sd(ml("close"));
      }
      getWriter() {
        if (!Gf(this))
          throw ml("getWriter");
        return Hf(this);
      }
    };
    function Hf(e2) {
      return new rl(e2);
    }
    function Wf(e2) {
      e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new bd(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
    }
    function Gf(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController");
    }
    function Vf(e2) {
      return void 0 !== e2._writer;
    }
    function $f(e2, t2) {
      const r2 = e2._state;
      if ("closed" === r2 || "errored" === r2)
        return ad(void 0);
      if (void 0 !== e2._pendingAbortRequest)
        return e2._pendingAbortRequest._promise;
      let i2 = false;
      "erroring" === r2 && (i2 = true, t2 = void 0);
      const n2 = nd((r3, n3) => {
        e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: n3, _reason: t2, _wasAlreadyErroring: i2 };
      });
      return e2._pendingAbortRequest._promise = n2, i2 || Yf(e2, t2), n2;
    }
    function Zf(e2) {
      const t2 = e2._state;
      if ("closed" === t2 || "errored" === t2)
        return sd(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
      const r2 = nd((t3, r3) => {
        const i3 = { _resolve: t3, _reject: r3 };
        e2._closeRequest = i3;
      }), i2 = e2._writer;
      var n2;
      return void 0 !== i2 && e2._backpressure && "writable" === t2 && Kl(i2), nf(n2 = e2._writableStreamController, ul, 0), pl(n2), r2;
    }
    function Xf(e2, t2) {
      "writable" !== e2._state ? Qf(e2) : Yf(e2, t2);
    }
    function Yf(e2, t2) {
      const r2 = e2._writableStreamController;
      e2._state = "erroring", e2._storedError = t2;
      const i2 = e2._writer;
      void 0 !== i2 && sl(i2, t2), !function(e3) {
        if (void 0 === e3._inFlightWriteRequest && void 0 === e3._inFlightCloseRequest)
          return false;
        return true;
      }(e2) && r2._started && Qf(e2);
    }
    function Qf(e2) {
      e2._state = "errored", e2._writableStreamController[Pd]();
      const t2 = e2._storedError;
      if (e2._writeRequests.forEach((e3) => {
        e3._reject(t2);
      }), e2._writeRequests = new bd(), void 0 === e2._pendingAbortRequest)
        return void el(e2);
      const r2 = e2._pendingAbortRequest;
      if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring)
        return r2._reject(t2), void el(e2);
      cd(e2._writableStreamController[Ed](r2._reason), () => {
        r2._resolve(), el(e2);
      }, (t3) => {
        r2._reject(t3), el(e2);
      });
    }
    function Jf(e2) {
      return void 0 !== e2._closeRequest || void 0 !== e2._inFlightCloseRequest;
    }
    function el(e2) {
      void 0 !== e2._closeRequest && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
      const t2 = e2._writer;
      void 0 !== t2 && Al(t2, e2._storedError);
    }
    function tl(e2, t2) {
      const r2 = e2._writer;
      void 0 !== r2 && t2 !== e2._backpressure && (t2 ? function(e3) {
        El(e3);
      }(r2) : Kl(r2)), e2._backpressure = t2;
    }
    Object.defineProperties(jf.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(jf.prototype, Zh.toStringTag, { value: "WritableStream", configurable: true });
    var rl = class {
      constructor(e2) {
        if (Id(e2, 1, "WritableStreamDefaultWriter"), Nf(e2, "First parameter"), Vf(e2))
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        this._ownerWritableStream = e2, e2._writer = this;
        const t2 = e2._state;
        if ("writable" === t2)
          !Jf(e2) && e2._backpressure ? El(this) : xl(this), _l(this);
        else if ("erroring" === t2)
          Pl(this, e2._storedError), _l(this);
        else if ("closed" === t2)
          xl(this), _l(r2 = this), Sl(r2);
        else {
          const t3 = e2._storedError;
          Pl(this, t3), kl(this, t3);
        }
        var r2;
      }
      get closed() {
        return il(this) ? this._closedPromise : sd(wl("closed"));
      }
      get desiredSize() {
        if (!il(this))
          throw wl("desiredSize");
        if (void 0 === this._ownerWritableStream)
          throw vl("desiredSize");
        return function(e2) {
          const t2 = e2._ownerWritableStream, r2 = t2._state;
          if ("errored" === r2 || "erroring" === r2)
            return null;
          if ("closed" === r2)
            return 0;
          return ll(t2._writableStreamController);
        }(this);
      }
      get ready() {
        return il(this) ? this._readyPromise : sd(wl("ready"));
      }
      abort(e2 = void 0) {
        return il(this) ? void 0 === this._ownerWritableStream ? sd(vl("abort")) : function(e3, t2) {
          const r2 = e3._ownerWritableStream;
          return $f(r2, t2);
        }(this, e2) : sd(wl("abort"));
      }
      close() {
        if (!il(this))
          return sd(wl("close"));
        const e2 = this._ownerWritableStream;
        return void 0 === e2 ? sd(vl("close")) : Jf(e2) ? sd(new TypeError("Cannot close an already-closing stream")) : nl(this);
      }
      releaseLock() {
        if (!il(this))
          throw wl("releaseLock");
        void 0 !== this._ownerWritableStream && ol(this);
      }
      write(e2 = void 0) {
        return il(this) ? void 0 === this._ownerWritableStream ? sd(vl("write to")) : cl(this, e2) : sd(wl("write"));
      }
    };
    function il(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream");
    }
    function nl(e2) {
      return Zf(e2._ownerWritableStream);
    }
    function al(e2, t2) {
      "pending" === e2._closedPromiseState ? Al(e2, t2) : function(e3, t3) {
        kl(e3, t3);
      }(e2, t2);
    }
    function sl(e2, t2) {
      "pending" === e2._readyPromiseState ? Ml(e2, t2) : function(e3, t3) {
        Pl(e3, t3);
      }(e2, t2);
    }
    function ol(e2) {
      const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
      sl(e2, r2), al(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
    }
    function cl(e2, t2) {
      const r2 = e2._ownerWritableStream, i2 = r2._writableStreamController, n2 = function(e3, t3) {
        try {
          return e3._strategySizeAlgorithm(t3);
        } catch (t4) {
          return yl(e3, t4), 1;
        }
      }(i2, t2);
      if (r2 !== e2._ownerWritableStream)
        return sd(vl("write to"));
      const a2 = r2._state;
      if ("errored" === a2)
        return sd(r2._storedError);
      if (Jf(r2) || "closed" === a2)
        return sd(new TypeError("The stream is closing or closed and cannot be written to"));
      if ("erroring" === a2)
        return sd(r2._storedError);
      const s2 = function(e3) {
        return nd((t3, r3) => {
          const i3 = { _resolve: t3, _reject: r3 };
          e3._writeRequests.push(i3);
        });
      }(r2);
      return function(e3, t3, r3) {
        try {
          nf(e3, t3, r3);
        } catch (t4) {
          return void yl(e3, t4);
        }
        const i3 = e3._controlledWritableStream;
        if (!Jf(i3) && "writable" === i3._state) {
          tl(i3, bl(e3));
        }
        pl(e3);
      }(i2, t2, n2), s2;
    }
    Object.defineProperties(rl.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(rl.prototype, Zh.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
    var ul = {};
    var hl = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      error(e2 = void 0) {
        if (!function(e3) {
          if (!Qh(e3))
            return false;
          if (!Object.prototype.hasOwnProperty.call(e3, "_controlledWritableStream"))
            return false;
          return true;
        }(this))
          throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
        "writable" === this._controlledWritableStream._state && gl(this, e2);
      }
      [Ed](e2) {
        const t2 = this._abortAlgorithm(e2);
        return fl(this), t2;
      }
      [Pd]() {
        af(this);
      }
    };
    function dl(e2, t2, r2, i2, n2, a2, s2, o2) {
      t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, af(t2), t2._started = false, t2._strategySizeAlgorithm = o2, t2._strategyHWM = s2, t2._writeAlgorithm = i2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
      const c2 = bl(t2);
      tl(e2, c2);
      cd(ad(r2()), () => {
        t2._started = true, pl(t2);
      }, (r3) => {
        t2._started = true, Xf(e2, r3);
      });
    }
    function fl(e2) {
      e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
    }
    function ll(e2) {
      return e2._strategyHWM - e2._queueTotalSize;
    }
    function pl(e2) {
      const t2 = e2._controlledWritableStream;
      if (!e2._started)
        return;
      if (void 0 !== t2._inFlightWriteRequest)
        return;
      if ("erroring" === t2._state)
        return void Qf(t2);
      if (0 === e2._queue.length)
        return;
      const r2 = e2._queue.peek().value;
      r2 === ul ? function(e3) {
        const t3 = e3._controlledWritableStream;
        (function(e4) {
          e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
        })(t3), rf(e3);
        const r3 = e3._closeAlgorithm();
        fl(e3), cd(r3, () => {
          !function(e4) {
            e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, "erroring" === e4._state && (e4._storedError = void 0, void 0 !== e4._pendingAbortRequest && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
            const t4 = e4._writer;
            void 0 !== t4 && Sl(t4);
          }(t3);
        }, (e4) => {
          !function(e5, t4) {
            e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, void 0 !== e5._pendingAbortRequest && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Xf(e5, t4);
          }(t3, e4);
        });
      }(e2) : function(e3, t3) {
        const r3 = e3._controlledWritableStream;
        !function(e4) {
          e4._inFlightWriteRequest = e4._writeRequests.shift();
        }(r3);
        const i2 = e3._writeAlgorithm(t3);
        cd(i2, () => {
          !function(e4) {
            e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
          }(r3);
          const t4 = r3._state;
          if (rf(e3), !Jf(r3) && "writable" === t4) {
            const t5 = bl(e3);
            tl(r3, t5);
          }
          pl(e3);
        }, (t4) => {
          "writable" === r3._state && fl(e3), function(e4, t5) {
            e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Xf(e4, t5);
          }(r3, t4);
        });
      }(e2, r2);
    }
    function yl(e2, t2) {
      "writable" === e2._controlledWritableStream._state && gl(e2, t2);
    }
    function bl(e2) {
      return ll(e2) <= 0;
    }
    function gl(e2, t2) {
      const r2 = e2._controlledWritableStream;
      fl(e2), Yf(r2, t2);
    }
    function ml(e2) {
      return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
    }
    function wl(e2) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
    }
    function vl(e2) {
      return new TypeError("Cannot " + e2 + " a stream using a released writer");
    }
    function _l(e2) {
      e2._closedPromise = nd((t2, r2) => {
        e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
      });
    }
    function kl(e2, t2) {
      _l(e2), Al(e2, t2);
    }
    function Al(e2, t2) {
      void 0 !== e2._closedPromise_reject && (fd(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
    }
    function Sl(e2) {
      void 0 !== e2._closedPromise_resolve && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
    }
    function El(e2) {
      e2._readyPromise = nd((t2, r2) => {
        e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
      }), e2._readyPromiseState = "pending";
    }
    function Pl(e2, t2) {
      El(e2), Ml(e2, t2);
    }
    function xl(e2) {
      El(e2), Kl(e2);
    }
    function Ml(e2, t2) {
      void 0 !== e2._readyPromise_reject && (fd(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
    }
    function Kl(e2) {
      void 0 !== e2._readyPromise_resolve && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
    }
    Object.defineProperties(hl.prototype, { error: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(hl.prototype, Zh.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
    var Cl = "undefined" != typeof DOMException ? DOMException : void 0;
    var Dl = function(e2) {
      if ("function" != typeof e2 && "object" != typeof e2)
        return false;
      try {
        return new e2(), true;
      } catch (e3) {
        return false;
      }
    }(Cl) ? Cl : function() {
      const e2 = function(e3, t2) {
        this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      };
      return Object.defineProperty(e2.prototype = Object.create(Error.prototype), "constructor", { value: e2, writable: true, configurable: true }), e2;
    }();
    function Ul(e2, t2, r2, i2, n2, a2) {
      const s2 = Od(e2), o2 = Hf(t2);
      e2._disturbed = true;
      let c2 = false, u2 = ad(void 0);
      return nd((h2, d2) => {
        let f2;
        if (void 0 !== a2) {
          if (f2 = () => {
            const r3 = new Dl("Aborted", "AbortError"), a3 = [];
            i2 || a3.push(() => "writable" === t2._state ? $f(t2, r3) : ad(void 0)), n2 || a3.push(() => "readable" === e2._state ? rp(e2, r3) : ad(void 0)), y2(() => Promise.all(a3.map((e3) => e3())), true, r3);
          }, a2.aborted)
            return void f2();
          a2.addEventListener("abort", f2);
        }
        if (p2(e2, s2._closedPromise, (e3) => {
          i2 ? b2(true, e3) : y2(() => $f(t2, e3), true, e3);
        }), p2(t2, o2._closedPromise, (t3) => {
          n2 ? b2(true, t3) : y2(() => rp(e2, t3), true, t3);
        }), function(e3, t3, r3) {
          "closed" === e3._state ? r3() : ud(t3, r3);
        }(e2, s2._closedPromise, () => {
          r2 ? b2() : y2(() => function(e3) {
            const t3 = e3._ownerWritableStream, r3 = t3._state;
            return Jf(t3) || "closed" === r3 ? ad(void 0) : "errored" === r3 ? sd(t3._storedError) : nl(e3);
          }(o2));
        }), Jf(t2) || "closed" === t2._state) {
          const t3 = new TypeError("the destination writable stream closed before all data could be piped to it");
          n2 ? b2(true, t3) : y2(() => rp(e2, t3), true, t3);
        }
        function l2() {
          const e3 = u2;
          return od(u2, () => e3 !== u2 ? l2() : void 0);
        }
        function p2(e3, t3, r3) {
          "errored" === e3._state ? r3(e3._storedError) : hd(t3, r3);
        }
        function y2(e3, r3, i3) {
          function n3() {
            cd(e3(), () => g2(r3, i3), (e4) => g2(true, e4));
          }
          c2 || (c2 = true, "writable" !== t2._state || Jf(t2) ? n3() : ud(l2(), n3));
        }
        function b2(e3, r3) {
          c2 || (c2 = true, "writable" !== t2._state || Jf(t2) ? g2(e3, r3) : ud(l2(), () => g2(e3, r3)));
        }
        function g2(e3, t3) {
          ol(o2), wd(s2), void 0 !== a2 && a2.removeEventListener("abort", f2), e3 ? d2(t3) : h2(void 0);
        }
        fd(nd((e3, t3) => {
          !function r3(i3) {
            i3 ? e3() : od(c2 ? ad(true) : od(o2._readyPromise, () => nd((e4, t4) => {
              Vd(s2, { _chunkSteps: (t5) => {
                u2 = od(cl(o2, t5), void 0, Xh), e4(false);
              }, _closeSteps: () => e4(true), _errorSteps: t4 });
            })), r3, t3);
          }(false);
        }));
      });
    }
    var Rl = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Il(this))
          throw Hl("desiredSize");
        return Ll(this);
      }
      close() {
        if (!Il(this))
          throw Hl("close");
        if (!Nl(this))
          throw new TypeError("The stream is not in a state that permits close");
        ql(this);
      }
      enqueue(e2 = void 0) {
        if (!Il(this))
          throw Hl("enqueue");
        if (!Nl(this))
          throw new TypeError("The stream is not in a state that permits enqueue");
        return Fl(this, e2);
      }
      error(e2 = void 0) {
        if (!Il(this))
          throw Hl("error");
        Ol(this, e2);
      }
      [xd](e2) {
        af(this);
        const t2 = this._cancelAlgorithm(e2);
        return zl(this), t2;
      }
      [Md](e2) {
        const t2 = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const r2 = rf(this);
          this._closeRequested && 0 === this._queue.length ? (zl(this), ip(t2)) : Bl(this), e2._chunkSteps(r2);
        } else
          Ld(t2, e2), Bl(this);
      }
    };
    function Il(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream");
    }
    function Bl(e2) {
      if (!Tl(e2))
        return;
      if (e2._pulling)
        return void (e2._pullAgain = true);
      e2._pulling = true;
      cd(e2._pullAlgorithm(), () => {
        e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, Bl(e2));
      }, (t2) => {
        Ol(e2, t2);
      });
    }
    function Tl(e2) {
      const t2 = e2._controlledReadableStream;
      if (!Nl(e2))
        return false;
      if (!e2._started)
        return false;
      if (tp(t2) && jd(t2) > 0)
        return true;
      return Ll(e2) > 0;
    }
    function zl(e2) {
      e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
    }
    function ql(e2) {
      if (!Nl(e2))
        return;
      const t2 = e2._controlledReadableStream;
      e2._closeRequested = true, 0 === e2._queue.length && (zl(e2), ip(t2));
    }
    function Fl(e2, t2) {
      if (!Nl(e2))
        return;
      const r2 = e2._controlledReadableStream;
      if (tp(r2) && jd(r2) > 0)
        Nd(r2, t2, false);
      else {
        let r3;
        try {
          r3 = e2._strategySizeAlgorithm(t2);
        } catch (t3) {
          throw Ol(e2, t3), t3;
        }
        try {
          nf(e2, t2, r3);
        } catch (t3) {
          throw Ol(e2, t3), t3;
        }
      }
      Bl(e2);
    }
    function Ol(e2, t2) {
      const r2 = e2._controlledReadableStream;
      "readable" === r2._state && (af(e2), zl(e2), np(r2, t2));
    }
    function Ll(e2) {
      const t2 = e2._controlledReadableStream._state;
      return "errored" === t2 ? null : "closed" === t2 ? 0 : e2._strategyHWM - e2._queueTotalSize;
    }
    function Nl(e2) {
      const t2 = e2._controlledReadableStream._state;
      return !e2._closeRequested && "readable" === t2;
    }
    function jl(e2, t2, r2, i2, n2, a2, s2) {
      t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, af(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = s2, t2._strategyHWM = a2, t2._pullAlgorithm = i2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
      cd(ad(r2()), () => {
        t2._started = true, Bl(t2);
      }, (e3) => {
        Ol(t2, e3);
      });
    }
    function Hl(e2) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
    }
    function Wl(e2, t2, r2) {
      return Ud(e2, r2), (r3) => yd(e2, t2, [r3]);
    }
    function Gl(e2, t2, r2) {
      return Ud(e2, r2), (r3) => yd(e2, t2, [r3]);
    }
    function Vl(e2, t2, r2) {
      return Ud(e2, r2), (r3) => pd(e2, t2, [r3]);
    }
    function $l(e2, t2) {
      if ("bytes" !== (e2 = "" + e2))
        throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
      return e2;
    }
    function Zl(e2, t2) {
      if ("byob" !== (e2 = "" + e2))
        throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
      return e2;
    }
    function Xl(e2, t2) {
      Dd(e2, t2);
      const r2 = null == e2 ? void 0 : e2.preventAbort, i2 = null == e2 ? void 0 : e2.preventCancel, n2 = null == e2 ? void 0 : e2.preventClose, a2 = null == e2 ? void 0 : e2.signal;
      return void 0 !== a2 && function(e3, t3) {
        if (!function(e4) {
          if ("object" != typeof e4 || null === e4)
            return false;
          try {
            return "boolean" == typeof e4.aborted;
          } catch (e5) {
            return false;
          }
        }(e3))
          throw new TypeError(t3 + " is not an AbortSignal.");
      }(a2, t2 + " has member 'signal' that"), { preventAbort: !!r2, preventCancel: !!i2, preventClose: !!n2, signal: a2 };
    }
    Object.defineProperties(Rl.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(Rl.prototype, Zh.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
    var Yl = class {
      constructor(e2 = {}, t2 = {}) {
        void 0 === e2 ? e2 = null : Rd(e2, "First parameter");
        const r2 = Tf(t2, "Second parameter"), i2 = function(e3, t3) {
          Dd(e3, t3);
          const r3 = e3, i3 = null == r3 ? void 0 : r3.autoAllocateChunkSize, n2 = null == r3 ? void 0 : r3.cancel, a2 = null == r3 ? void 0 : r3.pull, s2 = null == r3 ? void 0 : r3.start, o2 = null == r3 ? void 0 : r3.type;
          return { autoAllocateChunkSize: void 0 === i3 ? void 0 : qd(i3, t3 + " has member 'autoAllocateChunkSize' that"), cancel: void 0 === n2 ? void 0 : Wl(n2, r3, t3 + " has member 'cancel' that"), pull: void 0 === a2 ? void 0 : Gl(a2, r3, t3 + " has member 'pull' that"), start: void 0 === s2 ? void 0 : Vl(s2, r3, t3 + " has member 'start' that"), type: void 0 === o2 ? void 0 : $l(o2, t3 + " has member 'type' that") };
        }(e2, "First parameter");
        if (Jl(this), "bytes" === i2.type) {
          if (void 0 !== r2.size)
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          Ef(this, i2, If(r2, 0));
        } else {
          const e3 = Bf(r2);
          !function(e4, t3, r3, i3) {
            const n2 = Object.create(Rl.prototype);
            let a2 = () => {
            }, s2 = () => ad(void 0), o2 = () => ad(void 0);
            void 0 !== t3.start && (a2 = () => t3.start(n2)), void 0 !== t3.pull && (s2 = () => t3.pull(n2)), void 0 !== t3.cancel && (o2 = (e5) => t3.cancel(e5)), jl(e4, n2, a2, s2, o2, r3, i3);
          }(this, i2, If(r2, 1), e3);
        }
      }
      get locked() {
        if (!ep(this))
          throw ap("locked");
        return tp(this);
      }
      cancel(e2 = void 0) {
        return ep(this) ? tp(this) ? sd(new TypeError("Cannot cancel a stream that already has a reader")) : rp(this, e2) : sd(ap("cancel"));
      }
      getReader(e2 = void 0) {
        if (!ep(this))
          throw ap("getReader");
        const t2 = function(e3, t3) {
          Dd(e3, t3);
          const r2 = null == e3 ? void 0 : e3.mode;
          return { mode: void 0 === r2 ? void 0 : Zl(r2, t3 + " has member 'mode' that") };
        }(e2, "First parameter");
        return void 0 === t2.mode ? Od(this) : function(e3) {
          return new Df(e3);
        }(this);
      }
      pipeThrough(e2, t2 = {}) {
        if (!ep(this))
          throw ap("pipeThrough");
        Id(e2, 1, "pipeThrough");
        const r2 = function(e3, t3) {
          Dd(e3, t3);
          const r3 = null == e3 ? void 0 : e3.readable;
          Bd(r3, "readable", "ReadableWritablePair"), Fd(r3, t3 + " has member 'readable' that");
          const i3 = null == e3 ? void 0 : e3.writable;
          return Bd(i3, "writable", "ReadableWritablePair"), Nf(i3, t3 + " has member 'writable' that"), { readable: r3, writable: i3 };
        }(e2, "First parameter"), i2 = Xl(t2, "Second parameter");
        if (tp(this))
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (Vf(r2.writable))
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        return fd(Ul(this, r2.writable, i2.preventClose, i2.preventAbort, i2.preventCancel, i2.signal)), r2.readable;
      }
      pipeTo(e2, t2 = {}) {
        if (!ep(this))
          return sd(ap("pipeTo"));
        if (void 0 === e2)
          return sd("Parameter 1 is required in 'pipeTo'.");
        if (!Gf(e2))
          return sd(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        let r2;
        try {
          r2 = Xl(t2, "Second parameter");
        } catch (e3) {
          return sd(e3);
        }
        return tp(this) ? sd(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : Vf(e2) ? sd(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : Ul(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
      }
      tee() {
        if (!ep(this))
          throw ap("tee");
        const e2 = function(e3, t2) {
          const r2 = Od(e3);
          let i2, n2, a2, s2, o2, c2 = false, u2 = false, h2 = false;
          const d2 = nd((e4) => {
            o2 = e4;
          });
          function f2() {
            return c2 || (c2 = true, Vd(r2, { _chunkSteps: (e4) => {
              ld(() => {
                c2 = false;
                const t3 = e4, r3 = e4;
                u2 || Fl(a2._readableStreamController, t3), h2 || Fl(s2._readableStreamController, r3);
              });
            }, _closeSteps: () => {
              c2 = false, u2 || ql(a2._readableStreamController), h2 || ql(s2._readableStreamController), u2 && h2 || o2(void 0);
            }, _errorSteps: () => {
              c2 = false;
            } })), ad(void 0);
          }
          function l2() {
          }
          return a2 = Ql(l2, f2, function(t3) {
            if (u2 = true, i2 = t3, h2) {
              const t4 = sf([i2, n2]), r3 = rp(e3, t4);
              o2(r3);
            }
            return d2;
          }), s2 = Ql(l2, f2, function(t3) {
            if (h2 = true, n2 = t3, u2) {
              const t4 = sf([i2, n2]), r3 = rp(e3, t4);
              o2(r3);
            }
            return d2;
          }), hd(r2._closedPromise, (e4) => {
            Ol(a2._readableStreamController, e4), Ol(s2._readableStreamController, e4), u2 && h2 || o2(void 0);
          }), [a2, s2];
        }(this);
        return sf(e2);
      }
      values(e2 = void 0) {
        if (!ep(this))
          throw ap("values");
        return function(e3, t2) {
          const r2 = Od(e3), i2 = new Xd(r2, t2), n2 = Object.create(Yd);
          return n2._asyncIteratorImpl = i2, n2;
        }(this, function(e3, t2) {
          return Dd(e3, t2), { preventCancel: !!(null == e3 ? void 0 : e3.preventCancel) };
        }(e2, "First parameter").preventCancel);
      }
    };
    function Ql(e2, t2, r2, i2 = 1, n2 = () => 1) {
      const a2 = Object.create(Yl.prototype);
      Jl(a2);
      return jl(a2, Object.create(Rl.prototype), e2, t2, r2, i2, n2), a2;
    }
    function Jl(e2) {
      e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
    }
    function ep(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController");
    }
    function tp(e2) {
      return void 0 !== e2._reader;
    }
    function rp(e2, t2) {
      if (e2._disturbed = true, "closed" === e2._state)
        return ad(void 0);
      if ("errored" === e2._state)
        return sd(e2._storedError);
      ip(e2);
      return dd(e2._readableStreamController[xd](t2), Xh);
    }
    function ip(e2) {
      e2._state = "closed";
      const t2 = e2._reader;
      void 0 !== t2 && (Sd(t2), Gd(t2) && (t2._readRequests.forEach((e3) => {
        e3._closeSteps();
      }), t2._readRequests = new bd()));
    }
    function np(e2, t2) {
      e2._state = "errored", e2._storedError = t2;
      const r2 = e2._reader;
      void 0 !== r2 && (Ad(r2, t2), Gd(r2) ? (r2._readRequests.forEach((e3) => {
        e3._errorSteps(t2);
      }), r2._readRequests = new bd()) : (r2._readIntoRequests.forEach((e3) => {
        e3._errorSteps(t2);
      }), r2._readIntoRequests = new bd()));
    }
    function ap(e2) {
      return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
    }
    function sp(e2, t2) {
      Dd(e2, t2);
      const r2 = null == e2 ? void 0 : e2.highWaterMark;
      return Bd(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: Td(r2) };
    }
    Object.defineProperties(Yl.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(Yl.prototype, Zh.toStringTag, { value: "ReadableStream", configurable: true }), "symbol" == typeof Zh.asyncIterator && Object.defineProperty(Yl.prototype, Zh.asyncIterator, { value: Yl.prototype.values, writable: true, configurable: true });
    var op = function(e2) {
      return e2.byteLength;
    };
    var cp = class {
      constructor(e2) {
        Id(e2, 1, "ByteLengthQueuingStrategy"), e2 = sp(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!hp(this))
          throw up("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!hp(this))
          throw up("size");
        return op;
      }
    };
    function up(e2) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
    }
    function hp(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark");
    }
    Object.defineProperties(cp.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(cp.prototype, Zh.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
    var dp = function() {
      return 1;
    };
    var fp = class {
      constructor(e2) {
        Id(e2, 1, "CountQueuingStrategy"), e2 = sp(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!pp(this))
          throw lp("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!pp(this))
          throw lp("size");
        return dp;
      }
    };
    function lp(e2) {
      return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
    }
    function pp(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark");
    }
    function yp(e2, t2, r2) {
      return Ud(e2, r2), (r3) => yd(e2, t2, [r3]);
    }
    function bp(e2, t2, r2) {
      return Ud(e2, r2), (r3) => pd(e2, t2, [r3]);
    }
    function gp(e2, t2, r2) {
      return Ud(e2, r2), (r3, i2) => yd(e2, t2, [r3, i2]);
    }
    Object.defineProperties(fp.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(fp.prototype, Zh.toStringTag, { value: "CountQueuingStrategy", configurable: true });
    var mp = class {
      constructor(e2 = {}, t2 = {}, r2 = {}) {
        void 0 === e2 && (e2 = null);
        const i2 = Tf(t2, "Second parameter"), n2 = Tf(r2, "Third parameter"), a2 = function(e3, t3) {
          Dd(e3, t3);
          const r3 = null == e3 ? void 0 : e3.flush, i3 = null == e3 ? void 0 : e3.readableType, n3 = null == e3 ? void 0 : e3.start, a3 = null == e3 ? void 0 : e3.transform, s3 = null == e3 ? void 0 : e3.writableType;
          return { flush: void 0 === r3 ? void 0 : yp(r3, e3, t3 + " has member 'flush' that"), readableType: i3, start: void 0 === n3 ? void 0 : bp(n3, e3, t3 + " has member 'start' that"), transform: void 0 === a3 ? void 0 : gp(a3, e3, t3 + " has member 'transform' that"), writableType: s3 };
        }(e2, "First parameter");
        if (void 0 !== a2.readableType)
          throw new RangeError("Invalid readableType specified");
        if (void 0 !== a2.writableType)
          throw new RangeError("Invalid writableType specified");
        const s2 = If(n2, 0), o2 = Bf(n2), c2 = If(i2, 1), u2 = Bf(i2);
        let h2;
        !function(e3, t3, r3, i3, n3, a3) {
          function s3() {
            return t3;
          }
          function o3(t4) {
            return function(e4, t5) {
              const r4 = e4._transformStreamController;
              if (e4._backpressure) {
                return dd(e4._backpressureChangePromise, () => {
                  const i4 = e4._writable;
                  if ("erroring" === i4._state)
                    throw i4._storedError;
                  return xp(r4, t5);
                });
              }
              return xp(r4, t5);
            }(e3, t4);
          }
          function c3(t4) {
            return function(e4, t5) {
              return vp(e4, t5), ad(void 0);
            }(e3, t4);
          }
          function u3() {
            return function(e4) {
              const t4 = e4._readable, r4 = e4._transformStreamController, i4 = r4._flushAlgorithm();
              return Ep(r4), dd(i4, () => {
                if ("errored" === t4._state)
                  throw t4._storedError;
                ql(t4._readableStreamController);
              }, (r5) => {
                throw vp(e4, r5), t4._storedError;
              });
            }(e3);
          }
          function h3() {
            return function(e4) {
              return kp(e4, false), e4._backpressureChangePromise;
            }(e3);
          }
          function d2(t4) {
            return _p(e3, t4), ad(void 0);
          }
          e3._writable = function(e4, t4, r4, i4, n4 = 1, a4 = () => 1) {
            const s4 = Object.create(jf.prototype);
            return Wf(s4), dl(s4, Object.create(hl.prototype), e4, t4, r4, i4, n4, a4), s4;
          }(s3, o3, u3, c3, r3, i3), e3._readable = Ql(s3, h3, d2, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, kp(e3, true), e3._transformStreamController = void 0;
        }(this, nd((e3) => {
          h2 = e3;
        }), c2, u2, s2, o2), function(e3, t3) {
          const r3 = Object.create(Ap.prototype);
          let i3 = (e4) => {
            try {
              return Pp(r3, e4), ad(void 0);
            } catch (e5) {
              return sd(e5);
            }
          }, n3 = () => ad(void 0);
          void 0 !== t3.transform && (i3 = (e4) => t3.transform(e4, r3));
          void 0 !== t3.flush && (n3 = () => t3.flush(r3));
          !function(e4, t4, r4, i4) {
            t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = i4;
          }(e3, r3, i3, n3);
        }(this, a2), void 0 !== a2.start ? h2(a2.start(this._transformStreamController)) : h2(void 0);
      }
      get readable() {
        if (!wp(this))
          throw Kp("readable");
        return this._readable;
      }
      get writable() {
        if (!wp(this))
          throw Kp("writable");
        return this._writable;
      }
    };
    function wp(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController");
    }
    function vp(e2, t2) {
      Ol(e2._readable._readableStreamController, t2), _p(e2, t2);
    }
    function _p(e2, t2) {
      Ep(e2._transformStreamController), yl(e2._writable._writableStreamController, t2), e2._backpressure && kp(e2, false);
    }
    function kp(e2, t2) {
      void 0 !== e2._backpressureChangePromise && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = nd((t3) => {
        e2._backpressureChangePromise_resolve = t3;
      }), e2._backpressure = t2;
    }
    Object.defineProperties(mp.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(mp.prototype, Zh.toStringTag, { value: "TransformStream", configurable: true });
    var Ap = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Sp(this))
          throw Mp("desiredSize");
        return Ll(this._controlledTransformStream._readable._readableStreamController);
      }
      enqueue(e2 = void 0) {
        if (!Sp(this))
          throw Mp("enqueue");
        Pp(this, e2);
      }
      error(e2 = void 0) {
        if (!Sp(this))
          throw Mp("error");
        var t2;
        t2 = e2, vp(this._controlledTransformStream, t2);
      }
      terminate() {
        if (!Sp(this))
          throw Mp("terminate");
        !function(e2) {
          const t2 = e2._controlledTransformStream, r2 = t2._readable._readableStreamController;
          ql(r2);
          _p(t2, new TypeError("TransformStream terminated"));
        }(this);
      }
    };
    function Sp(e2) {
      return !!Qh(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream");
    }
    function Ep(e2) {
      e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0;
    }
    function Pp(e2, t2) {
      const r2 = e2._controlledTransformStream, i2 = r2._readable._readableStreamController;
      if (!Nl(i2))
        throw new TypeError("Readable side is not in a state that permits enqueue");
      try {
        Fl(i2, t2);
      } catch (e3) {
        throw _p(r2, e3), r2._readable._storedError;
      }
      const n2 = function(e3) {
        return !Tl(e3);
      }(i2);
      n2 !== r2._backpressure && kp(r2, true);
    }
    function xp(e2, t2) {
      return dd(e2._transformAlgorithm(t2), void 0, (t3) => {
        throw vp(e2._controlledTransformStream, t3), t3;
      });
    }
    function Mp(e2) {
      return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
    }
    function Kp(e2) {
      return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
    }
    Object.defineProperties(Ap.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), "symbol" == typeof Zh.toStringTag && Object.defineProperty(Ap.prototype, Zh.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
    var Cp = /* @__PURE__ */ Object.freeze({ __proto__: null, ByteLengthQueuingStrategy: cp, CountQueuingStrategy: fp, ReadableByteStreamController: cf, ReadableStream: Yl, ReadableStreamBYOBReader: Df, ReadableStreamBYOBRequest: of, ReadableStreamDefaultController: Rl, ReadableStreamDefaultReader: Wd, TransformStream: mp, TransformStreamDefaultController: Ap, WritableStream: jf, WritableStreamDefaultController: hl, WritableStreamDefaultWriter: rl });
    var Dp = function(e2, t2) {
      return Dp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
        e3.__proto__ = t3;
      } || function(e3, t3) {
        for (var r2 in t3)
          Object.prototype.hasOwnProperty.call(t3, r2) && (e3[r2] = t3[r2]);
      }, Dp(e2, t2);
    };
    function Up(e2, t2) {
      if ("function" != typeof t2 && null !== t2)
        throw new TypeError("Class extends value " + t2 + " is not a constructor or null");
      function r2() {
        this.constructor = e2;
      }
      Dp(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
    }
    function Rp(e2) {
      if (!e2)
        throw new TypeError("Assertion failed");
    }
    function Ip() {
    }
    function Bp(e2) {
      return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
    }
    function Tp(e2) {
      if ("function" != typeof e2)
        return false;
      var t2 = false;
      try {
        new e2({ start: function() {
          t2 = true;
        } });
      } catch (e3) {
      }
      return t2;
    }
    function zp(e2) {
      return !!Bp(e2) && "function" == typeof e2.getReader;
    }
    function qp(e2) {
      return !!Bp(e2) && "function" == typeof e2.getWriter;
    }
    function Fp(e2) {
      return !!Bp(e2) && (!!zp(e2.readable) && !!qp(e2.writable));
    }
    function Op(e2) {
      try {
        return e2.getReader({ mode: "byob" }).releaseLock(), true;
      } catch (e3) {
        return false;
      }
    }
    function Lp(e2, t2) {
      var r2 = (void 0 === t2 ? {} : t2).type;
      return Rp(zp(e2)), Rp(false === e2.locked), "bytes" === (r2 = Np(r2)) ? new Gp(e2) : new Hp(e2);
    }
    function Np(e2) {
      var t2 = e2 + "";
      if ("bytes" === t2)
        return t2;
      if (void 0 === e2)
        return e2;
      throw new RangeError("Invalid type is specified");
    }
    var jp = function() {
      function e2(e3) {
        this._underlyingReader = void 0, this._readerMode = void 0, this._readableStreamController = void 0, this._pendingRead = void 0, this._underlyingStream = e3, this._attachDefaultReader();
      }
      return e2.prototype.start = function(e3) {
        this._readableStreamController = e3;
      }, e2.prototype.cancel = function(e3) {
        return Rp(void 0 !== this._underlyingReader), this._underlyingReader.cancel(e3);
      }, e2.prototype._attachDefaultReader = function() {
        if ("default" !== this._readerMode) {
          this._detachReader();
          var e3 = this._underlyingStream.getReader();
          this._readerMode = "default", this._attachReader(e3);
        }
      }, e2.prototype._attachReader = function(e3) {
        var t2 = this;
        Rp(void 0 === this._underlyingReader), this._underlyingReader = e3;
        var r2 = this._underlyingReader.closed;
        r2 && r2.then(function() {
          return t2._finishPendingRead();
        }).then(function() {
          e3 === t2._underlyingReader && t2._readableStreamController.close();
        }, function(r3) {
          e3 === t2._underlyingReader && t2._readableStreamController.error(r3);
        }).catch(Ip);
      }, e2.prototype._detachReader = function() {
        void 0 !== this._underlyingReader && (this._underlyingReader.releaseLock(), this._underlyingReader = void 0, this._readerMode = void 0);
      }, e2.prototype._pullWithDefaultReader = function() {
        var e3 = this;
        this._attachDefaultReader();
        var t2 = this._underlyingReader.read().then(function(t3) {
          var r2 = e3._readableStreamController;
          t3.done ? e3._tryClose() : r2.enqueue(t3.value);
        });
        return this._setPendingRead(t2), t2;
      }, e2.prototype._tryClose = function() {
        try {
          this._readableStreamController.close();
        } catch (e3) {
        }
      }, e2.prototype._setPendingRead = function(e3) {
        var t2, r2 = this, i2 = function() {
          r2._pendingRead === t2 && (r2._pendingRead = void 0);
        };
        this._pendingRead = t2 = e3.then(i2, i2);
      }, e2.prototype._finishPendingRead = function() {
        var e3 = this;
        if (this._pendingRead) {
          var t2 = function() {
            return e3._finishPendingRead();
          };
          return this._pendingRead.then(t2, t2);
        }
      }, e2;
    }();
    var Hp = function(e2) {
      function t2() {
        return null !== e2 && e2.apply(this, arguments) || this;
      }
      return Up(t2, e2), t2.prototype.pull = function() {
        return this._pullWithDefaultReader();
      }, t2;
    }(jp);
    function Wp(e2) {
      return new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength);
    }
    var Gp = function(e2) {
      function t2(t3) {
        var r2 = this, i2 = Op(t3);
        return (r2 = e2.call(this, t3) || this)._supportsByob = i2, r2;
      }
      return Up(t2, e2), Object.defineProperty(t2.prototype, "type", { get: function() {
        return "bytes";
      }, enumerable: false, configurable: true }), t2.prototype._attachByobReader = function() {
        if ("byob" !== this._readerMode) {
          Rp(this._supportsByob), this._detachReader();
          var e3 = this._underlyingStream.getReader({ mode: "byob" });
          this._readerMode = "byob", this._attachReader(e3);
        }
      }, t2.prototype.pull = function() {
        if (this._supportsByob) {
          var e3 = this._readableStreamController.byobRequest;
          if (e3)
            return this._pullWithByobRequest(e3);
        }
        return this._pullWithDefaultReader();
      }, t2.prototype._pullWithByobRequest = function(e3) {
        var t3 = this;
        this._attachByobReader();
        var r2 = new Uint8Array(e3.view.byteLength), i2 = this._underlyingReader.read(r2).then(function(r3) {
          var i3, n2, a2;
          t3._readableStreamController, r3.done ? (t3._tryClose(), e3.respond(0)) : (i3 = r3.value, n2 = e3.view, a2 = Wp(i3), Wp(n2).set(a2, 0), e3.respond(r3.value.byteLength));
        });
        return this._setPendingRead(i2), i2;
      }, t2;
    }(jp);
    function Vp(e2) {
      Rp(qp(e2)), Rp(false === e2.locked);
      var t2 = e2.getWriter();
      return new $p(t2);
    }
    var $p = function() {
      function e2(e3) {
        var t2 = this;
        this._writableStreamController = void 0, this._pendingWrite = void 0, this._state = "writable", this._storedError = void 0, this._underlyingWriter = e3, this._errorPromise = new Promise(function(e4, r2) {
          t2._errorPromiseReject = r2;
        }), this._errorPromise.catch(Ip);
      }
      return e2.prototype.start = function(e3) {
        var t2 = this;
        this._writableStreamController = e3, this._underlyingWriter.closed.then(function() {
          t2._state = "closed";
        }).catch(function(e4) {
          return t2._finishErroring(e4);
        });
      }, e2.prototype.write = function(e3) {
        var t2 = this, r2 = this._underlyingWriter;
        if (null === r2.desiredSize)
          return r2.ready;
        var i2 = r2.write(e3);
        i2.catch(function(e4) {
          return t2._finishErroring(e4);
        }), r2.ready.catch(function(e4) {
          return t2._startErroring(e4);
        });
        var n2 = Promise.race([i2, this._errorPromise]);
        return this._setPendingWrite(n2), n2;
      }, e2.prototype.close = function() {
        var e3 = this;
        return void 0 === this._pendingWrite ? this._underlyingWriter.close() : this._finishPendingWrite().then(function() {
          return e3.close();
        });
      }, e2.prototype.abort = function(e3) {
        if ("errored" !== this._state)
          return this._underlyingWriter.abort(e3);
      }, e2.prototype._setPendingWrite = function(e3) {
        var t2, r2 = this, i2 = function() {
          r2._pendingWrite === t2 && (r2._pendingWrite = void 0);
        };
        this._pendingWrite = t2 = e3.then(i2, i2);
      }, e2.prototype._finishPendingWrite = function() {
        var e3 = this;
        if (void 0 === this._pendingWrite)
          return Promise.resolve();
        var t2 = function() {
          return e3._finishPendingWrite();
        };
        return this._pendingWrite.then(t2, t2);
      }, e2.prototype._startErroring = function(e3) {
        var t2 = this;
        if ("writable" === this._state) {
          this._state = "erroring", this._storedError = e3;
          var r2 = function() {
            return t2._finishErroring(e3);
          };
          void 0 === this._pendingWrite ? r2() : this._finishPendingWrite().then(r2, r2), this._writableStreamController.error(e3);
        }
      }, e2.prototype._finishErroring = function(e3) {
        "writable" === this._state && this._startErroring(e3), "erroring" === this._state && (this._state = "errored", this._errorPromiseReject(this._storedError));
      }, e2;
    }();
    function Zp(e2) {
      Rp(Fp(e2));
      var t2 = e2.readable, r2 = e2.writable;
      Rp(false === t2.locked), Rp(false === r2.locked);
      var i2, n2 = t2.getReader();
      try {
        i2 = r2.getWriter();
      } catch (e3) {
        throw n2.releaseLock(), e3;
      }
      return new Xp(n2, i2);
    }
    var Xp = function() {
      function e2(e3, t2) {
        var r2 = this;
        this._transformStreamController = void 0, this._onRead = function(e4) {
          if (!e4.done)
            return r2._transformStreamController.enqueue(e4.value), r2._reader.read().then(r2._onRead);
        }, this._onError = function(e4) {
          r2._flushReject(e4), r2._transformStreamController.error(e4), r2._reader.cancel(e4).catch(Ip), r2._writer.abort(e4).catch(Ip);
        }, this._onTerminate = function() {
          r2._flushResolve(), r2._transformStreamController.terminate();
          var e4 = new TypeError("TransformStream terminated");
          r2._writer.abort(e4).catch(Ip);
        }, this._reader = e3, this._writer = t2, this._flushPromise = new Promise(function(e4, t3) {
          r2._flushResolve = e4, r2._flushReject = t3;
        });
      }
      return e2.prototype.start = function(e3) {
        this._transformStreamController = e3, this._reader.read().then(this._onRead).then(this._onTerminate, this._onError);
        var t2 = this._reader.closed;
        t2 && t2.then(this._onTerminate, this._onError);
      }, e2.prototype.transform = function(e3) {
        return this._writer.write(e3);
      }, e2.prototype.flush = function() {
        var e3 = this;
        return this._writer.close().then(function() {
          return e3._flushPromise;
        });
      }, e2;
    }();
    var Yp = /* @__PURE__ */ Object.freeze({ __proto__: null, createReadableStreamWrapper: function(e2) {
      Rp(function(e3) {
        return !!Tp(e3) && !!zp(new e3());
      }(e2));
      var t2 = function(e3) {
        try {
          return new e3({ type: "bytes" }), true;
        } catch (e4) {
          return false;
        }
      }(e2);
      return function(r2, i2) {
        var n2 = (void 0 === i2 ? {} : i2).type;
        if ("bytes" !== (n2 = Np(n2)) || t2 || (n2 = void 0), r2.constructor === e2 && ("bytes" !== n2 || Op(r2)))
          return r2;
        if ("bytes" === n2) {
          var a2 = Lp(r2, { type: n2 });
          return new e2(a2);
        }
        a2 = Lp(r2);
        return new e2(a2);
      };
    }, createTransformStreamWrapper: function(e2) {
      return Rp(function(e3) {
        return !!Tp(e3) && !!Fp(new e3());
      }(e2)), function(t2) {
        if (t2.constructor === e2)
          return t2;
        var r2 = Zp(t2);
        return new e2(r2);
      };
    }, createWrappingReadableSource: Lp, createWrappingTransformer: Zp, createWrappingWritableSink: Vp, createWritableStreamWrapper: function(e2) {
      return Rp(function(e3) {
        return !!Tp(e3) && !!qp(new e3());
      }(e2)), function(t2) {
        if (t2.constructor === e2)
          return t2;
        var r2 = Vp(t2);
        return new e2(r2);
      };
    } });
    var Qp = mt(function(e2) {
      !function(e3, t2) {
        function r2(e4, t3) {
          if (!e4)
            throw Error(t3 || "Assertion failed");
        }
        function i2(e4, t3) {
          e4.super_ = t3;
          var r3 = function() {
          };
          r3.prototype = t3.prototype, e4.prototype = new r3(), e4.prototype.constructor = e4;
        }
        function n2(e4, t3, r3) {
          if (n2.isBN(e4))
            return e4;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e4 && ("le" !== t3 && "be" !== t3 || (r3 = t3, t3 = 10), this._init(e4 || 0, t3 || 10, r3 || "be"));
        }
        var a2;
        "object" == typeof e3 ? e3.exports = n2 : t2.BN = n2, n2.BN = n2, n2.wordSize = 26;
        try {
          a2 = u.default.Buffer;
        } catch (e4) {
        }
        function s2(e4, t3, r3) {
          for (var i3 = 0, n3 = Math.min(e4.length, r3), a3 = t3; a3 < n3; a3++) {
            var s3 = e4.charCodeAt(a3) - 48;
            i3 <<= 4, i3 |= s3 >= 49 && s3 <= 54 ? s3 - 49 + 10 : s3 >= 17 && s3 <= 22 ? s3 - 17 + 10 : 15 & s3;
          }
          return i3;
        }
        function o2(e4, t3, r3, i3) {
          for (var n3 = 0, a3 = Math.min(e4.length, r3), s3 = t3; s3 < a3; s3++) {
            var o3 = e4.charCodeAt(s3) - 48;
            n3 *= i3, n3 += o3 >= 49 ? o3 - 49 + 10 : o3 >= 17 ? o3 - 17 + 10 : o3;
          }
          return n3;
        }
        n2.isBN = function(e4) {
          return e4 instanceof n2 || null !== e4 && "object" == typeof e4 && e4.constructor.wordSize === n2.wordSize && Array.isArray(e4.words);
        }, n2.max = function(e4, t3) {
          return e4.cmp(t3) > 0 ? e4 : t3;
        }, n2.min = function(e4, t3) {
          return e4.cmp(t3) < 0 ? e4 : t3;
        }, n2.prototype._init = function(e4, t3, i3) {
          if ("number" == typeof e4)
            return this._initNumber(e4, t3, i3);
          if ("object" == typeof e4)
            return this._initArray(e4, t3, i3);
          "hex" === t3 && (t3 = 16), r2(t3 === (0 | t3) && t3 >= 2 && t3 <= 36);
          var n3 = 0;
          "-" === (e4 = e4.toString().replace(/\s+/g, ""))[0] && n3++, 16 === t3 ? this._parseHex(e4, n3) : this._parseBase(e4, t3, n3), "-" === e4[0] && (this.negative = 1), this.strip(), "le" === i3 && this._initArray(this.toArray(), t3, i3);
        }, n2.prototype._initNumber = function(e4, t3, i3) {
          e4 < 0 && (this.negative = 1, e4 = -e4), e4 < 67108864 ? (this.words = [67108863 & e4], this.length = 1) : e4 < 4503599627370496 ? (this.words = [67108863 & e4, e4 / 67108864 & 67108863], this.length = 2) : (r2(e4 < 9007199254740992), this.words = [67108863 & e4, e4 / 67108864 & 67108863, 1], this.length = 3), "le" === i3 && this._initArray(this.toArray(), t3, i3);
        }, n2.prototype._initArray = function(e4, t3, i3) {
          if (r2("number" == typeof e4.length), e4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(e4.length / 3), this.words = Array(this.length);
          for (var n3 = 0; n3 < this.length; n3++)
            this.words[n3] = 0;
          var a3, s3, o3 = 0;
          if ("be" === i3)
            for (n3 = e4.length - 1, a3 = 0; n3 >= 0; n3 -= 3)
              s3 = e4[n3] | e4[n3 - 1] << 8 | e4[n3 - 2] << 16, this.words[a3] |= s3 << o3 & 67108863, this.words[a3 + 1] = s3 >>> 26 - o3 & 67108863, (o3 += 24) >= 26 && (o3 -= 26, a3++);
          else if ("le" === i3)
            for (n3 = 0, a3 = 0; n3 < e4.length; n3 += 3)
              s3 = e4[n3] | e4[n3 + 1] << 8 | e4[n3 + 2] << 16, this.words[a3] |= s3 << o3 & 67108863, this.words[a3 + 1] = s3 >>> 26 - o3 & 67108863, (o3 += 24) >= 26 && (o3 -= 26, a3++);
          return this.strip();
        }, n2.prototype._parseHex = function(e4, t3) {
          this.length = Math.ceil((e4.length - t3) / 6), this.words = Array(this.length);
          for (var r3 = 0; r3 < this.length; r3++)
            this.words[r3] = 0;
          var i3, n3, a3 = 0;
          for (r3 = e4.length - 6, i3 = 0; r3 >= t3; r3 -= 6)
            n3 = s2(e4, r3, r3 + 6), this.words[i3] |= n3 << a3 & 67108863, this.words[i3 + 1] |= n3 >>> 26 - a3 & 4194303, (a3 += 24) >= 26 && (a3 -= 26, i3++);
          r3 + 6 !== t3 && (n3 = s2(e4, t3, r3 + 6), this.words[i3] |= n3 << a3 & 67108863, this.words[i3 + 1] |= n3 >>> 26 - a3 & 4194303), this.strip();
        }, n2.prototype._parseBase = function(e4, t3, r3) {
          this.words = [0], this.length = 1;
          for (var i3 = 0, n3 = 1; n3 <= 67108863; n3 *= t3)
            i3++;
          i3--, n3 = n3 / t3 | 0;
          for (var a3 = e4.length - r3, s3 = a3 % i3, c3 = Math.min(a3, a3 - s3) + r3, u2 = 0, h3 = r3; h3 < c3; h3 += i3)
            u2 = o2(e4, h3, h3 + i3, t3), this.imuln(n3), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          if (0 !== s3) {
            var d3 = 1;
            for (u2 = o2(e4, h3, e4.length, t3), h3 = 0; h3 < s3; h3++)
              d3 *= t3;
            this.imuln(d3), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          }
        }, n2.prototype.copy = function(e4) {
          e4.words = Array(this.length);
          for (var t3 = 0; t3 < this.length; t3++)
            e4.words[t3] = this.words[t3];
          e4.length = this.length, e4.negative = this.negative, e4.red = this.red;
        }, n2.prototype.clone = function() {
          var e4 = new n2(null);
          return this.copy(e4), e4;
        }, n2.prototype._expand = function(e4) {
          for (; this.length < e4; )
            this.words[this.length++] = 0;
          return this;
        }, n2.prototype.strip = function() {
          for (; this.length > 1 && 0 === this.words[this.length - 1]; )
            this.length--;
          return this._normSign();
        }, n2.prototype._normSign = function() {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, n2.prototype.inspect = function() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var c2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], d2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        function f2(e4, t3, r3) {
          r3.negative = t3.negative ^ e4.negative;
          var i3 = e4.length + t3.length | 0;
          r3.length = i3, i3 = i3 - 1 | 0;
          var n3 = 0 | e4.words[0], a3 = 0 | t3.words[0], s3 = n3 * a3, o3 = 67108863 & s3, c3 = s3 / 67108864 | 0;
          r3.words[0] = o3;
          for (var u2 = 1; u2 < i3; u2++) {
            for (var h3 = c3 >>> 26, d3 = 67108863 & c3, f3 = Math.min(u2, t3.length - 1), l3 = Math.max(0, u2 - e4.length + 1); l3 <= f3; l3++) {
              var p3 = u2 - l3 | 0;
              h3 += (s3 = (n3 = 0 | e4.words[p3]) * (a3 = 0 | t3.words[l3]) + d3) / 67108864 | 0, d3 = 67108863 & s3;
            }
            r3.words[u2] = 0 | d3, c3 = 0 | h3;
          }
          return 0 !== c3 ? r3.words[u2] = 0 | c3 : r3.length--, r3.strip();
        }
        n2.prototype.toString = function(e4, t3) {
          var i3;
          if (t3 = 0 | t3 || 1, 16 === (e4 = e4 || 10) || "hex" === e4) {
            i3 = "";
            for (var n3 = 0, a3 = 0, s3 = 0; s3 < this.length; s3++) {
              var o3 = this.words[s3], u2 = (16777215 & (o3 << n3 | a3)).toString(16);
              i3 = 0 !== (a3 = o3 >>> 24 - n3 & 16777215) || s3 !== this.length - 1 ? c2[6 - u2.length] + u2 + i3 : u2 + i3, (n3 += 2) >= 26 && (n3 -= 26, s3--);
            }
            for (0 !== a3 && (i3 = a3.toString(16) + i3); i3.length % t3 != 0; )
              i3 = "0" + i3;
            return 0 !== this.negative && (i3 = "-" + i3), i3;
          }
          if (e4 === (0 | e4) && e4 >= 2 && e4 <= 36) {
            var f3 = h2[e4], l3 = d2[e4];
            i3 = "";
            var p3 = this.clone();
            for (p3.negative = 0; !p3.isZero(); ) {
              var y3 = p3.modn(l3).toString(e4);
              i3 = (p3 = p3.idivn(l3)).isZero() ? y3 + i3 : c2[f3 - y3.length] + y3 + i3;
            }
            for (this.isZero() && (i3 = "0" + i3); i3.length % t3 != 0; )
              i3 = "0" + i3;
            return 0 !== this.negative && (i3 = "-" + i3), i3;
          }
          r2(false, "Base should be between 2 and 36");
        }, n2.prototype.toNumber = function() {
          var e4 = this.words[0];
          return 2 === this.length ? e4 += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e4 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r2(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e4 : e4;
        }, n2.prototype.toJSON = function() {
          return this.toString(16);
        }, n2.prototype.toBuffer = function(e4, t3) {
          return r2(void 0 !== a2), this.toArrayLike(a2, e4, t3);
        }, n2.prototype.toArray = function(e4, t3) {
          return this.toArrayLike(Array, e4, t3);
        }, n2.prototype.toArrayLike = function(e4, t3, i3) {
          var n3 = this.byteLength(), a3 = i3 || Math.max(1, n3);
          r2(n3 <= a3, "byte array longer than desired length"), r2(a3 > 0, "Requested array length <= 0"), this.strip();
          var s3, o3, c3 = "le" === t3, u2 = new e4(a3), h3 = this.clone();
          if (c3) {
            for (o3 = 0; !h3.isZero(); o3++)
              s3 = h3.andln(255), h3.iushrn(8), u2[o3] = s3;
            for (; o3 < a3; o3++)
              u2[o3] = 0;
          } else {
            for (o3 = 0; o3 < a3 - n3; o3++)
              u2[o3] = 0;
            for (o3 = 0; !h3.isZero(); o3++)
              s3 = h3.andln(255), h3.iushrn(8), u2[a3 - o3 - 1] = s3;
          }
          return u2;
        }, n2.prototype._countBits = Math.clz32 ? function(e4) {
          return 32 - Math.clz32(e4);
        } : function(e4) {
          var t3 = e4, r3 = 0;
          return t3 >= 4096 && (r3 += 13, t3 >>>= 13), t3 >= 64 && (r3 += 7, t3 >>>= 7), t3 >= 8 && (r3 += 4, t3 >>>= 4), t3 >= 2 && (r3 += 2, t3 >>>= 2), r3 + t3;
        }, n2.prototype._zeroBits = function(e4) {
          if (0 === e4)
            return 26;
          var t3 = e4, r3 = 0;
          return 0 == (8191 & t3) && (r3 += 13, t3 >>>= 13), 0 == (127 & t3) && (r3 += 7, t3 >>>= 7), 0 == (15 & t3) && (r3 += 4, t3 >>>= 4), 0 == (3 & t3) && (r3 += 2, t3 >>>= 2), 0 == (1 & t3) && r3++, r3;
        }, n2.prototype.bitLength = function() {
          var e4 = this.words[this.length - 1], t3 = this._countBits(e4);
          return 26 * (this.length - 1) + t3;
        }, n2.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var e4 = 0, t3 = 0; t3 < this.length; t3++) {
            var r3 = this._zeroBits(this.words[t3]);
            if (e4 += r3, 26 !== r3)
              break;
          }
          return e4;
        }, n2.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, n2.prototype.toTwos = function(e4) {
          return 0 !== this.negative ? this.abs().inotn(e4).iaddn(1) : this.clone();
        }, n2.prototype.fromTwos = function(e4) {
          return this.testn(e4 - 1) ? this.notn(e4).iaddn(1).ineg() : this.clone();
        }, n2.prototype.isNeg = function() {
          return 0 !== this.negative;
        }, n2.prototype.neg = function() {
          return this.clone().ineg();
        }, n2.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, n2.prototype.iuor = function(e4) {
          for (; this.length < e4.length; )
            this.words[this.length++] = 0;
          for (var t3 = 0; t3 < e4.length; t3++)
            this.words[t3] = this.words[t3] | e4.words[t3];
          return this.strip();
        }, n2.prototype.ior = function(e4) {
          return r2(0 == (this.negative | e4.negative)), this.iuor(e4);
        }, n2.prototype.or = function(e4) {
          return this.length > e4.length ? this.clone().ior(e4) : e4.clone().ior(this);
        }, n2.prototype.uor = function(e4) {
          return this.length > e4.length ? this.clone().iuor(e4) : e4.clone().iuor(this);
        }, n2.prototype.iuand = function(e4) {
          var t3;
          t3 = this.length > e4.length ? e4 : this;
          for (var r3 = 0; r3 < t3.length; r3++)
            this.words[r3] = this.words[r3] & e4.words[r3];
          return this.length = t3.length, this.strip();
        }, n2.prototype.iand = function(e4) {
          return r2(0 == (this.negative | e4.negative)), this.iuand(e4);
        }, n2.prototype.and = function(e4) {
          return this.length > e4.length ? this.clone().iand(e4) : e4.clone().iand(this);
        }, n2.prototype.uand = function(e4) {
          return this.length > e4.length ? this.clone().iuand(e4) : e4.clone().iuand(this);
        }, n2.prototype.iuxor = function(e4) {
          var t3, r3;
          this.length > e4.length ? (t3 = this, r3 = e4) : (t3 = e4, r3 = this);
          for (var i3 = 0; i3 < r3.length; i3++)
            this.words[i3] = t3.words[i3] ^ r3.words[i3];
          if (this !== t3)
            for (; i3 < t3.length; i3++)
              this.words[i3] = t3.words[i3];
          return this.length = t3.length, this.strip();
        }, n2.prototype.ixor = function(e4) {
          return r2(0 == (this.negative | e4.negative)), this.iuxor(e4);
        }, n2.prototype.xor = function(e4) {
          return this.length > e4.length ? this.clone().ixor(e4) : e4.clone().ixor(this);
        }, n2.prototype.uxor = function(e4) {
          return this.length > e4.length ? this.clone().iuxor(e4) : e4.clone().iuxor(this);
        }, n2.prototype.inotn = function(e4) {
          r2("number" == typeof e4 && e4 >= 0);
          var t3 = 0 | Math.ceil(e4 / 26), i3 = e4 % 26;
          this._expand(t3), i3 > 0 && t3--;
          for (var n3 = 0; n3 < t3; n3++)
            this.words[n3] = 67108863 & ~this.words[n3];
          return i3 > 0 && (this.words[n3] = ~this.words[n3] & 67108863 >> 26 - i3), this.strip();
        }, n2.prototype.notn = function(e4) {
          return this.clone().inotn(e4);
        }, n2.prototype.setn = function(e4, t3) {
          r2("number" == typeof e4 && e4 >= 0);
          var i3 = e4 / 26 | 0, n3 = e4 % 26;
          return this._expand(i3 + 1), this.words[i3] = t3 ? this.words[i3] | 1 << n3 : this.words[i3] & ~(1 << n3), this.strip();
        }, n2.prototype.iadd = function(e4) {
          var t3, r3, i3;
          if (0 !== this.negative && 0 === e4.negative)
            return this.negative = 0, t3 = this.isub(e4), this.negative ^= 1, this._normSign();
          if (0 === this.negative && 0 !== e4.negative)
            return e4.negative = 0, t3 = this.isub(e4), e4.negative = 1, t3._normSign();
          this.length > e4.length ? (r3 = this, i3 = e4) : (r3 = e4, i3 = this);
          for (var n3 = 0, a3 = 0; a3 < i3.length; a3++)
            t3 = (0 | r3.words[a3]) + (0 | i3.words[a3]) + n3, this.words[a3] = 67108863 & t3, n3 = t3 >>> 26;
          for (; 0 !== n3 && a3 < r3.length; a3++)
            t3 = (0 | r3.words[a3]) + n3, this.words[a3] = 67108863 & t3, n3 = t3 >>> 26;
          if (this.length = r3.length, 0 !== n3)
            this.words[this.length] = n3, this.length++;
          else if (r3 !== this)
            for (; a3 < r3.length; a3++)
              this.words[a3] = r3.words[a3];
          return this;
        }, n2.prototype.add = function(e4) {
          var t3;
          return 0 !== e4.negative && 0 === this.negative ? (e4.negative = 0, t3 = this.sub(e4), e4.negative ^= 1, t3) : 0 === e4.negative && 0 !== this.negative ? (this.negative = 0, t3 = e4.sub(this), this.negative = 1, t3) : this.length > e4.length ? this.clone().iadd(e4) : e4.clone().iadd(this);
        }, n2.prototype.isub = function(e4) {
          if (0 !== e4.negative) {
            e4.negative = 0;
            var t3 = this.iadd(e4);
            return e4.negative = 1, t3._normSign();
          }
          if (0 !== this.negative)
            return this.negative = 0, this.iadd(e4), this.negative = 1, this._normSign();
          var r3, i3, n3 = this.cmp(e4);
          if (0 === n3)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          n3 > 0 ? (r3 = this, i3 = e4) : (r3 = e4, i3 = this);
          for (var a3 = 0, s3 = 0; s3 < i3.length; s3++)
            a3 = (t3 = (0 | r3.words[s3]) - (0 | i3.words[s3]) + a3) >> 26, this.words[s3] = 67108863 & t3;
          for (; 0 !== a3 && s3 < r3.length; s3++)
            a3 = (t3 = (0 | r3.words[s3]) + a3) >> 26, this.words[s3] = 67108863 & t3;
          if (0 === a3 && s3 < r3.length && r3 !== this)
            for (; s3 < r3.length; s3++)
              this.words[s3] = r3.words[s3];
          return this.length = Math.max(this.length, s3), r3 !== this && (this.negative = 1), this.strip();
        }, n2.prototype.sub = function(e4) {
          return this.clone().isub(e4);
        };
        var l2 = function(e4, t3, r3) {
          var i3, n3, a3, s3 = e4.words, o3 = t3.words, c3 = r3.words, u2 = 0, h3 = 0 | s3[0], d3 = 8191 & h3, f3 = h3 >>> 13, l3 = 0 | s3[1], p3 = 8191 & l3, y3 = l3 >>> 13, b3 = 0 | s3[2], g3 = 8191 & b3, m3 = b3 >>> 13, w3 = 0 | s3[3], v6 = 8191 & w3, _3 = w3 >>> 13, k3 = 0 | s3[4], A3 = 8191 & k3, S2 = k3 >>> 13, E2 = 0 | s3[5], P2 = 8191 & E2, x2 = E2 >>> 13, M2 = 0 | s3[6], K2 = 8191 & M2, C2 = M2 >>> 13, D2 = 0 | s3[7], U2 = 8191 & D2, R2 = D2 >>> 13, I2 = 0 | s3[8], B2 = 8191 & I2, T2 = I2 >>> 13, z2 = 0 | s3[9], q2 = 8191 & z2, F2 = z2 >>> 13, O2 = 0 | o3[0], L2 = 8191 & O2, N2 = O2 >>> 13, j2 = 0 | o3[1], H2 = 8191 & j2, W2 = j2 >>> 13, G2 = 0 | o3[2], V2 = 8191 & G2, $2 = G2 >>> 13, Z2 = 0 | o3[3], X2 = 8191 & Z2, Y2 = Z2 >>> 13, Q2 = 0 | o3[4], J2 = 8191 & Q2, ee2 = Q2 >>> 13, te2 = 0 | o3[5], re2 = 8191 & te2, ie2 = te2 >>> 13, ne2 = 0 | o3[6], ae2 = 8191 & ne2, se2 = ne2 >>> 13, oe2 = 0 | o3[7], ce2 = 8191 & oe2, ue2 = oe2 >>> 13, he2 = 0 | o3[8], de2 = 8191 & he2, fe2 = he2 >>> 13, le2 = 0 | o3[9], pe2 = 8191 & le2, ye2 = le2 >>> 13;
          r3.negative = e4.negative ^ t3.negative, r3.length = 19;
          var be2 = (u2 + (i3 = Math.imul(d3, L2)) | 0) + ((8191 & (n3 = (n3 = Math.imul(d3, N2)) + Math.imul(f3, L2) | 0)) << 13) | 0;
          u2 = ((a3 = Math.imul(f3, N2)) + (n3 >>> 13) | 0) + (be2 >>> 26) | 0, be2 &= 67108863, i3 = Math.imul(p3, L2), n3 = (n3 = Math.imul(p3, N2)) + Math.imul(y3, L2) | 0, a3 = Math.imul(y3, N2);
          var ge2 = (u2 + (i3 = i3 + Math.imul(d3, H2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, W2) | 0) + Math.imul(f3, H2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, W2) | 0) + (n3 >>> 13) | 0) + (ge2 >>> 26) | 0, ge2 &= 67108863, i3 = Math.imul(g3, L2), n3 = (n3 = Math.imul(g3, N2)) + Math.imul(m3, L2) | 0, a3 = Math.imul(m3, N2), i3 = i3 + Math.imul(p3, H2) | 0, n3 = (n3 = n3 + Math.imul(p3, W2) | 0) + Math.imul(y3, H2) | 0, a3 = a3 + Math.imul(y3, W2) | 0;
          var me2 = (u2 + (i3 = i3 + Math.imul(d3, V2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, $2) | 0) + Math.imul(f3, V2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, $2) | 0) + (n3 >>> 13) | 0) + (me2 >>> 26) | 0, me2 &= 67108863, i3 = Math.imul(v6, L2), n3 = (n3 = Math.imul(v6, N2)) + Math.imul(_3, L2) | 0, a3 = Math.imul(_3, N2), i3 = i3 + Math.imul(g3, H2) | 0, n3 = (n3 = n3 + Math.imul(g3, W2) | 0) + Math.imul(m3, H2) | 0, a3 = a3 + Math.imul(m3, W2) | 0, i3 = i3 + Math.imul(p3, V2) | 0, n3 = (n3 = n3 + Math.imul(p3, $2) | 0) + Math.imul(y3, V2) | 0, a3 = a3 + Math.imul(y3, $2) | 0;
          var we2 = (u2 + (i3 = i3 + Math.imul(d3, X2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, Y2) | 0) + Math.imul(f3, X2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, Y2) | 0) + (n3 >>> 13) | 0) + (we2 >>> 26) | 0, we2 &= 67108863, i3 = Math.imul(A3, L2), n3 = (n3 = Math.imul(A3, N2)) + Math.imul(S2, L2) | 0, a3 = Math.imul(S2, N2), i3 = i3 + Math.imul(v6, H2) | 0, n3 = (n3 = n3 + Math.imul(v6, W2) | 0) + Math.imul(_3, H2) | 0, a3 = a3 + Math.imul(_3, W2) | 0, i3 = i3 + Math.imul(g3, V2) | 0, n3 = (n3 = n3 + Math.imul(g3, $2) | 0) + Math.imul(m3, V2) | 0, a3 = a3 + Math.imul(m3, $2) | 0, i3 = i3 + Math.imul(p3, X2) | 0, n3 = (n3 = n3 + Math.imul(p3, Y2) | 0) + Math.imul(y3, X2) | 0, a3 = a3 + Math.imul(y3, Y2) | 0;
          var ve2 = (u2 + (i3 = i3 + Math.imul(d3, J2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, ee2) | 0) + Math.imul(f3, J2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, ee2) | 0) + (n3 >>> 13) | 0) + (ve2 >>> 26) | 0, ve2 &= 67108863, i3 = Math.imul(P2, L2), n3 = (n3 = Math.imul(P2, N2)) + Math.imul(x2, L2) | 0, a3 = Math.imul(x2, N2), i3 = i3 + Math.imul(A3, H2) | 0, n3 = (n3 = n3 + Math.imul(A3, W2) | 0) + Math.imul(S2, H2) | 0, a3 = a3 + Math.imul(S2, W2) | 0, i3 = i3 + Math.imul(v6, V2) | 0, n3 = (n3 = n3 + Math.imul(v6, $2) | 0) + Math.imul(_3, V2) | 0, a3 = a3 + Math.imul(_3, $2) | 0, i3 = i3 + Math.imul(g3, X2) | 0, n3 = (n3 = n3 + Math.imul(g3, Y2) | 0) + Math.imul(m3, X2) | 0, a3 = a3 + Math.imul(m3, Y2) | 0, i3 = i3 + Math.imul(p3, J2) | 0, n3 = (n3 = n3 + Math.imul(p3, ee2) | 0) + Math.imul(y3, J2) | 0, a3 = a3 + Math.imul(y3, ee2) | 0;
          var _e2 = (u2 + (i3 = i3 + Math.imul(d3, re2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, ie2) | 0) + Math.imul(f3, re2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, ie2) | 0) + (n3 >>> 13) | 0) + (_e2 >>> 26) | 0, _e2 &= 67108863, i3 = Math.imul(K2, L2), n3 = (n3 = Math.imul(K2, N2)) + Math.imul(C2, L2) | 0, a3 = Math.imul(C2, N2), i3 = i3 + Math.imul(P2, H2) | 0, n3 = (n3 = n3 + Math.imul(P2, W2) | 0) + Math.imul(x2, H2) | 0, a3 = a3 + Math.imul(x2, W2) | 0, i3 = i3 + Math.imul(A3, V2) | 0, n3 = (n3 = n3 + Math.imul(A3, $2) | 0) + Math.imul(S2, V2) | 0, a3 = a3 + Math.imul(S2, $2) | 0, i3 = i3 + Math.imul(v6, X2) | 0, n3 = (n3 = n3 + Math.imul(v6, Y2) | 0) + Math.imul(_3, X2) | 0, a3 = a3 + Math.imul(_3, Y2) | 0, i3 = i3 + Math.imul(g3, J2) | 0, n3 = (n3 = n3 + Math.imul(g3, ee2) | 0) + Math.imul(m3, J2) | 0, a3 = a3 + Math.imul(m3, ee2) | 0, i3 = i3 + Math.imul(p3, re2) | 0, n3 = (n3 = n3 + Math.imul(p3, ie2) | 0) + Math.imul(y3, re2) | 0, a3 = a3 + Math.imul(y3, ie2) | 0;
          var ke2 = (u2 + (i3 = i3 + Math.imul(d3, ae2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, se2) | 0) + Math.imul(f3, ae2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, se2) | 0) + (n3 >>> 13) | 0) + (ke2 >>> 26) | 0, ke2 &= 67108863, i3 = Math.imul(U2, L2), n3 = (n3 = Math.imul(U2, N2)) + Math.imul(R2, L2) | 0, a3 = Math.imul(R2, N2), i3 = i3 + Math.imul(K2, H2) | 0, n3 = (n3 = n3 + Math.imul(K2, W2) | 0) + Math.imul(C2, H2) | 0, a3 = a3 + Math.imul(C2, W2) | 0, i3 = i3 + Math.imul(P2, V2) | 0, n3 = (n3 = n3 + Math.imul(P2, $2) | 0) + Math.imul(x2, V2) | 0, a3 = a3 + Math.imul(x2, $2) | 0, i3 = i3 + Math.imul(A3, X2) | 0, n3 = (n3 = n3 + Math.imul(A3, Y2) | 0) + Math.imul(S2, X2) | 0, a3 = a3 + Math.imul(S2, Y2) | 0, i3 = i3 + Math.imul(v6, J2) | 0, n3 = (n3 = n3 + Math.imul(v6, ee2) | 0) + Math.imul(_3, J2) | 0, a3 = a3 + Math.imul(_3, ee2) | 0, i3 = i3 + Math.imul(g3, re2) | 0, n3 = (n3 = n3 + Math.imul(g3, ie2) | 0) + Math.imul(m3, re2) | 0, a3 = a3 + Math.imul(m3, ie2) | 0, i3 = i3 + Math.imul(p3, ae2) | 0, n3 = (n3 = n3 + Math.imul(p3, se2) | 0) + Math.imul(y3, ae2) | 0, a3 = a3 + Math.imul(y3, se2) | 0;
          var Ae2 = (u2 + (i3 = i3 + Math.imul(d3, ce2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, ue2) | 0) + Math.imul(f3, ce2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, ue2) | 0) + (n3 >>> 13) | 0) + (Ae2 >>> 26) | 0, Ae2 &= 67108863, i3 = Math.imul(B2, L2), n3 = (n3 = Math.imul(B2, N2)) + Math.imul(T2, L2) | 0, a3 = Math.imul(T2, N2), i3 = i3 + Math.imul(U2, H2) | 0, n3 = (n3 = n3 + Math.imul(U2, W2) | 0) + Math.imul(R2, H2) | 0, a3 = a3 + Math.imul(R2, W2) | 0, i3 = i3 + Math.imul(K2, V2) | 0, n3 = (n3 = n3 + Math.imul(K2, $2) | 0) + Math.imul(C2, V2) | 0, a3 = a3 + Math.imul(C2, $2) | 0, i3 = i3 + Math.imul(P2, X2) | 0, n3 = (n3 = n3 + Math.imul(P2, Y2) | 0) + Math.imul(x2, X2) | 0, a3 = a3 + Math.imul(x2, Y2) | 0, i3 = i3 + Math.imul(A3, J2) | 0, n3 = (n3 = n3 + Math.imul(A3, ee2) | 0) + Math.imul(S2, J2) | 0, a3 = a3 + Math.imul(S2, ee2) | 0, i3 = i3 + Math.imul(v6, re2) | 0, n3 = (n3 = n3 + Math.imul(v6, ie2) | 0) + Math.imul(_3, re2) | 0, a3 = a3 + Math.imul(_3, ie2) | 0, i3 = i3 + Math.imul(g3, ae2) | 0, n3 = (n3 = n3 + Math.imul(g3, se2) | 0) + Math.imul(m3, ae2) | 0, a3 = a3 + Math.imul(m3, se2) | 0, i3 = i3 + Math.imul(p3, ce2) | 0, n3 = (n3 = n3 + Math.imul(p3, ue2) | 0) + Math.imul(y3, ce2) | 0, a3 = a3 + Math.imul(y3, ue2) | 0;
          var Se2 = (u2 + (i3 = i3 + Math.imul(d3, de2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, fe2) | 0) + Math.imul(f3, de2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, fe2) | 0) + (n3 >>> 13) | 0) + (Se2 >>> 26) | 0, Se2 &= 67108863, i3 = Math.imul(q2, L2), n3 = (n3 = Math.imul(q2, N2)) + Math.imul(F2, L2) | 0, a3 = Math.imul(F2, N2), i3 = i3 + Math.imul(B2, H2) | 0, n3 = (n3 = n3 + Math.imul(B2, W2) | 0) + Math.imul(T2, H2) | 0, a3 = a3 + Math.imul(T2, W2) | 0, i3 = i3 + Math.imul(U2, V2) | 0, n3 = (n3 = n3 + Math.imul(U2, $2) | 0) + Math.imul(R2, V2) | 0, a3 = a3 + Math.imul(R2, $2) | 0, i3 = i3 + Math.imul(K2, X2) | 0, n3 = (n3 = n3 + Math.imul(K2, Y2) | 0) + Math.imul(C2, X2) | 0, a3 = a3 + Math.imul(C2, Y2) | 0, i3 = i3 + Math.imul(P2, J2) | 0, n3 = (n3 = n3 + Math.imul(P2, ee2) | 0) + Math.imul(x2, J2) | 0, a3 = a3 + Math.imul(x2, ee2) | 0, i3 = i3 + Math.imul(A3, re2) | 0, n3 = (n3 = n3 + Math.imul(A3, ie2) | 0) + Math.imul(S2, re2) | 0, a3 = a3 + Math.imul(S2, ie2) | 0, i3 = i3 + Math.imul(v6, ae2) | 0, n3 = (n3 = n3 + Math.imul(v6, se2) | 0) + Math.imul(_3, ae2) | 0, a3 = a3 + Math.imul(_3, se2) | 0, i3 = i3 + Math.imul(g3, ce2) | 0, n3 = (n3 = n3 + Math.imul(g3, ue2) | 0) + Math.imul(m3, ce2) | 0, a3 = a3 + Math.imul(m3, ue2) | 0, i3 = i3 + Math.imul(p3, de2) | 0, n3 = (n3 = n3 + Math.imul(p3, fe2) | 0) + Math.imul(y3, de2) | 0, a3 = a3 + Math.imul(y3, fe2) | 0;
          var Ee2 = (u2 + (i3 = i3 + Math.imul(d3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(d3, ye2) | 0) + Math.imul(f3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(f3, ye2) | 0) + (n3 >>> 13) | 0) + (Ee2 >>> 26) | 0, Ee2 &= 67108863, i3 = Math.imul(q2, H2), n3 = (n3 = Math.imul(q2, W2)) + Math.imul(F2, H2) | 0, a3 = Math.imul(F2, W2), i3 = i3 + Math.imul(B2, V2) | 0, n3 = (n3 = n3 + Math.imul(B2, $2) | 0) + Math.imul(T2, V2) | 0, a3 = a3 + Math.imul(T2, $2) | 0, i3 = i3 + Math.imul(U2, X2) | 0, n3 = (n3 = n3 + Math.imul(U2, Y2) | 0) + Math.imul(R2, X2) | 0, a3 = a3 + Math.imul(R2, Y2) | 0, i3 = i3 + Math.imul(K2, J2) | 0, n3 = (n3 = n3 + Math.imul(K2, ee2) | 0) + Math.imul(C2, J2) | 0, a3 = a3 + Math.imul(C2, ee2) | 0, i3 = i3 + Math.imul(P2, re2) | 0, n3 = (n3 = n3 + Math.imul(P2, ie2) | 0) + Math.imul(x2, re2) | 0, a3 = a3 + Math.imul(x2, ie2) | 0, i3 = i3 + Math.imul(A3, ae2) | 0, n3 = (n3 = n3 + Math.imul(A3, se2) | 0) + Math.imul(S2, ae2) | 0, a3 = a3 + Math.imul(S2, se2) | 0, i3 = i3 + Math.imul(v6, ce2) | 0, n3 = (n3 = n3 + Math.imul(v6, ue2) | 0) + Math.imul(_3, ce2) | 0, a3 = a3 + Math.imul(_3, ue2) | 0, i3 = i3 + Math.imul(g3, de2) | 0, n3 = (n3 = n3 + Math.imul(g3, fe2) | 0) + Math.imul(m3, de2) | 0, a3 = a3 + Math.imul(m3, fe2) | 0;
          var Pe2 = (u2 + (i3 = i3 + Math.imul(p3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(p3, ye2) | 0) + Math.imul(y3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(y3, ye2) | 0) + (n3 >>> 13) | 0) + (Pe2 >>> 26) | 0, Pe2 &= 67108863, i3 = Math.imul(q2, V2), n3 = (n3 = Math.imul(q2, $2)) + Math.imul(F2, V2) | 0, a3 = Math.imul(F2, $2), i3 = i3 + Math.imul(B2, X2) | 0, n3 = (n3 = n3 + Math.imul(B2, Y2) | 0) + Math.imul(T2, X2) | 0, a3 = a3 + Math.imul(T2, Y2) | 0, i3 = i3 + Math.imul(U2, J2) | 0, n3 = (n3 = n3 + Math.imul(U2, ee2) | 0) + Math.imul(R2, J2) | 0, a3 = a3 + Math.imul(R2, ee2) | 0, i3 = i3 + Math.imul(K2, re2) | 0, n3 = (n3 = n3 + Math.imul(K2, ie2) | 0) + Math.imul(C2, re2) | 0, a3 = a3 + Math.imul(C2, ie2) | 0, i3 = i3 + Math.imul(P2, ae2) | 0, n3 = (n3 = n3 + Math.imul(P2, se2) | 0) + Math.imul(x2, ae2) | 0, a3 = a3 + Math.imul(x2, se2) | 0, i3 = i3 + Math.imul(A3, ce2) | 0, n3 = (n3 = n3 + Math.imul(A3, ue2) | 0) + Math.imul(S2, ce2) | 0, a3 = a3 + Math.imul(S2, ue2) | 0, i3 = i3 + Math.imul(v6, de2) | 0, n3 = (n3 = n3 + Math.imul(v6, fe2) | 0) + Math.imul(_3, de2) | 0, a3 = a3 + Math.imul(_3, fe2) | 0;
          var xe2 = (u2 + (i3 = i3 + Math.imul(g3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(g3, ye2) | 0) + Math.imul(m3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(m3, ye2) | 0) + (n3 >>> 13) | 0) + (xe2 >>> 26) | 0, xe2 &= 67108863, i3 = Math.imul(q2, X2), n3 = (n3 = Math.imul(q2, Y2)) + Math.imul(F2, X2) | 0, a3 = Math.imul(F2, Y2), i3 = i3 + Math.imul(B2, J2) | 0, n3 = (n3 = n3 + Math.imul(B2, ee2) | 0) + Math.imul(T2, J2) | 0, a3 = a3 + Math.imul(T2, ee2) | 0, i3 = i3 + Math.imul(U2, re2) | 0, n3 = (n3 = n3 + Math.imul(U2, ie2) | 0) + Math.imul(R2, re2) | 0, a3 = a3 + Math.imul(R2, ie2) | 0, i3 = i3 + Math.imul(K2, ae2) | 0, n3 = (n3 = n3 + Math.imul(K2, se2) | 0) + Math.imul(C2, ae2) | 0, a3 = a3 + Math.imul(C2, se2) | 0, i3 = i3 + Math.imul(P2, ce2) | 0, n3 = (n3 = n3 + Math.imul(P2, ue2) | 0) + Math.imul(x2, ce2) | 0, a3 = a3 + Math.imul(x2, ue2) | 0, i3 = i3 + Math.imul(A3, de2) | 0, n3 = (n3 = n3 + Math.imul(A3, fe2) | 0) + Math.imul(S2, de2) | 0, a3 = a3 + Math.imul(S2, fe2) | 0;
          var Me2 = (u2 + (i3 = i3 + Math.imul(v6, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(v6, ye2) | 0) + Math.imul(_3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(_3, ye2) | 0) + (n3 >>> 13) | 0) + (Me2 >>> 26) | 0, Me2 &= 67108863, i3 = Math.imul(q2, J2), n3 = (n3 = Math.imul(q2, ee2)) + Math.imul(F2, J2) | 0, a3 = Math.imul(F2, ee2), i3 = i3 + Math.imul(B2, re2) | 0, n3 = (n3 = n3 + Math.imul(B2, ie2) | 0) + Math.imul(T2, re2) | 0, a3 = a3 + Math.imul(T2, ie2) | 0, i3 = i3 + Math.imul(U2, ae2) | 0, n3 = (n3 = n3 + Math.imul(U2, se2) | 0) + Math.imul(R2, ae2) | 0, a3 = a3 + Math.imul(R2, se2) | 0, i3 = i3 + Math.imul(K2, ce2) | 0, n3 = (n3 = n3 + Math.imul(K2, ue2) | 0) + Math.imul(C2, ce2) | 0, a3 = a3 + Math.imul(C2, ue2) | 0, i3 = i3 + Math.imul(P2, de2) | 0, n3 = (n3 = n3 + Math.imul(P2, fe2) | 0) + Math.imul(x2, de2) | 0, a3 = a3 + Math.imul(x2, fe2) | 0;
          var Ke2 = (u2 + (i3 = i3 + Math.imul(A3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(A3, ye2) | 0) + Math.imul(S2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(S2, ye2) | 0) + (n3 >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, i3 = Math.imul(q2, re2), n3 = (n3 = Math.imul(q2, ie2)) + Math.imul(F2, re2) | 0, a3 = Math.imul(F2, ie2), i3 = i3 + Math.imul(B2, ae2) | 0, n3 = (n3 = n3 + Math.imul(B2, se2) | 0) + Math.imul(T2, ae2) | 0, a3 = a3 + Math.imul(T2, se2) | 0, i3 = i3 + Math.imul(U2, ce2) | 0, n3 = (n3 = n3 + Math.imul(U2, ue2) | 0) + Math.imul(R2, ce2) | 0, a3 = a3 + Math.imul(R2, ue2) | 0, i3 = i3 + Math.imul(K2, de2) | 0, n3 = (n3 = n3 + Math.imul(K2, fe2) | 0) + Math.imul(C2, de2) | 0, a3 = a3 + Math.imul(C2, fe2) | 0;
          var Ce2 = (u2 + (i3 = i3 + Math.imul(P2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(P2, ye2) | 0) + Math.imul(x2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(x2, ye2) | 0) + (n3 >>> 13) | 0) + (Ce2 >>> 26) | 0, Ce2 &= 67108863, i3 = Math.imul(q2, ae2), n3 = (n3 = Math.imul(q2, se2)) + Math.imul(F2, ae2) | 0, a3 = Math.imul(F2, se2), i3 = i3 + Math.imul(B2, ce2) | 0, n3 = (n3 = n3 + Math.imul(B2, ue2) | 0) + Math.imul(T2, ce2) | 0, a3 = a3 + Math.imul(T2, ue2) | 0, i3 = i3 + Math.imul(U2, de2) | 0, n3 = (n3 = n3 + Math.imul(U2, fe2) | 0) + Math.imul(R2, de2) | 0, a3 = a3 + Math.imul(R2, fe2) | 0;
          var De2 = (u2 + (i3 = i3 + Math.imul(K2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(K2, ye2) | 0) + Math.imul(C2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(C2, ye2) | 0) + (n3 >>> 13) | 0) + (De2 >>> 26) | 0, De2 &= 67108863, i3 = Math.imul(q2, ce2), n3 = (n3 = Math.imul(q2, ue2)) + Math.imul(F2, ce2) | 0, a3 = Math.imul(F2, ue2), i3 = i3 + Math.imul(B2, de2) | 0, n3 = (n3 = n3 + Math.imul(B2, fe2) | 0) + Math.imul(T2, de2) | 0, a3 = a3 + Math.imul(T2, fe2) | 0;
          var Ue2 = (u2 + (i3 = i3 + Math.imul(U2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(U2, ye2) | 0) + Math.imul(R2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(R2, ye2) | 0) + (n3 >>> 13) | 0) + (Ue2 >>> 26) | 0, Ue2 &= 67108863, i3 = Math.imul(q2, de2), n3 = (n3 = Math.imul(q2, fe2)) + Math.imul(F2, de2) | 0, a3 = Math.imul(F2, fe2);
          var Re2 = (u2 + (i3 = i3 + Math.imul(B2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(B2, ye2) | 0) + Math.imul(T2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(T2, ye2) | 0) + (n3 >>> 13) | 0) + (Re2 >>> 26) | 0, Re2 &= 67108863;
          var Ie2 = (u2 + (i3 = Math.imul(q2, pe2)) | 0) + ((8191 & (n3 = (n3 = Math.imul(q2, ye2)) + Math.imul(F2, pe2) | 0)) << 13) | 0;
          return u2 = ((a3 = Math.imul(F2, ye2)) + (n3 >>> 13) | 0) + (Ie2 >>> 26) | 0, Ie2 &= 67108863, c3[0] = be2, c3[1] = ge2, c3[2] = me2, c3[3] = we2, c3[4] = ve2, c3[5] = _e2, c3[6] = ke2, c3[7] = Ae2, c3[8] = Se2, c3[9] = Ee2, c3[10] = Pe2, c3[11] = xe2, c3[12] = Me2, c3[13] = Ke2, c3[14] = Ce2, c3[15] = De2, c3[16] = Ue2, c3[17] = Re2, c3[18] = Ie2, 0 !== u2 && (c3[19] = u2, r3.length++), r3;
        };
        function p2(e4, t3, r3) {
          return new y2().mulp(e4, t3, r3);
        }
        function y2(e4, t3) {
          this.x = e4, this.y = t3;
        }
        Math.imul || (l2 = f2), n2.prototype.mulTo = function(e4, t3) {
          var r3, i3 = this.length + e4.length;
          return r3 = 10 === this.length && 10 === e4.length ? l2(this, e4, t3) : i3 < 63 ? f2(this, e4, t3) : i3 < 1024 ? function(e5, t4, r4) {
            r4.negative = t4.negative ^ e5.negative, r4.length = e5.length + t4.length;
            for (var i4 = 0, n3 = 0, a3 = 0; a3 < r4.length - 1; a3++) {
              var s3 = n3;
              n3 = 0;
              for (var o3 = 67108863 & i4, c3 = Math.min(a3, t4.length - 1), u2 = Math.max(0, a3 - e5.length + 1); u2 <= c3; u2++) {
                var h3 = a3 - u2, d3 = (0 | e5.words[h3]) * (0 | t4.words[u2]), f3 = 67108863 & d3;
                o3 = 67108863 & (f3 = f3 + o3 | 0), n3 += (s3 = (s3 = s3 + (d3 / 67108864 | 0) | 0) + (f3 >>> 26) | 0) >>> 26, s3 &= 67108863;
              }
              r4.words[a3] = o3, i4 = s3, s3 = n3;
            }
            return 0 !== i4 ? r4.words[a3] = i4 : r4.length--, r4.strip();
          }(this, e4, t3) : p2(this, e4, t3), r3;
        }, y2.prototype.makeRBT = function(e4) {
          for (var t3 = Array(e4), r3 = n2.prototype._countBits(e4) - 1, i3 = 0; i3 < e4; i3++)
            t3[i3] = this.revBin(i3, r3, e4);
          return t3;
        }, y2.prototype.revBin = function(e4, t3, r3) {
          if (0 === e4 || e4 === r3 - 1)
            return e4;
          for (var i3 = 0, n3 = 0; n3 < t3; n3++)
            i3 |= (1 & e4) << t3 - n3 - 1, e4 >>= 1;
          return i3;
        }, y2.prototype.permute = function(e4, t3, r3, i3, n3, a3) {
          for (var s3 = 0; s3 < a3; s3++)
            i3[s3] = t3[e4[s3]], n3[s3] = r3[e4[s3]];
        }, y2.prototype.transform = function(e4, t3, r3, i3, n3, a3) {
          this.permute(a3, e4, t3, r3, i3, n3);
          for (var s3 = 1; s3 < n3; s3 <<= 1)
            for (var o3 = s3 << 1, c3 = Math.cos(2 * Math.PI / o3), u2 = Math.sin(2 * Math.PI / o3), h3 = 0; h3 < n3; h3 += o3)
              for (var d3 = c3, f3 = u2, l3 = 0; l3 < s3; l3++) {
                var p3 = r3[h3 + l3], y3 = i3[h3 + l3], b3 = r3[h3 + l3 + s3], g3 = i3[h3 + l3 + s3], m3 = d3 * b3 - f3 * g3;
                g3 = d3 * g3 + f3 * b3, b3 = m3, r3[h3 + l3] = p3 + b3, i3[h3 + l3] = y3 + g3, r3[h3 + l3 + s3] = p3 - b3, i3[h3 + l3 + s3] = y3 - g3, l3 !== o3 && (m3 = c3 * d3 - u2 * f3, f3 = c3 * f3 + u2 * d3, d3 = m3);
              }
        }, y2.prototype.guessLen13b = function(e4, t3) {
          var r3 = 1 | Math.max(t3, e4), i3 = 1 & r3, n3 = 0;
          for (r3 = r3 / 2 | 0; r3; r3 >>>= 1)
            n3++;
          return 1 << n3 + 1 + i3;
        }, y2.prototype.conjugate = function(e4, t3, r3) {
          if (!(r3 <= 1))
            for (var i3 = 0; i3 < r3 / 2; i3++) {
              var n3 = e4[i3];
              e4[i3] = e4[r3 - i3 - 1], e4[r3 - i3 - 1] = n3, n3 = t3[i3], t3[i3] = -t3[r3 - i3 - 1], t3[r3 - i3 - 1] = -n3;
            }
        }, y2.prototype.normalize13b = function(e4, t3) {
          for (var r3 = 0, i3 = 0; i3 < t3 / 2; i3++) {
            var n3 = 8192 * Math.round(e4[2 * i3 + 1] / t3) + Math.round(e4[2 * i3] / t3) + r3;
            e4[i3] = 67108863 & n3, r3 = n3 < 67108864 ? 0 : n3 / 67108864 | 0;
          }
          return e4;
        }, y2.prototype.convert13b = function(e4, t3, i3, n3) {
          for (var a3 = 0, s3 = 0; s3 < t3; s3++)
            a3 += 0 | e4[s3], i3[2 * s3] = 8191 & a3, a3 >>>= 13, i3[2 * s3 + 1] = 8191 & a3, a3 >>>= 13;
          for (s3 = 2 * t3; s3 < n3; ++s3)
            i3[s3] = 0;
          r2(0 === a3), r2(0 == (-8192 & a3));
        }, y2.prototype.stub = function(e4) {
          for (var t3 = Array(e4), r3 = 0; r3 < e4; r3++)
            t3[r3] = 0;
          return t3;
        }, y2.prototype.mulp = function(e4, t3, r3) {
          var i3 = 2 * this.guessLen13b(e4.length, t3.length), n3 = this.makeRBT(i3), a3 = this.stub(i3), s3 = Array(i3), o3 = Array(i3), c3 = Array(i3), u2 = Array(i3), h3 = Array(i3), d3 = Array(i3), f3 = r3.words;
          f3.length = i3, this.convert13b(e4.words, e4.length, s3, i3), this.convert13b(t3.words, t3.length, u2, i3), this.transform(s3, a3, o3, c3, i3, n3), this.transform(u2, a3, h3, d3, i3, n3);
          for (var l3 = 0; l3 < i3; l3++) {
            var p3 = o3[l3] * h3[l3] - c3[l3] * d3[l3];
            c3[l3] = o3[l3] * d3[l3] + c3[l3] * h3[l3], o3[l3] = p3;
          }
          return this.conjugate(o3, c3, i3), this.transform(o3, c3, f3, a3, i3, n3), this.conjugate(f3, a3, i3), this.normalize13b(f3, i3), r3.negative = e4.negative ^ t3.negative, r3.length = e4.length + t3.length, r3.strip();
        }, n2.prototype.mul = function(e4) {
          var t3 = new n2(null);
          return t3.words = Array(this.length + e4.length), this.mulTo(e4, t3);
        }, n2.prototype.mulf = function(e4) {
          var t3 = new n2(null);
          return t3.words = Array(this.length + e4.length), p2(this, e4, t3);
        }, n2.prototype.imul = function(e4) {
          return this.clone().mulTo(e4, this);
        }, n2.prototype.imuln = function(e4) {
          r2("number" == typeof e4), r2(e4 < 67108864);
          for (var t3 = 0, i3 = 0; i3 < this.length; i3++) {
            var n3 = (0 | this.words[i3]) * e4, a3 = (67108863 & n3) + (67108863 & t3);
            t3 >>= 26, t3 += n3 / 67108864 | 0, t3 += a3 >>> 26, this.words[i3] = 67108863 & a3;
          }
          return 0 !== t3 && (this.words[i3] = t3, this.length++), this;
        }, n2.prototype.muln = function(e4) {
          return this.clone().imuln(e4);
        }, n2.prototype.sqr = function() {
          return this.mul(this);
        }, n2.prototype.isqr = function() {
          return this.imul(this.clone());
        }, n2.prototype.pow = function(e4) {
          var t3 = function(e5) {
            for (var t4 = Array(e5.bitLength()), r4 = 0; r4 < t4.length; r4++) {
              var i4 = r4 / 26 | 0, n3 = r4 % 26;
              t4[r4] = (e5.words[i4] & 1 << n3) >>> n3;
            }
            return t4;
          }(e4);
          if (0 === t3.length)
            return new n2(1);
          for (var r3 = this, i3 = 0; i3 < t3.length && 0 === t3[i3]; i3++, r3 = r3.sqr())
            ;
          if (++i3 < t3.length)
            for (var a3 = r3.sqr(); i3 < t3.length; i3++, a3 = a3.sqr())
              0 !== t3[i3] && (r3 = r3.mul(a3));
          return r3;
        }, n2.prototype.iushln = function(e4) {
          r2("number" == typeof e4 && e4 >= 0);
          var t3, i3 = e4 % 26, n3 = (e4 - i3) / 26, a3 = 67108863 >>> 26 - i3 << 26 - i3;
          if (0 !== i3) {
            var s3 = 0;
            for (t3 = 0; t3 < this.length; t3++) {
              var o3 = this.words[t3] & a3, c3 = (0 | this.words[t3]) - o3 << i3;
              this.words[t3] = c3 | s3, s3 = o3 >>> 26 - i3;
            }
            s3 && (this.words[t3] = s3, this.length++);
          }
          if (0 !== n3) {
            for (t3 = this.length - 1; t3 >= 0; t3--)
              this.words[t3 + n3] = this.words[t3];
            for (t3 = 0; t3 < n3; t3++)
              this.words[t3] = 0;
            this.length += n3;
          }
          return this.strip();
        }, n2.prototype.ishln = function(e4) {
          return r2(0 === this.negative), this.iushln(e4);
        }, n2.prototype.iushrn = function(e4, t3, i3) {
          var n3;
          r2("number" == typeof e4 && e4 >= 0), n3 = t3 ? (t3 - t3 % 26) / 26 : 0;
          var a3 = e4 % 26, s3 = Math.min((e4 - a3) / 26, this.length), o3 = 67108863 ^ 67108863 >>> a3 << a3, c3 = i3;
          if (n3 = Math.max(0, n3 -= s3), c3) {
            for (var u2 = 0; u2 < s3; u2++)
              c3.words[u2] = this.words[u2];
            c3.length = s3;
          }
          if (0 === s3)
            ;
          else if (this.length > s3)
            for (this.length -= s3, u2 = 0; u2 < this.length; u2++)
              this.words[u2] = this.words[u2 + s3];
          else
            this.words[0] = 0, this.length = 1;
          var h3 = 0;
          for (u2 = this.length - 1; u2 >= 0 && (0 !== h3 || u2 >= n3); u2--) {
            var d3 = 0 | this.words[u2];
            this.words[u2] = h3 << 26 - a3 | d3 >>> a3, h3 = d3 & o3;
          }
          return c3 && 0 !== h3 && (c3.words[c3.length++] = h3), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
        }, n2.prototype.ishrn = function(e4, t3, i3) {
          return r2(0 === this.negative), this.iushrn(e4, t3, i3);
        }, n2.prototype.shln = function(e4) {
          return this.clone().ishln(e4);
        }, n2.prototype.ushln = function(e4) {
          return this.clone().iushln(e4);
        }, n2.prototype.shrn = function(e4) {
          return this.clone().ishrn(e4);
        }, n2.prototype.ushrn = function(e4) {
          return this.clone().iushrn(e4);
        }, n2.prototype.testn = function(e4) {
          r2("number" == typeof e4 && e4 >= 0);
          var t3 = e4 % 26, i3 = (e4 - t3) / 26, n3 = 1 << t3;
          return !(this.length <= i3) && !!(this.words[i3] & n3);
        }, n2.prototype.imaskn = function(e4) {
          r2("number" == typeof e4 && e4 >= 0);
          var t3 = e4 % 26, i3 = (e4 - t3) / 26;
          if (r2(0 === this.negative, "imaskn works only with positive numbers"), this.length <= i3)
            return this;
          if (0 !== t3 && i3++, this.length = Math.min(i3, this.length), 0 !== t3) {
            var n3 = 67108863 ^ 67108863 >>> t3 << t3;
            this.words[this.length - 1] &= n3;
          }
          return this.strip();
        }, n2.prototype.maskn = function(e4) {
          return this.clone().imaskn(e4);
        }, n2.prototype.iaddn = function(e4) {
          return r2("number" == typeof e4), r2(e4 < 67108864), e4 < 0 ? this.isubn(-e4) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < e4 ? (this.words[0] = e4 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e4), this.negative = 1, this) : this._iaddn(e4);
        }, n2.prototype._iaddn = function(e4) {
          this.words[0] += e4;
          for (var t3 = 0; t3 < this.length && this.words[t3] >= 67108864; t3++)
            this.words[t3] -= 67108864, t3 === this.length - 1 ? this.words[t3 + 1] = 1 : this.words[t3 + 1]++;
          return this.length = Math.max(this.length, t3 + 1), this;
        }, n2.prototype.isubn = function(e4) {
          if (r2("number" == typeof e4), r2(e4 < 67108864), e4 < 0)
            return this.iaddn(-e4);
          if (0 !== this.negative)
            return this.negative = 0, this.iaddn(e4), this.negative = 1, this;
          if (this.words[0] -= e4, 1 === this.length && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var t3 = 0; t3 < this.length && this.words[t3] < 0; t3++)
              this.words[t3] += 67108864, this.words[t3 + 1] -= 1;
          return this.strip();
        }, n2.prototype.addn = function(e4) {
          return this.clone().iaddn(e4);
        }, n2.prototype.subn = function(e4) {
          return this.clone().isubn(e4);
        }, n2.prototype.iabs = function() {
          return this.negative = 0, this;
        }, n2.prototype.abs = function() {
          return this.clone().iabs();
        }, n2.prototype._ishlnsubmul = function(e4, t3, i3) {
          var n3, a3, s3 = e4.length + i3;
          this._expand(s3);
          var o3 = 0;
          for (n3 = 0; n3 < e4.length; n3++) {
            a3 = (0 | this.words[n3 + i3]) + o3;
            var c3 = (0 | e4.words[n3]) * t3;
            o3 = ((a3 -= 67108863 & c3) >> 26) - (c3 / 67108864 | 0), this.words[n3 + i3] = 67108863 & a3;
          }
          for (; n3 < this.length - i3; n3++)
            o3 = (a3 = (0 | this.words[n3 + i3]) + o3) >> 26, this.words[n3 + i3] = 67108863 & a3;
          if (0 === o3)
            return this.strip();
          for (r2(-1 === o3), o3 = 0, n3 = 0; n3 < this.length; n3++)
            o3 = (a3 = -(0 | this.words[n3]) + o3) >> 26, this.words[n3] = 67108863 & a3;
          return this.negative = 1, this.strip();
        }, n2.prototype._wordDiv = function(e4, t3) {
          var r3 = (this.length, e4.length), i3 = this.clone(), a3 = e4, s3 = 0 | a3.words[a3.length - 1];
          0 !== (r3 = 26 - this._countBits(s3)) && (a3 = a3.ushln(r3), i3.iushln(r3), s3 = 0 | a3.words[a3.length - 1]);
          var o3, c3 = i3.length - a3.length;
          if ("mod" !== t3) {
            (o3 = new n2(null)).length = c3 + 1, o3.words = Array(o3.length);
            for (var u2 = 0; u2 < o3.length; u2++)
              o3.words[u2] = 0;
          }
          var h3 = i3.clone()._ishlnsubmul(a3, 1, c3);
          0 === h3.negative && (i3 = h3, o3 && (o3.words[c3] = 1));
          for (var d3 = c3 - 1; d3 >= 0; d3--) {
            var f3 = 67108864 * (0 | i3.words[a3.length + d3]) + (0 | i3.words[a3.length + d3 - 1]);
            for (f3 = Math.min(f3 / s3 | 0, 67108863), i3._ishlnsubmul(a3, f3, d3); 0 !== i3.negative; )
              f3--, i3.negative = 0, i3._ishlnsubmul(a3, 1, d3), i3.isZero() || (i3.negative ^= 1);
            o3 && (o3.words[d3] = f3);
          }
          return o3 && o3.strip(), i3.strip(), "div" !== t3 && 0 !== r3 && i3.iushrn(r3), { div: o3 || null, mod: i3 };
        }, n2.prototype.divmod = function(e4, t3, i3) {
          return r2(!e4.isZero()), this.isZero() ? { div: new n2(0), mod: new n2(0) } : 0 !== this.negative && 0 === e4.negative ? (o3 = this.neg().divmod(e4, t3), "mod" !== t3 && (a3 = o3.div.neg()), "div" !== t3 && (s3 = o3.mod.neg(), i3 && 0 !== s3.negative && s3.iadd(e4)), { div: a3, mod: s3 }) : 0 === this.negative && 0 !== e4.negative ? (o3 = this.divmod(e4.neg(), t3), "mod" !== t3 && (a3 = o3.div.neg()), { div: a3, mod: o3.mod }) : 0 != (this.negative & e4.negative) ? (o3 = this.neg().divmod(e4.neg(), t3), "div" !== t3 && (s3 = o3.mod.neg(), i3 && 0 !== s3.negative && s3.isub(e4)), { div: o3.div, mod: s3 }) : e4.length > this.length || this.cmp(e4) < 0 ? { div: new n2(0), mod: this } : 1 === e4.length ? "div" === t3 ? { div: this.divn(e4.words[0]), mod: null } : "mod" === t3 ? { div: null, mod: new n2(this.modn(e4.words[0])) } : { div: this.divn(e4.words[0]), mod: new n2(this.modn(e4.words[0])) } : this._wordDiv(e4, t3);
          var a3, s3, o3;
        }, n2.prototype.div = function(e4) {
          return this.divmod(e4, "div", false).div;
        }, n2.prototype.mod = function(e4) {
          return this.divmod(e4, "mod", false).mod;
        }, n2.prototype.umod = function(e4) {
          return this.divmod(e4, "mod", true).mod;
        }, n2.prototype.divRound = function(e4) {
          var t3 = this.divmod(e4);
          if (t3.mod.isZero())
            return t3.div;
          var r3 = 0 !== t3.div.negative ? t3.mod.isub(e4) : t3.mod, i3 = e4.ushrn(1), n3 = e4.andln(1), a3 = r3.cmp(i3);
          return a3 < 0 || 1 === n3 && 0 === a3 ? t3.div : 0 !== t3.div.negative ? t3.div.isubn(1) : t3.div.iaddn(1);
        }, n2.prototype.modn = function(e4) {
          r2(e4 <= 67108863);
          for (var t3 = (1 << 26) % e4, i3 = 0, n3 = this.length - 1; n3 >= 0; n3--)
            i3 = (t3 * i3 + (0 | this.words[n3])) % e4;
          return i3;
        }, n2.prototype.idivn = function(e4) {
          r2(e4 <= 67108863);
          for (var t3 = 0, i3 = this.length - 1; i3 >= 0; i3--) {
            var n3 = (0 | this.words[i3]) + 67108864 * t3;
            this.words[i3] = n3 / e4 | 0, t3 = n3 % e4;
          }
          return this.strip();
        }, n2.prototype.divn = function(e4) {
          return this.clone().idivn(e4);
        }, n2.prototype.egcd = function(e4) {
          r2(0 === e4.negative), r2(!e4.isZero());
          var t3 = this, i3 = e4.clone();
          t3 = 0 !== t3.negative ? t3.umod(e4) : t3.clone();
          for (var a3 = new n2(1), s3 = new n2(0), o3 = new n2(0), c3 = new n2(1), u2 = 0; t3.isEven() && i3.isEven(); )
            t3.iushrn(1), i3.iushrn(1), ++u2;
          for (var h3 = i3.clone(), d3 = t3.clone(); !t3.isZero(); ) {
            for (var f3 = 0, l3 = 1; 0 == (t3.words[0] & l3) && f3 < 26; ++f3, l3 <<= 1)
              ;
            if (f3 > 0)
              for (t3.iushrn(f3); f3-- > 0; )
                (a3.isOdd() || s3.isOdd()) && (a3.iadd(h3), s3.isub(d3)), a3.iushrn(1), s3.iushrn(1);
            for (var p3 = 0, y3 = 1; 0 == (i3.words[0] & y3) && p3 < 26; ++p3, y3 <<= 1)
              ;
            if (p3 > 0)
              for (i3.iushrn(p3); p3-- > 0; )
                (o3.isOdd() || c3.isOdd()) && (o3.iadd(h3), c3.isub(d3)), o3.iushrn(1), c3.iushrn(1);
            t3.cmp(i3) >= 0 ? (t3.isub(i3), a3.isub(o3), s3.isub(c3)) : (i3.isub(t3), o3.isub(a3), c3.isub(s3));
          }
          return { a: o3, b: c3, gcd: i3.iushln(u2) };
        }, n2.prototype._invmp = function(e4) {
          r2(0 === e4.negative), r2(!e4.isZero());
          var t3 = this, i3 = e4.clone();
          t3 = 0 !== t3.negative ? t3.umod(e4) : t3.clone();
          for (var a3, s3 = new n2(1), o3 = new n2(0), c3 = i3.clone(); t3.cmpn(1) > 0 && i3.cmpn(1) > 0; ) {
            for (var u2 = 0, h3 = 1; 0 == (t3.words[0] & h3) && u2 < 26; ++u2, h3 <<= 1)
              ;
            if (u2 > 0)
              for (t3.iushrn(u2); u2-- > 0; )
                s3.isOdd() && s3.iadd(c3), s3.iushrn(1);
            for (var d3 = 0, f3 = 1; 0 == (i3.words[0] & f3) && d3 < 26; ++d3, f3 <<= 1)
              ;
            if (d3 > 0)
              for (i3.iushrn(d3); d3-- > 0; )
                o3.isOdd() && o3.iadd(c3), o3.iushrn(1);
            t3.cmp(i3) >= 0 ? (t3.isub(i3), s3.isub(o3)) : (i3.isub(t3), o3.isub(s3));
          }
          return (a3 = 0 === t3.cmpn(1) ? s3 : o3).cmpn(0) < 0 && a3.iadd(e4), a3;
        }, n2.prototype.gcd = function(e4) {
          if (this.isZero())
            return e4.abs();
          if (e4.isZero())
            return this.abs();
          var t3 = this.clone(), r3 = e4.clone();
          t3.negative = 0, r3.negative = 0;
          for (var i3 = 0; t3.isEven() && r3.isEven(); i3++)
            t3.iushrn(1), r3.iushrn(1);
          for (; ; ) {
            for (; t3.isEven(); )
              t3.iushrn(1);
            for (; r3.isEven(); )
              r3.iushrn(1);
            var n3 = t3.cmp(r3);
            if (n3 < 0) {
              var a3 = t3;
              t3 = r3, r3 = a3;
            } else if (0 === n3 || 0 === r3.cmpn(1))
              break;
            t3.isub(r3);
          }
          return r3.iushln(i3);
        }, n2.prototype.invm = function(e4) {
          return this.egcd(e4).a.umod(e4);
        }, n2.prototype.isEven = function() {
          return 0 == (1 & this.words[0]);
        }, n2.prototype.isOdd = function() {
          return 1 == (1 & this.words[0]);
        }, n2.prototype.andln = function(e4) {
          return this.words[0] & e4;
        }, n2.prototype.bincn = function(e4) {
          r2("number" == typeof e4);
          var t3 = e4 % 26, i3 = (e4 - t3) / 26, n3 = 1 << t3;
          if (this.length <= i3)
            return this._expand(i3 + 1), this.words[i3] |= n3, this;
          for (var a3 = n3, s3 = i3; 0 !== a3 && s3 < this.length; s3++) {
            var o3 = 0 | this.words[s3];
            a3 = (o3 += a3) >>> 26, o3 &= 67108863, this.words[s3] = o3;
          }
          return 0 !== a3 && (this.words[s3] = a3, this.length++), this;
        }, n2.prototype.isZero = function() {
          return 1 === this.length && 0 === this.words[0];
        }, n2.prototype.cmpn = function(e4) {
          var t3, i3 = e4 < 0;
          if (0 !== this.negative && !i3)
            return -1;
          if (0 === this.negative && i3)
            return 1;
          if (this.strip(), this.length > 1)
            t3 = 1;
          else {
            i3 && (e4 = -e4), r2(e4 <= 67108863, "Number is too big");
            var n3 = 0 | this.words[0];
            t3 = n3 === e4 ? 0 : n3 < e4 ? -1 : 1;
          }
          return 0 !== this.negative ? 0 | -t3 : t3;
        }, n2.prototype.cmp = function(e4) {
          if (0 !== this.negative && 0 === e4.negative)
            return -1;
          if (0 === this.negative && 0 !== e4.negative)
            return 1;
          var t3 = this.ucmp(e4);
          return 0 !== this.negative ? 0 | -t3 : t3;
        }, n2.prototype.ucmp = function(e4) {
          if (this.length > e4.length)
            return 1;
          if (this.length < e4.length)
            return -1;
          for (var t3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var i3 = 0 | this.words[r3], n3 = 0 | e4.words[r3];
            if (i3 !== n3) {
              i3 < n3 ? t3 = -1 : i3 > n3 && (t3 = 1);
              break;
            }
          }
          return t3;
        }, n2.prototype.gtn = function(e4) {
          return 1 === this.cmpn(e4);
        }, n2.prototype.gt = function(e4) {
          return 1 === this.cmp(e4);
        }, n2.prototype.gten = function(e4) {
          return this.cmpn(e4) >= 0;
        }, n2.prototype.gte = function(e4) {
          return this.cmp(e4) >= 0;
        }, n2.prototype.ltn = function(e4) {
          return -1 === this.cmpn(e4);
        }, n2.prototype.lt = function(e4) {
          return -1 === this.cmp(e4);
        }, n2.prototype.lten = function(e4) {
          return this.cmpn(e4) <= 0;
        }, n2.prototype.lte = function(e4) {
          return this.cmp(e4) <= 0;
        }, n2.prototype.eqn = function(e4) {
          return 0 === this.cmpn(e4);
        }, n2.prototype.eq = function(e4) {
          return 0 === this.cmp(e4);
        }, n2.red = function(e4) {
          return new k2(e4);
        }, n2.prototype.toRed = function(e4) {
          return r2(!this.red, "Already a number in reduction context"), r2(0 === this.negative, "red works only with positives"), e4.convertTo(this)._forceRed(e4);
        }, n2.prototype.fromRed = function() {
          return r2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, n2.prototype._forceRed = function(e4) {
          return this.red = e4, this;
        }, n2.prototype.forceRed = function(e4) {
          return r2(!this.red, "Already a number in reduction context"), this._forceRed(e4);
        }, n2.prototype.redAdd = function(e4) {
          return r2(this.red, "redAdd works only with red numbers"), this.red.add(this, e4);
        }, n2.prototype.redIAdd = function(e4) {
          return r2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e4);
        }, n2.prototype.redSub = function(e4) {
          return r2(this.red, "redSub works only with red numbers"), this.red.sub(this, e4);
        }, n2.prototype.redISub = function(e4) {
          return r2(this.red, "redISub works only with red numbers"), this.red.isub(this, e4);
        }, n2.prototype.redShl = function(e4) {
          return r2(this.red, "redShl works only with red numbers"), this.red.shl(this, e4);
        }, n2.prototype.redMul = function(e4) {
          return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.mul(this, e4);
        }, n2.prototype.redIMul = function(e4) {
          return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.imul(this, e4);
        }, n2.prototype.redSqr = function() {
          return r2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, n2.prototype.redISqr = function() {
          return r2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, n2.prototype.redSqrt = function() {
          return r2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, n2.prototype.redInvm = function() {
          return r2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, n2.prototype.redNeg = function() {
          return r2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, n2.prototype.redPow = function(e4) {
          return r2(this.red && !e4.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e4);
        };
        var b2 = { k256: null, p224: null, p192: null, p25519: null };
        function g2(e4, t3) {
          this.name = e4, this.p = new n2(t3, 16), this.n = this.p.bitLength(), this.k = new n2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function m2() {
          g2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function w2() {
          g2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function v2() {
          g2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function _2() {
          g2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function k2(e4) {
          if ("string" == typeof e4) {
            var t3 = n2._prime(e4);
            this.m = t3.p, this.prime = t3;
          } else
            r2(e4.gtn(1), "modulus must be greater than 1"), this.m = e4, this.prime = null;
        }
        function A2(e4) {
          k2.call(this, e4), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        g2.prototype._tmp = function() {
          var e4 = new n2(null);
          return e4.words = Array(Math.ceil(this.n / 13)), e4;
        }, g2.prototype.ireduce = function(e4) {
          var t3, r3 = e4;
          do {
            this.split(r3, this.tmp), t3 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
          } while (t3 > this.n);
          var i3 = t3 < this.n ? -1 : r3.ucmp(this.p);
          return 0 === i3 ? (r3.words[0] = 0, r3.length = 1) : i3 > 0 ? r3.isub(this.p) : r3.strip(), r3;
        }, g2.prototype.split = function(e4, t3) {
          e4.iushrn(this.n, 0, t3);
        }, g2.prototype.imulK = function(e4) {
          return e4.imul(this.k);
        }, i2(m2, g2), m2.prototype.split = function(e4, t3) {
          for (var r3 = 4194303, i3 = Math.min(e4.length, 9), n3 = 0; n3 < i3; n3++)
            t3.words[n3] = e4.words[n3];
          if (t3.length = i3, e4.length <= 9)
            return e4.words[0] = 0, void (e4.length = 1);
          var a3 = e4.words[9];
          for (t3.words[t3.length++] = a3 & r3, n3 = 10; n3 < e4.length; n3++) {
            var s3 = 0 | e4.words[n3];
            e4.words[n3 - 10] = (s3 & r3) << 4 | a3 >>> 22, a3 = s3;
          }
          a3 >>>= 22, e4.words[n3 - 10] = a3, 0 === a3 && e4.length > 10 ? e4.length -= 10 : e4.length -= 9;
        }, m2.prototype.imulK = function(e4) {
          e4.words[e4.length] = 0, e4.words[e4.length + 1] = 0, e4.length += 2;
          for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
            var i3 = 0 | e4.words[r3];
            t3 += 977 * i3, e4.words[r3] = 67108863 & t3, t3 = 64 * i3 + (t3 / 67108864 | 0);
          }
          return 0 === e4.words[e4.length - 1] && (e4.length--, 0 === e4.words[e4.length - 1] && e4.length--), e4;
        }, i2(w2, g2), i2(v2, g2), i2(_2, g2), _2.prototype.imulK = function(e4) {
          for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
            var i3 = 19 * (0 | e4.words[r3]) + t3, n3 = 67108863 & i3;
            i3 >>>= 26, e4.words[r3] = n3, t3 = i3;
          }
          return 0 !== t3 && (e4.words[e4.length++] = t3), e4;
        }, n2._prime = function(e4) {
          if (b2[e4])
            return b2[e4];
          var t3;
          if ("k256" === e4)
            t3 = new m2();
          else if ("p224" === e4)
            t3 = new w2();
          else if ("p192" === e4)
            t3 = new v2();
          else {
            if ("p25519" !== e4)
              throw Error("Unknown prime " + e4);
            t3 = new _2();
          }
          return b2[e4] = t3, t3;
        }, k2.prototype._verify1 = function(e4) {
          r2(0 === e4.negative, "red works only with positives"), r2(e4.red, "red works only with red numbers");
        }, k2.prototype._verify2 = function(e4, t3) {
          r2(0 == (e4.negative | t3.negative), "red works only with positives"), r2(e4.red && e4.red === t3.red, "red works only with red numbers");
        }, k2.prototype.imod = function(e4) {
          return this.prime ? this.prime.ireduce(e4)._forceRed(this) : e4.umod(this.m)._forceRed(this);
        }, k2.prototype.neg = function(e4) {
          return e4.isZero() ? e4.clone() : this.m.sub(e4)._forceRed(this);
        }, k2.prototype.add = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.add(t3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
        }, k2.prototype.iadd = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.iadd(t3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
        }, k2.prototype.sub = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.sub(t3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
        }, k2.prototype.isub = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.isub(t3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
        }, k2.prototype.shl = function(e4, t3) {
          return this._verify1(e4), this.imod(e4.ushln(t3));
        }, k2.prototype.imul = function(e4, t3) {
          return this._verify2(e4, t3), this.imod(e4.imul(t3));
        }, k2.prototype.mul = function(e4, t3) {
          return this._verify2(e4, t3), this.imod(e4.mul(t3));
        }, k2.prototype.isqr = function(e4) {
          return this.imul(e4, e4.clone());
        }, k2.prototype.sqr = function(e4) {
          return this.mul(e4, e4);
        }, k2.prototype.sqrt = function(e4) {
          if (e4.isZero())
            return e4.clone();
          var t3 = this.m.andln(3);
          if (r2(t3 % 2 == 1), 3 === t3) {
            var i3 = this.m.add(new n2(1)).iushrn(2);
            return this.pow(e4, i3);
          }
          for (var a3 = this.m.subn(1), s3 = 0; !a3.isZero() && 0 === a3.andln(1); )
            s3++, a3.iushrn(1);
          r2(!a3.isZero());
          var o3 = new n2(1).toRed(this), c3 = o3.redNeg(), u2 = this.m.subn(1).iushrn(1), h3 = this.m.bitLength();
          for (h3 = new n2(2 * h3 * h3).toRed(this); 0 !== this.pow(h3, u2).cmp(c3); )
            h3.redIAdd(c3);
          for (var d3 = this.pow(h3, a3), f3 = this.pow(e4, a3.addn(1).iushrn(1)), l3 = this.pow(e4, a3), p3 = s3; 0 !== l3.cmp(o3); ) {
            for (var y3 = l3, b3 = 0; 0 !== y3.cmp(o3); b3++)
              y3 = y3.redSqr();
            r2(b3 < p3);
            var g3 = this.pow(d3, new n2(1).iushln(p3 - b3 - 1));
            f3 = f3.redMul(g3), d3 = g3.redSqr(), l3 = l3.redMul(d3), p3 = b3;
          }
          return f3;
        }, k2.prototype.invm = function(e4) {
          var t3 = e4._invmp(this.m);
          return 0 !== t3.negative ? (t3.negative = 0, this.imod(t3).redNeg()) : this.imod(t3);
        }, k2.prototype.pow = function(e4, t3) {
          if (t3.isZero())
            return new n2(1).toRed(this);
          if (0 === t3.cmpn(1))
            return e4.clone();
          var r3 = Array(16);
          r3[0] = new n2(1).toRed(this), r3[1] = e4;
          for (var i3 = 2; i3 < r3.length; i3++)
            r3[i3] = this.mul(r3[i3 - 1], e4);
          var a3 = r3[0], s3 = 0, o3 = 0, c3 = t3.bitLength() % 26;
          for (0 === c3 && (c3 = 26), i3 = t3.length - 1; i3 >= 0; i3--) {
            for (var u2 = t3.words[i3], h3 = c3 - 1; h3 >= 0; h3--) {
              var d3 = u2 >> h3 & 1;
              a3 !== r3[0] && (a3 = this.sqr(a3)), 0 !== d3 || 0 !== s3 ? (s3 <<= 1, s3 |= d3, (4 === ++o3 || 0 === i3 && 0 === h3) && (a3 = this.mul(a3, r3[s3]), o3 = 0, s3 = 0)) : o3 = 0;
            }
            c3 = 26;
          }
          return a3;
        }, k2.prototype.convertTo = function(e4) {
          var t3 = e4.umod(this.m);
          return t3 === e4 ? t3.clone() : t3;
        }, k2.prototype.convertFrom = function(e4) {
          var t3 = e4.clone();
          return t3.red = null, t3;
        }, n2.mont = function(e4) {
          return new A2(e4);
        }, i2(A2, k2), A2.prototype.convertTo = function(e4) {
          return this.imod(e4.ushln(this.shift));
        }, A2.prototype.convertFrom = function(e4) {
          var t3 = this.imod(e4.mul(this.rinv));
          return t3.red = null, t3;
        }, A2.prototype.imul = function(e4, t3) {
          if (e4.isZero() || t3.isZero())
            return e4.words[0] = 0, e4.length = 1, e4;
          var r3 = e4.imul(t3), i3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n3 = r3.isub(i3).iushrn(this.shift), a3 = n3;
          return n3.cmp(this.m) >= 0 ? a3 = n3.isub(this.m) : n3.cmpn(0) < 0 && (a3 = n3.iadd(this.m)), a3._forceRed(this);
        }, A2.prototype.mul = function(e4, t3) {
          if (e4.isZero() || t3.isZero())
            return new n2(0)._forceRed(this);
          var r3 = e4.mul(t3), i3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a3 = r3.isub(i3).iushrn(this.shift), s3 = a3;
          return a3.cmp(this.m) >= 0 ? s3 = a3.isub(this.m) : a3.cmpn(0) < 0 && (s3 = a3.iadd(this.m)), s3._forceRed(this);
        }, A2.prototype.invm = function(e4) {
          return this.imod(e4._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(e2, gt);
    });
    var Jp = /* @__PURE__ */ Object.freeze({ __proto__: null, default: Qp, __moduleExports: Qp });
    var ey = class _ey {
      constructor(e2) {
        if (void 0 === e2)
          throw Error("Invalid BigInteger input");
        this.value = new Qp(e2);
      }
      clone() {
        const e2 = new _ey(null);
        return this.value.copy(e2.value), e2;
      }
      iinc() {
        return this.value.iadd(new Qp(1)), this;
      }
      inc() {
        return this.clone().iinc();
      }
      idec() {
        return this.value.isub(new Qp(1)), this;
      }
      dec() {
        return this.clone().idec();
      }
      iadd(e2) {
        return this.value.iadd(e2.value), this;
      }
      add(e2) {
        return this.clone().iadd(e2);
      }
      isub(e2) {
        return this.value.isub(e2.value), this;
      }
      sub(e2) {
        return this.clone().isub(e2);
      }
      imul(e2) {
        return this.value.imul(e2.value), this;
      }
      mul(e2) {
        return this.clone().imul(e2);
      }
      imod(e2) {
        return this.value = this.value.umod(e2.value), this;
      }
      mod(e2) {
        return this.clone().imod(e2);
      }
      modExp(e2, t2) {
        const r2 = t2.isEven() ? Qp.red(t2.value) : Qp.mont(t2.value), i2 = this.clone();
        return i2.value = i2.value.toRed(r2).redPow(e2.value).fromRed(), i2;
      }
      modInv(e2) {
        if (!this.gcd(e2).isOne())
          throw Error("Inverse does not exist");
        return new _ey(this.value.invm(e2.value));
      }
      gcd(e2) {
        return new _ey(this.value.gcd(e2.value));
      }
      ileftShift(e2) {
        return this.value.ishln(e2.value.toNumber()), this;
      }
      leftShift(e2) {
        return this.clone().ileftShift(e2);
      }
      irightShift(e2) {
        return this.value.ishrn(e2.value.toNumber()), this;
      }
      rightShift(e2) {
        return this.clone().irightShift(e2);
      }
      equal(e2) {
        return this.value.eq(e2.value);
      }
      lt(e2) {
        return this.value.lt(e2.value);
      }
      lte(e2) {
        return this.value.lte(e2.value);
      }
      gt(e2) {
        return this.value.gt(e2.value);
      }
      gte(e2) {
        return this.value.gte(e2.value);
      }
      isZero() {
        return this.value.isZero();
      }
      isOne() {
        return this.value.eq(new Qp(1));
      }
      isNegative() {
        return this.value.isNeg();
      }
      isEven() {
        return this.value.isEven();
      }
      abs() {
        const e2 = this.clone();
        return e2.value = e2.value.abs(), e2;
      }
      toString() {
        return this.value.toString();
      }
      toNumber() {
        return this.value.toNumber();
      }
      getBit(e2) {
        return this.value.testn(e2) ? 1 : 0;
      }
      bitLength() {
        return this.value.bitLength();
      }
      byteLength() {
        return this.value.byteLength();
      }
      toUint8Array(e2 = "be", t2) {
        return this.value.toArrayLike(Uint8Array, e2, t2);
      }
    };
    var ty;
    var ry = /* @__PURE__ */ Object.freeze({ __proto__: null, default: ey });
    var iy = mt(function(e2, t2) {
      var r2 = t2;
      function i2(e3) {
        return 1 === e3.length ? "0" + e3 : e3;
      }
      function n2(e3) {
        for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
          t3 += i2(e3[r3].toString(16));
        return t3;
      }
      r2.toArray = function(e3, t3) {
        if (Array.isArray(e3))
          return e3.slice();
        if (!e3)
          return [];
        var r3 = [];
        if ("string" != typeof e3) {
          for (var i3 = 0; i3 < e3.length; i3++)
            r3[i3] = 0 | e3[i3];
          return r3;
        }
        if ("hex" === t3) {
          (e3 = e3.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e3 = "0" + e3);
          for (i3 = 0; i3 < e3.length; i3 += 2)
            r3.push(parseInt(e3[i3] + e3[i3 + 1], 16));
        } else
          for (i3 = 0; i3 < e3.length; i3++) {
            var n3 = e3.charCodeAt(i3), a2 = n3 >> 8, s2 = 255 & n3;
            a2 ? r3.push(a2, s2) : r3.push(s2);
          }
        return r3;
      }, r2.zero2 = i2, r2.toHex = n2, r2.encode = function(e3, t3) {
        return "hex" === t3 ? n2(e3) : e3;
      };
    });
    var ny = mt(function(e2, t2) {
      var r2 = t2;
      r2.assert = yt, r2.toArray = iy.toArray, r2.zero2 = iy.zero2, r2.toHex = iy.toHex, r2.encode = iy.encode, r2.getNAF = function(e3, t3) {
        for (var r3 = [], i2 = 1 << t3 + 1, n2 = e3.clone(); n2.cmpn(1) >= 0; ) {
          var a2;
          if (n2.isOdd()) {
            var s2 = n2.andln(i2 - 1);
            a2 = s2 > (i2 >> 1) - 1 ? (i2 >> 1) - s2 : s2, n2.isubn(a2);
          } else
            a2 = 0;
          r3.push(a2);
          for (var o2 = 0 !== n2.cmpn(0) && 0 === n2.andln(i2 - 1) ? t3 + 1 : 1, c2 = 1; c2 < o2; c2++)
            r3.push(0);
          n2.iushrn(o2);
        }
        return r3;
      }, r2.getJSF = function(e3, t3) {
        var r3 = [[], []];
        e3 = e3.clone(), t3 = t3.clone();
        for (var i2 = 0, n2 = 0; e3.cmpn(-i2) > 0 || t3.cmpn(-n2) > 0; ) {
          var a2, s2, o2, c2 = e3.andln(3) + i2 & 3, u2 = t3.andln(3) + n2 & 3;
          if (3 === c2 && (c2 = -1), 3 === u2 && (u2 = -1), 0 == (1 & c2))
            a2 = 0;
          else
            a2 = 3 !== (o2 = e3.andln(7) + i2 & 7) && 5 !== o2 || 2 !== u2 ? c2 : -c2;
          if (r3[0].push(a2), 0 == (1 & u2))
            s2 = 0;
          else
            s2 = 3 !== (o2 = t3.andln(7) + n2 & 7) && 5 !== o2 || 2 !== c2 ? u2 : -u2;
          r3[1].push(s2), 2 * i2 === a2 + 1 && (i2 = 1 - i2), 2 * n2 === s2 + 1 && (n2 = 1 - n2), e3.iushrn(1), t3.iushrn(1);
        }
        return r3;
      }, r2.cachedProperty = function(e3, t3, r3) {
        var i2 = "_" + t3;
        e3.prototype[t3] = function() {
          return void 0 !== this[i2] ? this[i2] : this[i2] = r3.call(this);
        };
      }, r2.parseBytes = function(e3) {
        return "string" == typeof e3 ? r2.toArray(e3, "hex") : e3;
      }, r2.intFromLE = function(e3) {
        return new Qp(e3, "hex", "le");
      };
    });
    var ay = function(e2) {
      return ty || (ty = new sy(null)), ty.generate(e2);
    };
    function sy(e2) {
      this.rand = e2;
    }
    var oy = sy;
    if (sy.prototype.generate = function(e2) {
      return this._rand(e2);
    }, sy.prototype._rand = function(e2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e2);
      for (var t2 = new Uint8Array(e2), r2 = 0; r2 < t2.length; r2++)
        t2[r2] = this.rand.getByte();
      return t2;
    }, "object" == typeof self)
      self.crypto && self.crypto.getRandomValues ? sy.prototype._rand = function(e2) {
        var t2 = new Uint8Array(e2);
        return self.crypto.getRandomValues(t2), t2;
      } : self.msCrypto && self.msCrypto.getRandomValues ? sy.prototype._rand = function(e2) {
        var t2 = new Uint8Array(e2);
        return self.msCrypto.getRandomValues(t2), t2;
      } : "object" == typeof window && (sy.prototype._rand = function() {
        throw Error("Not implemented yet");
      });
    else
      try {
        cy = d.default;
        if ("function" != typeof cy.randomBytes)
          throw Error("Not supported");
        sy.prototype._rand = function(e2) {
          return cy.randomBytes(e2);
        };
      } catch (e2) {
      }
    var cy;
    ay.Rand = oy;
    var uy = ny.getNAF;
    var hy = ny.getJSF;
    var dy = ny.assert;
    function fy(e2, t2) {
      this.type = e2, this.p = new Qp(t2.p, 16), this.red = t2.prime ? Qp.red(t2.prime) : Qp.mont(this.p), this.zero = new Qp(0).toRed(this.red), this.one = new Qp(1).toRed(this.red), this.two = new Qp(2).toRed(this.red), this.n = t2.n && new Qp(t2.n, 16), this.g = t2.g && this.pointFromJSON(t2.g, t2.gRed), this._wnafT1 = [, , , ,], this._wnafT2 = [, , , ,], this._wnafT3 = [, , , ,], this._wnafT4 = [, , , ,];
      var r2 = this.n && this.p.div(this.n);
      !r2 || r2.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    var ly = fy;
    function py(e2, t2) {
      this.curve = e2, this.type = t2, this.precomputed = null;
    }
    fy.prototype.point = function() {
      throw Error("Not implemented");
    }, fy.prototype.validate = function() {
      throw Error("Not implemented");
    }, fy.prototype._fixedNafMul = function(e2, t2) {
      dy(e2.precomputed);
      var r2 = e2._getDoubles(), i2 = uy(t2, 1), n2 = (1 << r2.step + 1) - (r2.step % 2 == 0 ? 2 : 1);
      n2 /= 3;
      for (var a2 = [], s2 = 0; s2 < i2.length; s2 += r2.step) {
        var o2 = 0;
        for (t2 = s2 + r2.step - 1; t2 >= s2; t2--)
          o2 = (o2 << 1) + i2[t2];
        a2.push(o2);
      }
      for (var c2 = this.jpoint(null, null, null), u2 = this.jpoint(null, null, null), h2 = n2; h2 > 0; h2--) {
        for (s2 = 0; s2 < a2.length; s2++) {
          (o2 = a2[s2]) === h2 ? u2 = u2.mixedAdd(r2.points[s2]) : o2 === -h2 && (u2 = u2.mixedAdd(r2.points[s2].neg()));
        }
        c2 = c2.add(u2);
      }
      return c2.toP();
    }, fy.prototype._wnafMul = function(e2, t2) {
      var r2 = 4, i2 = e2._getNAFPoints(r2);
      r2 = i2.wnd;
      for (var n2 = i2.points, a2 = uy(t2, r2), s2 = this.jpoint(null, null, null), o2 = a2.length - 1; o2 >= 0; o2--) {
        for (t2 = 0; o2 >= 0 && 0 === a2[o2]; o2--)
          t2++;
        if (o2 >= 0 && t2++, s2 = s2.dblp(t2), o2 < 0)
          break;
        var c2 = a2[o2];
        dy(0 !== c2), s2 = "affine" === e2.type ? c2 > 0 ? s2.mixedAdd(n2[c2 - 1 >> 1]) : s2.mixedAdd(n2[-c2 - 1 >> 1].neg()) : c2 > 0 ? s2.add(n2[c2 - 1 >> 1]) : s2.add(n2[-c2 - 1 >> 1].neg());
      }
      return "affine" === e2.type ? s2.toP() : s2;
    }, fy.prototype._wnafMulAdd = function(e2, t2, r2, i2, n2) {
      for (var a2 = this._wnafT1, s2 = this._wnafT2, o2 = this._wnafT3, c2 = 0, u2 = 0; u2 < i2; u2++) {
        var h2 = (A2 = t2[u2])._getNAFPoints(e2);
        a2[u2] = h2.wnd, s2[u2] = h2.points;
      }
      for (u2 = i2 - 1; u2 >= 1; u2 -= 2) {
        var d2 = u2 - 1, f2 = u2;
        if (1 === a2[d2] && 1 === a2[f2]) {
          var l2 = [t2[d2], null, null, t2[f2]];
          0 === t2[d2].y.cmp(t2[f2].y) ? (l2[1] = t2[d2].add(t2[f2]), l2[2] = t2[d2].toJ().mixedAdd(t2[f2].neg())) : 0 === t2[d2].y.cmp(t2[f2].y.redNeg()) ? (l2[1] = t2[d2].toJ().mixedAdd(t2[f2]), l2[2] = t2[d2].add(t2[f2].neg())) : (l2[1] = t2[d2].toJ().mixedAdd(t2[f2]), l2[2] = t2[d2].toJ().mixedAdd(t2[f2].neg()));
          var p2 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], y2 = hy(r2[d2], r2[f2]);
          c2 = Math.max(y2[0].length, c2), o2[d2] = Array(c2), o2[f2] = Array(c2);
          for (var b2 = 0; b2 < c2; b2++) {
            var g2 = 0 | y2[0][b2], m2 = 0 | y2[1][b2];
            o2[d2][b2] = p2[3 * (g2 + 1) + (m2 + 1)], o2[f2][b2] = 0, s2[d2] = l2;
          }
        } else
          o2[d2] = uy(r2[d2], a2[d2]), o2[f2] = uy(r2[f2], a2[f2]), c2 = Math.max(o2[d2].length, c2), c2 = Math.max(o2[f2].length, c2);
      }
      var w2 = this.jpoint(null, null, null), v2 = this._wnafT4;
      for (u2 = c2; u2 >= 0; u2--) {
        for (var _2 = 0; u2 >= 0; ) {
          var k2 = true;
          for (b2 = 0; b2 < i2; b2++)
            v2[b2] = 0 | o2[b2][u2], 0 !== v2[b2] && (k2 = false);
          if (!k2)
            break;
          _2++, u2--;
        }
        if (u2 >= 0 && _2++, w2 = w2.dblp(_2), u2 < 0)
          break;
        for (b2 = 0; b2 < i2; b2++) {
          var A2, S2 = v2[b2];
          0 !== S2 && (S2 > 0 ? A2 = s2[b2][S2 - 1 >> 1] : S2 < 0 && (A2 = s2[b2][-S2 - 1 >> 1].neg()), w2 = "affine" === A2.type ? w2.mixedAdd(A2) : w2.add(A2));
        }
      }
      for (u2 = 0; u2 < i2; u2++)
        s2[u2] = null;
      return n2 ? w2 : w2.toP();
    }, fy.BasePoint = py, py.prototype.eq = function() {
      throw Error("Not implemented");
    }, py.prototype.validate = function() {
      return this.curve.validate(this);
    }, fy.prototype.decodePoint = function(e2, t2) {
      e2 = ny.toArray(e2, t2);
      var r2 = this.p.byteLength();
      if ((4 === e2[0] || 6 === e2[0] || 7 === e2[0]) && e2.length - 1 == 2 * r2)
        return 6 === e2[0] ? dy(e2[e2.length - 1] % 2 == 0) : 7 === e2[0] && dy(e2[e2.length - 1] % 2 == 1), this.point(e2.slice(1, 1 + r2), e2.slice(1 + r2, 1 + 2 * r2));
      if ((2 === e2[0] || 3 === e2[0]) && e2.length - 1 === r2)
        return this.pointFromX(e2.slice(1, 1 + r2), 3 === e2[0]);
      throw Error("Unknown point format");
    }, py.prototype.encodeCompressed = function(e2) {
      return this.encode(e2, true);
    }, py.prototype._encode = function(e2) {
      var t2 = this.curve.p.byteLength(), r2 = this.getX().toArray("be", t2);
      return e2 ? [this.getY().isEven() ? 2 : 3].concat(r2) : [4].concat(r2, this.getY().toArray("be", t2));
    }, py.prototype.encode = function(e2, t2) {
      return ny.encode(this._encode(t2), e2);
    }, py.prototype.precompute = function(e2) {
      if (this.precomputed)
        return this;
      var t2 = { doubles: null, naf: null, beta: null };
      return t2.naf = this._getNAFPoints(8), t2.doubles = this._getDoubles(4, e2), t2.beta = this._getBeta(), this.precomputed = t2, this;
    }, py.prototype._hasDoubles = function(e2) {
      if (!this.precomputed)
        return false;
      var t2 = this.precomputed.doubles;
      return !!t2 && t2.points.length >= Math.ceil((e2.bitLength() + 1) / t2.step);
    }, py.prototype._getDoubles = function(e2, t2) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var r2 = [this], i2 = this, n2 = 0; n2 < t2; n2 += e2) {
        for (var a2 = 0; a2 < e2; a2++)
          i2 = i2.dbl();
        r2.push(i2);
      }
      return { step: e2, points: r2 };
    }, py.prototype._getNAFPoints = function(e2) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var t2 = [this], r2 = (1 << e2) - 1, i2 = 1 === r2 ? null : this.dbl(), n2 = 1; n2 < r2; n2++)
        t2[n2] = t2[n2 - 1].add(i2);
      return { wnd: e2, points: t2 };
    }, py.prototype._getBeta = function() {
      return null;
    }, py.prototype.dblp = function(e2) {
      for (var t2 = this, r2 = 0; r2 < e2; r2++)
        t2 = t2.dbl();
      return t2;
    };
    var yy = ny.assert;
    function by(e2) {
      ly.call(this, "short", e2), this.a = new Qp(e2.a, 16).toRed(this.red), this.b = new Qp(e2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e2), this._endoWnafT1 = [, , , ,], this._endoWnafT2 = [, , , ,];
    }
    _t(by, ly);
    var gy = by;
    function my(e2, t2, r2, i2) {
      ly.BasePoint.call(this, e2, "affine"), null === t2 && null === r2 ? (this.x = null, this.y = null, this.inf = true) : (this.x = new Qp(t2, 16), this.y = new Qp(r2, 16), i2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    function wy(e2, t2, r2, i2) {
      ly.BasePoint.call(this, e2, "jacobian"), null === t2 && null === r2 && null === i2 ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Qp(0)) : (this.x = new Qp(t2, 16), this.y = new Qp(r2, 16), this.z = new Qp(i2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    function vy(e2) {
      ly.call(this, "mont", e2), this.a = new Qp(e2.a, 16).toRed(this.red), this.b = new Qp(e2.b, 16).toRed(this.red), this.i4 = new Qp(4).toRed(this.red).redInvm(), this.two = new Qp(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    by.prototype._getEndomorphism = function(e2) {
      if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
        var t2, r2;
        if (e2.beta)
          t2 = new Qp(e2.beta, 16).toRed(this.red);
        else {
          var i2 = this._getEndoRoots(this.p);
          t2 = (t2 = i2[0].cmp(i2[1]) < 0 ? i2[0] : i2[1]).toRed(this.red);
        }
        if (e2.lambda)
          r2 = new Qp(e2.lambda, 16);
        else {
          var n2 = this._getEndoRoots(this.n);
          0 === this.g.mul(n2[0]).x.cmp(this.g.x.redMul(t2)) ? r2 = n2[0] : (r2 = n2[1], yy(0 === this.g.mul(r2).x.cmp(this.g.x.redMul(t2))));
        }
        return { beta: t2, lambda: r2, basis: e2.basis ? e2.basis.map(function(e3) {
          return { a: new Qp(e3.a, 16), b: new Qp(e3.b, 16) };
        }) : this._getEndoBasis(r2) };
      }
    }, by.prototype._getEndoRoots = function(e2) {
      var t2 = e2 === this.p ? this.red : Qp.mont(e2), r2 = new Qp(2).toRed(t2).redInvm(), i2 = r2.redNeg(), n2 = new Qp(3).toRed(t2).redNeg().redSqrt().redMul(r2);
      return [i2.redAdd(n2).fromRed(), i2.redSub(n2).fromRed()];
    }, by.prototype._getEndoBasis = function(e2) {
      for (var t2, r2, i2, n2, a2, s2, o2, c2, u2, h2 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), d2 = e2, f2 = this.n.clone(), l2 = new Qp(1), p2 = new Qp(0), y2 = new Qp(0), b2 = new Qp(1), g2 = 0; 0 !== d2.cmpn(0); ) {
        var m2 = f2.div(d2);
        c2 = f2.sub(m2.mul(d2)), u2 = y2.sub(m2.mul(l2));
        var w2 = b2.sub(m2.mul(p2));
        if (!i2 && c2.cmp(h2) < 0)
          t2 = o2.neg(), r2 = l2, i2 = c2.neg(), n2 = u2;
        else if (i2 && 2 == ++g2)
          break;
        o2 = c2, f2 = d2, d2 = c2, y2 = l2, l2 = u2, b2 = p2, p2 = w2;
      }
      a2 = c2.neg(), s2 = u2;
      var v2 = i2.sqr().add(n2.sqr());
      return a2.sqr().add(s2.sqr()).cmp(v2) >= 0 && (a2 = t2, s2 = r2), i2.negative && (i2 = i2.neg(), n2 = n2.neg()), a2.negative && (a2 = a2.neg(), s2 = s2.neg()), [{ a: i2, b: n2 }, { a: a2, b: s2 }];
    }, by.prototype._endoSplit = function(e2) {
      var t2 = this.endo.basis, r2 = t2[0], i2 = t2[1], n2 = i2.b.mul(e2).divRound(this.n), a2 = r2.b.neg().mul(e2).divRound(this.n), s2 = n2.mul(r2.a), o2 = a2.mul(i2.a), c2 = n2.mul(r2.b), u2 = a2.mul(i2.b);
      return { k1: e2.sub(s2).sub(o2), k2: c2.add(u2).neg() };
    }, by.prototype.pointFromX = function(e2, t2) {
      (e2 = new Qp(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr().redMul(e2).redIAdd(e2.redMul(this.a)).redIAdd(this.b), i2 = r2.redSqrt();
      if (0 !== i2.redSqr().redSub(r2).cmp(this.zero))
        throw Error("invalid point");
      var n2 = i2.fromRed().isOdd();
      return (t2 && !n2 || !t2 && n2) && (i2 = i2.redNeg()), this.point(e2, i2);
    }, by.prototype.validate = function(e2) {
      if (e2.inf)
        return true;
      var t2 = e2.x, r2 = e2.y, i2 = this.a.redMul(t2), n2 = t2.redSqr().redMul(t2).redIAdd(i2).redIAdd(this.b);
      return 0 === r2.redSqr().redISub(n2).cmpn(0);
    }, by.prototype._endoWnafMulAdd = function(e2, t2, r2) {
      for (var i2 = this._endoWnafT1, n2 = this._endoWnafT2, a2 = 0; a2 < e2.length; a2++) {
        var s2 = this._endoSplit(t2[a2]), o2 = e2[a2], c2 = o2._getBeta();
        s2.k1.negative && (s2.k1.ineg(), o2 = o2.neg(true)), s2.k2.negative && (s2.k2.ineg(), c2 = c2.neg(true)), i2[2 * a2] = o2, i2[2 * a2 + 1] = c2, n2[2 * a2] = s2.k1, n2[2 * a2 + 1] = s2.k2;
      }
      for (var u2 = this._wnafMulAdd(1, i2, n2, 2 * a2, r2), h2 = 0; h2 < 2 * a2; h2++)
        i2[h2] = null, n2[h2] = null;
      return u2;
    }, _t(my, ly.BasePoint), by.prototype.point = function(e2, t2, r2) {
      return new my(this, e2, t2, r2);
    }, by.prototype.pointFromJSON = function(e2, t2) {
      return my.fromJSON(this, e2, t2);
    }, my.prototype._getBeta = function() {
      if (this.curve.endo) {
        var e2 = this.precomputed;
        if (e2 && e2.beta)
          return e2.beta;
        var t2 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e2) {
          var r2 = this.curve, i2 = function(e3) {
            return r2.point(e3.x.redMul(r2.endo.beta), e3.y);
          };
          e2.beta = t2, t2.precomputed = { beta: null, naf: e2.naf && { wnd: e2.naf.wnd, points: e2.naf.points.map(i2) }, doubles: e2.doubles && { step: e2.doubles.step, points: e2.doubles.points.map(i2) } };
        }
        return t2;
      }
    }, my.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    }, my.fromJSON = function(e2, t2, r2) {
      "string" == typeof t2 && (t2 = JSON.parse(t2));
      var i2 = e2.point(t2[0], t2[1], r2);
      if (!t2[2])
        return i2;
      function n2(t3) {
        return e2.point(t3[0], t3[1], r2);
      }
      var a2 = t2[2];
      return i2.precomputed = { beta: null, doubles: a2.doubles && { step: a2.doubles.step, points: [i2].concat(a2.doubles.points.map(n2)) }, naf: a2.naf && { wnd: a2.naf.wnd, points: [i2].concat(a2.naf.points.map(n2)) } }, i2;
    }, my.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, my.prototype.isInfinity = function() {
      return this.inf;
    }, my.prototype.add = function(e2) {
      if (this.inf)
        return e2;
      if (e2.inf)
        return this;
      if (this.eq(e2))
        return this.dbl();
      if (this.neg().eq(e2))
        return this.curve.point(null, null);
      if (0 === this.x.cmp(e2.x))
        return this.curve.point(null, null);
      var t2 = this.y.redSub(e2.y);
      0 !== t2.cmpn(0) && (t2 = t2.redMul(this.x.redSub(e2.x).redInvm()));
      var r2 = t2.redSqr().redISub(this.x).redISub(e2.x), i2 = t2.redMul(this.x.redSub(r2)).redISub(this.y);
      return this.curve.point(r2, i2);
    }, my.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e2 = this.y.redAdd(this.y);
      if (0 === e2.cmpn(0))
        return this.curve.point(null, null);
      var t2 = this.curve.a, r2 = this.x.redSqr(), i2 = e2.redInvm(), n2 = r2.redAdd(r2).redIAdd(r2).redIAdd(t2).redMul(i2), a2 = n2.redSqr().redISub(this.x.redAdd(this.x)), s2 = n2.redMul(this.x.redSub(a2)).redISub(this.y);
      return this.curve.point(a2, s2);
    }, my.prototype.getX = function() {
      return this.x.fromRed();
    }, my.prototype.getY = function() {
      return this.y.fromRed();
    }, my.prototype.mul = function(e2) {
      return e2 = new Qp(e2, 16), this.isInfinity() ? this : this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e2]) : this.curve._wnafMul(this, e2);
    }, my.prototype.mulAdd = function(e2, t2, r2) {
      var i2 = [this, t2], n2 = [e2, r2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(i2, n2) : this.curve._wnafMulAdd(1, i2, n2, 2);
    }, my.prototype.jmulAdd = function(e2, t2, r2) {
      var i2 = [this, t2], n2 = [e2, r2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(i2, n2, true) : this.curve._wnafMulAdd(1, i2, n2, 2, true);
    }, my.prototype.eq = function(e2) {
      return this === e2 || this.inf === e2.inf && (this.inf || 0 === this.x.cmp(e2.x) && 0 === this.y.cmp(e2.y));
    }, my.prototype.neg = function(e2) {
      if (this.inf)
        return this;
      var t2 = this.curve.point(this.x, this.y.redNeg());
      if (e2 && this.precomputed) {
        var r2 = this.precomputed, i2 = function(e3) {
          return e3.neg();
        };
        t2.precomputed = { naf: r2.naf && { wnd: r2.naf.wnd, points: r2.naf.points.map(i2) }, doubles: r2.doubles && { step: r2.doubles.step, points: r2.doubles.points.map(i2) } };
      }
      return t2;
    }, my.prototype.toJ = function() {
      return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
    }, _t(wy, ly.BasePoint), by.prototype.jpoint = function(e2, t2, r2) {
      return new wy(this, e2, t2, r2);
    }, wy.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e2 = this.z.redInvm(), t2 = e2.redSqr(), r2 = this.x.redMul(t2), i2 = this.y.redMul(t2).redMul(e2);
      return this.curve.point(r2, i2);
    }, wy.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, wy.prototype.add = function(e2) {
      if (this.isInfinity())
        return e2;
      if (e2.isInfinity())
        return this;
      var t2 = e2.z.redSqr(), r2 = this.z.redSqr(), i2 = this.x.redMul(t2), n2 = e2.x.redMul(r2), a2 = this.y.redMul(t2.redMul(e2.z)), s2 = e2.y.redMul(r2.redMul(this.z)), o2 = i2.redSub(n2), c2 = a2.redSub(s2);
      if (0 === o2.cmpn(0))
        return 0 !== c2.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var u2 = o2.redSqr(), h2 = u2.redMul(o2), d2 = i2.redMul(u2), f2 = c2.redSqr().redIAdd(h2).redISub(d2).redISub(d2), l2 = c2.redMul(d2.redISub(f2)).redISub(a2.redMul(h2)), p2 = this.z.redMul(e2.z).redMul(o2);
      return this.curve.jpoint(f2, l2, p2);
    }, wy.prototype.mixedAdd = function(e2) {
      if (this.isInfinity())
        return e2.toJ();
      if (e2.isInfinity())
        return this;
      var t2 = this.z.redSqr(), r2 = this.x, i2 = e2.x.redMul(t2), n2 = this.y, a2 = e2.y.redMul(t2).redMul(this.z), s2 = r2.redSub(i2), o2 = n2.redSub(a2);
      if (0 === s2.cmpn(0))
        return 0 !== o2.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var c2 = s2.redSqr(), u2 = c2.redMul(s2), h2 = r2.redMul(c2), d2 = o2.redSqr().redIAdd(u2).redISub(h2).redISub(h2), f2 = o2.redMul(h2.redISub(d2)).redISub(n2.redMul(u2)), l2 = this.z.redMul(s2);
      return this.curve.jpoint(d2, f2, l2);
    }, wy.prototype.dblp = function(e2) {
      if (0 === e2)
        return this;
      if (this.isInfinity())
        return this;
      if (!e2)
        return this.dbl();
      if (this.curve.zeroA || this.curve.threeA) {
        for (var t2 = this, r2 = 0; r2 < e2; r2++)
          t2 = t2.dbl();
        return t2;
      }
      var i2 = this.curve.a, n2 = this.curve.tinv, a2 = this.x, s2 = this.y, o2 = this.z, c2 = o2.redSqr().redSqr(), u2 = s2.redAdd(s2);
      for (r2 = 0; r2 < e2; r2++) {
        var h2 = a2.redSqr(), d2 = u2.redSqr(), f2 = d2.redSqr(), l2 = h2.redAdd(h2).redIAdd(h2).redIAdd(i2.redMul(c2)), p2 = a2.redMul(d2), y2 = l2.redSqr().redISub(p2.redAdd(p2)), b2 = p2.redISub(y2), g2 = l2.redMul(b2);
        g2 = g2.redIAdd(g2).redISub(f2);
        var m2 = u2.redMul(o2);
        r2 + 1 < e2 && (c2 = c2.redMul(f2)), a2 = y2, o2 = m2, u2 = g2;
      }
      return this.curve.jpoint(a2, u2.redMul(n2), o2);
    }, wy.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, wy.prototype._zeroDbl = function() {
      var e2, t2, r2;
      if (this.zOne) {
        var i2 = this.x.redSqr(), n2 = this.y.redSqr(), a2 = n2.redSqr(), s2 = this.x.redAdd(n2).redSqr().redISub(i2).redISub(a2);
        s2 = s2.redIAdd(s2);
        var o2 = i2.redAdd(i2).redIAdd(i2), c2 = o2.redSqr().redISub(s2).redISub(s2), u2 = a2.redIAdd(a2);
        u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), e2 = c2, t2 = o2.redMul(s2.redISub(c2)).redISub(u2), r2 = this.y.redAdd(this.y);
      } else {
        var h2 = this.x.redSqr(), d2 = this.y.redSqr(), f2 = d2.redSqr(), l2 = this.x.redAdd(d2).redSqr().redISub(h2).redISub(f2);
        l2 = l2.redIAdd(l2);
        var p2 = h2.redAdd(h2).redIAdd(h2), y2 = p2.redSqr(), b2 = f2.redIAdd(f2);
        b2 = (b2 = b2.redIAdd(b2)).redIAdd(b2), e2 = y2.redISub(l2).redISub(l2), t2 = p2.redMul(l2.redISub(e2)).redISub(b2), r2 = (r2 = this.y.redMul(this.z)).redIAdd(r2);
      }
      return this.curve.jpoint(e2, t2, r2);
    }, wy.prototype._threeDbl = function() {
      var e2, t2, r2;
      if (this.zOne) {
        var i2 = this.x.redSqr(), n2 = this.y.redSqr(), a2 = n2.redSqr(), s2 = this.x.redAdd(n2).redSqr().redISub(i2).redISub(a2);
        s2 = s2.redIAdd(s2);
        var o2 = i2.redAdd(i2).redIAdd(i2).redIAdd(this.curve.a), c2 = o2.redSqr().redISub(s2).redISub(s2);
        e2 = c2;
        var u2 = a2.redIAdd(a2);
        u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), t2 = o2.redMul(s2.redISub(c2)).redISub(u2), r2 = this.y.redAdd(this.y);
      } else {
        var h2 = this.z.redSqr(), d2 = this.y.redSqr(), f2 = this.x.redMul(d2), l2 = this.x.redSub(h2).redMul(this.x.redAdd(h2));
        l2 = l2.redAdd(l2).redIAdd(l2);
        var p2 = f2.redIAdd(f2), y2 = (p2 = p2.redIAdd(p2)).redAdd(p2);
        e2 = l2.redSqr().redISub(y2), r2 = this.y.redAdd(this.z).redSqr().redISub(d2).redISub(h2);
        var b2 = d2.redSqr();
        b2 = (b2 = (b2 = b2.redIAdd(b2)).redIAdd(b2)).redIAdd(b2), t2 = l2.redMul(p2.redISub(e2)).redISub(b2);
      }
      return this.curve.jpoint(e2, t2, r2);
    }, wy.prototype._dbl = function() {
      var e2 = this.curve.a, t2 = this.x, r2 = this.y, i2 = this.z, n2 = i2.redSqr().redSqr(), a2 = t2.redSqr(), s2 = r2.redSqr(), o2 = a2.redAdd(a2).redIAdd(a2).redIAdd(e2.redMul(n2)), c2 = t2.redAdd(t2), u2 = (c2 = c2.redIAdd(c2)).redMul(s2), h2 = o2.redSqr().redISub(u2.redAdd(u2)), d2 = u2.redISub(h2), f2 = s2.redSqr();
      f2 = (f2 = (f2 = f2.redIAdd(f2)).redIAdd(f2)).redIAdd(f2);
      var l2 = o2.redMul(d2).redISub(f2), p2 = r2.redAdd(r2).redMul(i2);
      return this.curve.jpoint(h2, l2, p2);
    }, wy.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e2 = this.x.redSqr(), t2 = this.y.redSqr(), r2 = this.z.redSqr(), i2 = t2.redSqr(), n2 = e2.redAdd(e2).redIAdd(e2), a2 = n2.redSqr(), s2 = this.x.redAdd(t2).redSqr().redISub(e2).redISub(i2), o2 = (s2 = (s2 = (s2 = s2.redIAdd(s2)).redAdd(s2).redIAdd(s2)).redISub(a2)).redSqr(), c2 = i2.redIAdd(i2);
      c2 = (c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2)).redIAdd(c2);
      var u2 = n2.redIAdd(s2).redSqr().redISub(a2).redISub(o2).redISub(c2), h2 = t2.redMul(u2);
      h2 = (h2 = h2.redIAdd(h2)).redIAdd(h2);
      var d2 = this.x.redMul(o2).redISub(h2);
      d2 = (d2 = d2.redIAdd(d2)).redIAdd(d2);
      var f2 = this.y.redMul(u2.redMul(c2.redISub(u2)).redISub(s2.redMul(o2)));
      f2 = (f2 = (f2 = f2.redIAdd(f2)).redIAdd(f2)).redIAdd(f2);
      var l2 = this.z.redAdd(s2).redSqr().redISub(r2).redISub(o2);
      return this.curve.jpoint(d2, f2, l2);
    }, wy.prototype.mul = function(e2, t2) {
      return e2 = new Qp(e2, t2), this.curve._wnafMul(this, e2);
    }, wy.prototype.eq = function(e2) {
      if ("affine" === e2.type)
        return this.eq(e2.toJ());
      if (this === e2)
        return true;
      var t2 = this.z.redSqr(), r2 = e2.z.redSqr();
      if (0 !== this.x.redMul(r2).redISub(e2.x.redMul(t2)).cmpn(0))
        return false;
      var i2 = t2.redMul(this.z), n2 = r2.redMul(e2.z);
      return 0 === this.y.redMul(n2).redISub(e2.y.redMul(i2)).cmpn(0);
    }, wy.prototype.eqXToP = function(e2) {
      var t2 = this.z.redSqr(), r2 = e2.toRed(this.curve.red).redMul(t2);
      if (0 === this.x.cmp(r2))
        return true;
      for (var i2 = e2.clone(), n2 = this.curve.redN.redMul(t2); ; ) {
        if (i2.iadd(this.curve.n), i2.cmp(this.curve.p) >= 0)
          return false;
        if (r2.redIAdd(n2), 0 === this.x.cmp(r2))
          return true;
      }
    }, wy.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, wy.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0);
    }, _t(vy, ly);
    var _y = vy;
    function ky(e2, t2, r2) {
      ly.BasePoint.call(this, e2, "projective"), null === t2 && null === r2 ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Qp(t2, 16), this.z = new Qp(r2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    vy.prototype.validate = function(e2) {
      var t2 = e2.normalize().x, r2 = t2.redSqr(), i2 = r2.redMul(t2).redAdd(r2.redMul(this.a)).redAdd(t2);
      return 0 === i2.redSqrt().redSqr().cmp(i2);
    }, _t(ky, ly.BasePoint), vy.prototype.decodePoint = function(e2, t2) {
      if (33 === (e2 = ny.toArray(e2, t2)).length && 64 === e2[0] && (e2 = e2.slice(1, 33).reverse()), 32 !== e2.length)
        throw Error("Unknown point compression format");
      return this.point(e2, 1);
    }, vy.prototype.point = function(e2, t2) {
      return new ky(this, e2, t2);
    }, vy.prototype.pointFromJSON = function(e2) {
      return ky.fromJSON(this, e2);
    }, ky.prototype.precompute = function() {
    }, ky.prototype._encode = function(e2) {
      var t2 = this.curve.p.byteLength();
      return e2 ? [64].concat(this.getX().toArray("le", t2)) : this.getX().toArray("be", t2);
    }, ky.fromJSON = function(e2, t2) {
      return new ky(e2, t2[0], t2[1] || e2.one);
    }, ky.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, ky.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0);
    }, ky.prototype.dbl = function() {
      var e2 = this.x.redAdd(this.z).redSqr(), t2 = this.x.redSub(this.z).redSqr(), r2 = e2.redSub(t2), i2 = e2.redMul(t2), n2 = r2.redMul(t2.redAdd(this.curve.a24.redMul(r2)));
      return this.curve.point(i2, n2);
    }, ky.prototype.add = function() {
      throw Error("Not supported on Montgomery curve");
    }, ky.prototype.diffAdd = function(e2, t2) {
      var r2 = this.x.redAdd(this.z), i2 = this.x.redSub(this.z), n2 = e2.x.redAdd(e2.z), a2 = e2.x.redSub(e2.z).redMul(r2), s2 = n2.redMul(i2), o2 = t2.z.redMul(a2.redAdd(s2).redSqr()), c2 = t2.x.redMul(a2.redISub(s2).redSqr());
      return this.curve.point(o2, c2);
    }, ky.prototype.mul = function(e2) {
      for (var t2 = (e2 = new Qp(e2, 16)).clone(), r2 = this, i2 = this.curve.point(null, null), n2 = []; 0 !== t2.cmpn(0); t2.iushrn(1))
        n2.push(t2.andln(1));
      for (var a2 = n2.length - 1; a2 >= 0; a2--)
        0 === n2[a2] ? (r2 = r2.diffAdd(i2, this), i2 = i2.dbl()) : (i2 = r2.diffAdd(i2, this), r2 = r2.dbl());
      return i2;
    }, ky.prototype.mulAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, ky.prototype.jumlAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, ky.prototype.eq = function(e2) {
      return 0 === this.getX().cmp(e2.getX());
    }, ky.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, ky.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    var Ay = ny.assert;
    function Sy(e2) {
      this.twisted = 1 != (0 | e2.a), this.mOneA = this.twisted && -1 == (0 | e2.a), this.extended = this.mOneA, ly.call(this, "edwards", e2), this.a = new Qp(e2.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Qp(e2.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Qp(e2.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Ay(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | e2.c);
    }
    _t(Sy, ly);
    var Ey = Sy;
    function Py(e2, t2, r2, i2, n2) {
      ly.BasePoint.call(this, e2, "projective"), null === t2 && null === r2 && null === i2 ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Qp(t2, 16), this.y = new Qp(r2, 16), this.z = i2 ? new Qp(i2, 16) : this.curve.one, this.t = n2 && new Qp(n2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    Sy.prototype._mulA = function(e2) {
      return this.mOneA ? e2.redNeg() : this.a.redMul(e2);
    }, Sy.prototype._mulC = function(e2) {
      return this.oneC ? e2 : this.c.redMul(e2);
    }, Sy.prototype.jpoint = function(e2, t2, r2, i2) {
      return this.point(e2, t2, r2, i2);
    }, Sy.prototype.pointFromX = function(e2, t2) {
      (e2 = new Qp(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr(), i2 = this.c2.redSub(this.a.redMul(r2)), n2 = this.one.redSub(this.c2.redMul(this.d).redMul(r2)), a2 = i2.redMul(n2.redInvm()), s2 = a2.redSqrt();
      if (0 !== s2.redSqr().redSub(a2).cmp(this.zero))
        throw Error("invalid point");
      var o2 = s2.fromRed().isOdd();
      return (t2 && !o2 || !t2 && o2) && (s2 = s2.redNeg()), this.point(e2, s2);
    }, Sy.prototype.pointFromY = function(e2, t2) {
      (e2 = new Qp(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr(), i2 = r2.redSub(this.c2), n2 = r2.redMul(this.d).redMul(this.c2).redSub(this.a), a2 = i2.redMul(n2.redInvm());
      if (0 === a2.cmp(this.zero)) {
        if (t2)
          throw Error("invalid point");
        return this.point(this.zero, e2);
      }
      var s2 = a2.redSqrt();
      if (0 !== s2.redSqr().redSub(a2).cmp(this.zero))
        throw Error("invalid point");
      return s2.fromRed().isOdd() !== t2 && (s2 = s2.redNeg()), this.point(s2, e2);
    }, Sy.prototype.validate = function(e2) {
      if (e2.isInfinity())
        return true;
      e2.normalize();
      var t2 = e2.x.redSqr(), r2 = e2.y.redSqr(), i2 = t2.redMul(this.a).redAdd(r2), n2 = this.c2.redMul(this.one.redAdd(this.d.redMul(t2).redMul(r2)));
      return 0 === i2.cmp(n2);
    }, _t(Py, ly.BasePoint), Sy.prototype.pointFromJSON = function(e2) {
      return Py.fromJSON(this, e2);
    }, Sy.prototype.point = function(e2, t2, r2, i2) {
      return new Py(this, e2, t2, r2, i2);
    }, Py.fromJSON = function(e2, t2) {
      return new Py(e2, t2[0], t2[1], t2[2]);
    }, Py.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, Py.prototype.isInfinity = function() {
      return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
    }, Py.prototype._extDbl = function() {
      var e2 = this.x.redSqr(), t2 = this.y.redSqr(), r2 = this.z.redSqr();
      r2 = r2.redIAdd(r2);
      var i2 = this.curve._mulA(e2), n2 = this.x.redAdd(this.y).redSqr().redISub(e2).redISub(t2), a2 = i2.redAdd(t2), s2 = a2.redSub(r2), o2 = i2.redSub(t2), c2 = n2.redMul(s2), u2 = a2.redMul(o2), h2 = n2.redMul(o2), d2 = s2.redMul(a2);
      return this.curve.point(c2, u2, d2, h2);
    }, Py.prototype._projDbl = function() {
      var e2, t2, r2, i2 = this.x.redAdd(this.y).redSqr(), n2 = this.x.redSqr(), a2 = this.y.redSqr();
      if (this.curve.twisted) {
        var s2 = (u2 = this.curve._mulA(n2)).redAdd(a2);
        if (this.zOne)
          e2 = i2.redSub(n2).redSub(a2).redMul(s2.redSub(this.curve.two)), t2 = s2.redMul(u2.redSub(a2)), r2 = s2.redSqr().redSub(s2).redSub(s2);
        else {
          var o2 = this.z.redSqr(), c2 = s2.redSub(o2).redISub(o2);
          e2 = i2.redSub(n2).redISub(a2).redMul(c2), t2 = s2.redMul(u2.redSub(a2)), r2 = s2.redMul(c2);
        }
      } else {
        var u2 = n2.redAdd(a2);
        o2 = this.curve._mulC(this.z).redSqr(), c2 = u2.redSub(o2).redSub(o2);
        e2 = this.curve._mulC(i2.redISub(u2)).redMul(c2), t2 = this.curve._mulC(u2).redMul(n2.redISub(a2)), r2 = u2.redMul(c2);
      }
      return this.curve.point(e2, t2, r2);
    }, Py.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, Py.prototype._extAdd = function(e2) {
      var t2 = this.y.redSub(this.x).redMul(e2.y.redSub(e2.x)), r2 = this.y.redAdd(this.x).redMul(e2.y.redAdd(e2.x)), i2 = this.t.redMul(this.curve.dd).redMul(e2.t), n2 = this.z.redMul(e2.z.redAdd(e2.z)), a2 = r2.redSub(t2), s2 = n2.redSub(i2), o2 = n2.redAdd(i2), c2 = r2.redAdd(t2), u2 = a2.redMul(s2), h2 = o2.redMul(c2), d2 = a2.redMul(c2), f2 = s2.redMul(o2);
      return this.curve.point(u2, h2, f2, d2);
    }, Py.prototype._projAdd = function(e2) {
      var t2, r2, i2 = this.z.redMul(e2.z), n2 = i2.redSqr(), a2 = this.x.redMul(e2.x), s2 = this.y.redMul(e2.y), o2 = this.curve.d.redMul(a2).redMul(s2), c2 = n2.redSub(o2), u2 = n2.redAdd(o2), h2 = this.x.redAdd(this.y).redMul(e2.x.redAdd(e2.y)).redISub(a2).redISub(s2), d2 = i2.redMul(c2).redMul(h2);
      return this.curve.twisted ? (t2 = i2.redMul(u2).redMul(s2.redSub(this.curve._mulA(a2))), r2 = c2.redMul(u2)) : (t2 = i2.redMul(u2).redMul(s2.redSub(a2)), r2 = this.curve._mulC(c2).redMul(u2)), this.curve.point(d2, t2, r2);
    }, Py.prototype.add = function(e2) {
      return this.isInfinity() ? e2 : e2.isInfinity() ? this : this.curve.extended ? this._extAdd(e2) : this._projAdd(e2);
    }, Py.prototype.mul = function(e2) {
      return this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve._wnafMul(this, e2);
    }, Py.prototype.mulAdd = function(e2, t2, r2) {
      return this.curve._wnafMulAdd(1, [this, t2], [e2, r2], 2, false);
    }, Py.prototype.jmulAdd = function(e2, t2, r2) {
      return this.curve._wnafMulAdd(1, [this, t2], [e2, r2], 2, true);
    }, Py.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e2 = this.z.redInvm();
      return this.x = this.x.redMul(e2), this.y = this.y.redMul(e2), this.t && (this.t = this.t.redMul(e2)), this.z = this.curve.one, this.zOne = true, this;
    }, Py.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, Py.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    }, Py.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    }, Py.prototype.eq = function(e2) {
      return this === e2 || 0 === this.getX().cmp(e2.getX()) && 0 === this.getY().cmp(e2.getY());
    }, Py.prototype.eqXToP = function(e2) {
      var t2 = e2.toRed(this.curve.red).redMul(this.z);
      if (0 === this.x.cmp(t2))
        return true;
      for (var r2 = e2.clone(), i2 = this.curve.redN.redMul(this.z); ; ) {
        if (r2.iadd(this.curve.n), r2.cmp(this.curve.p) >= 0)
          return false;
        if (t2.redIAdd(i2), 0 === this.x.cmp(t2))
          return true;
      }
    }, Py.prototype.toP = Py.prototype.normalize, Py.prototype.mixedAdd = Py.prototype.add;
    var xy = mt(function(e2, t2) {
      var r2 = t2;
      r2.base = ly, r2.short = gy, r2.mont = _y, r2.edwards = Ey;
    });
    var My = Ct.rotl32;
    var Ky = Ct.sum32;
    var Cy = Ct.sum32_5;
    var Dy = Ft.ft_1;
    var Uy = Rt.BlockHash;
    var Ry = [1518500249, 1859775393, 2400959708, 3395469782];
    function Iy() {
      if (!(this instanceof Iy))
        return new Iy();
      Uy.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = Array(80);
    }
    Ct.inherits(Iy, Uy);
    var By = Iy;
    Iy.blockSize = 512, Iy.outSize = 160, Iy.hmacStrength = 80, Iy.padLength = 64, Iy.prototype._update = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 16; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2++)
        r2[i2] = My(r2[i2 - 3] ^ r2[i2 - 8] ^ r2[i2 - 14] ^ r2[i2 - 16], 1);
      var n2 = this.h[0], a2 = this.h[1], s2 = this.h[2], o2 = this.h[3], c2 = this.h[4];
      for (i2 = 0; i2 < r2.length; i2++) {
        var u2 = ~~(i2 / 20), h2 = Cy(My(n2, 5), Dy(u2, a2, s2, o2), c2, r2[i2], Ry[u2]);
        c2 = o2, o2 = s2, s2 = My(a2, 30), a2 = n2, n2 = h2;
      }
      this.h[0] = Ky(this.h[0], n2), this.h[1] = Ky(this.h[1], a2), this.h[2] = Ky(this.h[2], s2), this.h[3] = Ky(this.h[3], o2), this.h[4] = Ky(this.h[4], c2);
    }, Iy.prototype._digest = function(e2) {
      return "hex" === e2 ? Ct.toHex32(this.h, "big") : Ct.split32(this.h, "big");
    };
    var Ty = { sha1: By, sha224: er, sha256: Qt, sha384: Kr, sha512: yr };
    function zy(e2, t2, r2) {
      if (!(this instanceof zy))
        return new zy(e2, t2, r2);
      this.Hash = e2, this.blockSize = e2.blockSize / 8, this.outSize = e2.outSize / 8, this.inner = null, this.outer = null, this._init(Ct.toArray(t2, r2));
    }
    var qy = zy;
    zy.prototype._init = function(e2) {
      e2.length > this.blockSize && (e2 = new this.Hash().update(e2).digest()), yt(e2.length <= this.blockSize);
      for (var t2 = e2.length; t2 < this.blockSize; t2++)
        e2.push(0);
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] ^= 54;
      for (this.inner = new this.Hash().update(e2), t2 = 0; t2 < e2.length; t2++)
        e2[t2] ^= 106;
      this.outer = new this.Hash().update(e2);
    }, zy.prototype.update = function(e2, t2) {
      return this.inner.update(e2, t2), this;
    }, zy.prototype.digest = function(e2) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e2);
    };
    var Fy = mt(function(e2, t2) {
      var r2 = t2;
      r2.utils = Ct, r2.common = Rt, r2.sha = Ty, r2.ripemd = Hr, r2.hmac = qy, r2.sha1 = r2.sha.sha1, r2.sha256 = r2.sha.sha256, r2.sha224 = r2.sha.sha224, r2.sha384 = r2.sha.sha384, r2.sha512 = r2.sha.sha512, r2.ripemd160 = r2.ripemd.ripemd160;
    });
    var Oy = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    var Ly = mt(function(e2, t2) {
      var r2, i2 = t2, n2 = ny.assert;
      function a2(e3) {
        if ("short" === e3.type)
          this.curve = new xy.short(e3);
        else if ("edwards" === e3.type)
          this.curve = new xy.edwards(e3);
        else {
          if ("mont" !== e3.type)
            throw Error("Unknown curve type.");
          this.curve = new xy.mont(e3);
        }
        this.g = this.curve.g, this.n = this.curve.n, this.hash = e3.hash, n2(this.g.validate(), "Invalid curve"), n2(this.g.mul(this.n).isInfinity(), "Invalid curve, n*G != O");
      }
      function s2(e3, t3) {
        Object.defineProperty(i2, e3, { configurable: true, enumerable: true, get: function() {
          var r3 = new a2(t3);
          return Object.defineProperty(i2, e3, { configurable: true, enumerable: true, value: r3 }), r3;
        } });
      }
      i2.PresetCurve = a2, s2("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Fy.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), s2("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Fy.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), s2("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Fy.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), s2("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Fy.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), s2("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Fy.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), s2("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", cofactor: "8", hash: Fy.sha256, gRed: false, g: ["9"] }), s2("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", cofactor: "8", hash: Fy.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] }), s2("brainpoolP256r1", { type: "short", prime: null, p: "A9FB57DB A1EEA9BC 3E660A90 9D838D72 6E3BF623 D5262028 2013481D 1F6E5377", a: "7D5A0975 FC2C3057 EEF67530 417AFFE7 FB8055C1 26DC5C6C E94A4B44 F330B5D9", b: "26DC5C6C E94A4B44 F330B5D9 BBD77CBF 95841629 5CF7E1CE 6BCCDC18 FF8C07B6", n: "A9FB57DB A1EEA9BC 3E660A90 9D838D71 8C397AA3 B561A6F7 901E0E82 974856A7", hash: Fy.sha256, gRed: false, g: ["8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262", "547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997"] }), s2("brainpoolP384r1", { type: "short", prime: null, p: "8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B4 12B1DA19 7FB71123ACD3A729 901D1A71 87470013 3107EC53", a: "7BC382C6 3D8C150C 3C72080A CE05AFA0 C2BEA28E 4FB22787 139165EF BA91F90F8AA5814A 503AD4EB 04A8C7DD 22CE2826", b: "04A8C7DD 22CE2826 8B39B554 16F0447C 2FB77DE1 07DCD2A6 2E880EA5 3EEB62D57CB43902 95DBC994 3AB78696 FA504C11", n: "8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B3 1F166E6C AC0425A7CF3AB6AF 6B7FC310 3B883202 E9046565", hash: Fy.sha384, gRed: false, g: ["1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E", "8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315"] }), s2("brainpoolP512r1", { type: "short", prime: null, p: "AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 703308717D4D9B00 9BC66842 AECDA12A E6A380E6 2881FF2F 2D82C685 28AA6056 583A48F3", a: "7830A331 8B603B89 E2327145 AC234CC5 94CBDD8D 3DF91610 A83441CA EA9863BC2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A7 2BF2C7B9 E7C1AC4D 77FC94CA", b: "3DF91610 A83441CA EA9863BC 2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A72BF2C7B9 E7C1AC4D 77FC94CA DC083E67 984050B7 5EBAE5DD 2809BD63 8016F723", n: "AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 70330870553E5C41 4CA92619 41866119 7FAC1047 1DB1D381 085DDADD B5879682 9CA90069", hash: Fy.sha512, gRed: false, g: ["81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822", "7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892"] });
      try {
        r2 = Oy;
      } catch (e3) {
        r2 = void 0;
      }
      s2("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Fy.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", r2] });
    });
    function Ny(e2) {
      if (!(this instanceof Ny))
        return new Ny(e2);
      this.hash = e2.hash, this.predResist = !!e2.predResist, this.outLen = this.hash.outSize, this.minEntropy = e2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var t2 = iy.toArray(e2.entropy, e2.entropyEnc || "hex"), r2 = iy.toArray(e2.nonce, e2.nonceEnc || "hex"), i2 = iy.toArray(e2.pers, e2.persEnc || "hex");
      yt(t2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t2, r2, i2);
    }
    var jy = Ny;
    Ny.prototype._init = function(e2, t2, r2) {
      var i2 = e2.concat(t2).concat(r2);
      this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
      for (var n2 = 0; n2 < this.V.length; n2++)
        this.K[n2] = 0, this.V[n2] = 1;
      this._update(i2), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, Ny.prototype._hmac = function() {
      return new Fy.hmac(this.hash, this.K);
    }, Ny.prototype._update = function(e2) {
      var t2 = this._hmac().update(this.V).update([0]);
      e2 && (t2 = t2.update(e2)), this.K = t2.digest(), this.V = this._hmac().update(this.V).digest(), e2 && (this.K = this._hmac().update(this.V).update([1]).update(e2).digest(), this.V = this._hmac().update(this.V).digest());
    }, Ny.prototype.reseed = function(e2, t2, r2, i2) {
      "string" != typeof t2 && (i2 = r2, r2 = t2, t2 = null), e2 = iy.toArray(e2, t2), r2 = iy.toArray(r2, i2), yt(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e2.concat(r2 || [])), this._reseed = 1;
    }, Ny.prototype.generate = function(e2, t2, r2, i2) {
      if (this._reseed > this.reseedInterval)
        throw Error("Reseed is required");
      "string" != typeof t2 && (i2 = r2, r2 = t2, t2 = null), r2 && (r2 = iy.toArray(r2, i2 || "hex"), this._update(r2));
      for (var n2 = []; n2.length < e2; )
        this.V = this._hmac().update(this.V).digest(), n2 = n2.concat(this.V);
      var a2 = n2.slice(0, e2);
      return this._update(r2), this._reseed++, iy.encode(a2, t2);
    };
    var Hy = ny.assert;
    function Wy(e2, t2) {
      this.ec = e2, this.priv = null, this.pub = null, t2.priv && this._importPrivate(t2.priv, t2.privEnc), t2.pub && this._importPublic(t2.pub, t2.pubEnc);
    }
    var Gy = Wy;
    Wy.fromPublic = function(e2, t2, r2) {
      return t2 instanceof Wy ? t2 : new Wy(e2, { pub: t2, pubEnc: r2 });
    }, Wy.fromPrivate = function(e2, t2, r2) {
      return t2 instanceof Wy ? t2 : new Wy(e2, { priv: t2, privEnc: r2 });
    }, Wy.prototype.validate = function() {
      var e2 = this.getPublic();
      return e2.isInfinity() ? { result: false, reason: "Invalid public key" } : e2.validate() ? e2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    }, Wy.prototype.getPublic = function(e2, t2) {
      return this.pub || (this.pub = this.ec.g.mul(this.priv)), e2 ? this.pub.encode(e2, t2) : this.pub;
    }, Wy.prototype.getPrivate = function(e2) {
      return "hex" === e2 ? this.priv.toString(16, 2) : this.priv;
    }, Wy.prototype._importPrivate = function(e2, t2) {
      if (this.priv = new Qp(e2, t2 || 16), "mont" === this.ec.curve.type) {
        var r2 = this.ec.curve.one, i2 = r2.ushln(252).sub(r2).ushln(3);
        this.priv = this.priv.or(r2.ushln(254)), this.priv = this.priv.and(i2);
      } else
        this.priv = this.priv.umod(this.ec.curve.n);
    }, Wy.prototype._importPublic = function(e2, t2) {
      if (e2.x || e2.y)
        return "mont" === this.ec.curve.type ? Hy(e2.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || Hy(e2.x && e2.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(e2.x, e2.y));
      this.pub = this.ec.curve.decodePoint(e2, t2);
    }, Wy.prototype.derive = function(e2) {
      return e2.mul(this.priv).getX();
    }, Wy.prototype.sign = function(e2, t2, r2) {
      return this.ec.sign(e2, this, t2, r2);
    }, Wy.prototype.verify = function(e2, t2) {
      return this.ec.verify(e2, t2, this);
    }, Wy.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    var Vy = ny.assert;
    function $y(e2, t2) {
      if (e2 instanceof $y)
        return e2;
      this._importDER(e2, t2) || (Vy(e2.r && e2.s, "Signature without r or s"), this.r = new Qp(e2.r, 16), this.s = new Qp(e2.s, 16), void 0 === e2.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e2.recoveryParam);
    }
    var Zy = $y;
    function Xy() {
      this.place = 0;
    }
    function Yy(e2, t2) {
      var r2 = e2[t2.place++];
      if (!(128 & r2))
        return r2;
      for (var i2 = 15 & r2, n2 = 0, a2 = 0, s2 = t2.place; a2 < i2; a2++, s2++)
        n2 <<= 8, n2 |= e2[s2];
      return t2.place = s2, n2;
    }
    function Qy(e2) {
      for (var t2 = 0, r2 = e2.length - 1; !e2[t2] && !(128 & e2[t2 + 1]) && t2 < r2; )
        t2++;
      return 0 === t2 ? e2 : e2.slice(t2);
    }
    function Jy(e2, t2) {
      if (t2 < 128)
        e2.push(t2);
      else {
        var r2 = 1 + (Math.log(t2) / Math.LN2 >>> 3);
        for (e2.push(128 | r2); --r2; )
          e2.push(t2 >>> (r2 << 3) & 255);
        e2.push(t2);
      }
    }
    $y.prototype._importDER = function(e2, t2) {
      e2 = ny.toArray(e2, t2);
      var r2 = new Xy();
      if (48 !== e2[r2.place++])
        return false;
      if (Yy(e2, r2) + r2.place !== e2.length)
        return false;
      if (2 !== e2[r2.place++])
        return false;
      var i2 = Yy(e2, r2), n2 = e2.slice(r2.place, i2 + r2.place);
      if (r2.place += i2, 2 !== e2[r2.place++])
        return false;
      var a2 = Yy(e2, r2);
      if (e2.length !== a2 + r2.place)
        return false;
      var s2 = e2.slice(r2.place, a2 + r2.place);
      return 0 === n2[0] && 128 & n2[1] && (n2 = n2.slice(1)), 0 === s2[0] && 128 & s2[1] && (s2 = s2.slice(1)), this.r = new Qp(n2), this.s = new Qp(s2), this.recoveryParam = null, true;
    }, $y.prototype.toDER = function(e2) {
      var t2 = this.r.toArray(), r2 = this.s.toArray();
      for (128 & t2[0] && (t2 = [0].concat(t2)), 128 & r2[0] && (r2 = [0].concat(r2)), t2 = Qy(t2), r2 = Qy(r2); !(r2[0] || 128 & r2[1]); )
        r2 = r2.slice(1);
      var i2 = [2];
      Jy(i2, t2.length), (i2 = i2.concat(t2)).push(2), Jy(i2, r2.length);
      var n2 = i2.concat(r2), a2 = [48];
      return Jy(a2, n2.length), a2 = a2.concat(n2), ny.encode(a2, e2);
    };
    var eb = ny.assert;
    function tb(e2) {
      if (!(this instanceof tb))
        return new tb(e2);
      "string" == typeof e2 && (eb(Ly.hasOwnProperty(e2), "Unknown curve " + e2), e2 = Ly[e2]), e2 instanceof Ly.PresetCurve && (e2 = { curve: e2 }), this.curve = e2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e2.curve.g, this.g.precompute(e2.curve.n.bitLength() + 1), this.hash = e2.hash || e2.curve.hash;
    }
    var rb = tb;
    tb.prototype.keyPair = function(e2) {
      return new Gy(this, e2);
    }, tb.prototype.keyFromPrivate = function(e2, t2) {
      return Gy.fromPrivate(this, e2, t2);
    }, tb.prototype.keyFromPublic = function(e2, t2) {
      return Gy.fromPublic(this, e2, t2);
    }, tb.prototype.genKeyPair = function(e2) {
      e2 || (e2 = {});
      var t2 = new jy({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || ay(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.n.toArray() });
      if ("mont" === this.curve.type) {
        var r2 = new Qp(t2.generate(32));
        return this.keyFromPrivate(r2);
      }
      for (var i2 = this.n.byteLength(), n2 = this.n.sub(new Qp(2)); ; ) {
        if (!((r2 = new Qp(t2.generate(i2))).cmp(n2) > 0))
          return r2.iaddn(1), this.keyFromPrivate(r2);
      }
    }, tb.prototype._truncateToN = function(e2, t2, r2) {
      var i2 = (r2 = r2 || 8 * e2.byteLength()) - this.n.bitLength();
      return i2 > 0 && (e2 = e2.ushrn(i2)), !t2 && e2.cmp(this.n) >= 0 ? e2.sub(this.n) : e2;
    }, tb.prototype.truncateMsg = function(e2) {
      var t2;
      return e2 instanceof Uint8Array ? (t2 = 8 * e2.byteLength, e2 = this._truncateToN(new Qp(e2, 16), false, t2)) : "string" == typeof e2 ? (t2 = 4 * e2.length, e2 = this._truncateToN(new Qp(e2, 16), false, t2)) : e2 = this._truncateToN(new Qp(e2, 16)), e2;
    }, tb.prototype.sign = function(e2, t2, r2, i2) {
      "object" == typeof r2 && (i2 = r2, r2 = null), i2 || (i2 = {}), t2 = this.keyFromPrivate(t2, r2), e2 = this.truncateMsg(e2);
      for (var n2 = this.n.byteLength(), a2 = t2.getPrivate().toArray("be", n2), s2 = e2.toArray("be", n2), o2 = new jy({ hash: this.hash, entropy: a2, nonce: s2, pers: i2.pers, persEnc: i2.persEnc || "utf8" }), c2 = this.n.sub(new Qp(1)), u2 = 0; ; u2++) {
        var h2 = i2.k ? i2.k(u2) : new Qp(o2.generate(this.n.byteLength()));
        if (!((h2 = this._truncateToN(h2, true)).cmpn(1) <= 0 || h2.cmp(c2) >= 0)) {
          var d2 = this.g.mul(h2);
          if (!d2.isInfinity()) {
            var f2 = d2.getX(), l2 = f2.umod(this.n);
            if (0 !== l2.cmpn(0)) {
              var p2 = h2.invm(this.n).mul(l2.mul(t2.getPrivate()).iadd(e2));
              if (0 !== (p2 = p2.umod(this.n)).cmpn(0)) {
                var y2 = (d2.getY().isOdd() ? 1 : 0) | (0 !== f2.cmp(l2) ? 2 : 0);
                return i2.canonical && p2.cmp(this.nh) > 0 && (p2 = this.n.sub(p2), y2 ^= 1), new Zy({ r: l2, s: p2, recoveryParam: y2 });
              }
            }
          }
        }
      }
    }, tb.prototype.verify = function(e2, t2, r2, i2) {
      return r2 = this.keyFromPublic(r2, i2), t2 = new Zy(t2, "hex"), this._verify(this.truncateMsg(e2), t2, r2) || this._verify(this._truncateToN(new Qp(e2, 16)), t2, r2);
    }, tb.prototype._verify = function(e2, t2, r2) {
      var i2 = t2.r, n2 = t2.s;
      if (i2.cmpn(1) < 0 || i2.cmp(this.n) >= 0)
        return false;
      if (n2.cmpn(1) < 0 || n2.cmp(this.n) >= 0)
        return false;
      var a2, s2 = n2.invm(this.n), o2 = s2.mul(e2).umod(this.n), c2 = s2.mul(i2).umod(this.n);
      return this.curve._maxwellTrick ? !(a2 = this.g.jmulAdd(o2, r2.getPublic(), c2)).isInfinity() && a2.eqXToP(i2) : !(a2 = this.g.mulAdd(o2, r2.getPublic(), c2)).isInfinity() && 0 === a2.getX().umod(this.n).cmp(i2);
    }, tb.prototype.recoverPubKey = function(e2, t2, r2, i2) {
      eb((3 & r2) === r2, "The recovery param is more than two bits"), t2 = new Zy(t2, i2);
      var n2 = this.n, a2 = new Qp(e2), s2 = t2.r, o2 = t2.s, c2 = 1 & r2, u2 = r2 >> 1;
      if (s2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u2)
        throw Error("Unable to find sencond key candinate");
      s2 = u2 ? this.curve.pointFromX(s2.add(this.curve.n), c2) : this.curve.pointFromX(s2, c2);
      var h2 = t2.r.invm(n2), d2 = n2.sub(a2).mul(h2).umod(n2), f2 = o2.mul(h2).umod(n2);
      return this.g.mulAdd(d2, s2, f2);
    }, tb.prototype.getKeyRecoveryParam = function(e2, t2, r2, i2) {
      if (null !== (t2 = new Zy(t2, i2)).recoveryParam)
        return t2.recoveryParam;
      for (var n2 = 0; n2 < 4; n2++) {
        var a2;
        try {
          a2 = this.recoverPubKey(e2, t2, n2);
        } catch (e3) {
          continue;
        }
        if (a2.eq(r2))
          return n2;
      }
      throw Error("Unable to find valid recovery factor");
    };
    var ib = ny.assert;
    var nb = ny.parseBytes;
    var ab = ny.cachedProperty;
    function sb(e2, t2) {
      if (this.eddsa = e2, t2.hasOwnProperty("secret") && (this._secret = nb(t2.secret)), e2.isPoint(t2.pub))
        this._pub = t2.pub;
      else if (this._pubBytes = nb(t2.pub), this._pubBytes && 33 === this._pubBytes.length && 64 === this._pubBytes[0] && (this._pubBytes = this._pubBytes.slice(1, 33)), this._pubBytes && 32 !== this._pubBytes.length)
        throw Error("Unknown point compression format");
    }
    sb.fromPublic = function(e2, t2) {
      return t2 instanceof sb ? t2 : new sb(e2, { pub: t2 });
    }, sb.fromSecret = function(e2, t2) {
      return t2 instanceof sb ? t2 : new sb(e2, { secret: t2 });
    }, sb.prototype.secret = function() {
      return this._secret;
    }, ab(sb, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    }), ab(sb, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), ab(sb, "privBytes", function() {
      var e2 = this.eddsa, t2 = this.hash(), r2 = e2.encodingLength - 1, i2 = t2.slice(0, e2.encodingLength);
      return i2[0] &= 248, i2[r2] &= 127, i2[r2] |= 64, i2;
    }), ab(sb, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    }), ab(sb, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    }), ab(sb, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    }), sb.prototype.sign = function(e2) {
      return ib(this._secret, "KeyPair can only verify"), this.eddsa.sign(e2, this);
    }, sb.prototype.verify = function(e2, t2) {
      return this.eddsa.verify(e2, t2, this);
    }, sb.prototype.getSecret = function(e2) {
      return ib(this._secret, "KeyPair is public only"), ny.encode(this.secret(), e2);
    }, sb.prototype.getPublic = function(e2, t2) {
      return ny.encode((t2 ? [64] : []).concat(this.pubBytes()), e2);
    };
    var ob = sb;
    var cb = ny.assert;
    var ub = ny.cachedProperty;
    var hb = ny.parseBytes;
    function db(e2, t2) {
      this.eddsa = e2, "object" != typeof t2 && (t2 = hb(t2)), Array.isArray(t2) && (t2 = { R: t2.slice(0, e2.encodingLength), S: t2.slice(e2.encodingLength) }), cb(t2.R && t2.S, "Signature without R or S"), e2.isPoint(t2.R) && (this._R = t2.R), t2.S instanceof Qp && (this._S = t2.S), this._Rencoded = Array.isArray(t2.R) ? t2.R : t2.Rencoded, this._Sencoded = Array.isArray(t2.S) ? t2.S : t2.Sencoded;
    }
    ub(db, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    }), ub(db, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    }), ub(db, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    }), ub(db, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    }), db.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    }, db.prototype.toHex = function() {
      return ny.encode(this.toBytes(), "hex").toUpperCase();
    };
    var fb = db;
    var lb = ny.assert;
    var pb = ny.parseBytes;
    function yb(e2) {
      if (lb("ed25519" === e2, "only tested with ed25519 so far"), !(this instanceof yb))
        return new yb(e2);
      e2 = Ly[e2].curve;
      this.curve = e2, this.g = e2.g, this.g.precompute(e2.n.bitLength() + 1), this.pointClass = e2.point().constructor, this.encodingLength = Math.ceil(e2.n.bitLength() / 8), this.hash = Fy.sha512;
    }
    var bb = yb;
    yb.prototype.sign = function(e2, t2) {
      e2 = pb(e2);
      var r2 = this.keyFromSecret(t2), i2 = this.hashInt(r2.messagePrefix(), e2), n2 = this.g.mul(i2), a2 = this.encodePoint(n2), s2 = this.hashInt(a2, r2.pubBytes(), e2).mul(r2.priv()), o2 = i2.add(s2).umod(this.curve.n);
      return this.makeSignature({ R: n2, S: o2, Rencoded: a2 });
    }, yb.prototype.verify = function(e2, t2, r2) {
      e2 = pb(e2), t2 = this.makeSignature(t2);
      var i2 = this.keyFromPublic(r2), n2 = this.hashInt(t2.Rencoded(), i2.pubBytes(), e2), a2 = this.g.mul(t2.S());
      return t2.R().add(i2.pub().mul(n2)).eq(a2);
    }, yb.prototype.hashInt = function() {
      for (var e2 = this.hash(), t2 = 0; t2 < arguments.length; t2++)
        e2.update(arguments[t2]);
      return ny.intFromLE(e2.digest()).umod(this.curve.n);
    }, yb.prototype.keyPair = function(e2) {
      return new ob(this, e2);
    }, yb.prototype.keyFromPublic = function(e2) {
      return ob.fromPublic(this, e2);
    }, yb.prototype.keyFromSecret = function(e2) {
      return ob.fromSecret(this, e2);
    }, yb.prototype.genKeyPair = function(e2) {
      e2 || (e2 = {});
      var t2 = new jy({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || ay(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.curve.n.toArray() });
      return this.keyFromSecret(t2.generate(32));
    }, yb.prototype.makeSignature = function(e2) {
      return e2 instanceof fb ? e2 : new fb(this, e2);
    }, yb.prototype.encodePoint = function(e2) {
      var t2 = e2.getY().toArray("le", this.encodingLength);
      return t2[this.encodingLength - 1] |= e2.getX().isOdd() ? 128 : 0, t2;
    }, yb.prototype.decodePoint = function(e2) {
      var t2 = (e2 = ny.parseBytes(e2)).length - 1, r2 = e2.slice(0, t2).concat(-129 & e2[t2]), i2 = 0 != (128 & e2[t2]), n2 = ny.intFromLE(r2);
      return this.curve.pointFromY(n2, i2);
    }, yb.prototype.encodeInt = function(e2) {
      return e2.toArray("le", this.encodingLength);
    }, yb.prototype.decodeInt = function(e2) {
      return ny.intFromLE(e2);
    }, yb.prototype.isPoint = function(e2) {
      return e2 instanceof this.pointClass;
    };
    var gb = mt(function(e2, t2) {
      var r2 = t2;
      r2.utils = ny, r2.rand = ay, r2.curve = xy, r2.curves = Ly, r2.ec = rb, r2.eddsa = bb;
    });
    var mb = /* @__PURE__ */ Object.freeze({ __proto__: null, default: gb, __moduleExports: gb });
    exports2.AEADEncryptedDataPacket = Nu, exports2.CleartextMessage = Fh, exports2.CompressedDataPacket = Du, exports2.LiteralDataPacket = ku, exports2.MarkerPacket = class {
      static get tag() {
        return ue.packet.marker;
      }
      read(e2) {
        return 80 === e2[0] && 71 === e2[1] && 80 === e2[2];
      }
      write() {
        return new Uint8Array([80, 71, 80]);
      }
    }, exports2.Message = Bh, exports2.OnePassSignaturePacket = xu, exports2.PacketList = Ku, exports2.PrivateKey = Mh, exports2.PublicKey = xh, exports2.PublicKeyEncryptedSessionKeyPacket = ju, exports2.PublicKeyPacket = Vu, exports2.PublicSubkeyPacket = Xu, exports2.SecretKeyPacket = Qu, exports2.SecretSubkeyPacket = rh, exports2.Signature = nh, exports2.SignaturePacket = Eu, exports2.Subkey = kh, exports2.SymEncryptedIntegrityProtectedDataPacket = Ou, exports2.SymEncryptedSessionKeyPacket = Gu, exports2.SymmetricallyEncryptedDataPacket = Zu, exports2.TrustPacket = class {
      static get tag() {
        return ue.packet.trust;
      }
      read() {
        throw new Un("Trust packets are not supported");
      }
      write() {
        throw new Un("Trust packets are not supported");
      }
    }, exports2.UnparseablePacket = Rn, exports2.UserAttributePacket = Yu, exports2.UserIDPacket = th, exports2.armor = Me, exports2.config = we, exports2.createCleartextMessage = async function({ text: e2, ...t2 }) {
      if (!e2)
        throw Error("createCleartextMessage: must pass options object containing `text`");
      if (!de.isString(e2))
        throw Error("createCleartextMessage: options.text must be a string");
      const r2 = Object.keys(t2);
      if (r2.length > 0)
        throw Error("Unknown option: " + r2.join(", "));
      return new Fh(e2);
    }, exports2.createMessage = async function({ text: e2, binary: t2, filename: r2, date: i2 = /* @__PURE__ */ new Date(), format: n2 = void 0 !== e2 ? "utf8" : "binary", ...a2 }) {
      let s2 = void 0 !== e2 ? e2 : t2;
      if (void 0 === s2)
        throw Error("createMessage: must pass options object containing `text` or `binary`");
      if (e2 && !de.isString(e2) && !de.isStream(e2))
        throw Error("createMessage: options.text must be a string or stream");
      if (t2 && !de.isUint8Array(t2) && !de.isStream(t2))
        throw Error("createMessage: options.binary must be a Uint8Array or stream");
      const o2 = Object.keys(a2);
      if (o2.length > 0)
        throw Error("Unknown option: " + o2.join(", "));
      const c2 = de.isStream(s2);
      c2 && (await O(), s2 = N(s2));
      const u2 = new ku(i2);
      void 0 !== e2 ? u2.setText(s2, ue.write(ue.literal, n2)) : u2.setBytes(s2, ue.write(ue.literal, n2)), void 0 !== r2 && u2.setFilename(r2);
      const h2 = new Ku();
      h2.push(u2);
      const d2 = new Bh(h2);
      return d2.fromStream = c2, d2;
    }, exports2.decrypt = async function({ message: e2, decryptionKeys: t2, passwords: r2, sessionKeys: i2, verificationKeys: n2, expectSigned: a2 = false, format: s2 = "utf8", signature: o2 = null, date: c2 = /* @__PURE__ */ new Date(), config: u2, ...h2 }) {
      if (Hh(u2 = { ...we, ...u2 }), Oh(e2), n2 = Wh(n2), t2 = Wh(t2), r2 = Wh(r2), i2 = Wh(i2), h2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");
      if (h2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");
      const d2 = Object.keys(h2);
      if (d2.length > 0)
        throw Error("Unknown option: " + d2.join(", "));
      try {
        const h3 = await e2.decrypt(t2, r2, i2, c2, u2);
        n2 || (n2 = []);
        const d3 = {};
        if (d3.signatures = o2 ? await h3.verifyDetached(o2, n2, c2, u2) : await h3.verify(n2, c2, u2), d3.data = "binary" === s2 ? h3.getLiteralData() : h3.getText(), d3.filename = h3.getFilename(), Vh(d3, e2), a2) {
          if (0 === n2.length)
            throw Error("Verification keys are required to verify message signatures");
          if (0 === d3.signatures.length)
            throw Error("Message is not signed");
          d3.data = H([d3.data, ae(async () => {
            await de.anyPromise(d3.signatures.map((e3) => e3.verified));
          })]);
        }
        return d3.data = await Gh(d3.data, e2.fromStream, s2), d3;
      } catch (e3) {
        throw de.wrapError("Error decrypting message", e3);
      }
    }, exports2.decryptKey = async function({ privateKey: e2, passphrase: t2, config: r2, ...i2 }) {
      Hh(r2 = { ...we, ...r2 });
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      if (!e2.isPrivate())
        throw Error("Cannot decrypt a public key");
      const a2 = e2.clone(true), s2 = de.isArray(t2) ? t2 : [t2];
      try {
        return await Promise.all(a2.getKeys().map((e3) => de.anyPromise(s2.map((t3) => e3.keyPacket.decrypt(t3))))), await a2.validate(r2), a2;
      } catch (e3) {
        throw a2.clearPrivateParams(), de.wrapError("Error decrypting private key", e3);
      }
    }, exports2.decryptSessionKeys = async function({ message: e2, decryptionKeys: t2, passwords: r2, date: i2 = /* @__PURE__ */ new Date(), config: n2, ...a2 }) {
      if (Hh(n2 = { ...we, ...n2 }), Oh(e2), t2 = Wh(t2), r2 = Wh(r2), a2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");
      const s2 = Object.keys(a2);
      if (s2.length > 0)
        throw Error("Unknown option: " + s2.join(", "));
      try {
        return await e2.decryptSessionKeys(t2, r2, i2, n2);
      } catch (e3) {
        throw de.wrapError("Error decrypting session keys", e3);
      }
    }, exports2.encrypt = async function({ message: e2, encryptionKeys: t2, signingKeys: r2, passwords: i2, sessionKey: n2, format: a2 = "armored", signature: s2 = null, wildcard: o2 = false, signingKeyIDs: c2 = [], encryptionKeyIDs: u2 = [], date: h2 = /* @__PURE__ */ new Date(), signingUserIDs: d2 = [], encryptionUserIDs: f2 = [], signatureNotations: l2 = [], config: p2, ...y2 }) {
      if (Hh(p2 = { ...we, ...p2 }), Oh(e2), Nh(a2), t2 = Wh(t2), r2 = Wh(r2), i2 = Wh(i2), c2 = Wh(c2), u2 = Wh(u2), d2 = Wh(d2), f2 = Wh(f2), l2 = Wh(l2), y2.detached)
        throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");
      if (y2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");
      if (y2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");
      if (void 0 !== y2.armor)
        throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");
      const b2 = Object.keys(y2);
      if (b2.length > 0)
        throw Error("Unknown option: " + b2.join(", "));
      r2 || (r2 = []);
      const g2 = e2.fromStream;
      try {
        if ((r2.length || s2) && (e2 = await e2.sign(r2, s2, c2, h2, d2, l2, p2)), e2 = e2.compress(await dh("compression", t2, h2, f2, p2), p2), e2 = await e2.encrypt(t2, i2, n2, o2, u2, h2, f2, p2), "object" === a2)
          return e2;
        const y3 = "armored" === a2;
        return Gh(y3 ? e2.armor(p2) : e2.write(), g2, y3 ? "utf8" : "binary");
      } catch (e3) {
        throw de.wrapError("Error encrypting message", e3);
      }
    }, exports2.encryptKey = async function({ privateKey: e2, passphrase: t2, config: r2, ...i2 }) {
      Hh(r2 = { ...we, ...r2 });
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      if (!e2.isPrivate())
        throw Error("Cannot encrypt a public key");
      const a2 = e2.clone(true), s2 = a2.getKeys(), o2 = de.isArray(t2) ? t2 : Array(s2.length).fill(t2);
      if (o2.length !== s2.length)
        throw Error("Invalid number of passphrases given for key encryption");
      try {
        return await Promise.all(s2.map(async (e3, t3) => {
          const { keyPacket: i3 } = e3;
          await i3.encrypt(o2[t3], r2), i3.clearPrivateParams();
        })), a2;
      } catch (e3) {
        throw a2.clearPrivateParams(), de.wrapError("Error encrypting private key", e3);
      }
    }, exports2.encryptSessionKey = async function({ data: e2, algorithm: t2, aeadAlgorithm: r2, encryptionKeys: i2, passwords: n2, format: a2 = "armored", wildcard: s2 = false, encryptionKeyIDs: o2 = [], date: c2 = /* @__PURE__ */ new Date(), encryptionUserIDs: u2 = [], config: h2, ...d2 }) {
      if (Hh(h2 = { ...we, ...h2 }), function(e3, t3) {
        if (!de.isUint8Array(e3))
          throw Error("Parameter [" + (t3 || "data") + "] must be of type Uint8Array");
      }(e2), function(e3, t3) {
        if (!de.isString(e3))
          throw Error("Parameter [" + (t3 || "data") + "] must be of type String");
      }(t2, "algorithm"), Nh(a2), i2 = Wh(i2), n2 = Wh(n2), o2 = Wh(o2), u2 = Wh(u2), d2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");
      const f2 = Object.keys(d2);
      if (f2.length > 0)
        throw Error("Unknown option: " + f2.join(", "));
      if (!(i2 && 0 !== i2.length || n2 && 0 !== n2.length))
        throw Error("No encryption keys or passwords provided.");
      try {
        return $h(await Bh.encryptSessionKey(e2, t2, r2, i2, n2, s2, o2, c2, u2, h2), a2, h2);
      } catch (e3) {
        throw de.wrapError("Error encrypting session key", e3);
      }
    }, exports2.enums = ue, exports2.generateKey = async function({ userIDs: e2 = [], passphrase: t2, type: r2 = "ecc", rsaBits: i2 = 4096, curve: n2 = "curve25519", keyExpirationTime: a2 = 0, date: s2 = /* @__PURE__ */ new Date(), subkeys: o2 = [{}], format: c2 = "armored", config: u2, ...h2 }) {
      Hh(u2 = { ...we, ...u2 }), e2 = Wh(e2);
      const d2 = Object.keys(h2);
      if (d2.length > 0)
        throw Error("Unknown option: " + d2.join(", "));
      if (0 === e2.length)
        throw Error("UserIDs are required for key generation");
      if ("rsa" === r2 && i2 < u2.minRSABits)
        throw Error(`rsaBits should be at least ${u2.minRSABits}, got: ${i2}`);
      const f2 = { userIDs: e2, passphrase: t2, type: r2, rsaBits: i2, curve: n2, keyExpirationTime: a2, date: s2, subkeys: o2 };
      try {
        const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
          e4.sign = true, (e4 = bh(e4)).subkeys = e4.subkeys.map((t5, r4) => bh(e4.subkeys[r4], e4));
          let r3 = [sh(e4, t4)];
          r3 = r3.concat(e4.subkeys.map((e5) => ah(e5, t4)));
          const i3 = await Promise.all(r3), n3 = await Dh(i3[0], i3.slice(1), e4, t4), a3 = await n3.getRevocationCertificate(e4.date, t4);
          return n3.revocationSignatures = [], { key: n3, revocationCertificate: a3 };
        }(f2, u2);
        return e3.getKeys().forEach(({ keyPacket: e4 }) => vh(e4, u2)), { privateKey: $h(e3, c2, u2), publicKey: $h(e3.toPublic(), c2, u2), revocationCertificate: t3 };
      } catch (e3) {
        throw de.wrapError("Error generating keypair", e3);
      }
    }, exports2.generateSessionKey = async function({ encryptionKeys: e2, date: t2 = /* @__PURE__ */ new Date(), encryptionUserIDs: r2 = [], config: i2, ...n2 }) {
      if (Hh(i2 = { ...we, ...i2 }), e2 = Wh(e2), r2 = Wh(r2), n2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");
      const a2 = Object.keys(n2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      try {
        return await Bh.generateSessionKey(e2, t2, r2, i2);
      } catch (e3) {
        throw de.wrapError("Error generating session key", e3);
      }
    }, exports2.readCleartextMessage = async function({ cleartextMessage: e2, config: t2, ...r2 }) {
      if (t2 = { ...we, ...t2 }, !e2)
        throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");
      if (!de.isString(e2))
        throw Error("readCleartextMessage: options.cleartextMessage must be a string");
      const i2 = Object.keys(r2);
      if (i2.length > 0)
        throw Error("Unknown option: " + i2.join(", "));
      const n2 = await xe(e2);
      if (n2.type !== ue.armor.signed)
        throw Error("No cleartext signed message.");
      const a2 = await Ku.fromBinary(n2.data, qh, t2);
      !function(e3, t3) {
        const r3 = function(e4) {
          const r4 = (e5) => (t4) => e5.hashAlgorithm === t4;
          for (let i4 = 0; i4 < t3.length; i4++)
            if (t3[i4].constructor.tag === ue.packet.signature && !e4.some(r4(t3[i4])))
              return false;
          return true;
        };
        let i3 = null, n3 = [];
        if (e3.forEach(function(e4) {
          if (i3 = e4.match(/^Hash: (.+)$/), !i3)
            throw Error('Only "Hash" header allowed in cleartext signed message');
          i3 = i3[1].replace(/\s/g, ""), i3 = i3.split(","), i3 = i3.map(function(e5) {
            e5 = e5.toLowerCase();
            try {
              return ue.write(ue.hash, e5);
            } catch (t4) {
              throw Error("Unknown hash algorithm in armor header: " + e5);
            }
          }), n3 = n3.concat(i3);
        }), !n3.length && !r3([ue.hash.md5]))
          throw Error('If no "Hash" header in cleartext signed message, then only MD5 signatures allowed');
        if (n3.length && !r3(n3))
          throw Error("Hash algorithm mismatch in armor header and signature");
      }(n2.headers, a2);
      const s2 = new nh(a2);
      return new Fh(n2.text, s2);
    }, exports2.readKey = async function({ armoredKey: e2, binaryKey: t2, config: r2, ...i2 }) {
      if (r2 = { ...we, ...r2 }, !e2 && !t2)
        throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");
      if (e2 && !de.isString(e2))
        throw Error("readKey: options.armoredKey must be a string");
      if (t2 && !de.isUint8Array(t2))
        throw Error("readKey: options.binaryKey must be a Uint8Array");
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      let a2;
      if (e2) {
        const { type: t3, data: i3 } = await xe(e2, r2);
        if (t3 !== ue.armor.publicKey && t3 !== ue.armor.privateKey)
          throw Error("Armored text not of type key");
        a2 = i3;
      } else
        a2 = t2;
      return Ch(await Ku.fromBinary(a2, Kh, r2));
    }, exports2.readKeys = async function({ armoredKeys: e2, binaryKeys: t2, config: r2, ...i2 }) {
      r2 = { ...we, ...r2 };
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
      if (e2 && !de.isString(e2))
        throw Error("readKeys: options.armoredKeys must be a string");
      if (t2 && !de.isUint8Array(t2))
        throw Error("readKeys: options.binaryKeys must be a Uint8Array");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      if (e2) {
        const { type: t3, data: i3 } = await xe(e2, r2);
        if (t3 !== ue.armor.publicKey && t3 !== ue.armor.privateKey)
          throw Error("Armored text not of type key");
        n2 = i3;
      }
      const s2 = [], o2 = await Ku.fromBinary(n2, Kh, r2), c2 = o2.indexOfTag(ue.packet.publicKey, ue.packet.secretKey);
      if (0 === c2.length)
        throw Error("No key packet found");
      for (let e3 = 0; e3 < c2.length; e3++) {
        const t3 = Ch(o2.slice(c2[e3], c2[e3 + 1]));
        s2.push(t3);
      }
      return s2;
    }, exports2.readMessage = async function({ armoredMessage: e2, binaryMessage: t2, config: r2, ...i2 }) {
      r2 = { ...we, ...r2 };
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");
      if (e2 && !de.isString(e2) && !de.isStream(e2))
        throw Error("readMessage: options.armoredMessage must be a string or stream");
      if (t2 && !de.isUint8Array(t2) && !de.isStream(t2))
        throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      const s2 = de.isStream(n2);
      if (s2 && (await O(), n2 = N(n2)), e2) {
        const { type: e3, data: t3 } = await xe(n2, r2);
        if (e3 !== ue.armor.message)
          throw Error("Armored text not of type message");
        n2 = t3;
      }
      const o2 = await Ku.fromBinary(n2, Uh, r2), c2 = new Bh(o2);
      return c2.fromStream = s2, c2;
    }, exports2.readPrivateKey = async function({ armoredKey: e2, binaryKey: t2, config: r2, ...i2 }) {
      if (r2 = { ...we, ...r2 }, !e2 && !t2)
        throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");
      if (e2 && !de.isString(e2))
        throw Error("readPrivateKey: options.armoredKey must be a string");
      if (t2 && !de.isUint8Array(t2))
        throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      let a2;
      if (e2) {
        const { type: t3, data: i3 } = await xe(e2, r2);
        if (t3 !== ue.armor.privateKey)
          throw Error("Armored text not of type private key");
        a2 = i3;
      } else
        a2 = t2;
      const s2 = await Ku.fromBinary(a2, Kh, r2);
      return new Mh(s2);
    }, exports2.readPrivateKeys = async function({ armoredKeys: e2, binaryKeys: t2, config: r2 }) {
      r2 = { ...we, ...r2 };
      let i2 = e2 || t2;
      if (!i2)
        throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
      if (e2 && !de.isString(e2))
        throw Error("readPrivateKeys: options.armoredKeys must be a string");
      if (t2 && !de.isUint8Array(t2))
        throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");
      if (e2) {
        const { type: t3, data: n3 } = await xe(e2, r2);
        if (t3 !== ue.armor.privateKey)
          throw Error("Armored text not of type private key");
        i2 = n3;
      }
      const n2 = [], a2 = await Ku.fromBinary(i2, Kh, r2), s2 = a2.indexOfTag(ue.packet.secretKey);
      if (0 === s2.length)
        throw Error("No secret key packet found");
      for (let e3 = 0; e3 < s2.length; e3++) {
        const t3 = a2.slice(s2[e3], s2[e3 + 1]), r3 = new Mh(t3);
        n2.push(r3);
      }
      return n2;
    }, exports2.readSignature = async function({ armoredSignature: e2, binarySignature: t2, config: r2, ...i2 }) {
      r2 = { ...we, ...r2 };
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");
      if (e2 && !de.isString(e2))
        throw Error("readSignature: options.armoredSignature must be a string");
      if (t2 && !de.isUint8Array(t2))
        throw Error("readSignature: options.binarySignature must be a Uint8Array");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      if (e2) {
        const { type: e3, data: t3 } = await xe(n2, r2);
        if (e3 !== ue.armor.signature)
          throw Error("Armored text not of type signature");
        n2 = t3;
      }
      const s2 = await Ku.fromBinary(n2, ih, r2);
      return new nh(s2);
    }, exports2.reformatKey = async function({ privateKey: e2, userIDs: t2 = [], passphrase: r2, keyExpirationTime: i2 = 0, date: n2, format: a2 = "armored", config: s2, ...o2 }) {
      Hh(s2 = { ...we, ...s2 }), t2 = Wh(t2);
      const c2 = Object.keys(o2);
      if (c2.length > 0)
        throw Error("Unknown option: " + c2.join(", "));
      if (0 === t2.length)
        throw Error("UserIDs are required for key reformat");
      const u2 = { privateKey: e2, userIDs: t2, passphrase: r2, keyExpirationTime: i2, date: n2 };
      try {
        const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
          e4 = o3(e4);
          const { privateKey: r3 } = e4;
          if (!r3.isPrivate())
            throw Error("Cannot reformat a public key");
          if (r3.keyPacket.isDummy())
            throw Error("Cannot reformat a gnu-dummy primary key");
          if (!r3.getKeys().every(({ keyPacket: e5 }) => e5.isDecrypted()))
            throw Error("Key is not decrypted");
          const i3 = r3.keyPacket;
          e4.subkeys || (e4.subkeys = await Promise.all(r3.subkeys.map(async (e5) => {
            const r4 = e5.keyPacket, n4 = { key: i3, bind: r4 }, a4 = await oh(e5.bindingSignatures, i3, ue.signature.subkeyBinding, n4, null, t4).catch(() => ({}));
            return { sign: a4.keyFlags && a4.keyFlags[0] & ue.keyFlags.signData };
          })));
          const n3 = r3.subkeys.map((e5) => e5.keyPacket);
          if (e4.subkeys.length !== n3.length)
            throw Error("Number of subkey options does not match number of subkeys");
          e4.subkeys = e4.subkeys.map((t5) => o3(t5, e4));
          const a3 = await Dh(i3, n3, e4, t4), s3 = await a3.getRevocationCertificate(e4.date, t4);
          return a3.revocationSignatures = [], { key: a3, revocationCertificate: s3 };
          function o3(e5, t5 = {}) {
            return e5.keyExpirationTime = e5.keyExpirationTime || t5.keyExpirationTime, e5.passphrase = de.isString(e5.passphrase) ? e5.passphrase : t5.passphrase, e5.date = e5.date || t5.date, e5;
          }
        }(u2, s2);
        return { privateKey: $h(e3, a2, s2), publicKey: $h(e3.toPublic(), a2, s2), revocationCertificate: t3 };
      } catch (e3) {
        throw de.wrapError("Error reformatting keypair", e3);
      }
    }, exports2.revokeKey = async function({ key: e2, revocationCertificate: t2, reasonForRevocation: r2, date: i2 = /* @__PURE__ */ new Date(), format: n2 = "armored", config: a2, ...s2 }) {
      Hh(a2 = { ...we, ...a2 });
      const o2 = Object.keys(s2);
      if (o2.length > 0)
        throw Error("Unknown option: " + o2.join(", "));
      try {
        const s3 = t2 ? await e2.applyRevocationCertificate(t2, i2, a2) : await e2.revoke(r2, i2, a2);
        return s3.isPrivate() ? { privateKey: $h(s3, n2, a2), publicKey: $h(s3.toPublic(), n2, a2) } : { privateKey: null, publicKey: $h(s3, n2, a2) };
      } catch (e3) {
        throw de.wrapError("Error revoking key", e3);
      }
    }, exports2.sign = async function({ message: e2, signingKeys: t2, format: r2 = "armored", detached: i2 = false, signingKeyIDs: n2 = [], date: a2 = /* @__PURE__ */ new Date(), signingUserIDs: s2 = [], signatureNotations: o2 = [], config: c2, ...u2 }) {
      if (Hh(c2 = { ...we, ...c2 }), Lh(e2), Nh(r2), t2 = Wh(t2), n2 = Wh(n2), s2 = Wh(s2), o2 = Wh(o2), u2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");
      if (void 0 !== u2.armor)
        throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");
      const h2 = Object.keys(u2);
      if (h2.length > 0)
        throw Error("Unknown option: " + h2.join(", "));
      if (e2 instanceof Fh && "binary" === r2)
        throw Error("Cannot return signed cleartext message in binary format");
      if (e2 instanceof Fh && i2)
        throw Error("Cannot detach-sign a cleartext message");
      if (!t2 || 0 === t2.length)
        throw Error("No signing keys provided");
      try {
        let u3;
        if (u3 = i2 ? await e2.signDetached(t2, void 0, n2, a2, s2, o2, c2) : await e2.sign(t2, void 0, n2, a2, s2, o2, c2), "object" === r2)
          return u3;
        const h3 = "armored" === r2;
        return u3 = h3 ? u3.armor(c2) : u3.write(), i2 && (u3 = Y(e2.packets.write(), async (e3, t3) => {
          await Promise.all([V(u3, t3), ie(e3).catch(() => {
          })]);
        })), Gh(u3, e2.fromStream, h3 ? "utf8" : "binary");
      } catch (e3) {
        throw de.wrapError("Error signing message", e3);
      }
    }, exports2.unarmor = xe, exports2.verify = async function({ message: e2, verificationKeys: t2, expectSigned: r2 = false, format: i2 = "utf8", signature: n2 = null, date: a2 = /* @__PURE__ */ new Date(), config: s2, ...o2 }) {
      if (Hh(s2 = { ...we, ...s2 }), Lh(e2), t2 = Wh(t2), o2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");
      const c2 = Object.keys(o2);
      if (c2.length > 0)
        throw Error("Unknown option: " + c2.join(", "));
      if (e2 instanceof Fh && "binary" === i2)
        throw Error("Can't return cleartext message data as binary");
      if (e2 instanceof Fh && n2)
        throw Error("Can't verify detached cleartext signature");
      try {
        const o3 = {};
        if (o3.signatures = n2 ? await e2.verifyDetached(n2, t2, a2, s2) : await e2.verify(t2, a2, s2), o3.data = "binary" === i2 ? e2.getLiteralData() : e2.getText(), e2.fromStream && Vh(o3, e2), r2) {
          if (0 === o3.signatures.length)
            throw Error("Message is not signed");
          o3.data = H([o3.data, ae(async () => {
            await de.anyPromise(o3.signatures.map((e3) => e3.verified));
          })]);
        }
        return o3.data = await Gh(o3.data, e2.fromStream, i2), o3;
      } catch (e3) {
        throw de.wrapError("Error verifying signed message", e3);
      }
    };
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/constants.js
var require_constants6 = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/constants.js"(exports2, module2) {
    "use strict";
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module2.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/debug.js"(exports2, module2) {
    "use strict";
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug2;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/re.js"(exports2, module2) {
    "use strict";
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants6();
    var debug2 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = (value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    };
    var createToken = (name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug2(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    "use strict";
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = (options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    };
    module2.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    "use strict";
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/semver.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/semver.js"(exports2, module2) {
    "use strict";
    var debug2 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants6();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      constructor(version2, options) {
        options = parseOptions(options);
        if (version2 instanceof _SemVer) {
          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version2}".`);
        }
        if (version2.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug2("SemVer", version2, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release, identifier, identifierBase) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/parse.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var parse2 = (version2, options, throwErrors = false) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    };
    module2.exports = parse2;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/valid.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse2();
    var valid = (version2, options) => {
      const v = parse2(version2, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/clean.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse2();
    var clean = (version2, options) => {
      const s = parse2(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/inc.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var inc = (version2, release, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version2 instanceof SemVer ? version2.version : version2,
          options
        ).inc(release, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/diff.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse2();
    var diff = (version1, version2) => {
      const v12 = parse2(version1, null, true);
      const v2 = parse2(version2, null, true);
      const comparison = v12.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v12 : v2;
      const lowVersion = v1Higher ? v2 : v12;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v12.major !== v2.major) {
        return prefix + "major";
      }
      if (v12.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v12.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    };
    module2.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/major.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/minor.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/patch.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    "use strict";
    var parse2 = require_parse2();
    var prerelease = (version2, options) => {
      const parsed = parse2(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/sort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/rsort.js"(exports2, module2) {
    "use strict";
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/gt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/lt.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/eq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/neq.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/gte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/lte.js"(exports2, module2) {
    "use strict";
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/cmp.js"(exports2, module2) {
    "use strict";
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/coerce.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var parse2 = require_parse2();
    var { safeRe: re, t } = require_re();
    var coerce = (version2, options) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version2.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/range.js"(exports2, module2) {
    "use strict";
    var Range = class _Range {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug2("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug2("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug2("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug2("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug2 = require_debug();
    var SemVer = require_semver2();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants6();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    };
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    };
    var replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug2(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/classes/comparator.js"(exports2, module2) {
    "use strict";
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug2("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug2 = require_debug();
    var SemVer = require_semver2();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var satisfies = (version2, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/valid.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/outside.js"(exports2, module2) {
    "use strict";
    var SemVer = require_semver2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range, hilo, options) => {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var gtr = (version2, range, options) => outside(version2, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    "use strict";
    var outside = require_outside();
    var ltr = (version2, range, options) => outside(version2, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    };
    module2.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    "use strict";
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version2 of v) {
        const included = satisfies(version2, range, options);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/ranges/subset.js"(exports2, module2) {
    "use strict";
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.6.0/node_modules/semver/index.js
var require_semver3 = __commonJS({
  "node_modules/.pnpm/semver@7.6.0/node_modules/semver/index.js"(exports2, module2) {
    "use strict";
    var internalRe = require_re();
    var constants = require_constants6();
    var SemVer = require_semver2();
    var identifiers = require_identifiers();
    var parse2 = require_parse2();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module2.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js"(exports2, module2) {
    "use strict";
    var Buffer3 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer3.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer3.alloc === "function" && typeof Buffer3.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer3.alloc(input) : new Buffer3(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer3.from(input) : new Buffer3(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer3.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/.pnpm/proxy-from-env@1.1.0/node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          return 1;
        }
        if (env.FORCE_COLOR === "false") {
          return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
      });
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.3.4_supports-color@8.1.1/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/.pnpm/follow-redirects@1.15.5/node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.5/node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug2;
    module2.exports = function() {
      if (!debug2) {
        try {
          debug2 = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug2 !== "function") {
          debug2 = function() {
          };
        }
      }
      debug2.apply(null, arguments);
    };
  }
});

// node_modules/.pnpm/follow-redirects@1.15.5/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.5/node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL3 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug2 = require_debug2();
    var useNativeURL = false;
    try {
      assert(new URL3());
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer2(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction2(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction2(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug2("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction2(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString2(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction2(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString2(options.host) && !isString2(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug2("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL3(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString2(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL3(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString2(subdomain) && isString2(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString2(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction2(value) {
      return typeof value === "function";
    }
    function isBuffer2(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL3 && value instanceof URL3;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/.pnpm/axios@1.6.7/node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/.pnpm/axios@1.6.7/node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var EventEmitter = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    var EventEmitter__default = /* @__PURE__ */ _interopDefaultLegacy(EventEmitter);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray: isArray2 } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString2 = typeOfTest("string");
    var isFunction2 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject2 = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject2 = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject2(val) && isFunction2(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray2(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject2(result[targetKey]) && isPlainObject2(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject2(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray2(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction2(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray2(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray2 = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty7 = (({ hasOwnProperty: hasOwnProperty8 }) => (obj, prop) => hasOwnProperty8.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction2(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray2(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray2(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject2(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch);
    var utils$1 = {
      isArray: isArray2,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isBoolean,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isTypedArray: isTypedArray2,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty: hasOwnProperty7,
      hasOwnProp: hasOwnProperty7,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.6.7";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      const threshold = 1e3 / freq;
      let timer = null;
      return function throttled(force, args) {
        const now = Date.now();
        if (force || now - timestamp > threshold) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          timestamp = now;
          return fn.apply(null, args);
        }
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            timestamp = Date.now();
            return fn.apply(null, args);
          }, threshold - (now - timestamp));
        }
      };
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const self2 = this;
        const internals = this[kInternals] = {
          length: options.length,
          timeWindow: options.timeWindow,
          ticksRate: options.ticksRate,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
        let bytesNotified = 0;
        internals.updateProgress = throttle(function throttledHandler() {
          const totalBytes = internals.length;
          const bytesTransferred = internals.bytesSeen;
          const progressBytes = bytesTransferred - bytesNotified;
          if (!progressBytes || self2.destroyed)
            return;
          const rate = _speedometer(progressBytes);
          bytesNotified = bytesTransferred;
          process.nextTick(() => {
            self2.emit("progress", {
              "loaded": bytesTransferred,
              "total": totalBytes,
              "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
              "bytes": progressBytes,
              "rate": rate ? rate : void 0,
              "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
            });
          });
        }, internals.ticksRate);
        const onFinish = () => {
          internals.updateProgress(true);
        };
        this.once("end", onFinish);
        this.once("error", onFinish);
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const self2 = this;
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        function pushChunk(_chunk, _callback) {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          if (internals.isCaptured) {
            internals.updateProgress();
          }
          if (self2.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        }
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
      setLength(length) {
        this[kInternals].length = +length;
        return this;
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = utils$1.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = new util.TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + utils$1.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from(async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      }());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv.getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone)
            return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const emitter = new EventEmitter__default["default"]();
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        };
        onDone((value, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
        });
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
        }
        emitter.once("abort", reject);
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        const parsed = new URL(fullPath, "http://localhost");
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const onDownloadProgress = config.onDownloadProgress;
        const onUploadProgress = config.onUploadProgress;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data))
            ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            length: contentLength,
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", (progress) => {
            onUploadProgress(Object.assign(progress, {
              upload: true
            }));
          });
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsRequest ? https__default["default"] : http__default["default"];
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirects.config = config.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed)
            return;
          const streams = [res];
          const responseLength = +res.headers["content-length"];
          if (onDownloadProgress) {
            const transformStream = new AxiosTransformStream$1({
              length: utils$1.toFiniteNumber(responseLength),
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", (progress) => {
              onDownloadProgress(Object.assign(progress, {
                download: true
              }));
            });
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const offListeners = stream__default["default"].finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed)
                return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone)
              return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
            abort();
          });
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    };
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url2) {
          let href = url2;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack;
            } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug2 = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug2("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug2("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug2("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug2("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug2("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug2 = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug2("onclose had error %o", err);
        }
        function onend() {
          debug2("onend");
        }
        function onerror(err) {
          cleanup();
          debug2("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug2("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug2("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug2 = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug2("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       *
       * @api protected
       */
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug2("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug2("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug2("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug2("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/.pnpm/@hashicorp+js-releases@1.7.2/node_modules/@hashicorp/js-releases/out/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@hashicorp+js-releases@1.7.2/node_modules/@hashicorp/js-releases/out/utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.request = void 0;
    var axios_1 = require_axios();
    var HttpsProxyAgent = require_dist();
    var httpProxy = process.env["HTTP_PROXY"] || process.env["http_proxy"];
    var httpsProxy = process.env["HTTPS_PROXY"] || process.env["https_proxy"];
    var proxyConf = {};
    if (httpProxy || httpsProxy) {
      proxyConf = {
        proxy: false,
        httpAgent: httpProxy ? new HttpsProxyAgent(httpProxy) : void 0,
        httpsAgent: httpsProxy ? new HttpsProxyAgent(httpsProxy) : void 0
      };
    }
    var axios = axios_1.default.create(Object.assign({}, proxyConf));
    function request(url, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield axios.get(url, Object.assign({}, options));
        return result.data;
      });
    }
    exports2.request = request;
  }
});

// node_modules/.pnpm/@hashicorp+js-releases@1.7.2/node_modules/@hashicorp/js-releases/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/@hashicorp+js-releases@1.7.2/node_modules/@hashicorp/js-releases/out/index.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRelease = exports2.Release = void 0;
    var crypto5 = require("crypto");
    var fs = require("fs");
    var openpgp = require_openpgp_min();
    var semver = require_semver3();
    var stream = require("stream");
    var yauzl = require_yauzl();
    var util_1 = require("util");
    var utils_1 = require_utils3();
    var finished = (0, util_1.promisify)(stream.finished);
    var hashiPublicKeyId = "72D7468F";
    var hashiPublicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGB9+xkBEACabYZOWKmgZsHTdRDiyPJxhbuUiKX65GUWkyRMJKi/1dviVxOX
PG6hBPtF48IFnVgxKpIb7G6NjBousAV+CuLlv5yqFKpOZEGC6sBV+Gx8Vu1CICpl
Zm+HpQPcIzwBpN+Ar4l/exCG/f/MZq/oxGgH+TyRF3XcYDjG8dbJCpHO5nQ5Cy9h
QIp3/Bh09kET6lk+4QlofNgHKVT2epV8iK1cXlbQe2tZtfCUtxk+pxvU0UHXp+AB
0xc3/gIhjZp/dePmCOyQyGPJbp5bpO4UeAJ6frqhexmNlaw9Z897ltZmRLGq1p4a
RnWL8FPkBz9SCSKXS8uNyV5oMNVn4G1obCkc106iWuKBTibffYQzq5TG8FYVJKrh
RwWB6piacEB8hl20IIWSxIM3J9tT7CPSnk5RYYCTRHgA5OOrqZhC7JefudrP8n+M
pxkDgNORDu7GCfAuisrf7dXYjLsxG4tu22DBJJC0c/IpRpXDnOuJN1Q5e/3VUKKW
mypNumuQpP5lc1ZFG64TRzb1HR6oIdHfbrVQfdiQXpvdcFx+Fl57WuUraXRV6qfb
4ZmKHX1JEwM/7tu21QE4F1dz0jroLSricZxfaCTHHWNfvGJoZ30/MZUrpSC0IfB3
iQutxbZrwIlTBt+fGLtm3vDtwMFNWM+Rb1lrOxEQd2eijdxhvBOHtlIcswARAQAB
tERIYXNoaUNvcnAgU2VjdXJpdHkgKGhhc2hpY29ycC5jb20vc2VjdXJpdHkpIDxz
ZWN1cml0eUBoYXNoaWNvcnAuY29tPokCVAQTAQoAPhYhBMh0AR8KtAURDQIQVTQ2
XZRy10aPBQJgffsZAhsDBQkJZgGABQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAAAoJ
EDQ2XZRy10aPtpcP/0PhJKiHtC1zREpRTrjGizoyk4Sl2SXpBZYhkdrG++abo6zs
buaAG7kgWWChVXBo5E20L7dbstFK7OjVs7vAg/OLgO9dPD8n2M19rpqSbbvKYWvp
0NSgvFTT7lbyDhtPj0/bzpkZEhmvQaDWGBsbDdb2dBHGitCXhGMpdP0BuuPWEix+
QnUMaPwU51q9GM2guL45Tgks9EKNnpDR6ZdCeWcqo1IDmklloidxT8aKL21UOb8t
cD+Bg8iPaAr73bW7Jh8TdcV6s6DBFub+xPJEB/0bVPmq3ZHs5B4NItroZ3r+h3ke
VDoSOSIZLl6JtVooOJ2la9ZuMqxchO3mrXLlXxVCo6cGcSuOmOdQSz4OhQE5zBxx
LuzA5ASIjASSeNZaRnffLIHmht17BPslgNPtm6ufyOk02P5XXwa69UCjA3RYrA2P
QNNC+OWZ8qQLnzGldqE4MnRNAxRxV6cFNzv14ooKf7+k686LdZrP/3fQu2p3k5rY
0xQUXKh1uwMUMtGR867ZBYaxYvwqDrg9XB7xi3N6aNyNQ+r7zI2lt65lzwG1v9hg
FG2AHrDlBkQi/t3wiTS3JOo/GCT8BjN0nJh0lGaRFtQv2cXOQGVRW8+V/9IpqEJ1
qQreftdBFWxvH7VJq2mSOXUJyRsoUrjkUuIivaA9Ocdipk2CkP8bpuGz7ZF4uQIN
BGB9+xkBEACoklYsfvWRCjOwS8TOKBTfl8myuP9V9uBNbyHufzNETbhYeT33Cj0M
GCNd9GdoaknzBQLbQVSQogA+spqVvQPz1MND18GIdtmr0BXENiZE7SRvu76jNqLp
KxYALoK2Pc3yK0JGD30HcIIgx+lOofrVPA2dfVPTj1wXvm0rbSGA4Wd4Ng3d2AoR
G/wZDAQ7sdZi1A9hhfugTFZwfqR3XAYCk+PUeoFrkJ0O7wngaon+6x2GJVedVPOs
2x/XOR4l9ytFP3o+5ILhVnsK+ESVD9AQz2fhDEU6RhvzaqtHe+sQccR3oVLoGcat
ma5rbfzH0Fhj0JtkbP7WreQf9udYgXxVJKXLQFQgel34egEGG+NlbGSPG+qHOZtY
4uWdlDSvmo+1P95P4VG/EBteqyBbDDGDGiMs6lAMg2cULrwOsbxWjsWka8y2IN3z
1stlIJFvW2kggU+bKnQ+sNQnclq3wzCJjeDBfucR3a5WRojDtGoJP6Fc3luUtS7V
5TAdOx4dhaMFU9+01OoH8ZdTRiHZ1K7RFeAIslSyd4iA/xkhOhHq89F4ECQf3Bt4
ZhGsXDTaA/VgHmf3AULbrC94O7HNqOvTWzwGiWHLfcxXQsr+ijIEQvh6rHKmJK8R
9NMHqc3L18eMO6bqrzEHW0Xoiu9W8Yj+WuB3IKdhclT3w0pO4Pj8gQARAQABiQI8
BBgBCgAmFiEEyHQBHwq0BRENAhBVNDZdlHLXRo8FAmB9+xkCGwwFCQlmAYAACgkQ
NDZdlHLXRo9ZnA/7BmdpQLeTjEiXEJyW46efxlV1f6THn9U50GWcE9tebxCXgmQf
u+Uju4hreltx6GDi/zbVVV3HCa0yaJ4JVvA4LBULJVe3ym6tXXSYaOfMdkiK6P1v
JgfpBQ/b/mWB0yuWTUtWx18BQQwlNEQWcGe8n1lBbYsH9g7QkacRNb8tKUrUbWlQ
QsU8wuFgly22m+Va1nO2N5C/eE/ZEHyN15jEQ+QwgQgPrK2wThcOMyNMQX/VNEr1
Y3bI2wHfZFjotmek3d7ZfP2VjyDudnmCPQ5xjezWpKbN1kvjO3as2yhcVKfnvQI5
P5Frj19NgMIGAp7X6pF5Csr4FX/Vw316+AFJd9Ibhfud79HAylvFydpcYbvZpScl
7zgtgaXMCVtthe3GsG4gO7IdxxEBZ/Fm4NLnmbzCIWOsPMx/FxH06a539xFq/1E2
1nYFjiKg8a5JFmYU/4mV9MQs4bP/3ip9byi10V+fEIfp5cEEmfNeVeW5E7J8PqG9
t4rLJ8FR4yJgQUa2gs2SNYsjWQuwS/MJvAv4fDKlkQjQmYRAOp1SszAnyaplvri4
ncmfDsf0r65/sd6S40g5lHH8LIbGxcOIN6kwthSTPWX89r42CbY8GzjTkaeejNKx
v1aCrO58wAtursO1DiXCvBY7+NdafMRnoHwBk50iPqrVkNA8fv+auRyB2/G5Ag0E
YH3+JQEQALivllTjMolxUW2OxrXb+a2Pt6vjCBsiJzrUj0Pa63U+lT9jldbCCfgP
wDpcDuO1O05Q8k1MoYZ6HddjWnqKG7S3eqkV5c3ct3amAXp513QDKZUfIDylOmhU
qvxjEgvGjdRjz6kECFGYr6Vnj/p6AwWv4/FBRFlrq7cnQgPynbIH4hrWvewp3Tqw
GVgqm5RRofuAugi8iZQVlAiQZJo88yaztAQ/7VsXBiHTn61ugQ8bKdAsr8w/ZZU5
HScHLqRolcYg0cKN91c0EbJq9k1LUC//CakPB9mhi5+aUVUGusIM8ECShUEgSTCi
KQiJUPZ2CFbbPE9L5o9xoPCxjXoX+r7L/WyoCPTeoS3YRUMEnWKvc42Yxz3meRb+
BmaqgbheNmzOah5nMwPupJYmHrjWPkX7oyyHxLSFw4dtoP2j6Z7GdRXKa2dUYdk2
x3JYKocrDoPHh3Q0TAZujtpdjFi1BS8pbxYFb3hHmGSdvz7T7KcqP7ChC7k2RAKO
GiG7QQe4NX3sSMgweYpl4OwvQOn73t5CVWYp/gIBNZGsU3Pto8g27vHeWyH9mKr4
cSepDhw+/X8FGRNdxNfpLKm7Vc0Sm9Sof8TRFrBTqX+vIQupYHRi5QQCuYaV6OVr
ITeegNK3So4m39d6ajCR9QxRbmjnx9UcnSYYDmIB6fpBuwT0ogNtABEBAAGJBHIE
GAEKACYCGwIWIQTIdAEfCrQFEQ0CEFU0Nl2UctdGjwUCYH4bgAUJAeFQ2wJAwXQg
BBkBCgAdFiEEs2y6kaLAcwxDX8KAsLRBCXaFtnYFAmB9/iUACgkQsLRBCXaFtnYX
BhAAlxejyFXoQwyGo9U+2g9N6LUb/tNtH29RHYxy4A3/ZUY7d/FMkArmh4+dfjf0
p9MJz98Zkps20kaYP+2YzYmaizO6OA6RIddcEXQDRCPHmLts3097mJ/skx9qLAf6
rh9J7jWeSqWO6VW6Mlx8j9m7sm3Ae1OsjOx/m7lGZOhY4UYfY627+Jf7WQ5103Qs
lgQ09es/vhTCx0g34SYEmMW15Tc3eCjQ21b1MeJD/V26npeakV8iCZ1kHZHawPq/
aCCuYEcCeQOOteTWvl7HXaHMhHIx7jjOd8XX9V+UxsGz2WCIxX/j7EEEc7CAxwAN
nWp9jXeLfxYfjrUB7XQZsGCd4EHHzUyCf7iRJL7OJ3tz5Z+rOlNjSgci+ycHEccL
YeFAEV+Fz+sj7q4cFAferkr7imY1XEI0Ji5P8p/uRYw/n8uUf7LrLw5TzHmZsTSC
UaiL4llRzkDC6cVhYfqQWUXDd/r385OkE4oalNNE+n+txNRx92rpvXWZ5qFYfv7E
95fltvpXc0iOugPMzyof3lwo3Xi4WZKc1CC/jEviKTQhfn3WZukuF5lbz3V1PQfI
xFsYe9WYQmp25XGgezjXzp89C/OIcYsVB1KJAKihgbYdHyUN4fRCmOszmOUwEAKR
3k5j4X8V5bk08sA69NVXPn2ofxyk3YYOMYWW8ouObnXoS8QJEDQ2XZRy10aPMpsQ
AIbwX21erVqUDMPn1uONP6o4NBEq4MwG7d+fT85rc1U0RfeKBwjucAE/iStZDQoM
ZKWvGhFR+uoyg1LrXNKuSPB82unh2bpvj4zEnJsJadiwtShTKDsikhrfFEK3aCK8
Zuhpiu3jxMFDhpFzlxsSwaCcGJqcdwGhWUx0ZAVD2X71UCFoOXPjF9fNnpy80YNp
flPjj2RnOZbJyBIM0sWIVMd8F44qkTASf8K5Qb47WFN5tSpePq7OCm7s8u+lYZGK
wR18K7VliundR+5a8XAOyUXOL5UsDaQCK4Lj4lRaeFXunXl3DJ4E+7BKzZhReJL6
EugV5eaGonA52TWtFdB8p+79wPUeI3KcdPmQ9Ll5Zi/jBemY4bzasmgKzNeMtwWP
fk6WgrvBwptqohw71HDymGxFUnUP7XYYjic2sVKhv9AevMGycVgwWBiWroDCQ9Ja
btKfxHhI2p+g+rcywmBobWJbZsujTNjhtme+kNn1mhJsD3bKPjKQfAxaTskBLb0V
wgV21891TS1Dq9kdPLwoS4XNpYg2LLB4p9hmeG3fu9+OmqwY5oKXsHiWc43dei9Y
yxZ1AAUOIaIdPkq+YG/PhlGE4YcQZ4RPpltAr0HfGgZhmXWigbGS+66pUj+Ojysc
j0K5tCVxVu0fhhFpOlHv0LWaxCbnkgkQH9jfMEJkAWMOuQINBGCAXCYBEADW6RNr
ZVGNXvHVBqSiOWaxl1XOiEoiHPt50Aijt25yXbG+0kHIFSoR+1g6Lh20JTCChgfQ
kGGjzQvEuG1HTw07YhsvLc0pkjNMfu6gJqFox/ogc53mz69OxXauzUQ/TZ27GDVp
UBu+EhDKt1s3OtA6Bjz/csop/Um7gT0+ivHyvJ/jGdnPEZv8tNuSE/Uo+hn/Q9hg
8SbveZzo3C+U4KcabCESEFl8Gq6aRi9vAfa65oxD5jKaIz7cy+pwb0lizqlW7H9t
Qlr3dBfdIcdzgR55hTFC5/XrcwJ6/nHVH/xGskEasnfCQX8RYKMuy0UADJy72TkZ
bYaCx+XXIcVB8GTOmJVoAhrTSSVLAZspfCnjwnSxisDn3ZzsYrq3cV6sU8b+QlIX
7VAjurE+5cZiVlaxgCjyhKqlGgmonnReWOBacCgL/UvuwMmMp5TTLmiLXLT7uxeG
ojEyoCk4sMrqrU1jevHyGlDJH9Taux15GILDwnYFfAvPF9WCid4UZ4Ouwjcaxfys
3LxNiZIlUsXNKwS3mhiMRL4TRsbs4k4QE+LIMOsauIvcvm8/frydvQ/kUwIhVTH8
0XGOH909bYtJvY3fudK7ShIwm7ZFTduBJUG473E/Fn3VkhTmBX6+PjOC50HR/Hyb
waRCzfDruMe3TAcE/tSP5CUOb9C7+P+hPzQcDwARAQABiQRyBBgBCgAmFiEEyHQB
Hwq0BRENAhBVNDZdlHLXRo8FAmCAXCYCGwIFCQlmAYACQAkQNDZdlHLXRo/BdCAE
GQEKAB0WIQQ3TsdbSFkTYEqDHMfIIMbVzSerhwUCYIBcJgAKCRDIIMbVzSerh0Xw
D/9ghnUsoNCu1OulcoJdHboMazJvDt/znttdQSnULBVElgM5zk0Uyv87zFBzuCyQ
JWL3bWesQ2uFx5fRWEPDEfWVdDrjpQGb1OCCQyz1QlNPV/1M1/xhKGS9EeXrL8Dw
F6KTGkRwn1yXiP4BGgfeFIQHmJcKXEZ9HkrpNb8mcexkROv4aIPAwn+IaE+NHVtt
IBnufMXLyfpkWJQtJa9elh9PMLlHHnuvnYLvuAoOkhuvs7fXDMpfFZ01C+QSv1dz
Hm52GSStERQzZ51w4c0rYDneYDniC/sQT1x3dP5Xf6wzO+EhRMabkvoTbMqPsTEP
xyWr2pNtTBYp7pfQjsHxhJpQF0xjGN9C39z7f3gJG8IJhnPeulUqEZjhRFyVZQ6/
siUeq7vu4+dM/JQL+i7KKe7Lp9UMrG6NLMH+ltaoD3+lVm8fdTUxS5MNPoA/I8cK
1OWTJHkrp7V/XaY7mUtvQn5V1yET5b4bogz4nME6WLiFMd+7x73gB+YJ6MGYNuO8
e/NFK67MfHbk1/AiPTAJ6s5uHRQIkZcBPG7y5PpfcHpIlwPYCDGYlTajZXblyKrw
BttVnYKvKsnlysv11glSg0DphGxQJbXzWpvBNyhMNH5dffcfvd3eXJAxnD81GD2z
ZAriMJ4Av2TfeqQ2nxd2ddn0jX4WVHtAvLXfCgLM2Gveho4jD/9sZ6PZz/rEeTvt
h88t50qPcBa4bb25X0B5FO3TeK2LL3VKLuEp5lgdcHVonrcdqZFobN1CgGJua8TW
SprIkh+8ATZ/FXQTi01NzLhHXT1IQzSpFaZw0gb2f5ruXwvTPpfXzQrs2omY+7s7
fkCwGPesvpSXPKn9v8uhUwD7NGW/Dm+jUM+QtC/FqzX7+/Q+OuEPjClUh1cqopCZ
EvAI3HjnavGrYuU6DgQdjyGT/UDbuwbCXqHxHojVVkISGzCTGpmBcQYQqhcFRedJ
yJlu6PSXlA7+8Ajh52oiMJ3ez4xSssFgUQAyOB16432tm4erpGmCyakkoRmMUn3p
wx+QIppxRlsHznhcCQKR3tcblUqH3vq5i4/ZAihusMCa0YrShtxfdSb13oKX+pFr
aZXvxyZlCa5qoQQBV1sowmPL1N2j3dR9TVpdTyCFQSv4KeiExmowtLIjeCppRBEK
eeYHJnlfkyKXPhxTVVO6H+dU4nVu0ASQZ07KiQjbI+zTpPKFLPp3/0sPRJM57r1+
aTS71iR7nZNZ1f8LZV2OvGE6fJVtgJ1J4Nu02K54uuIhU3tg1+7Xt+IqwRc9rbVr
pHH/hFCYBPW2D2dxB+k2pQlg5NI+TpsXj5Zun8kRw5RtVb+dLuiH/xmxArIee8Jq
ZF5q4h4I33PSGDdSvGXn9UMY5Isjpg==
=7pIB

-----END PGP PUBLIC KEY BLOCK-----`;
    var releasesUrl = "https://releases.hashicorp.com";
    var Release = class {
      constructor(release) {
        this.name = release.name;
        this.version = release.version;
        this.builds = release.builds;
        this.shasums = release.shasums;
        if (release.shasums_signatures) {
          this.shasums_signature = release.shasums_signatures.find((sig) => sig.endsWith(`_SHA256SUMS.${hashiPublicKeyId}.sig`));
        } else {
          this.shasums_signature = release.shasums_signature;
        }
      }
      getBuild(platform, arch) {
        return this.builds.find((b) => b.os === platform && b.arch === arch);
      }
      download(downloadUrl, installPath, identifier) {
        return __awaiter(this, void 0, void 0, function* () {
          const headers = { "User-Agent": identifier };
          const writer = fs.createWriteStream(installPath);
          const result = yield (0, utils_1.request)(downloadUrl, { headers: Object.assign({}, headers), responseType: "stream" });
          result.pipe(writer);
          yield finished(writer);
        });
      }
      verify(pkg, buildName) {
        return __awaiter(this, void 0, void 0, function* () {
          const [localSum, remoteSum] = yield Promise.all([
            this.calculateFileSha256Sum(pkg),
            this.downloadSha256Sum(buildName)
          ]);
          if (remoteSum !== localSum) {
            throw new Error(`Install error: SHA sum for ${buildName} does not match.
(expected: ${remoteSum} calculated: ${localSum})`);
          }
        });
      }
      calculateFileSha256Sum(path) {
        return new Promise((resolve, reject) => {
          const hash = crypto5.createHash("sha256");
          fs.createReadStream(path).on("error", reject).on("data", (data) => hash.update(data)).on("end", () => resolve(hash.digest("hex")));
        });
      }
      downloadSha256Sum(buildName) {
        return __awaiter(this, void 0, void 0, function* () {
          const [shasumsResponse, shasumsSignature] = yield Promise.all([
            (0, utils_1.request)(`${releasesUrl}/${this.name}/${this.version}/${this.shasums}`, {
              responseType: "text"
            }),
            (0, utils_1.request)(`${releasesUrl}/${this.name}/${this.version}/${this.shasums_signature}`, {
              responseType: "arraybuffer"
            })
          ]);
          const publicKey = yield openpgp.readKey({ armoredKey: hashiPublicKey });
          const signature = yield openpgp.readSignature({ binarySignature: Buffer.from(shasumsSignature, "hex") });
          const message = yield openpgp.createMessage({ text: shasumsResponse });
          const verified = yield openpgp.verify({
            message,
            verificationKeys: publicKey,
            signature
          });
          if (!verified) {
            throw new Error("signature could not be verified");
          }
          const shasumLine = shasumsResponse.split(`
`).find((line) => line.includes(buildName));
          if (!shasumLine) {
            throw new Error(`Install error: no matching SHA sum for ${buildName}`);
          }
          return shasumLine.split("  ")[0];
        });
      }
      unpack(directory, pkgName) {
        return new Promise((resolve, reject) => {
          let executable;
          yauzl.open(pkgName, { lazyEntries: true }, (err, zipfile) => {
            if (err) {
              return reject(err);
            }
            zipfile.readEntry();
            zipfile.on("entry", (entry) => {
              zipfile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  return reject(err2);
                }
                readStream.on("end", () => {
                  zipfile.readEntry();
                });
                executable = `${directory}/${entry.fileName}`;
                const destination = fs.createWriteStream(executable);
                readStream.pipe(destination);
              });
            });
            zipfile.on("close", () => {
              fs.chmodSync(executable, "755");
              return resolve();
            });
          });
        });
      }
    };
    exports2.Release = Release;
    function getRelease2(product, version2, userAgent, includePrerelease) {
      return __awaiter(this, void 0, void 0, function* () {
        const validVersion = semver.validRange(version2, { includePrerelease, loose: true });
        const indexUrl = `${releasesUrl}/${product}/index.json`;
        const headers = userAgent ? { "User-Agent": userAgent } : null;
        const response = yield (0, utils_1.request)(indexUrl, { headers });
        const versions = Object.assign({}, ...Object.keys(response.versions).filter((key) => semver.valid(key) !== null).map((key) => ({ [key]: response.versions[key] })));
        if (!validVersion) {
          const releaseVersion = Object.keys(versions).filter((v) => !semver.prerelease(v)).sort((a, b) => semver.rcompare(a, b))[0];
          return new Release(versions[releaseVersion]);
        }
        return matchVersion(versions, validVersion, includePrerelease);
      });
    }
    exports2.getRelease = getRelease2;
    function matchVersion(versions, range, includePrerelease) {
      const version2 = semver.maxSatisfying(Object.keys(versions), range, { includePrerelease });
      if (version2) {
        return new Release(versions[version2]);
      } else {
        throw new Error("No matching version found");
      }
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  run: () => run
});
module.exports = __toCommonJS(src_exports);
var import_core = __toESM(require_core());
var import_tool_cache = __toESM(require_tool_cache());
var import_js_releases = __toESM(require_out());

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto4;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto5 = Object.prototype;
var hasOwnProperty3 = objectProto5.hasOwnProperty;
var propertyIsEnumerable = objectProto5.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto7 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isString.js
var stringTag2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag2;
}
var isString_default = isString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js
var mapTag3 = "[object Map]";
var setTag3 = "[object Set]";
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag3 || tag == setTag3) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty6.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// src/index.ts
var import_os = __toESM(require("os"));
var mapArch = (arch) => ({
  x32: "386",
  arm64: "arm64",
  x64: "amd64"
})[arch] ?? arch;
var mapOS = (os2) => ({
  win32: "windows"
})[os2] ?? os2;
var USER_AGENT = "escapace/setup-vault";
async function download(url, verify) {
  (0, import_core.debug)(`Downloading Vault from ${url}`);
  const zip = await (0, import_tool_cache.downloadTool)(url);
  await verify(zip);
  const pathToFile = await (0, import_tool_cache.extractZip)(zip);
  (0, import_core.debug)(`Vault path is ${pathToFile}.`);
  if (!isString_default(zip) || !isString_default(pathToFile)) {
    throw new Error(`Unable to download Vault from ${url}`);
  }
  return pathToFile;
}
async function run() {
  try {
    const version2 = (0, import_core.getInput)("vault-version");
    const platform = mapOS(import_os.default.platform());
    const arch = mapArch(import_os.default.arch());
    (0, import_core.debug)(`Finding releases for Vault version ${version2}`);
    const release = await (0, import_js_releases.getRelease)("vault", version2, USER_AGENT);
    (0, import_core.debug)(
      `Getting build for Vault version ${release.version}: ${platform} ${arch}`
    );
    const build = release.getBuild(platform, arch);
    if (!build) {
      throw new Error(
        `Vault version ${version2} not available for ${platform} and ${arch}`
      );
    }
    let toolPath = (0, import_tool_cache.find)("vault", release.version, arch);
    if (!isString_default(toolPath) || isEmpty_default(toolPath)) {
      toolPath = await download(
        build.url,
        async (zipFile) => await release.verify(zipFile, build.filename)
      );
    }
    (0, import_core.addPath)(toolPath);
  } catch (error) {
    if (isError_default(error)) {
      (0, import_core.setFailed)(error.message);
    } else if (isString_default(error)) {
      (0, import_core.setFailed)(error);
    }
    (0, import_core.setFailed)("Unknown Error");
  }
}
void run();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  run
});
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

openpgp/dist/node/openpgp.min.js:
  (*! OpenPGP.js v5.11.0 - 2023-10-25 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=index.cjs.map
