"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os2 = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os2.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issueCommand = void 0;
    var fs = __importStar(require("fs"));
    var os2 = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os2.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueCommand = issueCommand;
  }
});

// node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        return new URL(proxyVar);
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
        if (upperReqHosts.some((x) => x === upperNoProxyItem)) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
  }
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2("tunneling socket could not be established, statusCode=%d", res.statusCode);
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.debug = debug2;
  }
});

// node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes = exports2.HttpCodes || (exports2.HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers = exports2.Headers || (exports2.Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes = exports2.MediaTypes || (exports2.MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
  }
});

// node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/@actions+http-client@2.0.1/node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.result.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            core_1.debug(`ID token url is ${id_token_url}`);
            const id_token = yield OidcClient.getCall(id_token_url);
            core_1.setSecret(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      stringify() {
        return this._buffer;
      }
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/@actions+core@1.9.0/node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os2 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = utils_1.toCommandValue(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        const delimiter = "_GitHubActionsFileCommandDelimeter_";
        const commandValue = `${name}<<${delimiter}${os2.EOL}${convertedVal}${os2.EOL}${delimiter}`;
        file_command_1.issueCommand("ENV", commandValue);
      } else {
        command_1.issueCommand("set-env", { name }, convertedVal);
      }
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      command_1.issueCommand("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath2(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        file_command_1.issueCommand("PATH", inputPath);
      } else {
        command_1.issueCommand("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath2;
    function getInput2(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput2;
    function getMultilineInput(name, options) {
      const inputs = getInput2(name, options).split("\n").filter((x) => x !== "");
      return inputs;
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      process.stdout.write(os2.EOL);
      command_1.issueCommand("set-output", { name }, value);
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      command_1.issue("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed2(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports2.setFailed = setFailed2;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug2(message) {
      command_1.issueCommand("debug", {}, message);
    }
    exports2.debug = debug2;
    function error(message, properties = {}) {
      command_1.issueCommand("error", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error;
    function warning(message, properties = {}) {
      command_1.issueCommand("warning", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      command_1.issueCommand("notice", utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info(message) {
      process.stdout.write(message + os2.EOL);
    }
    exports2.info = info;
    function startGroup(name) {
      command_1.issue("group", name);
    }
    exports2.startGroup = startGroup;
    function endGroup() {
      command_1.issue("endgroup");
    }
    exports2.endGroup = endGroup;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name, value) {
      command_1.issueCommand("save-state", { name }, value);
    }
    exports2.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
  }
});

// node_modules/.pnpm/@actions+io@1.1.2/node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/.pnpm/@actions+io@1.1.2/node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rename = exports2.readlink = exports2.readdir = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs = __importStar(require("fs"));
    var path = __importStar(require("path"));
    _a = fs.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports2.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports2.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports2.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            const upperExt = path.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports2.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                const directory = path.dirname(filePath);
                const upperName = path.basename(filePath).toUpperCase();
                for (const actualName of yield exports2.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports2.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// node_modules/.pnpm/@actions+io@1.1.2/node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/.pnpm/@actions+io@1.1.2/node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert");
    var childProcess = __importStar(require("child_process"));
    var path = __importStar(require("path"));
    var util_1 = require("util");
    var ioUtil = __importStar(require_io_util());
    var exec = util_1.promisify(childProcess.exec);
    var execFile = util_1.promisify(childProcess.execFile);
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path.join(dest, path.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
          try {
            const cmdPath = ioUtil.getCmdPath();
            if (yield ioUtil.isDirectory(inputPath, true)) {
              yield exec(`${cmdPath} /s /c "rd /s /q "%inputPath%""`, {
                env: { inputPath }
              });
            } else {
              yield exec(`${cmdPath} /s /c "del /f /a "%inputPath%""`, {
                env: { inputPath }
              });
            }
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
          }
          try {
            yield ioUtil.unlink(inputPath);
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
          }
        } else {
          let isDir = false;
          try {
            isDir = yield ioUtil.isDirectory(inputPath);
          } catch (err) {
            if (err.code !== "ENOENT")
              throw err;
            return;
          }
          if (isDir) {
            yield execFile(`rm`, [`-rf`, `${inputPath}`]);
          } else {
            yield ioUtil.unlink(inputPath);
          }
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/.pnpm/semver@6.3.0/node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/semver@6.3.0/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug2(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug2("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER2) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug2("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug2("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug2("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug2("caret", comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug2(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/manifest.js
var require_manifest = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/manifest.js"(exports2, module2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._readLinuxVersionFile = exports2._getOsVersion = exports2._findMatch = void 0;
    var semver2 = __importStar(require_semver());
    var core_1 = require_core();
    var os2 = require("os");
    var cp = require("child_process");
    var fs = require("fs");
    function _findMatch(versionSpec, stable, candidates, archFilter) {
      return __awaiter(this, void 0, void 0, function* () {
        const platFilter = os2.platform();
        let result;
        let match;
        let file;
        for (const candidate of candidates) {
          const version = candidate.version;
          core_1.debug(`check ${version} satisfies ${versionSpec}`);
          if (semver2.satisfies(version, versionSpec) && (!stable || candidate.stable === stable)) {
            file = candidate.files.find((item) => {
              core_1.debug(`${item.arch}===${archFilter} && ${item.platform}===${platFilter}`);
              let chk = item.arch === archFilter && item.platform === platFilter;
              if (chk && item.platform_version) {
                const osVersion = module2.exports._getOsVersion();
                if (osVersion === item.platform_version) {
                  chk = true;
                } else {
                  chk = semver2.satisfies(osVersion, item.platform_version);
                }
              }
              return chk;
            });
            if (file) {
              core_1.debug(`matched ${candidate.version}`);
              match = candidate;
              break;
            }
          }
        }
        if (match && file) {
          result = Object.assign({}, match);
          result.files = [file];
        }
        return result;
      });
    }
    exports2._findMatch = _findMatch;
    function _getOsVersion() {
      const plat = os2.platform();
      let version = "";
      if (plat === "darwin") {
        version = cp.execSync("sw_vers -productVersion").toString();
      } else if (plat === "linux") {
        const lsbContents = module2.exports._readLinuxVersionFile();
        if (lsbContents) {
          const lines = lsbContents.split("\n");
          for (const line of lines) {
            const parts = line.split("=");
            if (parts.length === 2 && (parts[0].trim() === "VERSION_ID" || parts[0].trim() === "DISTRIB_RELEASE")) {
              version = parts[1].trim().replace(/^"/, "").replace(/"$/, "");
              break;
            }
          }
        }
      }
      return version;
    }
    exports2._getOsVersion = _getOsVersion;
    function _readLinuxVersionFile() {
      const lsbReleaseFile = "/etc/lsb-release";
      const osReleaseFile = "/etc/os-release";
      let contents = "";
      if (fs.existsSync(lsbReleaseFile)) {
        contents = fs.readFileSync(lsbReleaseFile).toString();
      } else if (fs.existsSync(osReleaseFile)) {
        contents = fs.readFileSync(osReleaseFile).toString();
      }
      return contents;
    }
    exports2._readLinuxVersionFile = _readLinuxVersionFile;
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/rng.js"(exports2, module2) {
    var crypto2 = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto2.randomBytes(16);
    };
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/.pnpm/uuid@3.4.0/node_modules/uuid/v4.js"(exports2, module2) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os2 = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path = __importStar(require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n = s.indexOf(os2.EOL);
          while (n > -1) {
            const line = s.substring(0, n);
            onLine(line);
            s = s.substring(n + os2.EOL.length);
            n = s.indexOf(os2.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x) => x === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os2.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error) {
                reject(error);
              } else {
                resolve(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        if (this.processExited) {
          if (this.processError) {
            error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder");
    var tr = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports2.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/retry-helper.js
var require_retry_helper = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/retry-helper.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryHelper = void 0;
    var core2 = __importStar(require_core());
    var RetryHelper = class {
      constructor(maxAttempts, minSeconds, maxSeconds) {
        if (maxAttempts < 1) {
          throw new Error("max attempts should be greater than or equal to 1");
        }
        this.maxAttempts = maxAttempts;
        this.minSeconds = Math.floor(minSeconds);
        this.maxSeconds = Math.floor(maxSeconds);
        if (this.minSeconds > this.maxSeconds) {
          throw new Error("min seconds should be less than or equal to max seconds");
        }
      }
      execute(action, isRetryable) {
        return __awaiter(this, void 0, void 0, function* () {
          let attempt = 1;
          while (attempt < this.maxAttempts) {
            try {
              return yield action();
            } catch (err) {
              if (isRetryable && !isRetryable(err)) {
                throw err;
              }
              core2.info(err.message);
            }
            const seconds = this.getSleepAmount();
            core2.info(`Waiting ${seconds} seconds before trying again`);
            yield this.sleep(seconds);
            attempt++;
          }
          return yield action();
        });
      }
      getSleepAmount() {
        return Math.floor(Math.random() * (this.maxSeconds - this.minSeconds + 1)) + this.minSeconds;
      }
      sleep(seconds) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
        });
      }
    };
    exports2.RetryHelper = RetryHelper;
  }
});

// node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/tool-cache.js
var require_tool_cache = __commonJS({
  "node_modules/.pnpm/@actions+tool-cache@2.0.1/node_modules/@actions/tool-cache/lib/tool-cache.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluateVersions = exports2.isExplicitVersion = exports2.findFromManifest = exports2.getManifestFromRepo = exports2.findAllVersions = exports2.find = exports2.cacheFile = exports2.cacheDir = exports2.extractZip = exports2.extractXar = exports2.extractTar = exports2.extract7z = exports2.downloadTool = exports2.HTTPError = void 0;
    var core2 = __importStar(require_core());
    var io = __importStar(require_io());
    var fs = __importStar(require("fs"));
    var mm = __importStar(require_manifest());
    var os2 = __importStar(require("os"));
    var path = __importStar(require("path"));
    var httpm = __importStar(require_lib());
    var semver2 = __importStar(require_semver());
    var stream = __importStar(require("stream"));
    var util = __importStar(require("util"));
    var assert_1 = require("assert");
    var v4_1 = __importDefault(require_v4());
    var exec_1 = require_exec();
    var retry_helper_1 = require_retry_helper();
    var HTTPError = class extends Error {
      constructor(httpStatusCode) {
        super(`Unexpected HTTP response: ${httpStatusCode}`);
        this.httpStatusCode = httpStatusCode;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports2.HTTPError = HTTPError;
    var IS_WINDOWS = process.platform === "win32";
    var IS_MAC = process.platform === "darwin";
    var userAgent = "actions/tool-cache";
    function downloadTool2(url, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        dest = dest || path.join(_getTempDirectory(), v4_1.default());
        yield io.mkdirP(path.dirname(dest));
        core2.debug(`Downloading ${url}`);
        core2.debug(`Destination ${dest}`);
        const maxAttempts = 3;
        const minSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MIN_SECONDS", 10);
        const maxSeconds = _getGlobal("TEST_DOWNLOAD_TOOL_RETRY_MAX_SECONDS", 20);
        const retryHelper = new retry_helper_1.RetryHelper(maxAttempts, minSeconds, maxSeconds);
        return yield retryHelper.execute(() => __awaiter(this, void 0, void 0, function* () {
          return yield downloadToolAttempt(url, dest || "", auth, headers);
        }), (err) => {
          if (err instanceof HTTPError && err.httpStatusCode) {
            if (err.httpStatusCode < 500 && err.httpStatusCode !== 408 && err.httpStatusCode !== 429) {
              return false;
            }
          }
          return true;
        });
      });
    }
    exports2.downloadTool = downloadTool2;
    function downloadToolAttempt(url, dest, auth, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (fs.existsSync(dest)) {
          throw new Error(`Destination file path ${dest} already exists`);
        }
        const http = new httpm.HttpClient(userAgent, [], {
          allowRetries: false
        });
        if (auth) {
          core2.debug("set auth");
          if (headers === void 0) {
            headers = {};
          }
          headers.authorization = auth;
        }
        const response = yield http.get(url, headers);
        if (response.message.statusCode !== 200) {
          const err = new HTTPError(response.message.statusCode);
          core2.debug(`Failed to download from "${url}". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);
          throw err;
        }
        const pipeline = util.promisify(stream.pipeline);
        const responseMessageFactory = _getGlobal("TEST_DOWNLOAD_TOOL_RESPONSE_MESSAGE_FACTORY", () => response.message);
        const readStream = responseMessageFactory();
        let succeeded = false;
        try {
          yield pipeline(readStream, fs.createWriteStream(dest));
          core2.debug("download complete");
          succeeded = true;
          return dest;
        } finally {
          if (!succeeded) {
            core2.debug("download failed");
            try {
              yield io.rmRF(dest);
            } catch (err) {
              core2.debug(`Failed to delete '${dest}'. ${err.message}`);
            }
          }
        }
      });
    }
    function extract7z(file, dest, _7zPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(IS_WINDOWS, "extract7z() not supported on current OS");
        assert_1.ok(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        const originalCwd = process.cwd();
        process.chdir(dest);
        if (_7zPath) {
          try {
            const logLevel = core2.isDebug() ? "-bb1" : "-bb0";
            const args = [
              "x",
              logLevel,
              "-bd",
              "-sccUTF-8",
              file
            ];
            const options = {
              silent: true
            };
            yield exec_1.exec(`"${_7zPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        } else {
          const escapedScript = path.join(__dirname, "..", "scripts", "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const escapedTarget = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          const command = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}'`;
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            command
          ];
          const options = {
            silent: true
          };
          try {
            const powershellPath = yield io.which("powershell", true);
            yield exec_1.exec(`"${powershellPath}"`, args, options);
          } finally {
            process.chdir(originalCwd);
          }
        }
        return dest;
      });
    }
    exports2.extract7z = extract7z;
    function extractTar(file, dest, flags = "xz") {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        core2.debug("Checking tar --version");
        let versionOutput = "";
        yield exec_1.exec("tar --version", [], {
          ignoreReturnCode: true,
          silent: true,
          listeners: {
            stdout: (data) => versionOutput += data.toString(),
            stderr: (data) => versionOutput += data.toString()
          }
        });
        core2.debug(versionOutput.trim());
        const isGnuTar = versionOutput.toUpperCase().includes("GNU TAR");
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        if (core2.isDebug() && !flags.includes("v")) {
          args.push("-v");
        }
        let destArg = dest;
        let fileArg = file;
        if (IS_WINDOWS && isGnuTar) {
          args.push("--force-local");
          destArg = dest.replace(/\\/g, "/");
          fileArg = file.replace(/\\/g, "/");
        }
        if (isGnuTar) {
          args.push("--warning=no-unknown-keyword");
          args.push("--overwrite");
        }
        args.push("-C", destArg, "-f", fileArg);
        yield exec_1.exec(`tar`, args);
        return dest;
      });
    }
    exports2.extractTar = extractTar;
    function extractXar(file, dest, flags = []) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(IS_MAC, "extractXar() not supported on current OS");
        assert_1.ok(file, 'parameter "file" is required');
        dest = yield _createExtractFolder(dest);
        let args;
        if (flags instanceof Array) {
          args = flags;
        } else {
          args = [flags];
        }
        args.push("-x", "-C", dest, "-f", file);
        if (core2.isDebug()) {
          args.push("-v");
        }
        const xarPath = yield io.which("xar", true);
        yield exec_1.exec(`"${xarPath}"`, _unique(args));
        return dest;
      });
    }
    exports2.extractXar = extractXar;
    function extractZip2(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        dest = yield _createExtractFolder(dest);
        if (IS_WINDOWS) {
          yield extractZipWin(file, dest);
        } else {
          yield extractZipNix(file, dest);
        }
        return dest;
      });
    }
    exports2.extractZip = extractZip2;
    function extractZipWin(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const escapedDest = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
        const pwshPath = yield io.which("pwsh", false);
        if (pwshPath) {
          const pwshCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.ZipFile } catch { } ;`,
            `try { [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`,
            `catch { if (($_.Exception.GetType().FullName -eq 'System.Management.Automation.MethodException') -or ($_.Exception.GetType().FullName -eq 'System.Management.Automation.RuntimeException') ){ Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force } else { throw $_ } } ;`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            pwshCommand
          ];
          core2.debug(`Using pwsh at path: ${pwshPath}`);
          yield exec_1.exec(`"${pwshPath}"`, args);
        } else {
          const powershellCommand = [
            `$ErrorActionPreference = 'Stop' ;`,
            `try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ;`,
            `if ((Get-Command -Name Expand-Archive -Module Microsoft.PowerShell.Archive -ErrorAction Ignore)) { Expand-Archive -LiteralPath '${escapedFile}' -DestinationPath '${escapedDest}' -Force }`,
            `else {[System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}', $true) }`
          ].join(" ");
          const args = [
            "-NoLogo",
            "-Sta",
            "-NoProfile",
            "-NonInteractive",
            "-ExecutionPolicy",
            "Unrestricted",
            "-Command",
            powershellCommand
          ];
          const powershellPath = yield io.which("powershell", true);
          core2.debug(`Using powershell at path: ${powershellPath}`);
          yield exec_1.exec(`"${powershellPath}"`, args);
        }
      });
    }
    function extractZipNix(file, dest) {
      return __awaiter(this, void 0, void 0, function* () {
        const unzipPath = yield io.which("unzip", true);
        const args = [file];
        if (!core2.isDebug()) {
          args.unshift("-q");
        }
        args.unshift("-o");
        yield exec_1.exec(`"${unzipPath}"`, args, { cwd: dest });
      });
    }
    function cacheDir(sourceDir, tool, version, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        version = semver2.clean(version) || version;
        arch = arch || os2.arch();
        core2.debug(`Caching tool ${tool} ${version} ${arch}`);
        core2.debug(`source dir: ${sourceDir}`);
        if (!fs.statSync(sourceDir).isDirectory()) {
          throw new Error("sourceDir is not a directory");
        }
        const destPath = yield _createToolPath(tool, version, arch);
        for (const itemName of fs.readdirSync(sourceDir)) {
          const s = path.join(sourceDir, itemName);
          yield io.cp(s, destPath, { recursive: true });
        }
        _completeToolPath(tool, version, arch);
        return destPath;
      });
    }
    exports2.cacheDir = cacheDir;
    function cacheFile(sourceFile, targetFile, tool, version, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        version = semver2.clean(version) || version;
        arch = arch || os2.arch();
        core2.debug(`Caching tool ${tool} ${version} ${arch}`);
        core2.debug(`source file: ${sourceFile}`);
        if (!fs.statSync(sourceFile).isFile()) {
          throw new Error("sourceFile is not a file");
        }
        const destFolder = yield _createToolPath(tool, version, arch);
        const destPath = path.join(destFolder, targetFile);
        core2.debug(`destination file ${destPath}`);
        yield io.cp(sourceFile, destPath);
        _completeToolPath(tool, version, arch);
        return destFolder;
      });
    }
    exports2.cacheFile = cacheFile;
    function find2(toolName, versionSpec, arch) {
      if (!toolName) {
        throw new Error("toolName parameter is required");
      }
      if (!versionSpec) {
        throw new Error("versionSpec parameter is required");
      }
      arch = arch || os2.arch();
      if (!isExplicitVersion(versionSpec)) {
        const localVersions = findAllVersions(toolName, arch);
        const match = evaluateVersions(localVersions, versionSpec);
        versionSpec = match;
      }
      let toolPath = "";
      if (versionSpec) {
        versionSpec = semver2.clean(versionSpec) || "";
        const cachePath = path.join(_getCacheDirectory(), toolName, versionSpec, arch);
        core2.debug(`checking cache: ${cachePath}`);
        if (fs.existsSync(cachePath) && fs.existsSync(`${cachePath}.complete`)) {
          core2.debug(`Found tool in cache ${toolName} ${versionSpec} ${arch}`);
          toolPath = cachePath;
        } else {
          core2.debug("not found");
        }
      }
      return toolPath;
    }
    exports2.find = find2;
    function findAllVersions(toolName, arch) {
      const versions = [];
      arch = arch || os2.arch();
      const toolPath = path.join(_getCacheDirectory(), toolName);
      if (fs.existsSync(toolPath)) {
        const children = fs.readdirSync(toolPath);
        for (const child of children) {
          if (isExplicitVersion(child)) {
            const fullPath = path.join(toolPath, child, arch || "");
            if (fs.existsSync(fullPath) && fs.existsSync(`${fullPath}.complete`)) {
              versions.push(child);
            }
          }
        }
      }
      return versions;
    }
    exports2.findAllVersions = findAllVersions;
    function getManifestFromRepo(owner, repo, auth, branch = "master") {
      return __awaiter(this, void 0, void 0, function* () {
        let releases = [];
        const treeUrl = `https://api.github.com/repos/${owner}/${repo}/git/trees/${branch}`;
        const http = new httpm.HttpClient("tool-cache");
        const headers = {};
        if (auth) {
          core2.debug("set auth");
          headers.authorization = auth;
        }
        const response = yield http.getJson(treeUrl, headers);
        if (!response.result) {
          return releases;
        }
        let manifestUrl = "";
        for (const item of response.result.tree) {
          if (item.path === "versions-manifest.json") {
            manifestUrl = item.url;
            break;
          }
        }
        headers["accept"] = "application/vnd.github.VERSION.raw";
        let versionsRaw = yield (yield http.get(manifestUrl, headers)).readBody();
        if (versionsRaw) {
          versionsRaw = versionsRaw.replace(/^\uFEFF/, "");
          try {
            releases = JSON.parse(versionsRaw);
          } catch (_a) {
            core2.debug("Invalid json");
          }
        }
        return releases;
      });
    }
    exports2.getManifestFromRepo = getManifestFromRepo;
    function findFromManifest(versionSpec, stable, manifest, archFilter = os2.arch()) {
      return __awaiter(this, void 0, void 0, function* () {
        const match = yield mm._findMatch(versionSpec, stable, manifest, archFilter);
        return match;
      });
    }
    exports2.findFromManifest = findFromManifest;
    function _createExtractFolder(dest) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!dest) {
          dest = path.join(_getTempDirectory(), v4_1.default());
        }
        yield io.mkdirP(dest);
        return dest;
      });
    }
    function _createToolPath(tool, version, arch) {
      return __awaiter(this, void 0, void 0, function* () {
        const folderPath = path.join(_getCacheDirectory(), tool, semver2.clean(version) || version, arch || "");
        core2.debug(`destination ${folderPath}`);
        const markerPath = `${folderPath}.complete`;
        yield io.rmRF(folderPath);
        yield io.rmRF(markerPath);
        yield io.mkdirP(folderPath);
        return folderPath;
      });
    }
    function _completeToolPath(tool, version, arch) {
      const folderPath = path.join(_getCacheDirectory(), tool, semver2.clean(version) || version, arch || "");
      const markerPath = `${folderPath}.complete`;
      fs.writeFileSync(markerPath, "");
      core2.debug("finished caching tool");
    }
    function isExplicitVersion(versionSpec) {
      const c = semver2.clean(versionSpec) || "";
      core2.debug(`isExplicit: ${c}`);
      const valid = semver2.valid(c) != null;
      core2.debug(`explicit? ${valid}`);
      return valid;
    }
    exports2.isExplicitVersion = isExplicitVersion;
    function evaluateVersions(versions, versionSpec) {
      let version = "";
      core2.debug(`evaluating ${versions.length} versions`);
      versions = versions.sort((a, b) => {
        if (semver2.gt(a, b)) {
          return 1;
        }
        return -1;
      });
      for (let i = versions.length - 1; i >= 0; i--) {
        const potential = versions[i];
        const satisfied = semver2.satisfies(potential, versionSpec);
        if (satisfied) {
          version = potential;
          break;
        }
      }
      if (version) {
        core2.debug(`matched: ${version}`);
      } else {
        core2.debug("match not found");
      }
      return version;
    }
    exports2.evaluateVersions = evaluateVersions;
    function _getCacheDirectory() {
      const cacheDirectory = process.env["RUNNER_TOOL_CACHE"] || "";
      assert_1.ok(cacheDirectory, "Expected RUNNER_TOOL_CACHE to be defined");
      return cacheDirectory;
    }
    function _getTempDirectory() {
      const tempDirectory = process.env["RUNNER_TEMP"] || "";
      assert_1.ok(tempDirectory, "Expected RUNNER_TEMP to be defined");
      return tempDirectory;
    }
    function _getGlobal(key, defaultValue) {
      const value = global[key];
      return value !== void 0 ? value : defaultValue;
    }
    function _unique(values) {
      return Array.from(new Set(values));
    }
  }
});

// node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js"(exports2, module2) {
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer3 !== "undefined");
        return this.toArrayLike(Buffer3, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/.pnpm/safer-buffer@2.1.2/node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer3) {
      if (!Buffer3.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer3[key];
    }
    safer.Buffer.prototype = Buffer3.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer3(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer3(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/reporter.js"(exports2) {
    "use strict";
    var inherits = require_inherits();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports2.Reporter = Reporter;
    Reporter.prototype.isError = function isError2(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      let err;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/buffer.js"(exports2) {
    "use strict";
    var inherits = require_inherits();
    var Reporter = require_reporter().Reporter;
    var Buffer3 = require_safer().Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer3.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports2.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && Buffer3.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty2() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!EncoderBuffer.isEncoderBuffer(item))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer3.byteLength(value);
      } else if (Buffer3.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports2.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = Buffer3.alloc(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer3.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/node.js"(exports2, module2) {
    "use strict";
    var Reporter = require_reporter().Reporter;
    var EncoderBuffer = require_buffer().EncoderBuffer;
    var DecoderBuffer = require_buffer().DecoderBuffer;
    var assert = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent, name) {
      const state = {};
      this._baseState = state;
      state.name = name;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module2.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      const state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            const value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state = this._baseState;
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode(input, options) {
      const state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        let tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          const save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          const explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
          let save;
          if (state.any)
            save = input.save();
          const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      const state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match = false;
      Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
          const value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter, data);
          if (child._baseState.key === null)
            return reporter.error("Child should have a key");
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/der.js"(exports2) {
    "use strict";
    function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    }
    exports2.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports2.tagClassByName = reverse(exports2.tagClass);
    exports2.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports2.tagByName = reverse(exports2.tag);
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der2 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/der.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Buffer3 = require_safer().Buffer;
    var Node = require_node();
    var der = require_der();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer3.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i = content.length; i >= 256; i >>= 8)
        lenOctets++;
      const header = Buffer3.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = Buffer3.alloc(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s.]+/g);
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      let size = 0;
      for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      const objid = Buffer3.alloc(size);
      let offset = objid.length - 1;
      for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer3.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer3.from(numArray);
      }
      if (Buffer3.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0)
          size2++;
        const out2 = Buffer3.alloc(size2);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size = 1;
      for (let i = num; i >= 256; i >>= 8)
        size++;
      const out = new Array(size);
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer3.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      const state = this._baseState;
      let i;
      if (state["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var DEREncoder = require_der2();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module2.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/encoders/index.js"(exports2) {
    "use strict";
    var encoders = exports2;
    encoders.der = require_der2();
    encoders.pem = require_pem();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der3 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/der.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var bignum = require_bn();
    var DecoderBuffer = require_buffer().DecoderBuffer;
    var Node = require_node();
    var der = require_der();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module2.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
      }
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      const state = buffer.save();
      const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      buffer.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
      if (buffer.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      const state = buffer.save();
      const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
      if (buffer.isError(res))
        return res;
      len = buffer.offset - state.offset;
      buffer.restore(state);
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      for (; ; ) {
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
        let res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      const result = [];
      while (!buffer.isEmpty()) {
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i = 0; i < raw.length / 2; i++) {
          str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer.raw();
      } else if (tag === "objDesc") {
        return buffer.raw();
      } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
      } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer.isEmpty()) {
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      const str = buffer.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      const res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      const raw = buffer.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      let tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      const cls = der.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      let len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len |= j;
      }
      return len;
    }
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports2, module2) {
    "use strict";
    var inherits = require_inherits();
    var Buffer3 = require_safer().Buffer;
    var DERDecoder = require_der3();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module2.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i;
        } else {
          if (match[1] !== "END")
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer3.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/decoders/index.js"(exports2) {
    "use strict";
    var decoders = exports2;
    decoders.der = require_der3();
    decoders.pem = require_pem2();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/api.js"(exports2) {
    "use strict";
    var encoders = require_encoders();
    var decoders = require_decoders();
    var inherits = require_inherits();
    var api = exports2;
    api.define = function define(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(Base) {
      const name = this.name;
      function Generated(entity) {
        this._initNamed(entity, name);
      }
      inherits(Generated, Base);
      Generated.prototype._initNamed = function _initNamed(entity, name2) {
        Base.call(this, entity, name2);
      };
      return new Generated(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/index.js
var require_base = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/base/index.js"(exports2) {
    "use strict";
    var base = exports2;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer().DecoderBuffer;
    base.EncoderBuffer = require_buffer().EncoderBuffer;
    base.Node = require_node();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1/constants/index.js"(exports2) {
    "use strict";
    var constants = exports2;
    constants._reverse = function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/.pnpm/asn1.js@5.4.1/node_modules/asn1.js/lib/asn1.js"(exports2) {
    "use strict";
    var asn1 = exports2;
    asn1.bignum = require_bn();
    asn1.define = require_api().define;
    asn1.base = require_base();
    asn1.constants = require_constants();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/.pnpm/openpgp@5.1.0/node_modules/openpgp/dist/node/openpgp.min.js
var require_openpgp_min = __commonJS({
  "node_modules/.pnpm/openpgp@5.1.0/node_modules/openpgp/dist/node/openpgp.min.js"(exports2) {
    "use strict";
    var e = typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
    Object.defineProperty(exports2, "__esModule", { value: true });
    var t = require("buffer");
    var r = require("stream");
    var i = require("crypto");
    var n = require("zlib");
    var a = require("os");
    var s = require("util");
    var o = require_asn1();
    function c(e2) {
      return e2 && typeof e2 == "object" && "default" in e2 ? e2 : { default: e2 };
    }
    var u = /* @__PURE__ */ c(t);
    var h = /* @__PURE__ */ c(r);
    var f = /* @__PURE__ */ c(i);
    var d = /* @__PURE__ */ c(n);
    var l = /* @__PURE__ */ c(a);
    var p = /* @__PURE__ */ c(s);
    var y = /* @__PURE__ */ c(o);
    var b = Symbol("doneWritingPromise");
    var m = Symbol("doneWritingResolve");
    var g = Symbol("doneWritingReject");
    var w = Symbol("readingIndex");
    var v = class extends Array {
      constructor() {
        super(), this[b] = new Promise((e2, t2) => {
          this[m] = e2, this[g] = t2;
        }), this[b].catch(() => {
        });
      }
    };
    function _(e2) {
      return e2 && e2.getReader && Array.isArray(e2);
    }
    function k(e2) {
      if (!_(e2)) {
        const t2 = e2.getWriter(), r2 = t2.releaseLock;
        return t2.releaseLock = () => {
          t2.closed.catch(function() {
          }), r2.call(t2);
        }, t2;
      }
      this.stream = e2;
    }
    v.prototype.getReader = function() {
      return this[w] === void 0 && (this[w] = 0), { read: async () => (await this[b], this[w] === this.length ? { value: void 0, done: true } : { value: this[this[w]++], done: false }) };
    }, v.prototype.readToEnd = async function(e2) {
      await this[b];
      const t2 = e2(this.slice(this[w]));
      return this.length = 0, t2;
    }, v.prototype.clone = function() {
      const e2 = new v();
      return e2[b] = this[b].then(() => {
        e2.push(...this);
      }), e2;
    }, k.prototype.write = async function(e2) {
      this.stream.push(e2);
    }, k.prototype.close = async function() {
      this.stream[m]();
    }, k.prototype.abort = async function(e2) {
      return this.stream[g](e2), e2;
    }, k.prototype.releaseLock = function() {
    };
    var A = typeof e.process == "object" && typeof e.process.versions == "object";
    var S = A && h.default.Readable;
    function E(t2) {
      return _(t2) ? "array" : e.ReadableStream && e.ReadableStream.prototype.isPrototypeOf(t2) ? "web" : z && z.prototype.isPrototypeOf(t2) ? "ponyfill" : S && S.prototype.isPrototypeOf(t2) ? "node" : !(!t2 || !t2.getReader) && "web-like";
    }
    function P(e2) {
      return Uint8Array.prototype.isPrototypeOf(e2);
    }
    function x(e2) {
      if (e2.length === 1)
        return e2[0];
      let t2 = 0;
      for (let r3 = 0; r3 < e2.length; r3++) {
        if (!P(e2[r3]))
          throw Error("concatUint8Array: Data must be in the form of a Uint8Array");
        t2 += e2[r3].length;
      }
      const r2 = new Uint8Array(t2);
      let i2 = 0;
      return e2.forEach(function(e3) {
        r2.set(e3, i2), i2 += e3.length;
      }), r2;
    }
    var M = A && u.default.Buffer;
    var C = A && h.default.Readable;
    var K;
    var D;
    if (C) {
      K = function(e3) {
        let t2 = false;
        return new z({ start(r2) {
          e3.pause(), e3.on("data", (i2) => {
            t2 || (M.isBuffer(i2) && (i2 = new Uint8Array(i2.buffer, i2.byteOffset, i2.byteLength)), r2.enqueue(i2), e3.pause());
          }), e3.on("end", () => {
            t2 || r2.close();
          }), e3.on("error", (e4) => r2.error(e4));
        }, pull() {
          e3.resume();
        }, cancel(r2) {
          t2 = true, e3.destroy(r2);
        } });
      };
      class e2 extends C {
        constructor(e3, t2) {
          super(t2), this._reader = H(e3);
        }
        async _read(e3) {
          try {
            for (; ; ) {
              const { done: e4, value: t2 } = await this._reader.read();
              if (e4) {
                this.push(null);
                break;
              }
              if (!this.push(t2) || this._cancelling) {
                this._reading = false;
                break;
              }
            }
          } catch (e4) {
            this.emit("error", e4);
          }
        }
        _destroy(e3) {
          this._reader.cancel(e3);
        }
      }
      D = function(t2, r2) {
        return new e2(t2, r2);
      };
    }
    var R = /* @__PURE__ */ new WeakSet();
    var I = Symbol("externalBuffer");
    function U(e2) {
      if (this.stream = e2, e2[I] && (this[I] = e2[I].slice()), _(e2)) {
        const t3 = e2.getReader();
        return this._read = t3.read.bind(t3), this._releaseLock = () => {
        }, void (this._cancel = () => {
        });
      }
      let t2 = E(e2);
      if (t2 === "node" && (e2 = K(e2)), t2) {
        const t3 = e2.getReader();
        return this._read = t3.read.bind(t3), this._releaseLock = () => {
          t3.closed.catch(function() {
          }), t3.releaseLock();
        }, void (this._cancel = t3.cancel.bind(t3));
      }
      let r2 = false;
      this._read = async () => r2 || R.has(e2) ? { value: void 0, done: true } : (r2 = true, { value: e2, done: false }), this._releaseLock = () => {
        if (r2)
          try {
            R.add(e2);
          } catch (e3) {
          }
      };
    }
    U.prototype.read = async function() {
      if (this[I] && this[I].length) {
        return { done: false, value: this[I].shift() };
      }
      return this._read();
    }, U.prototype.releaseLock = function() {
      this[I] && (this.stream[I] = this[I]), this._releaseLock();
    }, U.prototype.cancel = function(e2) {
      return this._cancel(e2);
    }, U.prototype.readLine = async function() {
      let e2, t2 = [];
      for (; !e2; ) {
        let { done: r2, value: i2 } = await this.read();
        if (i2 += "", r2)
          return t2.length ? W(t2) : void 0;
        const n2 = i2.indexOf("\n") + 1;
        n2 && (e2 = W(t2.concat(i2.substr(0, n2))), t2 = []), n2 !== i2.length && t2.push(i2.substr(n2));
      }
      return this.unshift(...t2), e2;
    }, U.prototype.readByte = async function() {
      const { done: e2, value: t2 } = await this.read();
      if (e2)
        return;
      const r2 = t2[0];
      return this.unshift(re(t2, 1)), r2;
    }, U.prototype.readBytes = async function(e2) {
      const t2 = [];
      let r2 = 0;
      for (; ; ) {
        const { done: i2, value: n2 } = await this.read();
        if (i2)
          return t2.length ? W(t2) : void 0;
        if (t2.push(n2), r2 += n2.length, r2 >= e2) {
          const r3 = W(t2);
          return this.unshift(re(r3, e2)), re(r3, 0, e2);
        }
      }
    }, U.prototype.peekBytes = async function(e2) {
      const t2 = await this.readBytes(e2);
      return this.unshift(t2), t2;
    }, U.prototype.unshift = function(...e2) {
      this[I] || (this[I] = []), e2.length === 1 && P(e2[0]) && this[I].length && e2[0].length && this[I][0].byteOffset >= e2[0].length ? this[I][0] = new Uint8Array(this[I][0].buffer, this[I][0].byteOffset - e2[0].length, this[I][0].byteLength + e2[0].length) : this[I].unshift(...e2.filter((e3) => e3 && e3.length));
    }, U.prototype.readToEnd = async function(e2 = W) {
      const t2 = [];
      for (; ; ) {
        const { done: e3, value: r2 } = await this.read();
        if (e3)
          break;
        t2.push(r2);
      }
      return e2(t2);
    };
    var B;
    var T;
    var { ReadableStream: z, WritableStream: q, TransformStream: O } = e;
    async function F() {
      if (O)
        return;
      const [t2, r2] = await Promise.all([Promise.resolve().then(function() {
        return ad;
      }), Promise.resolve().then(function() {
        return Pd;
      })]);
      ({ ReadableStream: z, WritableStream: q, TransformStream: O } = t2);
      const { createReadableStreamWrapper: i2 } = r2;
      e.ReadableStream && z !== e.ReadableStream && (B = i2(z), T = i2(e.ReadableStream));
    }
    var N = A && u.default.Buffer;
    function j(e2) {
      let t2 = E(e2);
      return t2 === "node" ? K(e2) : t2 === "web" && B ? B(e2) : t2 ? e2 : new z({ start(t3) {
        t3.enqueue(e2), t3.close();
      } });
    }
    function L(e2) {
      if (E(e2))
        return e2;
      const t2 = new v();
      return (async () => {
        const r2 = G(t2);
        await r2.write(e2), await r2.close();
      })(), t2;
    }
    function W(e2) {
      return e2.some((e3) => E(e3) && !_(e3)) ? function(e3) {
        e3 = e3.map(j);
        const t2 = Z(async function(e4) {
          await Promise.all(i2.map((t3) => ne(t3, e4)));
        });
        let r2 = Promise.resolve();
        const i2 = e3.map((i3, n2) => X(i3, (i4, a2) => (r2 = r2.then(() => V(i4, t2.writable, { preventClose: n2 !== e3.length - 1 })), r2)));
        return t2.readable;
      }(e2) : e2.some((e3) => _(e3)) ? function(e3) {
        const t2 = new v();
        let r2 = Promise.resolve();
        return e3.forEach((i2, n2) => (r2 = r2.then(() => V(i2, t2, { preventClose: n2 !== e3.length - 1 })), r2)), t2;
      }(e2) : typeof e2[0] == "string" ? e2.join("") : N && N.isBuffer(e2[0]) ? N.concat(e2) : x(e2);
    }
    function H(e2) {
      return new U(e2);
    }
    function G(e2) {
      return new k(e2);
    }
    async function V(e2, t2, { preventClose: r2 = false, preventAbort: i2 = false, preventCancel: n2 = false } = {}) {
      if (E(e2) && !_(e2)) {
        e2 = j(e2);
        try {
          if (e2[I]) {
            const r3 = G(t2);
            for (let t3 = 0; t3 < e2[I].length; t3++)
              await r3.ready, await r3.write(e2[I][t3]);
            r3.releaseLock();
          }
          await e2.pipeTo(t2, { preventClose: r2, preventAbort: i2, preventCancel: n2 });
        } catch (e3) {
        }
        return;
      }
      const a2 = H(e2 = L(e2)), s2 = G(t2);
      try {
        for (; ; ) {
          await s2.ready;
          const { done: e3, value: t3 } = await a2.read();
          if (e3) {
            r2 || await s2.close();
            break;
          }
          await s2.write(t3);
        }
      } catch (e3) {
        i2 || await s2.abort(e3);
      } finally {
        a2.releaseLock(), s2.releaseLock();
      }
    }
    function $(e2, t2) {
      const r2 = new O(t2);
      return V(e2, r2.writable), r2.readable;
    }
    function Z(e2) {
      let t2, r2, i2 = false;
      return { readable: new z({ start(e3) {
        r2 = e3;
      }, pull() {
        t2 ? t2() : i2 = true;
      }, cancel: e2 }, { highWaterMark: 0 }), writable: new q({ write: async function(e3) {
        r2.enqueue(e3), i2 ? i2 = false : (await new Promise((e4) => {
          t2 = e4;
        }), t2 = null);
      }, close: r2.close.bind(r2), abort: r2.error.bind(r2) }) };
    }
    function Y(e2, t2 = () => {
    }, r2 = () => {
    }) {
      if (_(e2)) {
        const i3 = new v();
        return (async () => {
          const n3 = await ie(e2), a2 = t2(n3), s2 = r2();
          let o2;
          o2 = a2 !== void 0 && s2 !== void 0 ? W([a2, s2]) : a2 !== void 0 ? a2 : s2;
          const c2 = G(i3);
          await c2.write(o2), await c2.close();
        })(), i3;
      }
      if (E(e2))
        return $(e2, { async transform(e3, r3) {
          try {
            const i3 = await t2(e3);
            i3 !== void 0 && r3.enqueue(i3);
          } catch (e4) {
            r3.error(e4);
          }
        }, async flush(e3) {
          try {
            const t3 = await r2();
            t3 !== void 0 && e3.enqueue(t3);
          } catch (t3) {
            e3.error(t3);
          }
        } });
      const i2 = t2(e2), n2 = r2();
      return i2 !== void 0 && n2 !== void 0 ? W([i2, n2]) : i2 !== void 0 ? i2 : n2;
    }
    function X(e2, t2) {
      if (E(e2) && !_(e2)) {
        let r3;
        const i2 = new O({ start(e3) {
          r3 = e3;
        } }), n2 = V(e2, i2.writable), a2 = Z(async function() {
          r3.error(Error("Readable side was canceled.")), await n2, await new Promise(setTimeout);
        });
        return t2(i2.readable, a2.writable), a2.readable;
      }
      e2 = L(e2);
      const r2 = new v();
      return t2(e2, r2), r2;
    }
    function Q(e2, t2) {
      let r2;
      const i2 = X(e2, (e3, n2) => {
        const a2 = H(e3);
        a2.remainder = () => (a2.releaseLock(), V(e3, n2), i2), r2 = t2(a2);
      });
      return r2;
    }
    function J(e2) {
      if (_(e2))
        return e2.clone();
      if (E(e2)) {
        const t2 = function(e3) {
          if (_(e3))
            throw Error("ArrayStream cannot be tee()d, use clone() instead");
          if (E(e3)) {
            const t3 = j(e3).tee();
            return t3[0][I] = t3[1][I] = e3[I], t3;
          }
          return [re(e3), re(e3)];
        }(e2);
        return te(e2, t2[0]), t2[1];
      }
      return re(e2);
    }
    function ee(e2) {
      return _(e2) ? J(e2) : E(e2) ? new z({ start(t2) {
        const r2 = X(e2, async (e3, r3) => {
          const i2 = H(e3), n2 = G(r3);
          try {
            for (; ; ) {
              await n2.ready;
              const { done: e4, value: r4 } = await i2.read();
              if (e4) {
                try {
                  t2.close();
                } catch (e5) {
                }
                return void await n2.close();
              }
              try {
                t2.enqueue(r4);
              } catch (e5) {
              }
              await n2.write(r4);
            }
          } catch (e4) {
            t2.error(e4), await n2.abort(e4);
          }
        });
        te(e2, r2);
      } }) : re(e2);
    }
    function te(e2, t2) {
      Object.entries(Object.getOwnPropertyDescriptors(e2.constructor.prototype)).forEach(([r2, i2]) => {
        r2 !== "constructor" && (i2.value ? i2.value = i2.value.bind(t2) : i2.get = i2.get.bind(t2), Object.defineProperty(e2, r2, i2));
      });
    }
    function re(e2, t2 = 0, r2 = 1 / 0) {
      if (_(e2))
        throw Error("Not implemented");
      if (E(e2)) {
        if (t2 >= 0 && r2 >= 0) {
          let i2 = 0;
          return $(e2, { transform(e3, n2) {
            i2 < r2 ? (i2 + e3.length >= t2 && n2.enqueue(re(e3, Math.max(t2 - i2, 0), r2 - i2)), i2 += e3.length) : n2.terminate();
          } });
        }
        if (t2 < 0 && (r2 < 0 || r2 === 1 / 0)) {
          let i2 = [];
          return Y(e2, (e3) => {
            e3.length >= -t2 ? i2 = [e3] : i2.push(e3);
          }, () => re(W(i2), t2, r2));
        }
        if (t2 === 0 && r2 < 0) {
          let i2;
          return Y(e2, (e3) => {
            const n2 = i2 ? W([i2, e3]) : e3;
            if (n2.length >= -r2)
              return i2 = re(n2, r2), re(n2, t2, r2);
            i2 = n2;
          });
        }
        return console.warn(`stream.slice(input, ${t2}, ${r2}) not implemented efficiently.`), ae(async () => re(await ie(e2), t2, r2));
      }
      return e2[I] && (e2 = W(e2[I].concat([e2]))), !P(e2) || N && N.isBuffer(e2) ? e2.slice(t2, r2) : (r2 === 1 / 0 && (r2 = e2.length), e2.subarray(t2, r2));
    }
    async function ie(e2, t2 = W) {
      return _(e2) ? e2.readToEnd(t2) : E(e2) ? H(e2).readToEnd(t2) : e2;
    }
    async function ne(e2, t2) {
      if (E(e2)) {
        if (e2.cancel)
          return e2.cancel(t2);
        if (e2.destroy)
          return e2.destroy(t2), await new Promise(setTimeout), t2;
      }
    }
    function ae(e2) {
      const t2 = new v();
      return (async () => {
        const r2 = G(t2);
        try {
          await r2.write(await e2()), await r2.close();
        } catch (e3) {
          await r2.abort(e3);
        }
      })(), t2;
    }
    var se = class {
      constructor(e2) {
        if (e2 === void 0)
          throw Error("Invalid BigInteger input");
        if (e2 instanceof Uint8Array) {
          const t2 = e2, r2 = Array(t2.length);
          for (let e3 = 0; e3 < t2.length; e3++) {
            const i2 = t2[e3].toString(16);
            r2[e3] = t2[e3] <= 15 ? "0" + i2 : i2;
          }
          this.value = BigInt("0x0" + r2.join(""));
        } else
          this.value = BigInt(e2);
      }
      clone() {
        return new se(this.value);
      }
      iinc() {
        return this.value++, this;
      }
      inc() {
        return this.clone().iinc();
      }
      idec() {
        return this.value--, this;
      }
      dec() {
        return this.clone().idec();
      }
      iadd(e2) {
        return this.value += e2.value, this;
      }
      add(e2) {
        return this.clone().iadd(e2);
      }
      isub(e2) {
        return this.value -= e2.value, this;
      }
      sub(e2) {
        return this.clone().isub(e2);
      }
      imul(e2) {
        return this.value *= e2.value, this;
      }
      mul(e2) {
        return this.clone().imul(e2);
      }
      imod(e2) {
        return this.value %= e2.value, this.isNegative() && this.iadd(e2), this;
      }
      mod(e2) {
        return this.clone().imod(e2);
      }
      modExp(e2, t2) {
        if (t2.isZero())
          throw Error("Modulo cannot be zero");
        if (t2.isOne())
          return new se(0);
        if (e2.isNegative())
          throw Error("Unsopported negative exponent");
        let r2 = e2.value, i2 = this.value;
        i2 %= t2.value;
        let n2 = BigInt(1);
        for (; r2 > BigInt(0); ) {
          const e3 = r2 & BigInt(1);
          r2 >>= BigInt(1);
          const a2 = n2 * i2 % t2.value;
          n2 = e3 ? a2 : n2, i2 = i2 * i2 % t2.value;
        }
        return new se(n2);
      }
      modInv(e2) {
        const { gcd: t2, x: r2 } = this._egcd(e2);
        if (!t2.isOne())
          throw Error("Inverse does not exist");
        return r2.add(e2).mod(e2);
      }
      _egcd(e2) {
        let t2 = BigInt(0), r2 = BigInt(1), i2 = BigInt(1), n2 = BigInt(0), a2 = this.value;
        for (e2 = e2.value; e2 !== BigInt(0); ) {
          const s2 = a2 / e2;
          let o2 = t2;
          t2 = i2 - s2 * t2, i2 = o2, o2 = r2, r2 = n2 - s2 * r2, n2 = o2, o2 = e2, e2 = a2 % e2, a2 = o2;
        }
        return { x: new se(i2), y: new se(n2), gcd: new se(a2) };
      }
      gcd(e2) {
        let t2 = this.value;
        for (e2 = e2.value; e2 !== BigInt(0); ) {
          const r2 = e2;
          e2 = t2 % e2, t2 = r2;
        }
        return new se(t2);
      }
      ileftShift(e2) {
        return this.value <<= e2.value, this;
      }
      leftShift(e2) {
        return this.clone().ileftShift(e2);
      }
      irightShift(e2) {
        return this.value >>= e2.value, this;
      }
      rightShift(e2) {
        return this.clone().irightShift(e2);
      }
      equal(e2) {
        return this.value === e2.value;
      }
      lt(e2) {
        return this.value < e2.value;
      }
      lte(e2) {
        return this.value <= e2.value;
      }
      gt(e2) {
        return this.value > e2.value;
      }
      gte(e2) {
        return this.value >= e2.value;
      }
      isZero() {
        return this.value === BigInt(0);
      }
      isOne() {
        return this.value === BigInt(1);
      }
      isNegative() {
        return this.value < BigInt(0);
      }
      isEven() {
        return !(this.value & BigInt(1));
      }
      abs() {
        const e2 = this.clone();
        return this.isNegative() && (e2.value = -e2.value), e2;
      }
      toString() {
        return this.value.toString();
      }
      toNumber() {
        const e2 = Number(this.value);
        if (e2 > Number.MAX_SAFE_INTEGER)
          throw Error("Number can only safely store up to 53 bits");
        return e2;
      }
      getBit(e2) {
        return (this.value >> BigInt(e2) & BigInt(1)) === BigInt(0) ? 0 : 1;
      }
      bitLength() {
        const e2 = new se(0), t2 = new se(1), r2 = new se(-1), i2 = this.isNegative() ? r2 : e2;
        let n2 = 1;
        const a2 = this.clone();
        for (; !a2.irightShift(t2).equal(i2); )
          n2++;
        return n2;
      }
      byteLength() {
        const e2 = new se(0), t2 = new se(-1), r2 = this.isNegative() ? t2 : e2, i2 = new se(8);
        let n2 = 1;
        const a2 = this.clone();
        for (; !a2.irightShift(i2).equal(r2); )
          n2++;
        return n2;
      }
      toUint8Array(e2 = "be", t2) {
        let r2 = this.value.toString(16);
        r2.length % 2 == 1 && (r2 = "0" + r2);
        const i2 = r2.length / 2, n2 = new Uint8Array(t2 || i2), a2 = t2 ? t2 - i2 : 0;
        let s2 = 0;
        for (; s2 < i2; )
          n2[s2 + a2] = parseInt(r2.slice(2 * s2, 2 * s2 + 2), 16), s2++;
        return e2 !== "be" && n2.reverse(), n2;
      }
    };
    var oe = (() => {
      try {
        return process.env.NODE_ENV === "development";
      } catch (e2) {
      }
      return false;
    })();
    var ce = { isString: function(e2) {
      return typeof e2 == "string" || String.prototype.isPrototypeOf(e2);
    }, isArray: function(e2) {
      return Array.prototype.isPrototypeOf(e2);
    }, isUint8Array: P, isStream: E, readNumber: function(e2) {
      let t2 = 0;
      for (let r2 = 0; r2 < e2.length; r2++)
        t2 += 256 ** r2 * e2[e2.length - 1 - r2];
      return t2;
    }, writeNumber: function(e2, t2) {
      const r2 = new Uint8Array(t2);
      for (let i2 = 0; i2 < t2; i2++)
        r2[i2] = e2 >> 8 * (t2 - i2 - 1) & 255;
      return r2;
    }, readDate: function(e2) {
      const t2 = ce.readNumber(e2);
      return new Date(1e3 * t2);
    }, writeDate: function(e2) {
      const t2 = Math.floor(e2.getTime() / 1e3);
      return ce.writeNumber(t2, 4);
    }, normalizeDate: function(e2 = Date.now()) {
      return e2 === null || e2 === 1 / 0 ? e2 : new Date(1e3 * Math.floor(+e2 / 1e3));
    }, readMPI: function(e2) {
      const t2 = (e2[0] << 8 | e2[1]) + 7 >>> 3;
      return e2.subarray(2, 2 + t2);
    }, leftPad(e2, t2) {
      const r2 = new Uint8Array(t2), i2 = t2 - e2.length;
      return r2.set(e2, i2), r2;
    }, uint8ArrayToMPI: function(e2) {
      const t2 = ce.uint8ArrayBitLength(e2);
      if (t2 === 0)
        throw Error("Zero MPI");
      const r2 = e2.subarray(e2.length - Math.ceil(t2 / 8)), i2 = new Uint8Array([(65280 & t2) >> 8, 255 & t2]);
      return ce.concatUint8Array([i2, r2]);
    }, uint8ArrayBitLength: function(e2) {
      let t2;
      for (t2 = 0; t2 < e2.length && e2[t2] === 0; t2++)
        ;
      if (t2 === e2.length)
        return 0;
      const r2 = e2.subarray(t2);
      return 8 * (r2.length - 1) + ce.nbits(r2[0]);
    }, hexToUint8Array: function(e2) {
      const t2 = new Uint8Array(e2.length >> 1);
      for (let r2 = 0; r2 < e2.length >> 1; r2++)
        t2[r2] = parseInt(e2.substr(r2 << 1, 2), 16);
      return t2;
    }, uint8ArrayToHex: function(e2) {
      const t2 = [], r2 = e2.length;
      let i2, n2 = 0;
      for (; n2 < r2; ) {
        for (i2 = e2[n2++].toString(16); i2.length < 2; )
          i2 = "0" + i2;
        t2.push("" + i2);
      }
      return t2.join("");
    }, stringToUint8Array: function(e2) {
      return Y(e2, (e3) => {
        if (!ce.isString(e3))
          throw Error("stringToUint8Array: Data must be in the form of a string");
        const t2 = new Uint8Array(e3.length);
        for (let r2 = 0; r2 < e3.length; r2++)
          t2[r2] = e3.charCodeAt(r2);
        return t2;
      });
    }, uint8ArrayToString: function(e2) {
      const t2 = [], r2 = 16384, i2 = (e2 = new Uint8Array(e2)).length;
      for (let n2 = 0; n2 < i2; n2 += r2)
        t2.push(String.fromCharCode.apply(String, e2.subarray(n2, n2 + r2 < i2 ? n2 + r2 : i2)));
      return t2.join("");
    }, encodeUTF8: function(e2) {
      const t2 = new TextEncoder("utf-8");
      function r2(e3, r3 = false) {
        return t2.encode(e3, { stream: !r3 });
      }
      return Y(e2, r2, () => r2("", true));
    }, decodeUTF8: function(e2) {
      const t2 = new TextDecoder("utf-8");
      function r2(e3, r3 = false) {
        return t2.decode(e3, { stream: !r3 });
      }
      return Y(e2, r2, () => r2(new Uint8Array(), true));
    }, concat: W, concatUint8Array: x, equalsUint8Array: function(e2, t2) {
      if (!ce.isUint8Array(e2) || !ce.isUint8Array(t2))
        throw Error("Data must be in the form of a Uint8Array");
      if (e2.length !== t2.length)
        return false;
      for (let r2 = 0; r2 < e2.length; r2++)
        if (e2[r2] !== t2[r2])
          return false;
      return true;
    }, writeChecksum: function(e2) {
      let t2 = 0;
      for (let r2 = 0; r2 < e2.length; r2++)
        t2 = t2 + e2[r2] & 65535;
      return ce.writeNumber(t2, 2);
    }, printDebug: function(e2) {
      oe && console.log(e2);
    }, printDebugError: function(e2) {
      oe && console.error(e2);
    }, nbits: function(e2) {
      let t2 = 1, r2 = e2 >>> 16;
      return r2 !== 0 && (e2 = r2, t2 += 16), r2 = e2 >> 8, r2 !== 0 && (e2 = r2, t2 += 8), r2 = e2 >> 4, r2 !== 0 && (e2 = r2, t2 += 4), r2 = e2 >> 2, r2 !== 0 && (e2 = r2, t2 += 2), r2 = e2 >> 1, r2 !== 0 && (e2 = r2, t2 += 1), t2;
    }, double: function(e2) {
      const t2 = new Uint8Array(e2.length), r2 = e2.length - 1;
      for (let i2 = 0; i2 < r2; i2++)
        t2[i2] = e2[i2] << 1 ^ e2[i2 + 1] >> 7;
      return t2[r2] = e2[r2] << 1 ^ 135 * (e2[0] >> 7), t2;
    }, shiftRight: function(e2, t2) {
      if (t2)
        for (let r2 = e2.length - 1; r2 >= 0; r2--)
          e2[r2] >>= t2, r2 > 0 && (e2[r2] |= e2[r2 - 1] << 8 - t2);
      return e2;
    }, getWebCrypto: function() {
      return e !== void 0 && e.crypto && e.crypto.subtle;
    }, detectNode: function() {
      return typeof e.process == "object" && typeof e.process.versions == "object";
    }, detectBigInt: () => typeof BigInt != "undefined", getBigInteger: async function() {
      if (ce.detectBigInt())
        return se;
      {
        const { default: e2 } = await Promise.resolve().then(function() {
          return Dd;
        });
        return e2;
      }
    }, getNodeCrypto: function() {
      return f.default;
    }, getNodeZlib: function() {
      return d.default;
    }, getNodeBuffer: function() {
      return (u.default || {}).Buffer;
    }, getHardwareConcurrency: function() {
      if (ce.detectNode()) {
        return l.default.cpus().length;
      }
      return navigator.hardwareConcurrency || 1;
    }, isEmailAddress: function(e2) {
      if (!ce.isString(e2))
        return false;
      return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+([a-zA-Z]{2,}|xn--[a-zA-Z\-0-9]+)))$/.test(e2);
    }, canonicalizeEOL: function(e2) {
      let t2 = false;
      return Y(e2, (e3) => {
        let r2;
        t2 && (e3 = ce.concatUint8Array([new Uint8Array([13]), e3])), e3[e3.length - 1] === 13 ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
        const i2 = [];
        for (let t3 = 0; r2 = e3.indexOf(10, t3) + 1, r2; t3 = r2)
          e3[r2 - 2] !== 13 && i2.push(r2);
        if (!i2.length)
          return e3;
        const n2 = new Uint8Array(e3.length + i2.length);
        let a2 = 0;
        for (let t3 = 0; t3 < i2.length; t3++) {
          const r3 = e3.subarray(i2[t3 - 1] || 0, i2[t3]);
          n2.set(r3, a2), a2 += r3.length, n2[a2 - 1] = 13, n2[a2] = 10, a2++;
        }
        return n2.set(e3.subarray(i2[i2.length - 1] || 0), a2), n2;
      }, () => t2 ? new Uint8Array([13]) : void 0);
    }, nativeEOL: function(e2) {
      let t2 = false;
      return Y(e2, (e3) => {
        let r2;
        (e3 = t2 && e3[0] !== 10 ? ce.concatUint8Array([new Uint8Array([13]), e3]) : new Uint8Array(e3))[e3.length - 1] === 13 ? (t2 = true, e3 = e3.subarray(0, -1)) : t2 = false;
        let i2 = 0;
        for (let t3 = 0; t3 !== e3.length; t3 = r2) {
          r2 = e3.indexOf(13, t3) + 1, r2 || (r2 = e3.length);
          const n2 = r2 - (e3[r2] === 10 ? 1 : 0);
          t3 && e3.copyWithin(i2, t3, n2), i2 += n2 - t3;
        }
        return e3.subarray(0, i2);
      }, () => t2 ? new Uint8Array([13]) : void 0);
    }, removeTrailingSpaces: function(e2) {
      return e2.split("\n").map((e3) => {
        let t2 = e3.length - 1;
        for (; t2 >= 0 && (e3[t2] === " " || e3[t2] === "	"); t2--)
          ;
        return e3.substr(0, t2 + 1);
      }).join("\n");
    }, wrapError: function(e2, t2) {
      if (!t2)
        return Error(e2);
      try {
        t2.message = e2 + ": " + t2.message;
      } catch (e3) {
      }
      return t2;
    }, constructAllowedPackets: function(e2) {
      const t2 = {};
      return e2.forEach((e3) => {
        if (!e3.tag)
          throw Error("Invalid input: expected a packet class");
        t2[e3.tag] = e3;
      }), t2;
    }, anyPromise: function(e2) {
      return new Promise(async (t2, r2) => {
        let i2;
        await Promise.all(e2.map(async (e3) => {
          try {
            t2(await e3);
          } catch (e4) {
            i2 = e4;
          }
        })), r2(i2);
      });
    }, selectUint8Array: function(e2, t2, r2) {
      const i2 = Math.max(t2.length, r2.length), n2 = new Uint8Array(i2);
      let a2 = 0;
      for (let i3 = 0; i3 < n2.length; i3++)
        n2[i3] = t2[i3] & 256 - e2 | r2[i3] & 255 + e2, a2 += e2 & i3 < t2.length | 1 - e2 & i3 < r2.length;
      return n2.subarray(0, a2);
    }, selectUint8: function(e2, t2, r2) {
      return t2 & 256 - e2 | r2 & 255 + e2;
    } };
    var ue = ce.getNodeBuffer();
    var he;
    var fe;
    function de(e2) {
      let t2 = new Uint8Array();
      return Y(e2, (e3) => {
        t2 = ce.concatUint8Array([t2, e3]);
        const r2 = [], i2 = Math.floor(t2.length / 45), n2 = 45 * i2, a2 = he(t2.subarray(0, n2));
        for (let e4 = 0; e4 < i2; e4++)
          r2.push(a2.substr(60 * e4, 60)), r2.push("\n");
        return t2 = t2.subarray(n2), r2.join("");
      }, () => t2.length ? he(t2) + "\n" : "");
    }
    function le(e2) {
      let t2 = "";
      return Y(e2, (e3) => {
        t2 += e3;
        let r2 = 0;
        const i2 = [" ", "	", "\r", "\n"];
        for (let e4 = 0; e4 < i2.length; e4++) {
          const n3 = i2[e4];
          for (let e5 = t2.indexOf(n3); e5 !== -1; e5 = t2.indexOf(n3, e5 + 1))
            r2++;
        }
        let n2 = t2.length;
        for (; n2 > 0 && (n2 - r2) % 4 != 0; n2--)
          i2.includes(t2[n2]) && r2--;
        const a2 = fe(t2.substr(0, n2));
        return t2 = t2.substr(n2), a2;
      }, () => fe(t2));
    }
    function pe(e2) {
      return le(e2.replace(/-/g, "+").replace(/_/g, "/"));
    }
    function ye(e2, t2) {
      let r2 = de(e2).replace(/[\r\n]/g, "");
      return t2 && (r2 = r2.replace(/[+]/g, "-").replace(/[/]/g, "_").replace(/[=]/g, "")), r2;
    }
    ue ? (he = (e2) => ue.from(e2).toString("base64"), fe = (e2) => {
      const t2 = ue.from(e2, "base64");
      return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
    }) : (he = (e2) => btoa(ce.uint8ArrayToString(e2)), fe = (e2) => ce.stringToUint8Array(atob(e2)));
    var be = Symbol("byValue");
    var me = { curve: { p256: "p256", "P-256": "p256", secp256r1: "p256", prime256v1: "p256", "1.2.840.10045.3.1.7": "p256", "2a8648ce3d030107": "p256", "2A8648CE3D030107": "p256", p384: "p384", "P-384": "p384", secp384r1: "p384", "1.3.132.0.34": "p384", "2b81040022": "p384", "2B81040022": "p384", p521: "p521", "P-521": "p521", secp521r1: "p521", "1.3.132.0.35": "p521", "2b81040023": "p521", "2B81040023": "p521", secp256k1: "secp256k1", "1.3.132.0.10": "secp256k1", "2b8104000a": "secp256k1", "2B8104000A": "secp256k1", ED25519: "ed25519", ed25519: "ed25519", Ed25519: "ed25519", "1.3.6.1.4.1.11591.15.1": "ed25519", "2b06010401da470f01": "ed25519", "2B06010401DA470F01": "ed25519", X25519: "curve25519", cv25519: "curve25519", curve25519: "curve25519", Curve25519: "curve25519", "1.3.6.1.4.1.3029.1.5.1": "curve25519", "2b060104019755010501": "curve25519", "2B060104019755010501": "curve25519", brainpoolP256r1: "brainpoolP256r1", "1.3.36.3.3.2.8.1.1.7": "brainpoolP256r1", "2b2403030208010107": "brainpoolP256r1", "2B2403030208010107": "brainpoolP256r1", brainpoolP384r1: "brainpoolP384r1", "1.3.36.3.3.2.8.1.1.11": "brainpoolP384r1", "2b240303020801010b": "brainpoolP384r1", "2B240303020801010B": "brainpoolP384r1", brainpoolP512r1: "brainpoolP512r1", "1.3.36.3.3.2.8.1.1.13": "brainpoolP512r1", "2b240303020801010d": "brainpoolP512r1", "2B240303020801010D": "brainpoolP512r1" }, s2k: { simple: 0, salted: 1, iterated: 3, gnu: 101 }, publicKey: { rsaEncryptSign: 1, rsaEncrypt: 2, rsaSign: 3, elgamal: 16, dsa: 17, ecdh: 18, ecdsa: 19, eddsa: 22, aedh: 23, aedsa: 24 }, symmetric: { plaintext: 0, idea: 1, tripledes: 2, cast5: 3, blowfish: 4, aes128: 7, aes192: 8, aes256: 9, twofish: 10 }, compression: { uncompressed: 0, zip: 1, zlib: 2, bzip2: 3 }, hash: { md5: 1, sha1: 2, ripemd: 3, sha256: 8, sha384: 9, sha512: 10, sha224: 11 }, webHash: { "SHA-1": 2, "SHA-256": 8, "SHA-384": 9, "SHA-512": 10 }, aead: { eax: 1, ocb: 2, experimentalGCM: 100 }, packet: { publicKeyEncryptedSessionKey: 1, signature: 2, symEncryptedSessionKey: 3, onePassSignature: 4, secretKey: 5, publicKey: 6, secretSubkey: 7, compressedData: 8, symmetricallyEncryptedData: 9, marker: 10, literalData: 11, trust: 12, userID: 13, publicSubkey: 14, userAttribute: 17, symEncryptedIntegrityProtectedData: 18, modificationDetectionCode: 19, aeadEncryptedData: 20 }, literal: { binary: 98, text: 116, utf8: 117, mime: 109 }, signature: { binary: 0, text: 1, standalone: 2, certGeneric: 16, certPersona: 17, certCasual: 18, certPositive: 19, certRevocation: 48, subkeyBinding: 24, keyBinding: 25, key: 31, keyRevocation: 32, subkeyRevocation: 40, timestamp: 64, thirdParty: 80 }, signatureSubpacket: { signatureCreationTime: 2, signatureExpirationTime: 3, exportableCertification: 4, trustSignature: 5, regularExpression: 6, revocable: 7, keyExpirationTime: 9, placeholderBackwardsCompatibility: 10, preferredSymmetricAlgorithms: 11, revocationKey: 12, issuer: 16, notationData: 20, preferredHashAlgorithms: 21, preferredCompressionAlgorithms: 22, keyServerPreferences: 23, preferredKeyServer: 24, primaryUserID: 25, policyURI: 26, keyFlags: 27, signersUserID: 28, reasonForRevocation: 29, features: 30, signatureTarget: 31, embeddedSignature: 32, issuerFingerprint: 33, preferredAEADAlgorithms: 34 }, keyFlags: { certifyKeys: 1, signData: 2, encryptCommunication: 4, encryptStorage: 8, splitPrivateKey: 16, authentication: 32, sharedPrivateKey: 128 }, armor: { multipartSection: 0, multipartLast: 1, signed: 2, message: 3, publicKey: 4, privateKey: 5, signature: 6 }, reasonForRevocation: { noReason: 0, keySuperseded: 1, keyCompromised: 2, keyRetired: 3, userIDInvalid: 32 }, features: { modificationDetection: 1, aead: 2, v5Keys: 4 }, write: function(e2, t2) {
      if (typeof t2 == "number" && (t2 = this.read(e2, t2)), e2[t2] !== void 0)
        return e2[t2];
      throw Error("Invalid enum value.");
    }, read: function(e2, t2) {
      if (e2[be] || (e2[be] = [], Object.entries(e2).forEach(([t3, r2]) => {
        e2[be][r2] = t3;
      })), e2[be][t2] !== void 0)
        return e2[be][t2];
      throw Error("Invalid enum value.");
    } };
    var ge = { preferredHashAlgorithm: me.hash.sha256, preferredSymmetricAlgorithm: me.symmetric.aes256, preferredCompressionAlgorithm: me.compression.uncompressed, deflateLevel: 6, aeadProtect: false, preferredAEADAlgorithm: me.aead.eax, aeadChunkSizeByte: 12, v5Keys: false, s2kIterationCountByte: 224, allowUnauthenticatedMessages: false, allowUnauthenticatedStream: false, checksumRequired: false, minRSABits: 2047, passwordCollisionCheck: false, revocationsExpire: false, allowInsecureDecryptionWithSigningKeys: false, allowInsecureVerificationWithReformattedKeys: false, constantTimePKCS1Decryption: false, constantTimePKCS1DecryptionSupportedSymmetricAlgorithms: /* @__PURE__ */ new Set([me.symmetric.aes128, me.symmetric.aes192, me.symmetric.aes256]), minBytesForWebCrypto: 1e3, ignoreUnsupportedPackets: true, ignoreMalformedPackets: false, showVersion: false, showComment: false, versionString: "OpenPGP.js 5.1.0", commentString: "https://openpgpjs.org", maxUserIDLength: 5120, knownNotations: ["preferred-email-encoding@pgp.com", "pka-address@gnupg.org"], useIndutnyElliptic: true, rejectHashAlgorithms: /* @__PURE__ */ new Set([me.hash.md5, me.hash.ripemd]), rejectMessageHashAlgorithms: /* @__PURE__ */ new Set([me.hash.md5, me.hash.ripemd, me.hash.sha1]), rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set([me.publicKey.elgamal, me.publicKey.dsa]), rejectCurves: /* @__PURE__ */ new Set([me.curve.brainpoolP256r1, me.curve.brainpoolP384r1, me.curve.brainpoolP512r1, me.curve.secp256k1]) };
    function we(e2) {
      const t2 = e2.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);
      if (!t2)
        throw Error("Unknown ASCII armor type");
      return /MESSAGE, PART \d+\/\d+/.test(t2[1]) ? me.armor.multipartSection : /MESSAGE, PART \d+/.test(t2[1]) ? me.armor.multipartLast : /SIGNED MESSAGE/.test(t2[1]) ? me.armor.signed : /MESSAGE/.test(t2[1]) ? me.armor.message : /PUBLIC KEY BLOCK/.test(t2[1]) ? me.armor.publicKey : /PRIVATE KEY BLOCK/.test(t2[1]) ? me.armor.privateKey : /SIGNATURE/.test(t2[1]) ? me.armor.signature : void 0;
    }
    function ve(e2, t2) {
      let r2 = "";
      return t2.showVersion && (r2 += "Version: " + t2.versionString + "\n"), t2.showComment && (r2 += "Comment: " + t2.commentString + "\n"), e2 && (r2 += "Comment: " + e2 + "\n"), r2 += "\n", r2;
    }
    function _e(e2) {
      return de(function(e3) {
        let t2 = 13501623;
        return Y(e3, (e4) => {
          const r2 = Ae ? Math.floor(e4.length / 4) : 0, i2 = new Uint32Array(e4.buffer, e4.byteOffset, r2);
          for (let e5 = 0; e5 < r2; e5++)
            t2 ^= i2[e5], t2 = ke[0][t2 >> 24 & 255] ^ ke[1][t2 >> 16 & 255] ^ ke[2][t2 >> 8 & 255] ^ ke[3][t2 >> 0 & 255];
          for (let i3 = 4 * r2; i3 < e4.length; i3++)
            t2 = t2 >> 8 ^ ke[0][255 & t2 ^ e4[i3]];
        }, () => new Uint8Array([t2, t2 >> 8, t2 >> 16]));
      }(e2));
    }
    var ke = [Array(255), Array(255), Array(255), Array(255)];
    for (let e2 = 0; e2 <= 255; e2++) {
      let t2 = e2 << 16;
      for (let e3 = 0; e3 < 8; e3++)
        t2 = t2 << 1 ^ ((8388608 & t2) != 0 ? 8801531 : 0);
      ke[0][e2] = (16711680 & t2) >> 16 | 65280 & t2 | (255 & t2) << 16;
    }
    for (let e2 = 0; e2 <= 255; e2++)
      ke[1][e2] = ke[0][e2] >> 8 ^ ke[0][255 & ke[0][e2]];
    for (let e2 = 0; e2 <= 255; e2++)
      ke[2][e2] = ke[1][e2] >> 8 ^ ke[0][255 & ke[1][e2]];
    for (let e2 = 0; e2 <= 255; e2++)
      ke[3][e2] = ke[2][e2] >> 8 ^ ke[0][255 & ke[2][e2]];
    var Ae = function() {
      const e2 = new ArrayBuffer(2);
      return new DataView(e2).setInt16(0, 255, true), new Int16Array(e2)[0] === 255;
    }();
    function Se(e2) {
      for (let t2 = 0; t2 < e2.length; t2++) {
        if (!/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(e2[t2]))
          throw Error("Improperly formatted armor header: " + e2[t2]);
        /^(Version|Comment|MessageID|Hash|Charset): .+$/.test(e2[t2]) || ce.printDebugError(Error("Unknown header: " + e2[t2]));
      }
    }
    function Ee(e2) {
      let t2 = e2, r2 = "";
      const i2 = e2.lastIndexOf("=");
      return i2 >= 0 && i2 !== e2.length - 1 && (t2 = e2.slice(0, i2), r2 = e2.slice(i2 + 1).substr(0, 4)), { body: t2, checksum: r2 };
    }
    function Pe(e2, t2 = ge) {
      return new Promise(async (r2, i2) => {
        try {
          const n2 = /^-----[^-]+-----$/m, a2 = /^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;
          let s2;
          const o2 = [];
          let c2, u2, h2, f2 = o2, d2 = [], l2 = le(X(e2, async (e3, t3) => {
            const p2 = H(e3);
            try {
              for (; ; ) {
                let e4 = await p2.readLine();
                if (e4 === void 0)
                  throw Error("Misformed armored text");
                if (e4 = ce.removeTrailingSpaces(e4.replace(/[\r\n]/g, "")), s2)
                  if (c2)
                    u2 || s2 !== 2 || (n2.test(e4) ? (d2 = d2.join("\r\n"), u2 = true, Se(f2), f2 = [], c2 = false) : d2.push(e4.replace(/^- /, "")));
                  else if (n2.test(e4) && i2(Error("Mandatory blank line missing between armor headers and armor data")), a2.test(e4)) {
                    if (Se(f2), c2 = true, u2 || s2 !== 2) {
                      r2({ text: d2, data: l2, headers: o2, type: s2 });
                      break;
                    }
                  } else
                    f2.push(e4);
                else
                  n2.test(e4) && (s2 = we(e4));
              }
            } catch (e4) {
              return void i2(e4);
            }
            const y2 = G(t3);
            try {
              for (; ; ) {
                await y2.ready;
                const { done: e4, value: t4 } = await p2.read();
                if (e4)
                  throw Error("Misformed armored text");
                const r3 = t4 + "";
                if (r3.indexOf("=") !== -1 || r3.indexOf("-") !== -1) {
                  let e5 = await p2.readToEnd();
                  e5.length || (e5 = ""), e5 = r3 + e5, e5 = ce.removeTrailingSpaces(e5.replace(/\r/g, ""));
                  const t5 = e5.split(n2);
                  if (t5.length === 1)
                    throw Error("Misformed armored text");
                  const i3 = Ee(t5[0].slice(0, -1));
                  h2 = i3.checksum, await y2.write(i3.body);
                  break;
                }
                await y2.write(r3);
              }
              await y2.ready, await y2.close();
            } catch (e4) {
              await y2.abort(e4);
            }
          }));
          l2 = X(l2, async (e3, r3) => {
            const i3 = ie(_e(ee(e3)));
            i3.catch(() => {
            }), await V(e3, r3, { preventClose: true });
            const n3 = G(r3);
            try {
              const e4 = (await i3).replace("\n", "");
              if (h2 !== e4 && (h2 || t2.checksumRequired))
                throw Error("Ascii armor integrity check failed");
              await n3.ready, await n3.close();
            } catch (e4) {
              await n3.abort(e4);
            }
          });
        } catch (e3) {
          i2(e3);
        }
      }).then(async (e3) => (_(e3.data) && (e3.data = await ie(e3.data)), e3));
    }
    function xe(e2, t2, r2, i2, n2, a2 = ge) {
      let s2, o2;
      e2 === me.armor.signed && (s2 = t2.text, o2 = t2.hash, t2 = t2.data);
      const c2 = ee(t2), u2 = [];
      switch (e2) {
        case me.armor.multipartSection:
          u2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "/" + i2 + "-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP MESSAGE, PART " + r2 + "/" + i2 + "-----\n");
          break;
        case me.armor.multipartLast:
          u2.push("-----BEGIN PGP MESSAGE, PART " + r2 + "-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP MESSAGE, PART " + r2 + "-----\n");
          break;
        case me.armor.signed:
          u2.push("\n-----BEGIN PGP SIGNED MESSAGE-----\n"), u2.push("Hash: " + o2 + "\n\n"), u2.push(s2.replace(/^-/gm, "- -")), u2.push("\n-----BEGIN PGP SIGNATURE-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP SIGNATURE-----\n");
          break;
        case me.armor.message:
          u2.push("-----BEGIN PGP MESSAGE-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP MESSAGE-----\n");
          break;
        case me.armor.publicKey:
          u2.push("-----BEGIN PGP PUBLIC KEY BLOCK-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP PUBLIC KEY BLOCK-----\n");
          break;
        case me.armor.privateKey:
          u2.push("-----BEGIN PGP PRIVATE KEY BLOCK-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP PRIVATE KEY BLOCK-----\n");
          break;
        case me.armor.signature:
          u2.push("-----BEGIN PGP SIGNATURE-----\n"), u2.push(ve(n2, a2)), u2.push(de(t2)), u2.push("=", _e(c2)), u2.push("-----END PGP SIGNATURE-----\n");
      }
      return ce.concat(u2);
    }
    var Me = class {
      constructor() {
        this.bytes = "";
      }
      read(e2) {
        this.bytes = ce.uint8ArrayToString(e2.subarray(0, 8));
      }
      write() {
        return ce.stringToUint8Array(this.bytes);
      }
      toHex() {
        return ce.uint8ArrayToHex(ce.stringToUint8Array(this.bytes));
      }
      equals(e2, t2 = false) {
        return t2 && (e2.isWildcard() || this.isWildcard()) || this.bytes === e2.bytes;
      }
      isNull() {
        return this.bytes === "";
      }
      isWildcard() {
        return /^0+$/.test(this.toHex());
      }
      static mapToHex(e2) {
        return e2.toHex();
      }
      static fromID(e2) {
        const t2 = new Me();
        return t2.read(ce.hexToUint8Array(e2)), t2;
      }
      static wildcard() {
        const e2 = new Me();
        return e2.read(new Uint8Array(8)), e2;
      }
    };
    var Ce = function() {
      var e2, t2, r2 = false;
      function i2(r3, i3) {
        var n3 = e2[(t2[r3] + t2[i3]) % 255];
        return r3 !== 0 && i3 !== 0 || (n3 = 0), n3;
      }
      var n2, a2, s2, o2, c2 = false;
      function u2() {
        function u3(r3) {
          var i3, n3, a3;
          for (n3 = a3 = function(r4) {
            var i4 = e2[255 - t2[r4]];
            return r4 === 0 && (i4 = 0), i4;
          }(r3), i3 = 0; i3 < 4; i3++)
            a3 ^= n3 = 255 & (n3 << 1 | n3 >>> 7);
          return a3 ^= 99;
        }
        r2 || function() {
          e2 = [], t2 = [];
          var i3, n3, a3 = 1;
          for (i3 = 0; i3 < 255; i3++)
            e2[i3] = a3, n3 = 128 & a3, a3 <<= 1, a3 &= 255, n3 === 128 && (a3 ^= 27), a3 ^= e2[i3], t2[e2[i3]] = i3;
          e2[255] = e2[0], t2[0] = 0, r2 = true;
        }(), n2 = [], a2 = [], s2 = [[], [], [], []], o2 = [[], [], [], []];
        for (var h3 = 0; h3 < 256; h3++) {
          var f2 = u3(h3);
          n2[h3] = f2, a2[f2] = h3, s2[0][h3] = i2(2, f2) << 24 | f2 << 16 | f2 << 8 | i2(3, f2), o2[0][f2] = i2(14, h3) << 24 | i2(9, h3) << 16 | i2(13, h3) << 8 | i2(11, h3);
          for (var d2 = 1; d2 < 4; d2++)
            s2[d2][h3] = s2[d2 - 1][h3] >>> 8 | s2[d2 - 1][h3] << 24, o2[d2][f2] = o2[d2 - 1][f2] >>> 8 | o2[d2 - 1][f2] << 24;
        }
        c2 = true;
      }
      var h2 = function(e3, t3) {
        c2 || u2();
        var r3 = new Uint32Array(t3);
        r3.set(n2, 512), r3.set(a2, 768);
        for (var i3 = 0; i3 < 4; i3++)
          r3.set(s2[i3], 4096 + 1024 * i3 >> 2), r3.set(o2[i3], 8192 + 1024 * i3 >> 2);
        var h3 = function(e4, t4, r4) {
          ;
          var i4 = 0, n3 = 0, a3 = 0, s3 = 0, o3 = 0, c3 = 0, u3 = 0, h4 = 0, f2 = 0, d2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, m2 = 0, g2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0;
          var S2 = new e4.Uint32Array(r4), E2 = new e4.Uint8Array(r4);
          function P2(e5, t5, r5, o4, c4, u4, h5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            c4 = c4 | 0;
            u4 = u4 | 0;
            h5 = h5 | 0;
            f3 = f3 | 0;
            var d3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0, g3 = 0, w3 = 0;
            d3 = r5 | 1024, l3 = r5 | 2048, p3 = r5 | 3072;
            c4 = c4 ^ S2[(e5 | 0) >> 2], u4 = u4 ^ S2[(e5 | 4) >> 2], h5 = h5 ^ S2[(e5 | 8) >> 2], f3 = f3 ^ S2[(e5 | 12) >> 2];
            for (w3 = 16; (w3 | 0) <= o4 << 4; w3 = w3 + 16 | 0) {
              y3 = S2[(r5 | c4 >> 22 & 1020) >> 2] ^ S2[(d3 | u4 >> 14 & 1020) >> 2] ^ S2[(l3 | h5 >> 6 & 1020) >> 2] ^ S2[(p3 | f3 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 0) >> 2], b3 = S2[(r5 | u4 >> 22 & 1020) >> 2] ^ S2[(d3 | h5 >> 14 & 1020) >> 2] ^ S2[(l3 | f3 >> 6 & 1020) >> 2] ^ S2[(p3 | c4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 4) >> 2], m3 = S2[(r5 | h5 >> 22 & 1020) >> 2] ^ S2[(d3 | f3 >> 14 & 1020) >> 2] ^ S2[(l3 | c4 >> 6 & 1020) >> 2] ^ S2[(p3 | u4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 8) >> 2], g3 = S2[(r5 | f3 >> 22 & 1020) >> 2] ^ S2[(d3 | c4 >> 14 & 1020) >> 2] ^ S2[(l3 | u4 >> 6 & 1020) >> 2] ^ S2[(p3 | h5 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 12) >> 2];
              c4 = y3, u4 = b3, h5 = m3, f3 = g3;
            }
            i4 = S2[(t5 | c4 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | u4 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | h5 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | f3 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 0) >> 2], n3 = S2[(t5 | u4 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | h5 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | f3 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | c4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 4) >> 2], a3 = S2[(t5 | h5 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | f3 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | c4 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | u4 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 8) >> 2], s3 = S2[(t5 | f3 >> 22 & 1020) >> 2] << 24 ^ S2[(t5 | c4 >> 14 & 1020) >> 2] << 16 ^ S2[(t5 | u4 >> 6 & 1020) >> 2] << 8 ^ S2[(t5 | h5 << 2 & 1020) >> 2] ^ S2[(e5 | w3 | 12) >> 2];
          }
          function x2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            P2(0, 2048, 4096, A2, e5, t5, r5, i5);
          }
          function M2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            var a4 = 0;
            P2(1024, 3072, 8192, A2, e5, i5, r5, t5);
            a4 = n3, n3 = s3, s3 = a4;
          }
          function C2(e5, t5, r5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            f3 = f3 | 0;
            P2(0, 2048, 4096, A2, o3 ^ e5, c3 ^ t5, u3 ^ r5, h4 ^ f3);
            o3 = i4, c3 = n3, u3 = a3, h4 = s3;
          }
          function K2(e5, t5, r5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            f3 = f3 | 0;
            var d3 = 0;
            P2(1024, 3072, 8192, A2, e5, f3, r5, t5);
            d3 = n3, n3 = s3, s3 = d3;
            i4 = i4 ^ o3, n3 = n3 ^ c3, a3 = a3 ^ u3, s3 = s3 ^ h4;
            o3 = e5, c3 = t5, u3 = r5, h4 = f3;
          }
          function D2(e5, t5, r5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            f3 = f3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            o3 = i4 = i4 ^ e5, c3 = n3 = n3 ^ t5, u3 = a3 = a3 ^ r5, h4 = s3 = s3 ^ f3;
          }
          function R2(e5, t5, r5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            f3 = f3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            i4 = i4 ^ e5, n3 = n3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ f3;
            o3 = e5, c3 = t5, u3 = r5, h4 = f3;
          }
          function I2(e5, t5, r5, f3) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            f3 = f3 | 0;
            P2(0, 2048, 4096, A2, o3, c3, u3, h4);
            o3 = i4, c3 = n3, u3 = a3, h4 = s3;
            i4 = i4 ^ e5, n3 = n3 ^ t5, a3 = a3 ^ r5, s3 = s3 ^ f3;
          }
          function U2(e5, t5, r5, o4) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            P2(0, 2048, 4096, A2, f2, d2, l2, p2);
            p2 = ~g2 & p2 | g2 & p2 + 1;
            l2 = ~m2 & l2 | m2 & l2 + ((p2 | 0) == 0);
            d2 = ~b2 & d2 | b2 & d2 + ((l2 | 0) == 0);
            f2 = ~y2 & f2 | y2 & f2 + ((d2 | 0) == 0);
            i4 = i4 ^ e5;
            n3 = n3 ^ t5;
            a3 = a3 ^ r5;
            s3 = s3 ^ o4;
          }
          function B2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            var n4 = 0, a4 = 0, s4 = 0, f3 = 0, d3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0;
            e5 = e5 ^ o3, t5 = t5 ^ c3, r5 = r5 ^ u3, i5 = i5 ^ h4;
            n4 = w2 | 0, a4 = v2 | 0, s4 = _2 | 0, f3 = k2 | 0;
            for (; (b3 | 0) < 128; b3 = b3 + 1 | 0) {
              if (n4 >>> 31) {
                d3 = d3 ^ e5, l3 = l3 ^ t5, p3 = p3 ^ r5, y3 = y3 ^ i5;
              }
              n4 = n4 << 1 | a4 >>> 31, a4 = a4 << 1 | s4 >>> 31, s4 = s4 << 1 | f3 >>> 31, f3 = f3 << 1;
              m3 = i5 & 1;
              i5 = i5 >>> 1 | r5 << 31, r5 = r5 >>> 1 | t5 << 31, t5 = t5 >>> 1 | e5 << 31, e5 = e5 >>> 1;
              if (m3)
                e5 = e5 ^ 3774873600;
            }
            o3 = d3, c3 = l3, u3 = p3, h4 = y3;
          }
          function T2(e5) {
            e5 = e5 | 0;
            A2 = e5;
          }
          function z2(e5, t5, r5, o4) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            o4 = o4 | 0;
            i4 = e5, n3 = t5, a3 = r5, s3 = o4;
          }
          function q2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            o3 = e5, c3 = t5, u3 = r5, h4 = i5;
          }
          function O2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            f2 = e5, d2 = t5, l2 = r5, p2 = i5;
          }
          function F2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            y2 = e5, b2 = t5, m2 = r5, g2 = i5;
          }
          function N2(e5, t5, r5, i5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            i5 = i5 | 0;
            p2 = ~g2 & p2 | g2 & i5, l2 = ~m2 & l2 | m2 & r5, d2 = ~b2 & d2 | b2 & t5, f2 = ~y2 & f2 | y2 & e5;
          }
          function j2(e5) {
            e5 = e5 | 0;
            if (e5 & 15)
              return -1;
            E2[e5 | 0] = i4 >>> 24, E2[e5 | 1] = i4 >>> 16 & 255, E2[e5 | 2] = i4 >>> 8 & 255, E2[e5 | 3] = i4 & 255, E2[e5 | 4] = n3 >>> 24, E2[e5 | 5] = n3 >>> 16 & 255, E2[e5 | 6] = n3 >>> 8 & 255, E2[e5 | 7] = n3 & 255, E2[e5 | 8] = a3 >>> 24, E2[e5 | 9] = a3 >>> 16 & 255, E2[e5 | 10] = a3 >>> 8 & 255, E2[e5 | 11] = a3 & 255, E2[e5 | 12] = s3 >>> 24, E2[e5 | 13] = s3 >>> 16 & 255, E2[e5 | 14] = s3 >>> 8 & 255, E2[e5 | 15] = s3 & 255;
            return 16;
          }
          function L2(e5) {
            e5 = e5 | 0;
            if (e5 & 15)
              return -1;
            E2[e5 | 0] = o3 >>> 24, E2[e5 | 1] = o3 >>> 16 & 255, E2[e5 | 2] = o3 >>> 8 & 255, E2[e5 | 3] = o3 & 255, E2[e5 | 4] = c3 >>> 24, E2[e5 | 5] = c3 >>> 16 & 255, E2[e5 | 6] = c3 >>> 8 & 255, E2[e5 | 7] = c3 & 255, E2[e5 | 8] = u3 >>> 24, E2[e5 | 9] = u3 >>> 16 & 255, E2[e5 | 10] = u3 >>> 8 & 255, E2[e5 | 11] = u3 & 255, E2[e5 | 12] = h4 >>> 24, E2[e5 | 13] = h4 >>> 16 & 255, E2[e5 | 14] = h4 >>> 8 & 255, E2[e5 | 15] = h4 & 255;
            return 16;
          }
          function W2() {
            x2(0, 0, 0, 0);
            w2 = i4, v2 = n3, _2 = a3, k2 = s3;
          }
          function H2(e5, t5, r5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            var o4 = 0;
            if (t5 & 15)
              return -1;
            while ((r5 | 0) >= 16) {
              V2[e5 & 7](E2[t5 | 0] << 24 | E2[t5 | 1] << 16 | E2[t5 | 2] << 8 | E2[t5 | 3], E2[t5 | 4] << 24 | E2[t5 | 5] << 16 | E2[t5 | 6] << 8 | E2[t5 | 7], E2[t5 | 8] << 24 | E2[t5 | 9] << 16 | E2[t5 | 10] << 8 | E2[t5 | 11], E2[t5 | 12] << 24 | E2[t5 | 13] << 16 | E2[t5 | 14] << 8 | E2[t5 | 15]);
              E2[t5 | 0] = i4 >>> 24, E2[t5 | 1] = i4 >>> 16 & 255, E2[t5 | 2] = i4 >>> 8 & 255, E2[t5 | 3] = i4 & 255, E2[t5 | 4] = n3 >>> 24, E2[t5 | 5] = n3 >>> 16 & 255, E2[t5 | 6] = n3 >>> 8 & 255, E2[t5 | 7] = n3 & 255, E2[t5 | 8] = a3 >>> 24, E2[t5 | 9] = a3 >>> 16 & 255, E2[t5 | 10] = a3 >>> 8 & 255, E2[t5 | 11] = a3 & 255, E2[t5 | 12] = s3 >>> 24, E2[t5 | 13] = s3 >>> 16 & 255, E2[t5 | 14] = s3 >>> 8 & 255, E2[t5 | 15] = s3 & 255;
              o4 = o4 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
            }
            return o4 | 0;
          }
          function G2(e5, t5, r5) {
            e5 = e5 | 0;
            t5 = t5 | 0;
            r5 = r5 | 0;
            var i5 = 0;
            if (t5 & 15)
              return -1;
            while ((r5 | 0) >= 16) {
              $2[e5 & 1](E2[t5 | 0] << 24 | E2[t5 | 1] << 16 | E2[t5 | 2] << 8 | E2[t5 | 3], E2[t5 | 4] << 24 | E2[t5 | 5] << 16 | E2[t5 | 6] << 8 | E2[t5 | 7], E2[t5 | 8] << 24 | E2[t5 | 9] << 16 | E2[t5 | 10] << 8 | E2[t5 | 11], E2[t5 | 12] << 24 | E2[t5 | 13] << 16 | E2[t5 | 14] << 8 | E2[t5 | 15]);
              i5 = i5 + 16 | 0, t5 = t5 + 16 | 0, r5 = r5 - 16 | 0;
            }
            return i5 | 0;
          }
          var V2 = [x2, M2, C2, K2, D2, R2, I2, U2];
          var $2 = [C2, B2];
          return { set_rounds: T2, set_state: z2, set_iv: q2, set_nonce: O2, set_mask: F2, set_counter: N2, get_state: j2, get_iv: L2, gcm_init: W2, cipher: H2, mac: G2 };
        }({ Uint8Array, Uint32Array }, e3, t3);
        return h3.set_key = function(e4, t4, i4, a3, s3, c3, u3, f2, d2) {
          var l2 = r3.subarray(0, 60), p2 = r3.subarray(256, 316);
          l2.set([t4, i4, a3, s3, c3, u3, f2, d2]);
          for (var y2 = e4, b2 = 1; y2 < 4 * e4 + 28; y2++) {
            var m2 = l2[y2 - 1];
            (y2 % e4 == 0 || e4 === 8 && y2 % e4 == 4) && (m2 = n2[m2 >>> 24] << 24 ^ n2[m2 >>> 16 & 255] << 16 ^ n2[m2 >>> 8 & 255] << 8 ^ n2[255 & m2]), y2 % e4 == 0 && (m2 = m2 << 8 ^ m2 >>> 24 ^ b2 << 24, b2 = b2 << 1 ^ (128 & b2 ? 27 : 0)), l2[y2] = l2[y2 - e4] ^ m2;
          }
          for (var g2 = 0; g2 < y2; g2 += 4)
            for (var w2 = 0; w2 < 4; w2++) {
              m2 = l2[y2 - (4 + g2) + (4 - w2) % 4];
              p2[g2 + w2] = g2 < 4 || g2 >= y2 - 4 ? m2 : o2[0][n2[m2 >>> 24]] ^ o2[1][n2[m2 >>> 16 & 255]] ^ o2[2][n2[m2 >>> 8 & 255]] ^ o2[3][n2[255 & m2]];
            }
          h3.set_rounds(e4 + 5);
        }, h3;
      };
      return h2.ENC = { ECB: 0, CBC: 2, CFB: 4, OFB: 6, CTR: 7 }, h2.DEC = { ECB: 1, CBC: 3, CFB: 5, OFB: 6, CTR: 7 }, h2.MAC = { CBC: 0, GCM: 1 }, h2.HEAP_DATA = 16384, h2;
    }();
    function Ke(e2) {
      return e2 instanceof Uint8Array;
    }
    function De(e2, t2) {
      const r2 = e2 ? e2.byteLength : t2 || 65536;
      if (4095 & r2 || r2 <= 0)
        throw Error("heap size must be a positive integer and a multiple of 4096");
      return e2 = e2 || new Uint8Array(new ArrayBuffer(r2));
    }
    function Re(e2, t2, r2, i2, n2) {
      const a2 = e2.length - t2, s2 = a2 < n2 ? a2 : n2;
      return e2.set(r2.subarray(i2, i2 + s2), t2), s2;
    }
    function Ie(...e2) {
      const t2 = e2.reduce((e3, t3) => e3 + t3.length, 0), r2 = new Uint8Array(t2);
      let i2 = 0;
      for (let t3 = 0; t3 < e2.length; t3++)
        r2.set(e2[t3], i2), i2 += e2[t3].length;
      return r2;
    }
    var Ue = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var Be = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var Te = class extends Error {
      constructor(...e2) {
        super(...e2);
      }
    };
    var ze = [];
    var qe = [];
    var Oe = class {
      constructor(e2, t2, r2 = true, i2, n2, a2) {
        this.pos = 0, this.len = 0, this.mode = i2, this.pos = 0, this.len = 0, this.key = e2, this.iv = t2, this.padding = r2, this.acquire_asm(n2, a2);
      }
      acquire_asm(e2, t2) {
        return this.heap !== void 0 && this.asm !== void 0 || (this.heap = e2 || ze.pop() || De().subarray(Ce.HEAP_DATA), this.asm = t2 || qe.pop() || new Ce(null, this.heap.buffer), this.reset(this.key, this.iv)), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        this.heap !== void 0 && this.asm !== void 0 && (ze.push(this.heap), qe.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      reset(e2, t2) {
        const { asm: r2 } = this.acquire_asm(), i2 = e2.length;
        if (i2 !== 16 && i2 !== 24 && i2 !== 32)
          throw new Be("illegal key size");
        const n2 = new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
        if (r2.set_key(i2 >> 2, n2.getUint32(0), n2.getUint32(4), n2.getUint32(8), n2.getUint32(12), i2 > 16 ? n2.getUint32(16) : 0, i2 > 16 ? n2.getUint32(20) : 0, i2 > 24 ? n2.getUint32(24) : 0, i2 > 24 ? n2.getUint32(28) : 0), t2 !== void 0) {
          if (t2.length !== 16)
            throw new Be("illegal iv size");
          let e3 = new DataView(t2.buffer, t2.byteOffset, t2.byteLength);
          r2.set_iv(e3.getUint32(0), e3.getUint32(4), e3.getUint32(8), e3.getUint32(12));
        } else
          r2.set_iv(0, 0, 0, 0);
      }
      AES_Encrypt_process(e2) {
        if (!Ke(e2))
          throw new TypeError("data isn't of expected type");
        let { heap: t2, asm: r2 } = this.acquire_asm(), i2 = Ce.ENC[this.mode], n2 = Ce.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, u2 = 0, h2 = 0, f2 = new Uint8Array(s2 + c2 & -16);
        for (; c2 > 0; )
          h2 = Re(t2, a2 + s2, e2, o2, c2), s2 += h2, o2 += h2, c2 -= h2, h2 = r2.cipher(i2, n2 + a2, s2), h2 && f2.set(t2.subarray(a2, a2 + h2), u2), u2 += h2, h2 < s2 ? (a2 += h2, s2 -= h2) : (a2 = 0, s2 = 0);
        return this.pos = a2, this.len = s2, f2;
      }
      AES_Encrypt_finish() {
        let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = Ce.ENC[this.mode], i2 = Ce.HEAP_DATA, n2 = this.pos, a2 = this.len, s2 = 16 - a2 % 16, o2 = a2;
        if (this.hasOwnProperty("padding")) {
          if (this.padding) {
            for (let t3 = 0; t3 < s2; ++t3)
              e2[n2 + a2 + t3] = s2;
            a2 += s2, o2 = a2;
          } else if (a2 % 16)
            throw new Be("data length must be a multiple of the block size");
        } else
          a2 += s2;
        const c2 = new Uint8Array(o2);
        return a2 && t2.cipher(r2, i2 + n2, a2), o2 && c2.set(e2.subarray(n2, n2 + o2)), this.pos = 0, this.len = 0, this.release_asm(), c2;
      }
      AES_Decrypt_process(e2) {
        if (!Ke(e2))
          throw new TypeError("data isn't of expected type");
        let { heap: t2, asm: r2 } = this.acquire_asm(), i2 = Ce.DEC[this.mode], n2 = Ce.HEAP_DATA, a2 = this.pos, s2 = this.len, o2 = 0, c2 = e2.length || 0, u2 = 0, h2 = s2 + c2 & -16, f2 = 0, d2 = 0;
        this.padding && (f2 = s2 + c2 - h2 || 16, h2 -= f2);
        const l2 = new Uint8Array(h2);
        for (; c2 > 0; )
          d2 = Re(t2, a2 + s2, e2, o2, c2), s2 += d2, o2 += d2, c2 -= d2, d2 = r2.cipher(i2, n2 + a2, s2 - (c2 ? 0 : f2)), d2 && l2.set(t2.subarray(a2, a2 + d2), u2), u2 += d2, d2 < s2 ? (a2 += d2, s2 -= d2) : (a2 = 0, s2 = 0);
        return this.pos = a2, this.len = s2, l2;
      }
      AES_Decrypt_finish() {
        let { heap: e2, asm: t2 } = this.acquire_asm(), r2 = Ce.DEC[this.mode], i2 = Ce.HEAP_DATA, n2 = this.pos, a2 = this.len, s2 = a2;
        if (a2 > 0) {
          if (a2 % 16) {
            if (this.hasOwnProperty("padding"))
              throw new Be("data length must be a multiple of the block size");
            a2 += 16 - a2 % 16;
          }
          if (t2.cipher(r2, i2 + n2, a2), this.hasOwnProperty("padding") && this.padding) {
            let t3 = e2[n2 + s2 - 1];
            if (t3 < 1 || t3 > 16 || t3 > s2)
              throw new Te("bad padding");
            let r3 = 0;
            for (let i3 = t3; i3 > 1; i3--)
              r3 |= t3 ^ e2[n2 + s2 - i3];
            if (r3)
              throw new Te("bad padding");
            s2 -= t3;
          }
        }
        const o2 = new Uint8Array(s2);
        return s2 > 0 && o2.set(e2.subarray(n2, n2 + s2)), this.pos = 0, this.len = 0, this.release_asm(), o2;
      }
    };
    var Fe = class {
      static encrypt(e2, t2, r2 = false) {
        return new Fe(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2 = false) {
        return new Fe(t2, r2).decrypt(e2);
      }
      constructor(e2, t2 = false, r2) {
        this.aes = r2 || new Oe(e2, void 0, t2, "ECB");
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    function Ne(e2) {
      const t2 = function(e3) {
        const t3 = new Fe(e3);
        this.encrypt = function(e4) {
          return t3.encrypt(e4);
        }, this.decrypt = function(e4) {
          return t3.decrypt(e4);
        };
      };
      return t2.blockSize = t2.prototype.blockSize = 16, t2.keySize = t2.prototype.keySize = e2 / 8, t2;
    }
    function je(e2, t2, r2, i2, n2, a2) {
      const s2 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], o2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], c2 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], u2 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], h2 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], f2 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], d2 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], l2 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
      let p2, y2, b2, m2, g2, w2, v2, _2, k2, A2, S2, E2, P2, x2, M2 = 0, C2 = t2.length;
      const K2 = e2.length === 32 ? 3 : 9;
      _2 = K2 === 3 ? r2 ? [0, 32, 2] : [30, -2, -2] : r2 ? [0, 32, 2, 62, 30, -2, 64, 96, 2] : [94, 62, -2, 32, 64, 2, 30, -2, -2], r2 && (C2 = (t2 = function(e3, t3) {
        const r3 = 8 - e3.length % 8;
        let i3;
        if (t3 === 2 && r3 < 8)
          i3 = 32;
        else if (t3 === 1)
          i3 = r3;
        else {
          if (t3 || !(r3 < 8)) {
            if (r3 === 8)
              return e3;
            throw Error("des: invalid padding");
          }
          i3 = 0;
        }
        const n3 = new Uint8Array(e3.length + r3);
        for (let t4 = 0; t4 < e3.length; t4++)
          n3[t4] = e3[t4];
        for (let t4 = 0; t4 < r3; t4++)
          n3[e3.length + t4] = i3;
        return n3;
      }(t2, a2)).length);
      let D2 = new Uint8Array(C2), R2 = 0;
      for (i2 === 1 && (k2 = n2[M2++] << 24 | n2[M2++] << 16 | n2[M2++] << 8 | n2[M2++], S2 = n2[M2++] << 24 | n2[M2++] << 16 | n2[M2++] << 8 | n2[M2++], M2 = 0); M2 < C2; ) {
        for (w2 = t2[M2++] << 24 | t2[M2++] << 16 | t2[M2++] << 8 | t2[M2++], v2 = t2[M2++] << 24 | t2[M2++] << 16 | t2[M2++] << 8 | t2[M2++], i2 === 1 && (r2 ? (w2 ^= k2, v2 ^= S2) : (A2 = k2, E2 = S2, k2 = w2, S2 = v2)), b2 = 252645135 & (w2 >>> 4 ^ v2), v2 ^= b2, w2 ^= b2 << 4, b2 = 65535 & (w2 >>> 16 ^ v2), v2 ^= b2, w2 ^= b2 << 16, b2 = 858993459 & (v2 >>> 2 ^ w2), w2 ^= b2, v2 ^= b2 << 2, b2 = 16711935 & (v2 >>> 8 ^ w2), w2 ^= b2, v2 ^= b2 << 8, b2 = 1431655765 & (w2 >>> 1 ^ v2), v2 ^= b2, w2 ^= b2 << 1, w2 = w2 << 1 | w2 >>> 31, v2 = v2 << 1 | v2 >>> 31, y2 = 0; y2 < K2; y2 += 3) {
          for (P2 = _2[y2 + 1], x2 = _2[y2 + 2], p2 = _2[y2]; p2 !== P2; p2 += x2)
            m2 = v2 ^ e2[p2], g2 = (v2 >>> 4 | v2 << 28) ^ e2[p2 + 1], b2 = w2, w2 = v2, v2 = b2 ^ (o2[m2 >>> 24 & 63] | u2[m2 >>> 16 & 63] | f2[m2 >>> 8 & 63] | l2[63 & m2] | s2[g2 >>> 24 & 63] | c2[g2 >>> 16 & 63] | h2[g2 >>> 8 & 63] | d2[63 & g2]);
          b2 = w2, w2 = v2, v2 = b2;
        }
        w2 = w2 >>> 1 | w2 << 31, v2 = v2 >>> 1 | v2 << 31, b2 = 1431655765 & (w2 >>> 1 ^ v2), v2 ^= b2, w2 ^= b2 << 1, b2 = 16711935 & (v2 >>> 8 ^ w2), w2 ^= b2, v2 ^= b2 << 8, b2 = 858993459 & (v2 >>> 2 ^ w2), w2 ^= b2, v2 ^= b2 << 2, b2 = 65535 & (w2 >>> 16 ^ v2), v2 ^= b2, w2 ^= b2 << 16, b2 = 252645135 & (w2 >>> 4 ^ v2), v2 ^= b2, w2 ^= b2 << 4, i2 === 1 && (r2 ? (k2 = w2, S2 = v2) : (w2 ^= A2, v2 ^= E2)), D2[R2++] = w2 >>> 24, D2[R2++] = w2 >>> 16 & 255, D2[R2++] = w2 >>> 8 & 255, D2[R2++] = 255 & w2, D2[R2++] = v2 >>> 24, D2[R2++] = v2 >>> 16 & 255, D2[R2++] = v2 >>> 8 & 255, D2[R2++] = 255 & v2;
      }
      return r2 || (D2 = function(e3, t3) {
        let r3, i3 = null;
        if (t3 === 2)
          r3 = 32;
        else if (t3 === 1)
          i3 = e3[e3.length - 1];
        else {
          if (t3)
            throw Error("des: invalid padding");
          r3 = 0;
        }
        if (!i3) {
          for (i3 = 1; e3[e3.length - i3] === r3; )
            i3++;
          i3--;
        }
        return e3.subarray(0, e3.length - i3);
      }(D2, a2)), D2;
    }
    function Le(e2) {
      const t2 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], r2 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], i2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], n2 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], a2 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], s2 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], o2 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], c2 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], u2 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], h2 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], f2 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], d2 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], l2 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], p2 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], y2 = e2.length > 8 ? 3 : 1, b2 = Array(32 * y2), m2 = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      let g2, w2, v2, _2 = 0, k2 = 0;
      for (let A2 = 0; A2 < y2; A2++) {
        let y3 = e2[_2++] << 24 | e2[_2++] << 16 | e2[_2++] << 8 | e2[_2++], A3 = e2[_2++] << 24 | e2[_2++] << 16 | e2[_2++] << 8 | e2[_2++];
        v2 = 252645135 & (y3 >>> 4 ^ A3), A3 ^= v2, y3 ^= v2 << 4, v2 = 65535 & (A3 >>> -16 ^ y3), y3 ^= v2, A3 ^= v2 << -16, v2 = 858993459 & (y3 >>> 2 ^ A3), A3 ^= v2, y3 ^= v2 << 2, v2 = 65535 & (A3 >>> -16 ^ y3), y3 ^= v2, A3 ^= v2 << -16, v2 = 1431655765 & (y3 >>> 1 ^ A3), A3 ^= v2, y3 ^= v2 << 1, v2 = 16711935 & (A3 >>> 8 ^ y3), y3 ^= v2, A3 ^= v2 << 8, v2 = 1431655765 & (y3 >>> 1 ^ A3), A3 ^= v2, y3 ^= v2 << 1, v2 = y3 << 8 | A3 >>> 20 & 240, y3 = A3 << 24 | A3 << 8 & 16711680 | A3 >>> 8 & 65280 | A3 >>> 24 & 240, A3 = v2;
        for (let e3 = 0; e3 < 16; e3++)
          m2[e3] ? (y3 = y3 << 2 | y3 >>> 26, A3 = A3 << 2 | A3 >>> 26) : (y3 = y3 << 1 | y3 >>> 27, A3 = A3 << 1 | A3 >>> 27), y3 &= -15, A3 &= -15, g2 = t2[y3 >>> 28] | r2[y3 >>> 24 & 15] | i2[y3 >>> 20 & 15] | n2[y3 >>> 16 & 15] | a2[y3 >>> 12 & 15] | s2[y3 >>> 8 & 15] | o2[y3 >>> 4 & 15], w2 = c2[A3 >>> 28] | u2[A3 >>> 24 & 15] | h2[A3 >>> 20 & 15] | f2[A3 >>> 16 & 15] | d2[A3 >>> 12 & 15] | l2[A3 >>> 8 & 15] | p2[A3 >>> 4 & 15], v2 = 65535 & (w2 >>> 16 ^ g2), b2[k2++] = g2 ^ v2, b2[k2++] = w2 ^ v2 << 16;
      }
      return b2;
    }
    function We(e2) {
      this.key = [];
      for (let t2 = 0; t2 < 3; t2++)
        this.key.push(new Uint8Array(e2.subarray(8 * t2, 8 * t2 + 8)));
      this.encrypt = function(e3) {
        return je(Le(this.key[2]), je(Le(this.key[1]), je(Le(this.key[0]), e3, true, 0, null, null), false, 0, null, null), true, 0, null, null);
      };
    }
    function He() {
      this.BlockSize = 8, this.KeySize = 16, this.setKey = function(e3) {
        if (this.masking = Array(16), this.rotate = Array(16), this.reset(), e3.length !== this.KeySize)
          throw Error("CAST-128: keys must be 16 bytes");
        return this.keySchedule(e3), true;
      }, this.reset = function() {
        for (let e3 = 0; e3 < 16; e3++)
          this.masking[e3] = 0, this.rotate[e3] = 0;
      }, this.getBlockSize = function() {
        return this.BlockSize;
      }, this.encrypt = function(e3) {
        const t3 = Array(e3.length);
        for (let a3 = 0; a3 < e3.length; a3 += 8) {
          let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
          s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >>> 16 & 255, t3[a3 + 6] = o2 >>> 8 & 255, t3[a3 + 7] = 255 & o2;
        }
        return t3;
      }, this.decrypt = function(e3) {
        const t3 = Array(e3.length);
        for (let a3 = 0; a3 < e3.length; a3 += 8) {
          let s2, o2 = e3[a3] << 24 | e3[a3 + 1] << 16 | e3[a3 + 2] << 8 | e3[a3 + 3], c2 = e3[a3 + 4] << 24 | e3[a3 + 5] << 16 | e3[a3 + 6] << 8 | e3[a3 + 7];
          s2 = c2, c2 = o2 ^ r2(c2, this.masking[15], this.rotate[15]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[14], this.rotate[14]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[13], this.rotate[13]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[12], this.rotate[12]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[11], this.rotate[11]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[10], this.rotate[10]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[9], this.rotate[9]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[8], this.rotate[8]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[7], this.rotate[7]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[6], this.rotate[6]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[5], this.rotate[5]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[4], this.rotate[4]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[3], this.rotate[3]), o2 = s2, s2 = c2, c2 = o2 ^ n2(c2, this.masking[2], this.rotate[2]), o2 = s2, s2 = c2, c2 = o2 ^ i2(c2, this.masking[1], this.rotate[1]), o2 = s2, s2 = c2, c2 = o2 ^ r2(c2, this.masking[0], this.rotate[0]), o2 = s2, t3[a3] = c2 >>> 24 & 255, t3[a3 + 1] = c2 >>> 16 & 255, t3[a3 + 2] = c2 >>> 8 & 255, t3[a3 + 3] = 255 & c2, t3[a3 + 4] = o2 >>> 24 & 255, t3[a3 + 5] = o2 >> 16 & 255, t3[a3 + 6] = o2 >> 8 & 255, t3[a3 + 7] = 255 & o2;
        }
        return t3;
      };
      const e2 = [, , , ,];
      e2[0] = [, , , ,], e2[0][0] = [4, 0, 13, 15, 12, 14, 8], e2[0][1] = [5, 2, 16, 18, 17, 19, 10], e2[0][2] = [6, 3, 23, 22, 21, 20, 9], e2[0][3] = [7, 1, 26, 25, 27, 24, 11], e2[1] = [, , , ,], e2[1][0] = [0, 6, 21, 23, 20, 22, 16], e2[1][1] = [1, 4, 0, 2, 1, 3, 18], e2[1][2] = [2, 5, 7, 6, 5, 4, 17], e2[1][3] = [3, 7, 10, 9, 11, 8, 19], e2[2] = [, , , ,], e2[2][0] = [4, 0, 13, 15, 12, 14, 8], e2[2][1] = [5, 2, 16, 18, 17, 19, 10], e2[2][2] = [6, 3, 23, 22, 21, 20, 9], e2[2][3] = [7, 1, 26, 25, 27, 24, 11], e2[3] = [, , , ,], e2[3][0] = [0, 6, 21, 23, 20, 22, 16], e2[3][1] = [1, 4, 0, 2, 1, 3, 18], e2[3][2] = [2, 5, 7, 6, 5, 4, 17], e2[3][3] = [3, 7, 10, 9, 11, 8, 19];
      const t2 = [, , , ,];
      function r2(e3, t3, r3) {
        const i3 = t3 + e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return (a2[0][n3 >>> 24] ^ a2[1][n3 >>> 16 & 255]) - a2[2][n3 >>> 8 & 255] + a2[3][255 & n3];
      }
      function i2(e3, t3, r3) {
        const i3 = t3 ^ e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return a2[0][n3 >>> 24] - a2[1][n3 >>> 16 & 255] + a2[2][n3 >>> 8 & 255] ^ a2[3][255 & n3];
      }
      function n2(e3, t3, r3) {
        const i3 = t3 - e3, n3 = i3 << r3 | i3 >>> 32 - r3;
        return (a2[0][n3 >>> 24] + a2[1][n3 >>> 16 & 255] ^ a2[2][n3 >>> 8 & 255]) - a2[3][255 & n3];
      }
      t2[0] = [, , , ,], t2[0][0] = [24, 25, 23, 22, 18], t2[0][1] = [26, 27, 21, 20, 22], t2[0][2] = [28, 29, 19, 18, 25], t2[0][3] = [30, 31, 17, 16, 28], t2[1] = [, , , ,], t2[1][0] = [3, 2, 12, 13, 8], t2[1][1] = [1, 0, 14, 15, 13], t2[1][2] = [7, 6, 8, 9, 3], t2[1][3] = [5, 4, 10, 11, 7], t2[2] = [, , , ,], t2[2][0] = [19, 18, 28, 29, 25], t2[2][1] = [17, 16, 30, 31, 28], t2[2][2] = [23, 22, 24, 25, 18], t2[2][3] = [21, 20, 26, 27, 22], t2[3] = [, , , ,], t2[3][0] = [8, 9, 7, 6, 3], t2[3][1] = [10, 11, 5, 4, 7], t2[3][2] = [12, 13, 3, 2, 8], t2[3][3] = [14, 15, 1, 0, 13], this.keySchedule = function(r3) {
        const i3 = [, , , , , , , ,], n3 = Array(32);
        let s2;
        for (let e3 = 0; e3 < 4; e3++)
          s2 = 4 * e3, i3[e3] = r3[s2] << 24 | r3[s2 + 1] << 16 | r3[s2 + 2] << 8 | r3[s2 + 3];
        const o2 = [6, 7, 4, 5];
        let c2, u2 = 0;
        for (let r4 = 0; r4 < 2; r4++)
          for (let r5 = 0; r5 < 4; r5++) {
            for (s2 = 0; s2 < 4; s2++) {
              const t3 = e2[r5][s2];
              c2 = i3[t3[1]], c2 ^= a2[4][i3[t3[2] >>> 2] >>> 24 - 8 * (3 & t3[2]) & 255], c2 ^= a2[5][i3[t3[3] >>> 2] >>> 24 - 8 * (3 & t3[3]) & 255], c2 ^= a2[6][i3[t3[4] >>> 2] >>> 24 - 8 * (3 & t3[4]) & 255], c2 ^= a2[7][i3[t3[5] >>> 2] >>> 24 - 8 * (3 & t3[5]) & 255], c2 ^= a2[o2[s2]][i3[t3[6] >>> 2] >>> 24 - 8 * (3 & t3[6]) & 255], i3[t3[0]] = c2;
            }
            for (s2 = 0; s2 < 4; s2++) {
              const e3 = t2[r5][s2];
              c2 = a2[4][i3[e3[0] >>> 2] >>> 24 - 8 * (3 & e3[0]) & 255], c2 ^= a2[5][i3[e3[1] >>> 2] >>> 24 - 8 * (3 & e3[1]) & 255], c2 ^= a2[6][i3[e3[2] >>> 2] >>> 24 - 8 * (3 & e3[2]) & 255], c2 ^= a2[7][i3[e3[3] >>> 2] >>> 24 - 8 * (3 & e3[3]) & 255], c2 ^= a2[4 + s2][i3[e3[4] >>> 2] >>> 24 - 8 * (3 & e3[4]) & 255], n3[u2] = c2, u2++;
            }
          }
        for (let e3 = 0; e3 < 16; e3++)
          this.masking[e3] = n3[e3], this.rotate[e3] = 31 & n3[16 + e3];
      };
      const a2 = [, , , , , , , ,];
      a2[0] = [821772500, 2678128395, 1810681135, 1059425402, 505495343, 2617265619, 1610868032, 3483355465, 3218386727, 2294005173, 3791863952, 2563806837, 1852023008, 365126098, 3269944861, 584384398, 677919599, 3229601881, 4280515016, 2002735330, 1136869587, 3744433750, 2289869850, 2731719981, 2714362070, 879511577, 1639411079, 575934255, 717107937, 2857637483, 576097850, 2731753936, 1725645e3, 2810460463, 5111599, 767152862, 2543075244, 1251459544, 1383482551, 3052681127, 3089939183, 3612463449, 1878520045, 1510570527, 2189125840, 2431448366, 582008916, 3163445557, 1265446783, 1354458274, 3529918736, 3202711853, 3073581712, 3912963487, 3029263377, 1275016285, 4249207360, 2905708351, 3304509486, 1442611557, 3585198765, 2712415662, 2731849581, 3248163920, 2283946226, 208555832, 2766454743, 1331405426, 1447828783, 3315356441, 3108627284, 2957404670, 2981538698, 3339933917, 1669711173, 286233437, 1465092821, 1782121619, 3862771680, 710211251, 980974943, 1651941557, 430374111, 2051154026, 704238805, 4128970897, 3144820574, 2857402727, 948965521, 3333752299, 2227686284, 718756367, 2269778983, 2731643755, 718440111, 2857816721, 3616097120, 1113355533, 2478022182, 410092745, 1811985197, 1944238868, 2696854588, 1415722873, 1682284203, 1060277122, 1998114690, 1503841958, 82706478, 2315155686, 1068173648, 845149890, 2167947013, 1768146376, 1993038550, 3566826697, 3390574031, 940016341, 3355073782, 2328040721, 904371731, 1205506512, 4094660742, 2816623006, 825647681, 85914773, 2857843460, 1249926541, 1417871568, 3287612, 3211054559, 3126306446, 1975924523, 1353700161, 2814456437, 2438597621, 1800716203, 722146342, 2873936343, 1151126914, 4160483941, 2877670899, 458611604, 2866078500, 3483680063, 770352098, 2652916994, 3367839148, 3940505011, 3585973912, 3809620402, 718646636, 2504206814, 2914927912, 3631288169, 2857486607, 2860018678, 575749918, 2857478043, 718488780, 2069512688, 3548183469, 453416197, 1106044049, 3032691430, 52586708, 3378514636, 3459808877, 3211506028, 1785789304, 218356169, 3571399134, 3759170522, 1194783844, 1523787992, 3007827094, 1975193539, 2555452411, 1341901877, 3045838698, 3776907964, 3217423946, 2802510864, 2889438986, 1057244207, 1636348243, 3761863214, 1462225785, 2632663439, 481089165, 718503062, 24497053, 3332243209, 3344655856, 3655024856, 3960371065, 1195698900, 2971415156, 3710176158, 2115785917, 4027663609, 3525578417, 2524296189, 2745972565, 3564906415, 1372086093, 1452307862, 2780501478, 1476592880, 3389271281, 18495466, 2378148571, 901398090, 891748256, 3279637769, 3157290713, 2560960102, 1447622437, 4284372637, 216884176, 2086908623, 1879786977, 3588903153, 2242455666, 2938092967, 3559082096, 2810645491, 758861177, 1121993112, 215018983, 642190776, 4169236812, 1196255959, 2081185372, 3508738393, 941322904, 4124243163, 2877523539, 1848581667, 2205260958, 3180453958, 2589345134, 3694731276, 550028657, 2519456284, 3789985535, 2973870856, 2093648313, 443148163, 46942275, 2734146937, 1117713533, 1115362972, 1523183689, 3717140224, 1551984063], a2[1] = [522195092, 4010518363, 1776537470, 960447360, 4267822970, 4005896314, 1435016340, 1929119313, 2913464185, 1310552629, 3579470798, 3724818106, 2579771631, 1594623892, 417127293, 2715217907, 2696228731, 1508390405, 3994398868, 3925858569, 3695444102, 4019471449, 3129199795, 3770928635, 3520741761, 990456497, 4187484609, 2783367035, 21106139, 3840405339, 631373633, 3783325702, 532942976, 396095098, 3548038825, 4267192484, 2564721535, 2011709262, 2039648873, 620404603, 3776170075, 2898526339, 3612357925, 4159332703, 1645490516, 223693667, 1567101217, 3362177881, 1029951347, 3470931136, 3570957959, 1550265121, 119497089, 972513919, 907948164, 3840628539, 1613718692, 3594177948, 465323573, 2659255085, 654439692, 2575596212, 2699288441, 3127702412, 277098644, 624404830, 4100943870, 2717858591, 546110314, 2403699828, 3655377447, 1321679412, 4236791657, 1045293279, 4010672264, 895050893, 2319792268, 494945126, 1914543101, 2777056443, 3894764339, 2219737618, 311263384, 4275257268, 3458730721, 669096869, 3584475730, 3835122877, 3319158237, 3949359204, 2005142349, 2713102337, 2228954793, 3769984788, 569394103, 3855636576, 1425027204, 108000370, 2736431443, 3671869269, 3043122623, 1750473702, 2211081108, 762237499, 3972989403, 2798899386, 3061857628, 2943854345, 867476300, 964413654, 1591880597, 1594774276, 2179821409, 552026980, 3026064248, 3726140315, 2283577634, 3110545105, 2152310760, 582474363, 1582640421, 1383256631, 2043843868, 3322775884, 1217180674, 463797851, 2763038571, 480777679, 2718707717, 2289164131, 3118346187, 214354409, 200212307, 3810608407, 3025414197, 2674075964, 3997296425, 1847405948, 1342460550, 510035443, 4080271814, 815934613, 833030224, 1620250387, 1945732119, 2703661145, 3966000196, 1388869545, 3456054182, 2687178561, 2092620194, 562037615, 1356438536, 3409922145, 3261847397, 1688467115, 2150901366, 631725691, 3840332284, 549916902, 3455104640, 394546491, 837744717, 2114462948, 751520235, 2221554606, 2415360136, 3999097078, 2063029875, 803036379, 2702586305, 821456707, 3019566164, 360699898, 4018502092, 3511869016, 3677355358, 2402471449, 812317050, 49299192, 2570164949, 3259169295, 2816732080, 3331213574, 3101303564, 2156015656, 3705598920, 3546263921, 143268808, 3200304480, 1638124008, 3165189453, 3341807610, 578956953, 2193977524, 3638120073, 2333881532, 807278310, 658237817, 2969561766, 1641658566, 11683945, 3086995007, 148645947, 1138423386, 4158756760, 1981396783, 2401016740, 3699783584, 380097457, 2680394679, 2803068651, 3334260286, 441530178, 4016580796, 1375954390, 761952171, 891809099, 2183123478, 157052462, 3683840763, 1592404427, 341349109, 2438483839, 1417898363, 644327628, 2233032776, 2353769706, 2201510100, 220455161, 1815641738, 182899273, 2995019788, 3627381533, 3702638151, 2890684138, 1052606899, 588164016, 1681439879, 4038439418, 2405343923, 4229449282, 167996282, 1336969661, 1688053129, 2739224926, 1543734051, 1046297529, 1138201970, 2121126012, 115334942, 1819067631, 1902159161, 1941945968, 2206692869, 1159982321], a2[2] = [2381300288, 637164959, 3952098751, 3893414151, 1197506559, 916448331, 2350892612, 2932787856, 3199334847, 4009478890, 3905886544, 1373570990, 2450425862, 4037870920, 3778841987, 2456817877, 286293407, 124026297, 3001279700, 1028597854, 3115296800, 4208886496, 2691114635, 2188540206, 1430237888, 1218109995, 3572471700, 308166588, 570424558, 2187009021, 2455094765, 307733056, 1310360322, 3135275007, 1384269543, 2388071438, 863238079, 2359263624, 2801553128, 3380786597, 2831162807, 1470087780, 1728663345, 4072488799, 1090516929, 532123132, 2389430977, 1132193179, 2578464191, 3051079243, 1670234342, 1434557849, 2711078940, 1241591150, 3314043432, 3435360113, 3091448339, 1812415473, 2198440252, 267246943, 796911696, 3619716990, 38830015, 1526438404, 2806502096, 374413614, 2943401790, 1489179520, 1603809326, 1920779204, 168801282, 260042626, 2358705581, 1563175598, 2397674057, 1356499128, 2217211040, 514611088, 2037363785, 2186468373, 4022173083, 2792511869, 2913485016, 1173701892, 4200428547, 3896427269, 1334932762, 2455136706, 602925377, 2835607854, 1613172210, 41346230, 2499634548, 2457437618, 2188827595, 41386358, 4172255629, 1313404830, 2405527007, 3801973774, 2217704835, 873260488, 2528884354, 2478092616, 4012915883, 2555359016, 2006953883, 2463913485, 575479328, 2218240648, 2099895446, 660001756, 2341502190, 3038761536, 3888151779, 3848713377, 3286851934, 1022894237, 1620365795, 3449594689, 1551255054, 15374395, 3570825345, 4249311020, 4151111129, 3181912732, 310226346, 1133119310, 530038928, 136043402, 2476768958, 3107506709, 2544909567, 1036173560, 2367337196, 1681395281, 1758231547, 3641649032, 306774401, 1575354324, 3716085866, 1990386196, 3114533736, 2455606671, 1262092282, 3124342505, 2768229131, 4210529083, 1833535011, 423410938, 660763973, 2187129978, 1639812e3, 3508421329, 3467445492, 310289298, 272797111, 2188552562, 2456863912, 310240523, 677093832, 1013118031, 901835429, 3892695601, 1116285435, 3036471170, 1337354835, 243122523, 520626091, 277223598, 4244441197, 4194248841, 1766575121, 594173102, 316590669, 742362309, 3536858622, 4176435350, 3838792410, 2501204839, 1229605004, 3115755532, 1552908988, 2312334149, 979407927, 3959474601, 1148277331, 176638793, 3614686272, 2083809052, 40992502, 1340822838, 2731552767, 3535757508, 3560899520, 1354035053, 122129617, 7215240, 2732932949, 3118912700, 2718203926, 2539075635, 3609230695, 3725561661, 1928887091, 2882293555, 1988674909, 2063640240, 2491088897, 1459647954, 4189817080, 2302804382, 1113892351, 2237858528, 1927010603, 4002880361, 1856122846, 1594404395, 2944033133, 3855189863, 3474975698, 1643104450, 4054590833, 3431086530, 1730235576, 2984608721, 3084664418, 2131803598, 4178205752, 267404349, 1617849798, 1616132681, 1462223176, 736725533, 2327058232, 551665188, 2945899023, 1749386277, 2575514597, 1611482493, 674206544, 2201269090, 3642560800, 728599968, 1680547377, 2620414464, 1388111496, 453204106, 4156223445, 1094905244, 2754698257, 2201108165, 3757000246, 2704524545, 3922940700, 3996465027], a2[3] = [2645754912, 532081118, 2814278639, 3530793624, 1246723035, 1689095255, 2236679235, 4194438865, 2116582143, 3859789411, 157234593, 2045505824, 4245003587, 1687664561, 4083425123, 605965023, 672431967, 1336064205, 3376611392, 214114848, 4258466608, 3232053071, 489488601, 605322005, 3998028058, 264917351, 1912574028, 756637694, 436560991, 202637054, 135989450, 85393697, 2152923392, 3896401662, 2895836408, 2145855233, 3535335007, 115294817, 3147733898, 1922296357, 3464822751, 4117858305, 1037454084, 2725193275, 2127856640, 1417604070, 1148013728, 1827919605, 642362335, 2929772533, 909348033, 1346338451, 3547799649, 297154785, 1917849091, 4161712827, 2883604526, 3968694238, 1469521537, 3780077382, 3375584256, 1763717519, 136166297, 4290970789, 1295325189, 2134727907, 2798151366, 1566297257, 3672928234, 2677174161, 2672173615, 965822077, 2780786062, 289653839, 1133871874, 3491843819, 35685304, 1068898316, 418943774, 672553190, 642281022, 2346158704, 1954014401, 3037126780, 4079815205, 2030668546, 3840588673, 672283427, 1776201016, 359975446, 3750173538, 555499703, 2769985273, 1324923, 69110472, 152125443, 3176785106, 3822147285, 1340634837, 798073664, 1434183902, 15393959, 216384236, 1303690150, 3881221631, 3711134124, 3960975413, 106373927, 2578434224, 1455997841, 1801814300, 1578393881, 1854262133, 3188178946, 3258078583, 2302670060, 1539295533, 3505142565, 3078625975, 2372746020, 549938159, 3278284284, 2620926080, 181285381, 2865321098, 3970029511, 68876850, 488006234, 1728155692, 2608167508, 836007927, 2435231793, 919367643, 3339422534, 3655756360, 1457871481, 40520939, 1380155135, 797931188, 234455205, 2255801827, 3990488299, 397000196, 739833055, 3077865373, 2871719860, 4022553888, 772369276, 390177364, 3853951029, 557662966, 740064294, 1640166671, 1699928825, 3535942136, 622006121, 3625353122, 68743880, 1742502, 219489963, 1664179233, 1577743084, 1236991741, 410585305, 2366487942, 823226535, 1050371084, 3426619607, 3586839478, 212779912, 4147118561, 1819446015, 1911218849, 530248558, 3486241071, 3252585495, 2886188651, 3410272728, 2342195030, 20547779, 2982490058, 3032363469, 3631753222, 312714466, 1870521650, 1493008054, 3491686656, 615382978, 4103671749, 2534517445, 1932181, 2196105170, 278426614, 6369430, 3274544417, 2913018367, 697336853, 2143000447, 2946413531, 701099306, 1558357093, 2805003052, 3500818408, 2321334417, 3567135975, 216290473, 3591032198, 23009561, 1996984579, 3735042806, 2024298078, 3739440863, 569400510, 2339758983, 3016033873, 3097871343, 3639523026, 3844324983, 3256173865, 795471839, 2951117563, 4101031090, 4091603803, 3603732598, 971261452, 534414648, 428311343, 3389027175, 2844869880, 694888862, 1227866773, 2456207019, 3043454569, 2614353370, 3749578031, 3676663836, 459166190, 4132644070, 1794958188, 51825668, 2252611902, 3084671440, 2036672799, 3436641603, 1099053433, 2469121526, 3059204941, 1323291266, 2061838604, 1018778475, 2233344254, 2553501054, 334295216, 3556750194, 1065731521, 183467730], a2[4] = [2127105028, 745436345, 2601412319, 2788391185, 3093987327, 500390133, 1155374404, 389092991, 150729210, 3891597772, 3523549952, 1935325696, 716645080, 946045387, 2901812282, 1774124410, 3869435775, 4039581901, 3293136918, 3438657920, 948246080, 363898952, 3867875531, 1286266623, 1598556673, 68334250, 630723836, 1104211938, 1312863373, 613332731, 2377784574, 1101634306, 441780740, 3129959883, 1917973735, 2510624549, 3238456535, 2544211978, 3308894634, 1299840618, 4076074851, 1756332096, 3977027158, 297047435, 3790297736, 2265573040, 3621810518, 1311375015, 1667687725, 47300608, 3299642885, 2474112369, 201668394, 1468347890, 576830978, 3594690761, 3742605952, 1958042578, 1747032512, 3558991340, 1408974056, 3366841779, 682131401, 1033214337, 1545599232, 4265137049, 206503691, 103024618, 2855227313, 1337551222, 2428998917, 2963842932, 4015366655, 3852247746, 2796956967, 3865723491, 3747938335, 247794022, 3755824572, 702416469, 2434691994, 397379957, 851939612, 2314769512, 218229120, 1380406772, 62274761, 214451378, 3170103466, 2276210409, 3845813286, 28563499, 446592073, 1693330814, 3453727194, 29968656, 3093872512, 220656637, 2470637031, 77972100, 1667708854, 1358280214, 4064765667, 2395616961, 325977563, 4277240721, 4220025399, 3605526484, 3355147721, 811859167, 3069544926, 3962126810, 652502677, 3075892249, 4132761541, 3498924215, 1217549313, 3250244479, 3858715919, 3053989961, 1538642152, 2279026266, 2875879137, 574252750, 3324769229, 2651358713, 1758150215, 141295887, 2719868960, 3515574750, 4093007735, 4194485238, 1082055363, 3417560400, 395511885, 2966884026, 179534037, 3646028556, 3738688086, 1092926436, 2496269142, 257381841, 3772900718, 1636087230, 1477059743, 2499234752, 3811018894, 2675660129, 3285975680, 90732309, 1684827095, 1150307763, 1723134115, 3237045386, 1769919919, 1240018934, 815675215, 750138730, 2239792499, 1234303040, 1995484674, 138143821, 675421338, 1145607174, 1936608440, 3238603024, 2345230278, 2105974004, 323969391, 779555213, 3004902369, 2861610098, 1017501463, 2098600890, 2628620304, 2940611490, 2682542546, 1171473753, 3656571411, 3687208071, 4091869518, 393037935, 159126506, 1662887367, 1147106178, 391545844, 3452332695, 1891500680, 3016609650, 1851642611, 546529401, 1167818917, 3194020571, 2848076033, 3953471836, 575554290, 475796850, 4134673196, 450035699, 2351251534, 844027695, 1080539133, 86184846, 1554234488, 3692025454, 1972511363, 2018339607, 1491841390, 1141460869, 1061690759, 4244549243, 2008416118, 2351104703, 2868147542, 1598468138, 722020353, 1027143159, 212344630, 1387219594, 1725294528, 3745187956, 2500153616, 458938280, 4129215917, 1828119673, 544571780, 3503225445, 2297937496, 1241802790, 267843827, 2694610800, 1397140384, 1558801448, 3782667683, 1806446719, 929573330, 2234912681, 400817706, 616011623, 4121520928, 3603768725, 1761550015, 1968522284, 4053731006, 4192232858, 4005120285, 872482584, 3140537016, 3894607381, 2287405443, 1963876937, 3663887957, 1584857e3, 2975024454, 1833426440, 4025083860], a2[5] = [4143615901, 749497569, 1285769319, 3795025788, 2514159847, 23610292, 3974978748, 844452780, 3214870880, 3751928557, 2213566365, 1676510905, 448177848, 3730751033, 4086298418, 2307502392, 871450977, 3222878141, 4110862042, 3831651966, 2735270553, 1310974780, 2043402188, 1218528103, 2736035353, 4274605013, 2702448458, 3936360550, 2693061421, 162023535, 2827510090, 687910808, 23484817, 3784910947, 3371371616, 779677500, 3503626546, 3473927188, 4157212626, 3500679282, 4248902014, 2466621104, 3899384794, 1958663117, 925738300, 1283408968, 3669349440, 1840910019, 137959847, 2679828185, 1239142320, 1315376211, 1547541505, 1690155329, 739140458, 3128809933, 3933172616, 3876308834, 905091803, 1548541325, 4040461708, 3095483362, 144808038, 451078856, 676114313, 2861728291, 2469707347, 993665471, 373509091, 2599041286, 4025009006, 4170239449, 2149739950, 3275793571, 3749616649, 2794760199, 1534877388, 572371878, 2590613551, 1753320020, 3467782511, 1405125690, 4270405205, 633333386, 3026356924, 3475123903, 632057672, 2846462855, 1404951397, 3882875879, 3915906424, 195638627, 2385783745, 3902872553, 1233155085, 3355999740, 2380578713, 2702246304, 2144565621, 3663341248, 3894384975, 2502479241, 4248018925, 3094885567, 1594115437, 572884632, 3385116731, 767645374, 1331858858, 1475698373, 3793881790, 3532746431, 1321687957, 619889600, 1121017241, 3440213920, 2070816767, 2833025776, 1933951238, 4095615791, 890643334, 3874130214, 859025556, 360630002, 925594799, 1764062180, 3920222280, 4078305929, 979562269, 2810700344, 4087740022, 1949714515, 546639971, 1165388173, 3069891591, 1495988560, 922170659, 1291546247, 2107952832, 1813327274, 3406010024, 3306028637, 4241950635, 153207855, 2313154747, 1608695416, 1150242611, 1967526857, 721801357, 1220138373, 3691287617, 3356069787, 2112743302, 3281662835, 1111556101, 1778980689, 250857638, 2298507990, 673216130, 2846488510, 3207751581, 3562756981, 3008625920, 3417367384, 2198807050, 529510932, 3547516680, 3426503187, 2364944742, 102533054, 2294910856, 1617093527, 1204784762, 3066581635, 1019391227, 1069574518, 1317995090, 1691889997, 3661132003, 510022745, 3238594800, 1362108837, 1817929911, 2184153760, 805817662, 1953603311, 3699844737, 120799444, 2118332377, 207536705, 2282301548, 4120041617, 145305846, 2508124933, 3086745533, 3261524335, 1877257368, 2977164480, 3160454186, 2503252186, 4221677074, 759945014, 254147243, 2767453419, 3801518371, 629083197, 2471014217, 907280572, 3900796746, 940896768, 2751021123, 2625262786, 3161476951, 3661752313, 3260732218, 1425318020, 2977912069, 1496677566, 3988592072, 2140652971, 3126511541, 3069632175, 977771578, 1392695845, 1698528874, 1411812681, 1369733098, 1343739227, 3620887944, 1142123638, 67414216, 3102056737, 3088749194, 1626167401, 2546293654, 3941374235, 697522451, 33404913, 143560186, 2595682037, 994885535, 1247667115, 3859094837, 2699155541, 3547024625, 4114935275, 2968073508, 3199963069, 2732024527, 1237921620, 951448369, 1898488916, 1211705605, 2790989240, 2233243581, 3598044975], a2[6] = [2246066201, 858518887, 1714274303, 3485882003, 713916271, 2879113490, 3730835617, 539548191, 36158695, 1298409750, 419087104, 1358007170, 749914897, 2989680476, 1261868530, 2995193822, 2690628854, 3443622377, 3780124940, 3796824509, 2976433025, 4259637129, 1551479e3, 512490819, 1296650241, 951993153, 2436689437, 2460458047, 144139966, 3136204276, 310820559, 3068840729, 643875328, 1969602020, 1680088954, 2185813161, 3283332454, 672358534, 198762408, 896343282, 276269502, 3014846926, 84060815, 197145886, 376173866, 3943890818, 3813173521, 3545068822, 1316698879, 1598252827, 2633424951, 1233235075, 859989710, 2358460855, 3503838400, 3409603720, 1203513385, 1193654839, 2792018475, 2060853022, 207403770, 1144516871, 3068631394, 1121114134, 177607304, 3785736302, 326409831, 1929119770, 2983279095, 4183308101, 3474579288, 3200513878, 3228482096, 119610148, 1170376745, 3378393471, 3163473169, 951863017, 3337026068, 3135789130, 2907618374, 1183797387, 2015970143, 4045674555, 2182986399, 2952138740, 3928772205, 384012900, 2454997643, 10178499, 2879818989, 2596892536, 111523738, 2995089006, 451689641, 3196290696, 235406569, 1441906262, 3890558523, 3013735005, 4158569349, 1644036924, 376726067, 1006849064, 3664579700, 2041234796, 1021632941, 1374734338, 2566452058, 371631263, 4007144233, 490221539, 206551450, 3140638584, 1053219195, 1853335209, 3412429660, 3562156231, 735133835, 1623211703, 3104214392, 2738312436, 4096837757, 3366392578, 3110964274, 3956598718, 3196820781, 2038037254, 3877786376, 2339753847, 300912036, 3766732888, 2372630639, 1516443558, 4200396704, 1574567987, 4069441456, 4122592016, 2699739776, 146372218, 2748961456, 2043888151, 35287437, 2596680554, 655490400, 1132482787, 110692520, 1031794116, 2188192751, 1324057718, 1217253157, 919197030, 686247489, 3261139658, 1028237775, 3135486431, 3059715558, 2460921700, 986174950, 2661811465, 4062904701, 2752986992, 3709736643, 367056889, 1353824391, 731860949, 1650113154, 1778481506, 784341916, 357075625, 3608602432, 1074092588, 2480052770, 3811426202, 92751289, 877911070, 3600361838, 1231880047, 480201094, 3756190983, 3094495953, 434011822, 87971354, 363687820, 1717726236, 1901380172, 3926403882, 2481662265, 400339184, 1490350766, 2661455099, 1389319756, 2558787174, 784598401, 1983468483, 30828846, 3550527752, 2716276238, 3841122214, 1765724805, 1955612312, 1277890269, 1333098070, 1564029816, 2704417615, 1026694237, 3287671188, 1260819201, 3349086767, 1016692350, 1582273796, 1073413053, 1995943182, 694588404, 1025494639, 3323872702, 3551898420, 4146854327, 453260480, 1316140391, 1435673405, 3038941953, 3486689407, 1622062951, 403978347, 817677117, 950059133, 4246079218, 3278066075, 1486738320, 1417279718, 481875527, 2549965225, 3933690356, 760697757, 1452955855, 3897451437, 1177426808, 1702951038, 4085348628, 2447005172, 1084371187, 3516436277, 3068336338, 1073369276, 1027665953, 3284188590, 1230553676, 1368340146, 2226246512, 267243139, 2274220762, 4070734279, 2497715176, 2423353163, 2504755875], a2[7] = [3793104909, 3151888380, 2817252029, 895778965, 2005530807, 3871412763, 237245952, 86829237, 296341424, 3851759377, 3974600970, 2475086196, 709006108, 1994621201, 2972577594, 937287164, 3734691505, 168608556, 3189338153, 2225080640, 3139713551, 3033610191, 3025041904, 77524477, 185966941, 1208824168, 2344345178, 1721625922, 3354191921, 1066374631, 1927223579, 1971335949, 2483503697, 1551748602, 2881383779, 2856329572, 3003241482, 48746954, 1398218158, 2050065058, 313056748, 4255789917, 393167848, 1912293076, 940740642, 3465845460, 3091687853, 2522601570, 2197016661, 1727764327, 364383054, 492521376, 1291706479, 3264136376, 1474851438, 1685747964, 2575719748, 1619776915, 1814040067, 970743798, 1561002147, 2925768690, 2123093554, 1880132620, 3151188041, 697884420, 2550985770, 2607674513, 2659114323, 110200136, 1489731079, 997519150, 1378877361, 3527870668, 478029773, 2766872923, 1022481122, 431258168, 1112503832, 897933369, 2635587303, 669726182, 3383752315, 918222264, 163866573, 3246985393, 3776823163, 114105080, 1903216136, 761148244, 3571337562, 1690750982, 3166750252, 1037045171, 1888456500, 2010454850, 642736655, 616092351, 365016990, 1185228132, 4174898510, 1043824992, 2023083429, 2241598885, 3863320456, 3279669087, 3674716684, 108438443, 2132974366, 830746235, 606445527, 4173263986, 2204105912, 1844756978, 2532684181, 4245352700, 2969441100, 3796921661, 1335562986, 4061524517, 2720232303, 2679424040, 634407289, 885462008, 3294724487, 3933892248, 2094100220, 339117932, 4048830727, 3202280980, 1458155303, 2689246273, 1022871705, 2464987878, 3714515309, 353796843, 2822958815, 4256850100, 4052777845, 551748367, 618185374, 3778635579, 4020649912, 1904685140, 3069366075, 2670879810, 3407193292, 2954511620, 4058283405, 2219449317, 3135758300, 1120655984, 3447565834, 1474845562, 3577699062, 550456716, 3466908712, 2043752612, 881257467, 869518812, 2005220179, 938474677, 3305539448, 3850417126, 1315485940, 3318264702, 226533026, 965733244, 321539988, 1136104718, 804158748, 573969341, 3708209826, 937399083, 3290727049, 2901666755, 1461057207, 4013193437, 4066861423, 3242773476, 2421326174, 1581322155, 3028952165, 786071460, 3900391652, 3918438532, 1485433313, 4023619836, 3708277595, 3678951060, 953673138, 1467089153, 1930354364, 1533292819, 2492563023, 1346121658, 1685000834, 1965281866, 3765933717, 4190206607, 2052792609, 3515332758, 690371149, 3125873887, 2180283551, 2903598061, 3933952357, 436236910, 289419410, 14314871, 1242357089, 2904507907, 1616633776, 2666382180, 585885352, 3471299210, 2699507360, 1432659641, 277164553, 3354103607, 770115018, 2303809295, 3741942315, 3177781868, 2853364978, 2269453327, 3774259834, 987383833, 1290892879, 225909803, 1741533526, 890078084, 1496906255, 1111072499, 916028167, 243534141, 1252605537, 2204162171, 531204876, 290011180, 3916834213, 102027703, 237315147, 209093447, 1486785922, 220223953, 2758195998, 4175039106, 82940208, 3127791296, 2569425252, 518464269, 1353887104, 3941492737, 2377294467, 3935040926];
    }
    function Ge(e2) {
      this.cast5 = new He(), this.cast5.setKey(e2), this.encrypt = function(e3) {
        return this.cast5.encrypt(e3);
      };
    }
    We.keySize = We.prototype.keySize = 24, We.blockSize = We.prototype.blockSize = 8, Ge.blockSize = Ge.prototype.blockSize = 8, Ge.keySize = Ge.prototype.keySize = 16;
    var Ve = 4294967295;
    function $e(e2, t2) {
      return (e2 << t2 | e2 >>> 32 - t2) & Ve;
    }
    function Ze(e2, t2) {
      return e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24;
    }
    function Ye(e2, t2, r2) {
      e2.splice(t2, 4, 255 & r2, r2 >>> 8 & 255, r2 >>> 16 & 255, r2 >>> 24 & 255);
    }
    function Xe(e2, t2) {
      return e2 >>> 8 * t2 & 255;
    }
    function Qe(e2) {
      this.tf = function() {
        let e3 = null, t2 = null, r2 = -1, i2 = [], n2 = [[], [], [], []];
        function a2(e4) {
          return n2[0][Xe(e4, 0)] ^ n2[1][Xe(e4, 1)] ^ n2[2][Xe(e4, 2)] ^ n2[3][Xe(e4, 3)];
        }
        function s2(e4) {
          return n2[0][Xe(e4, 3)] ^ n2[1][Xe(e4, 0)] ^ n2[2][Xe(e4, 1)] ^ n2[3][Xe(e4, 2)];
        }
        function o2(e4, t3) {
          let r3 = a2(t3[0]), n3 = s2(t3[1]);
          t3[2] = $e(t3[2] ^ r3 + n3 + i2[4 * e4 + 8] & Ve, 31), t3[3] = $e(t3[3], 1) ^ r3 + 2 * n3 + i2[4 * e4 + 9] & Ve, r3 = a2(t3[2]), n3 = s2(t3[3]), t3[0] = $e(t3[0] ^ r3 + n3 + i2[4 * e4 + 10] & Ve, 31), t3[1] = $e(t3[1], 1) ^ r3 + 2 * n3 + i2[4 * e4 + 11] & Ve;
        }
        function c2(e4, t3) {
          let r3 = a2(t3[0]), n3 = s2(t3[1]);
          t3[2] = $e(t3[2], 1) ^ r3 + n3 + i2[4 * e4 + 10] & Ve, t3[3] = $e(t3[3] ^ r3 + 2 * n3 + i2[4 * e4 + 11] & Ve, 31), r3 = a2(t3[2]), n3 = s2(t3[3]), t3[0] = $e(t3[0], 1) ^ r3 + n3 + i2[4 * e4 + 8] & Ve, t3[1] = $e(t3[1] ^ r3 + 2 * n3 + i2[4 * e4 + 9] & Ve, 31);
        }
        return { name: "twofish", blocksize: 16, open: function(t3) {
          let r3, a3, s3, o3, c3;
          e3 = t3;
          const u2 = [], h2 = [], f2 = [];
          let d2;
          const l2 = [];
          let p2, y2, b2;
          const m2 = [[8, 1, 7, 13, 6, 15, 3, 2, 0, 11, 5, 9, 14, 12, 10, 4], [2, 8, 11, 13, 15, 7, 6, 14, 3, 1, 9, 4, 0, 10, 12, 5]], g2 = [[14, 12, 11, 8, 1, 2, 3, 5, 15, 4, 10, 6, 7, 0, 9, 13], [1, 14, 2, 11, 4, 12, 3, 7, 6, 13, 10, 5, 15, 9, 0, 8]], w2 = [[11, 10, 5, 14, 6, 13, 9, 0, 12, 8, 15, 3, 2, 4, 7, 1], [4, 12, 7, 5, 1, 6, 9, 10, 0, 14, 13, 8, 2, 11, 3, 15]], v2 = [[13, 7, 15, 4, 1, 2, 6, 14, 9, 11, 3, 0, 8, 5, 12, 10], [11, 9, 5, 1, 12, 3, 13, 14, 6, 4, 7, 15, 2, 0, 8, 10]], _2 = [0, 8, 1, 9, 2, 10, 3, 11, 4, 12, 5, 13, 6, 14, 7, 15], k2 = [0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 5, 14, 7], A2 = [[], []], S2 = [[], [], [], []];
          function E2(e4) {
            return e4 ^ e4 >> 2 ^ [0, 90, 180, 238][3 & e4];
          }
          function P2(e4) {
            return e4 ^ e4 >> 1 ^ e4 >> 2 ^ [0, 238, 180, 90][3 & e4];
          }
          function x2(e4, t4) {
            let r4, i3, n3;
            for (r4 = 0; r4 < 8; r4++)
              i3 = t4 >>> 24, t4 = t4 << 8 & Ve | e4 >>> 24, e4 = e4 << 8 & Ve, n3 = i3 << 1, 128 & i3 && (n3 ^= 333), t4 ^= i3 ^ n3 << 16, n3 ^= i3 >>> 1, 1 & i3 && (n3 ^= 166), t4 ^= n3 << 24 | n3 << 8;
            return t4;
          }
          function M2(e4, t4) {
            const r4 = t4 >> 4, i3 = 15 & t4, n3 = m2[e4][r4 ^ i3], a4 = g2[e4][_2[i3] ^ k2[r4]];
            return v2[e4][_2[a4] ^ k2[n3]] << 4 | w2[e4][n3 ^ a4];
          }
          function C2(e4, t4) {
            let r4 = Xe(e4, 0), i3 = Xe(e4, 1), n3 = Xe(e4, 2), a4 = Xe(e4, 3);
            switch (d2) {
              case 4:
                r4 = A2[1][r4] ^ Xe(t4[3], 0), i3 = A2[0][i3] ^ Xe(t4[3], 1), n3 = A2[0][n3] ^ Xe(t4[3], 2), a4 = A2[1][a4] ^ Xe(t4[3], 3);
              case 3:
                r4 = A2[1][r4] ^ Xe(t4[2], 0), i3 = A2[1][i3] ^ Xe(t4[2], 1), n3 = A2[0][n3] ^ Xe(t4[2], 2), a4 = A2[0][a4] ^ Xe(t4[2], 3);
              case 2:
                r4 = A2[0][A2[0][r4] ^ Xe(t4[1], 0)] ^ Xe(t4[0], 0), i3 = A2[0][A2[1][i3] ^ Xe(t4[1], 1)] ^ Xe(t4[0], 1), n3 = A2[1][A2[0][n3] ^ Xe(t4[1], 2)] ^ Xe(t4[0], 2), a4 = A2[1][A2[1][a4] ^ Xe(t4[1], 3)] ^ Xe(t4[0], 3);
            }
            return S2[0][r4] ^ S2[1][i3] ^ S2[2][n3] ^ S2[3][a4];
          }
          for (e3 = e3.slice(0, 32), r3 = e3.length; r3 !== 16 && r3 !== 24 && r3 !== 32; )
            e3[r3++] = 0;
          for (r3 = 0; r3 < e3.length; r3 += 4)
            f2[r3 >> 2] = Ze(e3, r3);
          for (r3 = 0; r3 < 256; r3++)
            A2[0][r3] = M2(0, r3), A2[1][r3] = M2(1, r3);
          for (r3 = 0; r3 < 256; r3++)
            p2 = A2[1][r3], y2 = E2(p2), b2 = P2(p2), S2[0][r3] = p2 + (y2 << 8) + (b2 << 16) + (b2 << 24), S2[2][r3] = y2 + (b2 << 8) + (p2 << 16) + (b2 << 24), p2 = A2[0][r3], y2 = E2(p2), b2 = P2(p2), S2[1][r3] = b2 + (b2 << 8) + (y2 << 16) + (p2 << 24), S2[3][r3] = y2 + (p2 << 8) + (b2 << 16) + (y2 << 24);
          for (d2 = f2.length / 2, r3 = 0; r3 < d2; r3++)
            a3 = f2[r3 + r3], u2[r3] = a3, s3 = f2[r3 + r3 + 1], h2[r3] = s3, l2[d2 - r3 - 1] = x2(a3, s3);
          for (r3 = 0; r3 < 40; r3 += 2)
            a3 = 16843009 * r3, s3 = a3 + 16843009, a3 = C2(a3, u2), s3 = $e(C2(s3, h2), 8), i2[r3] = a3 + s3 & Ve, i2[r3 + 1] = $e(a3 + 2 * s3, 9);
          for (r3 = 0; r3 < 256; r3++)
            switch (a3 = s3 = o3 = c3 = r3, d2) {
              case 4:
                a3 = A2[1][a3] ^ Xe(l2[3], 0), s3 = A2[0][s3] ^ Xe(l2[3], 1), o3 = A2[0][o3] ^ Xe(l2[3], 2), c3 = A2[1][c3] ^ Xe(l2[3], 3);
              case 3:
                a3 = A2[1][a3] ^ Xe(l2[2], 0), s3 = A2[1][s3] ^ Xe(l2[2], 1), o3 = A2[0][o3] ^ Xe(l2[2], 2), c3 = A2[0][c3] ^ Xe(l2[2], 3);
              case 2:
                n2[0][r3] = S2[0][A2[0][A2[0][a3] ^ Xe(l2[1], 0)] ^ Xe(l2[0], 0)], n2[1][r3] = S2[1][A2[0][A2[1][s3] ^ Xe(l2[1], 1)] ^ Xe(l2[0], 1)], n2[2][r3] = S2[2][A2[1][A2[0][o3] ^ Xe(l2[1], 2)] ^ Xe(l2[0], 2)], n2[3][r3] = S2[3][A2[1][A2[1][c3] ^ Xe(l2[1], 3)] ^ Xe(l2[0], 3)];
            }
        }, close: function() {
          i2 = [], n2 = [[], [], [], []];
        }, encrypt: function(e4, n3) {
          t2 = e4, r2 = n3;
          const a3 = [Ze(t2, r2) ^ i2[0], Ze(t2, r2 + 4) ^ i2[1], Ze(t2, r2 + 8) ^ i2[2], Ze(t2, r2 + 12) ^ i2[3]];
          for (let e5 = 0; e5 < 8; e5++)
            o2(e5, a3);
          return Ye(t2, r2, a3[2] ^ i2[4]), Ye(t2, r2 + 4, a3[3] ^ i2[5]), Ye(t2, r2 + 8, a3[0] ^ i2[6]), Ye(t2, r2 + 12, a3[1] ^ i2[7]), r2 += 16, t2;
        }, decrypt: function(e4, n3) {
          t2 = e4, r2 = n3;
          const a3 = [Ze(t2, r2) ^ i2[4], Ze(t2, r2 + 4) ^ i2[5], Ze(t2, r2 + 8) ^ i2[6], Ze(t2, r2 + 12) ^ i2[7]];
          for (let e5 = 7; e5 >= 0; e5--)
            c2(e5, a3);
          Ye(t2, r2, a3[2] ^ i2[0]), Ye(t2, r2 + 4, a3[3] ^ i2[1]), Ye(t2, r2 + 8, a3[0] ^ i2[2]), Ye(t2, r2 + 12, a3[1] ^ i2[3]), r2 += 16;
        }, finalize: function() {
          return t2;
        } };
      }(), this.tf.open(Array.from(e2), 0), this.encrypt = function(e3) {
        return this.tf.encrypt(Array.from(e3), 0);
      };
    }
    function Je() {
    }
    function et(e2) {
      this.bf = new Je(), this.bf.init(e2), this.encrypt = function(e3) {
        return this.bf.encryptBlock(e3);
      };
    }
    Qe.keySize = Qe.prototype.keySize = 32, Qe.blockSize = Qe.prototype.blockSize = 16, Je.prototype.BLOCKSIZE = 8, Je.prototype.SBOXES = [[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 842905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396308128, 445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 458293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], [1266315497, 3048417604, 3681880366, 3289982499, 290971e4, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 1332590856, 1866599683, 4127851711, 750260880, 613907577, 1450815602, 3165620655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820, 4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 2148256476, 2655287854, 3276092548, 4258621189, 236887753, 3681803219, 274041037, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], [3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 3666258015, 3200248200, 1692713982, 2646376535, 4042768518, 1618508792, 1610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], [976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501309, 3286998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409e3, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 54117162, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329, 2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1469046755, 985887462]], Je.prototype.PARRAY = [608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], Je.prototype.NN = 16, Je.prototype._clean = function(e2) {
      if (e2 < 0) {
        e2 = (2147483647 & e2) + 2147483648;
      }
      return e2;
    }, Je.prototype._F = function(e2) {
      let t2;
      const r2 = 255 & e2, i2 = 255 & (e2 >>>= 8), n2 = 255 & (e2 >>>= 8), a2 = 255 & (e2 >>>= 8);
      return t2 = this.sboxes[0][a2] + this.sboxes[1][n2], t2 ^= this.sboxes[2][i2], t2 += this.sboxes[3][r2], t2;
    }, Je.prototype._encryptBlock = function(e2) {
      let t2, r2 = e2[0], i2 = e2[1];
      for (t2 = 0; t2 < this.NN; ++t2) {
        r2 ^= this.parray[t2], i2 = this._F(r2) ^ i2;
        const e3 = r2;
        r2 = i2, i2 = e3;
      }
      r2 ^= this.parray[this.NN + 0], i2 ^= this.parray[this.NN + 1], e2[0] = this._clean(i2), e2[1] = this._clean(r2);
    }, Je.prototype.encryptBlock = function(e2) {
      let t2;
      const r2 = [0, 0], i2 = this.BLOCKSIZE / 2;
      for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2)
        r2[0] = r2[0] << 8 | 255 & e2[t2 + 0], r2[1] = r2[1] << 8 | 255 & e2[t2 + i2];
      this._encryptBlock(r2);
      const n2 = [];
      for (t2 = 0; t2 < this.BLOCKSIZE / 2; ++t2)
        n2[t2 + 0] = r2[0] >>> 24 - 8 * t2 & 255, n2[t2 + i2] = r2[1] >>> 24 - 8 * t2 & 255;
      return n2;
    }, Je.prototype._decryptBlock = function(e2) {
      let t2, r2 = e2[0], i2 = e2[1];
      for (t2 = this.NN + 1; t2 > 1; --t2) {
        r2 ^= this.parray[t2], i2 = this._F(r2) ^ i2;
        const e3 = r2;
        r2 = i2, i2 = e3;
      }
      r2 ^= this.parray[1], i2 ^= this.parray[0], e2[0] = this._clean(i2), e2[1] = this._clean(r2);
    }, Je.prototype.init = function(e2) {
      let t2, r2 = 0;
      for (this.parray = [], t2 = 0; t2 < this.NN + 2; ++t2) {
        let i3 = 0;
        for (let t3 = 0; t3 < 4; ++t3)
          i3 = i3 << 8 | 255 & e2[r2], ++r2 >= e2.length && (r2 = 0);
        this.parray[t2] = this.PARRAY[t2] ^ i3;
      }
      for (this.sboxes = [], t2 = 0; t2 < 4; ++t2)
        for (this.sboxes[t2] = [], r2 = 0; r2 < 256; ++r2)
          this.sboxes[t2][r2] = this.SBOXES[t2][r2];
      const i2 = [0, 0];
      for (t2 = 0; t2 < this.NN + 2; t2 += 2)
        this._encryptBlock(i2), this.parray[t2 + 0] = i2[0], this.parray[t2 + 1] = i2[1];
      for (t2 = 0; t2 < 4; ++t2)
        for (r2 = 0; r2 < 256; r2 += 2)
          this._encryptBlock(i2), this.sboxes[t2][r2 + 0] = i2[0], this.sboxes[t2][r2 + 1] = i2[1];
    }, et.keySize = et.prototype.keySize = 16, et.blockSize = et.prototype.blockSize = 8;
    var tt = Ne(128);
    var rt = Ne(192);
    var it = Ne(256);
    var nt = /* @__PURE__ */ Object.freeze({ __proto__: null, aes128: tt, aes192: rt, aes256: it, des: function(e2) {
      this.key = e2, this.encrypt = function(e3, t2) {
        return je(Le(this.key), e3, true, 0, null, t2);
      }, this.decrypt = function(e3, t2) {
        return je(Le(this.key), e3, false, 0, null, t2);
      };
    }, tripledes: We, cast5: Ge, twofish: Qe, blowfish: et, idea: function() {
      throw Error("IDEA symmetric-key algorithm not implemented");
    } });
    var at = function(e2, t2, r2) {
      ;
      var i2 = 0, n2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, u2 = 0;
      var h2 = 0, f2 = 0, d2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, m2 = 0, g2 = 0, w2 = 0;
      var v2 = new e2.Uint8Array(r2);
      function _2(e3, t3, r3, c3, u3, h3, f3, d3, l3, p3, y3, b3, m3, g3, w3, v3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        c3 = c3 | 0;
        u3 = u3 | 0;
        h3 = h3 | 0;
        f3 = f3 | 0;
        d3 = d3 | 0;
        l3 = l3 | 0;
        p3 = p3 | 0;
        y3 = y3 | 0;
        b3 = b3 | 0;
        m3 = m3 | 0;
        g3 = g3 | 0;
        w3 = w3 | 0;
        v3 = v3 | 0;
        var _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, C3 = 0, K3 = 0, D3 = 0, R3 = 0, I2 = 0, U2 = 0, B2 = 0, T2 = 0, z2 = 0, q2 = 0, O2 = 0, F2 = 0, N2 = 0, j2 = 0, L2 = 0, W2 = 0, H2 = 0, G2 = 0, V2 = 0, $2 = 0, Z2 = 0, Y2 = 0, X2 = 0, Q2 = 0, J2 = 0, ee2 = 0, te2 = 0, re2 = 0, ie2 = 0, ne2 = 0, ae2 = 0, se2 = 0, oe2 = 0, ce2 = 0, ue2 = 0, he2 = 0, fe2 = 0, de2 = 0, le2 = 0, pe2 = 0, ye2 = 0, be2 = 0, me2 = 0, ge2 = 0, we2 = 0, ve2 = 0, _e2 = 0, ke2 = 0, Ae2 = 0, Se2 = 0, Ee2 = 0, Pe2 = 0, xe2 = 0, Me2 = 0, Ce2 = 0, Ke2 = 0, De2 = 0, Re2 = 0, Ie2 = 0, Ue2 = 0, Be2 = 0, Te2 = 0, ze2 = 0;
        _3 = i2;
        k3 = n2;
        A3 = a2;
        S3 = s2;
        E3 = o2;
        x3 = e3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = t3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = r3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = c3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = u3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = h3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = f3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = d3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = l3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = p3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = y3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = b3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = m3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = g3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = w3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        x3 = v3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = g3 ^ l3 ^ r3 ^ e3;
        M3 = P3 << 1 | P3 >>> 31;
        x3 = M3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = w3 ^ p3 ^ c3 ^ t3;
        C3 = P3 << 1 | P3 >>> 31;
        x3 = C3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = v3 ^ y3 ^ u3 ^ r3;
        K3 = P3 << 1 | P3 >>> 31;
        x3 = K3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = M3 ^ b3 ^ h3 ^ c3;
        D3 = P3 << 1 | P3 >>> 31;
        x3 = D3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | ~k3 & S3) + 1518500249 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = C3 ^ m3 ^ f3 ^ u3;
        R3 = P3 << 1 | P3 >>> 31;
        x3 = R3 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = K3 ^ g3 ^ d3 ^ h3;
        I2 = P3 << 1 | P3 >>> 31;
        x3 = I2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = D3 ^ w3 ^ l3 ^ f3;
        U2 = P3 << 1 | P3 >>> 31;
        x3 = U2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = R3 ^ v3 ^ p3 ^ d3;
        B2 = P3 << 1 | P3 >>> 31;
        x3 = B2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = I2 ^ M3 ^ y3 ^ l3;
        T2 = P3 << 1 | P3 >>> 31;
        x3 = T2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = U2 ^ C3 ^ b3 ^ p3;
        z2 = P3 << 1 | P3 >>> 31;
        x3 = z2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = B2 ^ K3 ^ m3 ^ y3;
        q2 = P3 << 1 | P3 >>> 31;
        x3 = q2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = T2 ^ D3 ^ g3 ^ b3;
        O2 = P3 << 1 | P3 >>> 31;
        x3 = O2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = z2 ^ R3 ^ w3 ^ m3;
        F2 = P3 << 1 | P3 >>> 31;
        x3 = F2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = q2 ^ I2 ^ v3 ^ g3;
        N2 = P3 << 1 | P3 >>> 31;
        x3 = N2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = O2 ^ U2 ^ M3 ^ w3;
        j2 = P3 << 1 | P3 >>> 31;
        x3 = j2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = F2 ^ B2 ^ C3 ^ v3;
        L2 = P3 << 1 | P3 >>> 31;
        x3 = L2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = N2 ^ T2 ^ K3 ^ M3;
        W2 = P3 << 1 | P3 >>> 31;
        x3 = W2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = j2 ^ z2 ^ D3 ^ C3;
        H2 = P3 << 1 | P3 >>> 31;
        x3 = H2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = L2 ^ q2 ^ R3 ^ K3;
        G2 = P3 << 1 | P3 >>> 31;
        x3 = G2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = W2 ^ O2 ^ I2 ^ D3;
        V2 = P3 << 1 | P3 >>> 31;
        x3 = V2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = H2 ^ F2 ^ U2 ^ R3;
        $2 = P3 << 1 | P3 >>> 31;
        x3 = $2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = G2 ^ N2 ^ B2 ^ I2;
        Z2 = P3 << 1 | P3 >>> 31;
        x3 = Z2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = V2 ^ j2 ^ T2 ^ U2;
        Y2 = P3 << 1 | P3 >>> 31;
        x3 = Y2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = $2 ^ L2 ^ z2 ^ B2;
        X2 = P3 << 1 | P3 >>> 31;
        x3 = X2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) + 1859775393 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Z2 ^ W2 ^ q2 ^ T2;
        Q2 = P3 << 1 | P3 >>> 31;
        x3 = Q2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Y2 ^ H2 ^ O2 ^ z2;
        J2 = P3 << 1 | P3 >>> 31;
        x3 = J2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = X2 ^ G2 ^ F2 ^ q2;
        ee2 = P3 << 1 | P3 >>> 31;
        x3 = ee2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Q2 ^ V2 ^ N2 ^ O2;
        te2 = P3 << 1 | P3 >>> 31;
        x3 = te2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = J2 ^ $2 ^ j2 ^ F2;
        re2 = P3 << 1 | P3 >>> 31;
        x3 = re2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ee2 ^ Z2 ^ L2 ^ N2;
        ie2 = P3 << 1 | P3 >>> 31;
        x3 = ie2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = te2 ^ Y2 ^ W2 ^ j2;
        ne2 = P3 << 1 | P3 >>> 31;
        x3 = ne2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = re2 ^ X2 ^ H2 ^ L2;
        ae2 = P3 << 1 | P3 >>> 31;
        x3 = ae2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ie2 ^ Q2 ^ G2 ^ W2;
        se2 = P3 << 1 | P3 >>> 31;
        x3 = se2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ne2 ^ J2 ^ V2 ^ H2;
        oe2 = P3 << 1 | P3 >>> 31;
        x3 = oe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ae2 ^ ee2 ^ $2 ^ G2;
        ce2 = P3 << 1 | P3 >>> 31;
        x3 = ce2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = se2 ^ te2 ^ Z2 ^ V2;
        ue2 = P3 << 1 | P3 >>> 31;
        x3 = ue2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = oe2 ^ re2 ^ Y2 ^ $2;
        he2 = P3 << 1 | P3 >>> 31;
        x3 = he2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ce2 ^ ie2 ^ X2 ^ Z2;
        fe2 = P3 << 1 | P3 >>> 31;
        x3 = fe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ue2 ^ ne2 ^ Q2 ^ Y2;
        de2 = P3 << 1 | P3 >>> 31;
        x3 = de2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = he2 ^ ae2 ^ J2 ^ X2;
        le2 = P3 << 1 | P3 >>> 31;
        x3 = le2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = fe2 ^ se2 ^ ee2 ^ Q2;
        pe2 = P3 << 1 | P3 >>> 31;
        x3 = pe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = de2 ^ oe2 ^ te2 ^ J2;
        ye2 = P3 << 1 | P3 >>> 31;
        x3 = ye2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = le2 ^ ce2 ^ re2 ^ ee2;
        be2 = P3 << 1 | P3 >>> 31;
        x3 = be2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = pe2 ^ ue2 ^ ie2 ^ te2;
        me2 = P3 << 1 | P3 >>> 31;
        x3 = me2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 & A3 | k3 & S3 | A3 & S3) - 1894007588 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ye2 ^ he2 ^ ne2 ^ re2;
        ge2 = P3 << 1 | P3 >>> 31;
        x3 = ge2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = be2 ^ fe2 ^ ae2 ^ ie2;
        we2 = P3 << 1 | P3 >>> 31;
        x3 = we2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = me2 ^ de2 ^ se2 ^ ne2;
        ve2 = P3 << 1 | P3 >>> 31;
        x3 = ve2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ge2 ^ le2 ^ oe2 ^ ae2;
        _e2 = P3 << 1 | P3 >>> 31;
        x3 = _e2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = we2 ^ pe2 ^ ce2 ^ se2;
        ke2 = P3 << 1 | P3 >>> 31;
        x3 = ke2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ve2 ^ ye2 ^ ue2 ^ oe2;
        Ae2 = P3 << 1 | P3 >>> 31;
        x3 = Ae2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = _e2 ^ be2 ^ he2 ^ ce2;
        Se2 = P3 << 1 | P3 >>> 31;
        x3 = Se2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = ke2 ^ me2 ^ fe2 ^ ue2;
        Ee2 = P3 << 1 | P3 >>> 31;
        x3 = Ee2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ae2 ^ ge2 ^ de2 ^ he2;
        Pe2 = P3 << 1 | P3 >>> 31;
        x3 = Pe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Se2 ^ we2 ^ le2 ^ fe2;
        xe2 = P3 << 1 | P3 >>> 31;
        x3 = xe2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ee2 ^ ve2 ^ pe2 ^ de2;
        Me2 = P3 << 1 | P3 >>> 31;
        x3 = Me2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Pe2 ^ _e2 ^ ye2 ^ le2;
        Ce2 = P3 << 1 | P3 >>> 31;
        x3 = Ce2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = xe2 ^ ke2 ^ be2 ^ pe2;
        Ke2 = P3 << 1 | P3 >>> 31;
        x3 = Ke2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Me2 ^ Ae2 ^ me2 ^ ye2;
        De2 = P3 << 1 | P3 >>> 31;
        x3 = De2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ce2 ^ Se2 ^ ge2 ^ be2;
        Re2 = P3 << 1 | P3 >>> 31;
        x3 = Re2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ke2 ^ Ee2 ^ we2 ^ me2;
        Ie2 = P3 << 1 | P3 >>> 31;
        x3 = Ie2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = De2 ^ Pe2 ^ ve2 ^ ge2;
        Ue2 = P3 << 1 | P3 >>> 31;
        x3 = Ue2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Re2 ^ xe2 ^ _e2 ^ we2;
        Be2 = P3 << 1 | P3 >>> 31;
        x3 = Be2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ie2 ^ Me2 ^ ke2 ^ ve2;
        Te2 = P3 << 1 | P3 >>> 31;
        x3 = Te2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        P3 = Ue2 ^ Ce2 ^ Ae2 ^ _e2;
        ze2 = P3 << 1 | P3 >>> 31;
        x3 = ze2 + (_3 << 5 | _3 >>> 27) + E3 + (k3 ^ A3 ^ S3) - 899497514 | 0;
        E3 = S3;
        S3 = A3;
        A3 = k3 << 30 | k3 >>> 2;
        k3 = _3;
        _3 = x3;
        i2 = i2 + _3 | 0;
        n2 = n2 + k3 | 0;
        a2 = a2 + A3 | 0;
        s2 = s2 + S3 | 0;
        o2 = o2 + E3 | 0;
      }
      function k2(e3) {
        e3 = e3 | 0;
        _2(v2[e3 | 0] << 24 | v2[e3 | 1] << 16 | v2[e3 | 2] << 8 | v2[e3 | 3], v2[e3 | 4] << 24 | v2[e3 | 5] << 16 | v2[e3 | 6] << 8 | v2[e3 | 7], v2[e3 | 8] << 24 | v2[e3 | 9] << 16 | v2[e3 | 10] << 8 | v2[e3 | 11], v2[e3 | 12] << 24 | v2[e3 | 13] << 16 | v2[e3 | 14] << 8 | v2[e3 | 15], v2[e3 | 16] << 24 | v2[e3 | 17] << 16 | v2[e3 | 18] << 8 | v2[e3 | 19], v2[e3 | 20] << 24 | v2[e3 | 21] << 16 | v2[e3 | 22] << 8 | v2[e3 | 23], v2[e3 | 24] << 24 | v2[e3 | 25] << 16 | v2[e3 | 26] << 8 | v2[e3 | 27], v2[e3 | 28] << 24 | v2[e3 | 29] << 16 | v2[e3 | 30] << 8 | v2[e3 | 31], v2[e3 | 32] << 24 | v2[e3 | 33] << 16 | v2[e3 | 34] << 8 | v2[e3 | 35], v2[e3 | 36] << 24 | v2[e3 | 37] << 16 | v2[e3 | 38] << 8 | v2[e3 | 39], v2[e3 | 40] << 24 | v2[e3 | 41] << 16 | v2[e3 | 42] << 8 | v2[e3 | 43], v2[e3 | 44] << 24 | v2[e3 | 45] << 16 | v2[e3 | 46] << 8 | v2[e3 | 47], v2[e3 | 48] << 24 | v2[e3 | 49] << 16 | v2[e3 | 50] << 8 | v2[e3 | 51], v2[e3 | 52] << 24 | v2[e3 | 53] << 16 | v2[e3 | 54] << 8 | v2[e3 | 55], v2[e3 | 56] << 24 | v2[e3 | 57] << 16 | v2[e3 | 58] << 8 | v2[e3 | 59], v2[e3 | 60] << 24 | v2[e3 | 61] << 16 | v2[e3 | 62] << 8 | v2[e3 | 63]);
      }
      function A2(e3) {
        e3 = e3 | 0;
        v2[e3 | 0] = i2 >>> 24;
        v2[e3 | 1] = i2 >>> 16 & 255;
        v2[e3 | 2] = i2 >>> 8 & 255;
        v2[e3 | 3] = i2 & 255;
        v2[e3 | 4] = n2 >>> 24;
        v2[e3 | 5] = n2 >>> 16 & 255;
        v2[e3 | 6] = n2 >>> 8 & 255;
        v2[e3 | 7] = n2 & 255;
        v2[e3 | 8] = a2 >>> 24;
        v2[e3 | 9] = a2 >>> 16 & 255;
        v2[e3 | 10] = a2 >>> 8 & 255;
        v2[e3 | 11] = a2 & 255;
        v2[e3 | 12] = s2 >>> 24;
        v2[e3 | 13] = s2 >>> 16 & 255;
        v2[e3 | 14] = s2 >>> 8 & 255;
        v2[e3 | 15] = s2 & 255;
        v2[e3 | 16] = o2 >>> 24;
        v2[e3 | 17] = o2 >>> 16 & 255;
        v2[e3 | 18] = o2 >>> 8 & 255;
        v2[e3 | 19] = o2 & 255;
      }
      function S2() {
        i2 = 1732584193;
        n2 = 4023233417;
        a2 = 2562383102;
        s2 = 271733878;
        o2 = 3285377520;
        c2 = u2 = 0;
      }
      function E2(e3, t3, r3, h3, f3, d3, l3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        h3 = h3 | 0;
        f3 = f3 | 0;
        d3 = d3 | 0;
        l3 = l3 | 0;
        i2 = e3;
        n2 = t3;
        a2 = r3;
        s2 = h3;
        o2 = f3;
        c2 = d3;
        u2 = l3;
      }
      function P2(e3, t3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        var r3 = 0;
        if (e3 & 63)
          return -1;
        while ((t3 | 0) >= 64) {
          k2(e3);
          e3 = e3 + 64 | 0;
          t3 = t3 - 64 | 0;
          r3 = r3 + 64 | 0;
        }
        c2 = c2 + r3 | 0;
        if (c2 >>> 0 < r3 >>> 0)
          u2 = u2 + 1 | 0;
        return r3 | 0;
      }
      function x2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var i3 = 0, n3 = 0;
        if (e3 & 63)
          return -1;
        if (~r3) {
          if (r3 & 31)
            return -1;
        }
        if ((t3 | 0) >= 64) {
          i3 = P2(e3, t3) | 0;
          if ((i3 | 0) == -1)
            return -1;
          e3 = e3 + i3 | 0;
          t3 = t3 - i3 | 0;
        }
        i3 = i3 + t3 | 0;
        c2 = c2 + t3 | 0;
        if (c2 >>> 0 < t3 >>> 0)
          u2 = u2 + 1 | 0;
        v2[e3 | t3] = 128;
        if ((t3 | 0) >= 56) {
          for (n3 = t3 + 1 | 0; (n3 | 0) < 64; n3 = n3 + 1 | 0)
            v2[e3 | n3] = 0;
          k2(e3);
          t3 = 0;
          v2[e3 | 0] = 0;
        }
        for (n3 = t3 + 1 | 0; (n3 | 0) < 59; n3 = n3 + 1 | 0)
          v2[e3 | n3] = 0;
        v2[e3 | 56] = u2 >>> 21 & 255;
        v2[e3 | 57] = u2 >>> 13 & 255;
        v2[e3 | 58] = u2 >>> 5 & 255;
        v2[e3 | 59] = u2 << 3 & 255 | c2 >>> 29;
        v2[e3 | 60] = c2 >>> 21 & 255;
        v2[e3 | 61] = c2 >>> 13 & 255;
        v2[e3 | 62] = c2 >>> 5 & 255;
        v2[e3 | 63] = c2 << 3 & 255;
        k2(e3);
        if (~r3)
          A2(r3);
        return i3 | 0;
      }
      function M2() {
        i2 = h2;
        n2 = f2;
        a2 = d2;
        s2 = l2;
        o2 = p2;
        c2 = 64;
        u2 = 0;
      }
      function C2() {
        i2 = y2;
        n2 = b2;
        a2 = m2;
        s2 = g2;
        o2 = w2;
        c2 = 64;
        u2 = 0;
      }
      function K2(e3, t3, r3, v3, k3, A3, E3, P3, x3, M3, C3, K3, D3, R3, I2, U2) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        v3 = v3 | 0;
        k3 = k3 | 0;
        A3 = A3 | 0;
        E3 = E3 | 0;
        P3 = P3 | 0;
        x3 = x3 | 0;
        M3 = M3 | 0;
        C3 = C3 | 0;
        K3 = K3 | 0;
        D3 = D3 | 0;
        R3 = R3 | 0;
        I2 = I2 | 0;
        U2 = U2 | 0;
        S2();
        _2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, v3 ^ 1549556828, k3 ^ 1549556828, A3 ^ 1549556828, E3 ^ 1549556828, P3 ^ 1549556828, x3 ^ 1549556828, M3 ^ 1549556828, C3 ^ 1549556828, K3 ^ 1549556828, D3 ^ 1549556828, R3 ^ 1549556828, I2 ^ 1549556828, U2 ^ 1549556828);
        y2 = i2;
        b2 = n2;
        m2 = a2;
        g2 = s2;
        w2 = o2;
        S2();
        _2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, v3 ^ 909522486, k3 ^ 909522486, A3 ^ 909522486, E3 ^ 909522486, P3 ^ 909522486, x3 ^ 909522486, M3 ^ 909522486, C3 ^ 909522486, K3 ^ 909522486, D3 ^ 909522486, R3 ^ 909522486, I2 ^ 909522486, U2 ^ 909522486);
        h2 = i2;
        f2 = n2;
        d2 = a2;
        l2 = s2;
        p2 = o2;
        c2 = 64;
        u2 = 0;
      }
      function D2(e3, t3, r3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        var c3 = 0, u3 = 0, h3 = 0, f3 = 0, d3 = 0, l3 = 0;
        if (e3 & 63)
          return -1;
        if (~r3) {
          if (r3 & 31)
            return -1;
        }
        l3 = x2(e3, t3, -1) | 0;
        c3 = i2, u3 = n2, h3 = a2, f3 = s2, d3 = o2;
        C2();
        _2(c3, u3, h3, f3, d3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
        if (~r3)
          A2(r3);
        return l3 | 0;
      }
      function R2(e3, t3, r3, c3, u3) {
        e3 = e3 | 0;
        t3 = t3 | 0;
        r3 = r3 | 0;
        c3 = c3 | 0;
        u3 = u3 | 0;
        var h3 = 0, f3 = 0, d3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0, g3 = 0, w3 = 0;
        if (e3 & 63)
          return -1;
        if (~u3) {
          if (u3 & 31)
            return -1;
        }
        v2[e3 + t3 | 0] = r3 >>> 24;
        v2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
        v2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
        v2[e3 + t3 + 3 | 0] = r3 & 255;
        D2(e3, t3 + 4 | 0, -1) | 0;
        h3 = y3 = i2, f3 = b3 = n2, d3 = m3 = a2, l3 = g3 = s2, p3 = w3 = o2;
        c3 = c3 - 1 | 0;
        while ((c3 | 0) > 0) {
          M2();
          _2(y3, b3, m3, g3, w3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
          y3 = i2, b3 = n2, m3 = a2, g3 = s2, w3 = o2;
          C2();
          _2(y3, b3, m3, g3, w3, 2147483648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 672);
          y3 = i2, b3 = n2, m3 = a2, g3 = s2, w3 = o2;
          h3 = h3 ^ i2;
          f3 = f3 ^ n2;
          d3 = d3 ^ a2;
          l3 = l3 ^ s2;
          p3 = p3 ^ o2;
          c3 = c3 - 1 | 0;
        }
        i2 = h3;
        n2 = f3;
        a2 = d3;
        s2 = l3;
        o2 = p3;
        if (~u3)
          A2(u3);
        return 0;
      }
      return { reset: S2, init: E2, process: P2, finish: x2, hmac_reset: M2, hmac_init: K2, hmac_finish: D2, pbkdf2_generate_block: R2 };
    };
    var st = class {
      constructor() {
        this.pos = 0, this.len = 0;
      }
      reset() {
        const { asm: e2 } = this.acquire_asm();
        return this.result = null, this.pos = 0, this.len = 0, e2.reset(), this;
      }
      process(e2) {
        if (this.result !== null)
          throw new Ue("state must be reset before processing new data");
        const { asm: t2, heap: r2 } = this.acquire_asm();
        let i2 = this.pos, n2 = this.len, a2 = 0, s2 = e2.length, o2 = 0;
        for (; s2 > 0; )
          o2 = Re(r2, i2 + n2, e2, a2, s2), n2 += o2, a2 += o2, s2 -= o2, o2 = t2.process(i2, n2), i2 += o2, n2 -= o2, n2 || (i2 = 0);
        return this.pos = i2, this.len = n2, this;
      }
      finish() {
        if (this.result !== null)
          throw new Ue("state must be reset before processing new data");
        const { asm: e2, heap: t2 } = this.acquire_asm();
        return e2.finish(this.pos, this.len, 0), this.result = new Uint8Array(this.HASH_SIZE), this.result.set(t2.subarray(0, this.HASH_SIZE)), this.pos = 0, this.len = 0, this.release_asm(), this;
      }
    };
    var ot = [];
    var ct = [];
    var ut = class extends st {
      constructor() {
        super(), this.NAME = "sha1", this.BLOCK_SIZE = 64, this.HASH_SIZE = 20, this.acquire_asm();
      }
      acquire_asm() {
        return this.heap !== void 0 && this.asm !== void 0 || (this.heap = ot.pop() || De(), this.asm = ct.pop() || at({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        this.heap !== void 0 && this.asm !== void 0 && (ot.push(this.heap), ct.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      static bytes(e2) {
        return new ut().process(e2).finish().result;
      }
    };
    ut.NAME = "sha1", ut.heap_pool = [], ut.asm_pool = [], ut.asm_function = at;
    var ht = [];
    var ft = [];
    var dt = class extends st {
      constructor() {
        super(), this.NAME = "sha256", this.BLOCK_SIZE = 64, this.HASH_SIZE = 32, this.acquire_asm();
      }
      acquire_asm() {
        return this.heap !== void 0 && this.asm !== void 0 || (this.heap = ht.pop() || De(), this.asm = ft.pop() || function(e2, t2, r2) {
          ;
          var i2 = 0, n2 = 0, a2 = 0, s2 = 0, o2 = 0, c2 = 0, u2 = 0, h2 = 0, f2 = 0, d2 = 0, l2 = 0, p2 = 0, y2 = 0, b2 = 0, m2 = 0, g2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0, S2 = 0, E2 = 0, P2 = 0, x2 = 0, M2 = 0, C2 = new e2.Uint8Array(r2);
          function K2(e3, t3, r3, f3, d3, l3, p3, y3, b3, m3, g3, w3, v3, _3, k3, A3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            f3 = f3 | 0;
            d3 = d3 | 0;
            l3 = l3 | 0;
            p3 = p3 | 0;
            y3 = y3 | 0;
            b3 = b3 | 0;
            m3 = m3 | 0;
            g3 = g3 | 0;
            w3 = w3 | 0;
            v3 = v3 | 0;
            _3 = _3 | 0;
            k3 = k3 | 0;
            A3 = A3 | 0;
            var S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, C3 = 0, K3 = 0, D3 = 0;
            S3 = i2;
            E3 = n2;
            P3 = a2;
            x3 = s2;
            M3 = o2;
            C3 = c2;
            K3 = u2;
            D3 = h2;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 1116352408 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            K3 = t3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 1899447441 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            C3 = r3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 3049323471 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            M3 = f3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3921009573 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            x3 = d3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 961987163 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1508970993 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            E3 = p3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 2453635748 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            S3 = y3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 2870763221 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 3624381080 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            K3 = m3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 310598401 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 607225278 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 1426881987 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            x3 = v3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 1925078388 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 2162078206 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            E3 = k3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 2614888103 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            S3 = A3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 3248222580 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + m3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 3835390401 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + g3 | 0;
            K3 = t3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 4022224774 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            C3 = r3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 264347078 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + f3 + v3 | 0;
            M3 = f3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 604807628 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + d3 + _3 | 0;
            x3 = d3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 770255983 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1249150122 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 1555081692 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 1996064986 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 2554220882 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            m3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + m3 + r3 | 0;
            K3 = m3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 2821834349 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            g3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + g3 + f3 | 0;
            C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 2952996808 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            w3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + w3 + d3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3210313671 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            v3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + v3 + l3 | 0;
            x3 = v3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 3336571891 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 3584528711 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 113926993 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 338241895 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + m3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 666307205 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + g3 | 0;
            K3 = t3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 773529912 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            C3 = r3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 1294757372 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + f3 + v3 | 0;
            M3 = f3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 1396182291 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + d3 + _3 | 0;
            x3 = d3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 1695183700 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1986661051 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 2177026350 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 2456956037 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 2730485921 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            m3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + m3 + r3 | 0;
            K3 = m3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 2820302411 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            g3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + g3 + f3 | 0;
            C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 3259730800 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            w3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + w3 + d3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 3345764771 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            v3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + v3 + l3 | 0;
            x3 = v3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 3516065817 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 3600352804 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 4094571909 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 275423344 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            e3 = (t3 >>> 7 ^ t3 >>> 18 ^ t3 >>> 3 ^ t3 << 25 ^ t3 << 14) + (k3 >>> 17 ^ k3 >>> 19 ^ k3 >>> 10 ^ k3 << 15 ^ k3 << 13) + e3 + m3 | 0;
            D3 = e3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 430227734 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            t3 = (r3 >>> 7 ^ r3 >>> 18 ^ r3 >>> 3 ^ r3 << 25 ^ r3 << 14) + (A3 >>> 17 ^ A3 >>> 19 ^ A3 >>> 10 ^ A3 << 15 ^ A3 << 13) + t3 + g3 | 0;
            K3 = t3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 506948616 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            r3 = (f3 >>> 7 ^ f3 >>> 18 ^ f3 >>> 3 ^ f3 << 25 ^ f3 << 14) + (e3 >>> 17 ^ e3 >>> 19 ^ e3 >>> 10 ^ e3 << 15 ^ e3 << 13) + r3 + w3 | 0;
            C3 = r3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 659060556 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            f3 = (d3 >>> 7 ^ d3 >>> 18 ^ d3 >>> 3 ^ d3 << 25 ^ d3 << 14) + (t3 >>> 17 ^ t3 >>> 19 ^ t3 >>> 10 ^ t3 << 15 ^ t3 << 13) + f3 + v3 | 0;
            M3 = f3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 883997877 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            d3 = (l3 >>> 7 ^ l3 >>> 18 ^ l3 >>> 3 ^ l3 << 25 ^ l3 << 14) + (r3 >>> 17 ^ r3 >>> 19 ^ r3 >>> 10 ^ r3 << 15 ^ r3 << 13) + d3 + _3 | 0;
            x3 = d3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 958139571 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            l3 = (p3 >>> 7 ^ p3 >>> 18 ^ p3 >>> 3 ^ p3 << 25 ^ p3 << 14) + (f3 >>> 17 ^ f3 >>> 19 ^ f3 >>> 10 ^ f3 << 15 ^ f3 << 13) + l3 + k3 | 0;
            P3 = l3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 1322822218 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            p3 = (y3 >>> 7 ^ y3 >>> 18 ^ y3 >>> 3 ^ y3 << 25 ^ y3 << 14) + (d3 >>> 17 ^ d3 >>> 19 ^ d3 >>> 10 ^ d3 << 15 ^ d3 << 13) + p3 + A3 | 0;
            E3 = p3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 1537002063 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            y3 = (b3 >>> 7 ^ b3 >>> 18 ^ b3 >>> 3 ^ b3 << 25 ^ b3 << 14) + (l3 >>> 17 ^ l3 >>> 19 ^ l3 >>> 10 ^ l3 << 15 ^ l3 << 13) + y3 + e3 | 0;
            S3 = y3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 1747873779 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            b3 = (m3 >>> 7 ^ m3 >>> 18 ^ m3 >>> 3 ^ m3 << 25 ^ m3 << 14) + (p3 >>> 17 ^ p3 >>> 19 ^ p3 >>> 10 ^ p3 << 15 ^ p3 << 13) + b3 + t3 | 0;
            D3 = b3 + D3 + (M3 >>> 6 ^ M3 >>> 11 ^ M3 >>> 25 ^ M3 << 26 ^ M3 << 21 ^ M3 << 7) + (K3 ^ M3 & (C3 ^ K3)) + 1955562222 | 0;
            x3 = x3 + D3 | 0;
            D3 = D3 + (S3 & E3 ^ P3 & (S3 ^ E3)) + (S3 >>> 2 ^ S3 >>> 13 ^ S3 >>> 22 ^ S3 << 30 ^ S3 << 19 ^ S3 << 10) | 0;
            m3 = (g3 >>> 7 ^ g3 >>> 18 ^ g3 >>> 3 ^ g3 << 25 ^ g3 << 14) + (y3 >>> 17 ^ y3 >>> 19 ^ y3 >>> 10 ^ y3 << 15 ^ y3 << 13) + m3 + r3 | 0;
            K3 = m3 + K3 + (x3 >>> 6 ^ x3 >>> 11 ^ x3 >>> 25 ^ x3 << 26 ^ x3 << 21 ^ x3 << 7) + (C3 ^ x3 & (M3 ^ C3)) + 2024104815 | 0;
            P3 = P3 + K3 | 0;
            K3 = K3 + (D3 & S3 ^ E3 & (D3 ^ S3)) + (D3 >>> 2 ^ D3 >>> 13 ^ D3 >>> 22 ^ D3 << 30 ^ D3 << 19 ^ D3 << 10) | 0;
            g3 = (w3 >>> 7 ^ w3 >>> 18 ^ w3 >>> 3 ^ w3 << 25 ^ w3 << 14) + (b3 >>> 17 ^ b3 >>> 19 ^ b3 >>> 10 ^ b3 << 15 ^ b3 << 13) + g3 + f3 | 0;
            C3 = g3 + C3 + (P3 >>> 6 ^ P3 >>> 11 ^ P3 >>> 25 ^ P3 << 26 ^ P3 << 21 ^ P3 << 7) + (M3 ^ P3 & (x3 ^ M3)) + 2227730452 | 0;
            E3 = E3 + C3 | 0;
            C3 = C3 + (K3 & D3 ^ S3 & (K3 ^ D3)) + (K3 >>> 2 ^ K3 >>> 13 ^ K3 >>> 22 ^ K3 << 30 ^ K3 << 19 ^ K3 << 10) | 0;
            w3 = (v3 >>> 7 ^ v3 >>> 18 ^ v3 >>> 3 ^ v3 << 25 ^ v3 << 14) + (m3 >>> 17 ^ m3 >>> 19 ^ m3 >>> 10 ^ m3 << 15 ^ m3 << 13) + w3 + d3 | 0;
            M3 = w3 + M3 + (E3 >>> 6 ^ E3 >>> 11 ^ E3 >>> 25 ^ E3 << 26 ^ E3 << 21 ^ E3 << 7) + (x3 ^ E3 & (P3 ^ x3)) + 2361852424 | 0;
            S3 = S3 + M3 | 0;
            M3 = M3 + (C3 & K3 ^ D3 & (C3 ^ K3)) + (C3 >>> 2 ^ C3 >>> 13 ^ C3 >>> 22 ^ C3 << 30 ^ C3 << 19 ^ C3 << 10) | 0;
            v3 = (_3 >>> 7 ^ _3 >>> 18 ^ _3 >>> 3 ^ _3 << 25 ^ _3 << 14) + (g3 >>> 17 ^ g3 >>> 19 ^ g3 >>> 10 ^ g3 << 15 ^ g3 << 13) + v3 + l3 | 0;
            x3 = v3 + x3 + (S3 >>> 6 ^ S3 >>> 11 ^ S3 >>> 25 ^ S3 << 26 ^ S3 << 21 ^ S3 << 7) + (P3 ^ S3 & (E3 ^ P3)) + 2428436474 | 0;
            D3 = D3 + x3 | 0;
            x3 = x3 + (M3 & C3 ^ K3 & (M3 ^ C3)) + (M3 >>> 2 ^ M3 >>> 13 ^ M3 >>> 22 ^ M3 << 30 ^ M3 << 19 ^ M3 << 10) | 0;
            _3 = (k3 >>> 7 ^ k3 >>> 18 ^ k3 >>> 3 ^ k3 << 25 ^ k3 << 14) + (w3 >>> 17 ^ w3 >>> 19 ^ w3 >>> 10 ^ w3 << 15 ^ w3 << 13) + _3 + p3 | 0;
            P3 = _3 + P3 + (D3 >>> 6 ^ D3 >>> 11 ^ D3 >>> 25 ^ D3 << 26 ^ D3 << 21 ^ D3 << 7) + (E3 ^ D3 & (S3 ^ E3)) + 2756734187 | 0;
            K3 = K3 + P3 | 0;
            P3 = P3 + (x3 & M3 ^ C3 & (x3 ^ M3)) + (x3 >>> 2 ^ x3 >>> 13 ^ x3 >>> 22 ^ x3 << 30 ^ x3 << 19 ^ x3 << 10) | 0;
            k3 = (A3 >>> 7 ^ A3 >>> 18 ^ A3 >>> 3 ^ A3 << 25 ^ A3 << 14) + (v3 >>> 17 ^ v3 >>> 19 ^ v3 >>> 10 ^ v3 << 15 ^ v3 << 13) + k3 + y3 | 0;
            E3 = k3 + E3 + (K3 >>> 6 ^ K3 >>> 11 ^ K3 >>> 25 ^ K3 << 26 ^ K3 << 21 ^ K3 << 7) + (S3 ^ K3 & (D3 ^ S3)) + 3204031479 | 0;
            C3 = C3 + E3 | 0;
            E3 = E3 + (P3 & x3 ^ M3 & (P3 ^ x3)) + (P3 >>> 2 ^ P3 >>> 13 ^ P3 >>> 22 ^ P3 << 30 ^ P3 << 19 ^ P3 << 10) | 0;
            A3 = (e3 >>> 7 ^ e3 >>> 18 ^ e3 >>> 3 ^ e3 << 25 ^ e3 << 14) + (_3 >>> 17 ^ _3 >>> 19 ^ _3 >>> 10 ^ _3 << 15 ^ _3 << 13) + A3 + b3 | 0;
            S3 = A3 + S3 + (C3 >>> 6 ^ C3 >>> 11 ^ C3 >>> 25 ^ C3 << 26 ^ C3 << 21 ^ C3 << 7) + (D3 ^ C3 & (K3 ^ D3)) + 3329325298 | 0;
            M3 = M3 + S3 | 0;
            S3 = S3 + (E3 & P3 ^ x3 & (E3 ^ P3)) + (E3 >>> 2 ^ E3 >>> 13 ^ E3 >>> 22 ^ E3 << 30 ^ E3 << 19 ^ E3 << 10) | 0;
            i2 = i2 + S3 | 0;
            n2 = n2 + E3 | 0;
            a2 = a2 + P3 | 0;
            s2 = s2 + x3 | 0;
            o2 = o2 + M3 | 0;
            c2 = c2 + C3 | 0;
            u2 = u2 + K3 | 0;
            h2 = h2 + D3 | 0;
          }
          function D2(e3) {
            e3 = e3 | 0;
            K2(C2[e3 | 0] << 24 | C2[e3 | 1] << 16 | C2[e3 | 2] << 8 | C2[e3 | 3], C2[e3 | 4] << 24 | C2[e3 | 5] << 16 | C2[e3 | 6] << 8 | C2[e3 | 7], C2[e3 | 8] << 24 | C2[e3 | 9] << 16 | C2[e3 | 10] << 8 | C2[e3 | 11], C2[e3 | 12] << 24 | C2[e3 | 13] << 16 | C2[e3 | 14] << 8 | C2[e3 | 15], C2[e3 | 16] << 24 | C2[e3 | 17] << 16 | C2[e3 | 18] << 8 | C2[e3 | 19], C2[e3 | 20] << 24 | C2[e3 | 21] << 16 | C2[e3 | 22] << 8 | C2[e3 | 23], C2[e3 | 24] << 24 | C2[e3 | 25] << 16 | C2[e3 | 26] << 8 | C2[e3 | 27], C2[e3 | 28] << 24 | C2[e3 | 29] << 16 | C2[e3 | 30] << 8 | C2[e3 | 31], C2[e3 | 32] << 24 | C2[e3 | 33] << 16 | C2[e3 | 34] << 8 | C2[e3 | 35], C2[e3 | 36] << 24 | C2[e3 | 37] << 16 | C2[e3 | 38] << 8 | C2[e3 | 39], C2[e3 | 40] << 24 | C2[e3 | 41] << 16 | C2[e3 | 42] << 8 | C2[e3 | 43], C2[e3 | 44] << 24 | C2[e3 | 45] << 16 | C2[e3 | 46] << 8 | C2[e3 | 47], C2[e3 | 48] << 24 | C2[e3 | 49] << 16 | C2[e3 | 50] << 8 | C2[e3 | 51], C2[e3 | 52] << 24 | C2[e3 | 53] << 16 | C2[e3 | 54] << 8 | C2[e3 | 55], C2[e3 | 56] << 24 | C2[e3 | 57] << 16 | C2[e3 | 58] << 8 | C2[e3 | 59], C2[e3 | 60] << 24 | C2[e3 | 61] << 16 | C2[e3 | 62] << 8 | C2[e3 | 63]);
          }
          function R2(e3) {
            e3 = e3 | 0;
            C2[e3 | 0] = i2 >>> 24;
            C2[e3 | 1] = i2 >>> 16 & 255;
            C2[e3 | 2] = i2 >>> 8 & 255;
            C2[e3 | 3] = i2 & 255;
            C2[e3 | 4] = n2 >>> 24;
            C2[e3 | 5] = n2 >>> 16 & 255;
            C2[e3 | 6] = n2 >>> 8 & 255;
            C2[e3 | 7] = n2 & 255;
            C2[e3 | 8] = a2 >>> 24;
            C2[e3 | 9] = a2 >>> 16 & 255;
            C2[e3 | 10] = a2 >>> 8 & 255;
            C2[e3 | 11] = a2 & 255;
            C2[e3 | 12] = s2 >>> 24;
            C2[e3 | 13] = s2 >>> 16 & 255;
            C2[e3 | 14] = s2 >>> 8 & 255;
            C2[e3 | 15] = s2 & 255;
            C2[e3 | 16] = o2 >>> 24;
            C2[e3 | 17] = o2 >>> 16 & 255;
            C2[e3 | 18] = o2 >>> 8 & 255;
            C2[e3 | 19] = o2 & 255;
            C2[e3 | 20] = c2 >>> 24;
            C2[e3 | 21] = c2 >>> 16 & 255;
            C2[e3 | 22] = c2 >>> 8 & 255;
            C2[e3 | 23] = c2 & 255;
            C2[e3 | 24] = u2 >>> 24;
            C2[e3 | 25] = u2 >>> 16 & 255;
            C2[e3 | 26] = u2 >>> 8 & 255;
            C2[e3 | 27] = u2 & 255;
            C2[e3 | 28] = h2 >>> 24;
            C2[e3 | 29] = h2 >>> 16 & 255;
            C2[e3 | 30] = h2 >>> 8 & 255;
            C2[e3 | 31] = h2 & 255;
          }
          function I2() {
            i2 = 1779033703;
            n2 = 3144134277;
            a2 = 1013904242;
            s2 = 2773480762;
            o2 = 1359893119;
            c2 = 2600822924;
            u2 = 528734635;
            h2 = 1541459225;
            f2 = d2 = 0;
          }
          function U2(e3, t3, r3, l3, p3, y3, b3, m3, g3, w3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            l3 = l3 | 0;
            p3 = p3 | 0;
            y3 = y3 | 0;
            b3 = b3 | 0;
            m3 = m3 | 0;
            g3 = g3 | 0;
            w3 = w3 | 0;
            i2 = e3;
            n2 = t3;
            a2 = r3;
            s2 = l3;
            o2 = p3;
            c2 = y3;
            u2 = b3;
            h2 = m3;
            f2 = g3;
            d2 = w3;
          }
          function B2(e3, t3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            var r3 = 0;
            if (e3 & 63)
              return -1;
            while ((t3 | 0) >= 64) {
              D2(e3);
              e3 = e3 + 64 | 0;
              t3 = t3 - 64 | 0;
              r3 = r3 + 64 | 0;
            }
            f2 = f2 + r3 | 0;
            if (f2 >>> 0 < r3 >>> 0)
              d2 = d2 + 1 | 0;
            return r3 | 0;
          }
          function T2(e3, t3, r3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            var i3 = 0, n3 = 0;
            if (e3 & 63)
              return -1;
            if (~r3) {
              if (r3 & 31)
                return -1;
            }
            if ((t3 | 0) >= 64) {
              i3 = B2(e3, t3) | 0;
              if ((i3 | 0) == -1)
                return -1;
              e3 = e3 + i3 | 0;
              t3 = t3 - i3 | 0;
            }
            i3 = i3 + t3 | 0;
            f2 = f2 + t3 | 0;
            if (f2 >>> 0 < t3 >>> 0)
              d2 = d2 + 1 | 0;
            C2[e3 | t3] = 128;
            if ((t3 | 0) >= 56) {
              for (n3 = t3 + 1 | 0; (n3 | 0) < 64; n3 = n3 + 1 | 0)
                C2[e3 | n3] = 0;
              D2(e3);
              t3 = 0;
              C2[e3 | 0] = 0;
            }
            for (n3 = t3 + 1 | 0; (n3 | 0) < 59; n3 = n3 + 1 | 0)
              C2[e3 | n3] = 0;
            C2[e3 | 56] = d2 >>> 21 & 255;
            C2[e3 | 57] = d2 >>> 13 & 255;
            C2[e3 | 58] = d2 >>> 5 & 255;
            C2[e3 | 59] = d2 << 3 & 255 | f2 >>> 29;
            C2[e3 | 60] = f2 >>> 21 & 255;
            C2[e3 | 61] = f2 >>> 13 & 255;
            C2[e3 | 62] = f2 >>> 5 & 255;
            C2[e3 | 63] = f2 << 3 & 255;
            D2(e3);
            if (~r3)
              R2(r3);
            return i3 | 0;
          }
          function z2() {
            i2 = l2;
            n2 = p2;
            a2 = y2;
            s2 = b2;
            o2 = m2;
            c2 = g2;
            u2 = w2;
            h2 = v2;
            f2 = 64;
            d2 = 0;
          }
          function q2() {
            i2 = _2;
            n2 = k2;
            a2 = A2;
            s2 = S2;
            o2 = E2;
            c2 = P2;
            u2 = x2;
            h2 = M2;
            f2 = 64;
            d2 = 0;
          }
          function O2(e3, t3, r3, C3, D3, R3, U3, B3, T3, z3, q3, O3, F3, N3, j2, L2) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            C3 = C3 | 0;
            D3 = D3 | 0;
            R3 = R3 | 0;
            U3 = U3 | 0;
            B3 = B3 | 0;
            T3 = T3 | 0;
            z3 = z3 | 0;
            q3 = q3 | 0;
            O3 = O3 | 0;
            F3 = F3 | 0;
            N3 = N3 | 0;
            j2 = j2 | 0;
            L2 = L2 | 0;
            I2();
            K2(e3 ^ 1549556828, t3 ^ 1549556828, r3 ^ 1549556828, C3 ^ 1549556828, D3 ^ 1549556828, R3 ^ 1549556828, U3 ^ 1549556828, B3 ^ 1549556828, T3 ^ 1549556828, z3 ^ 1549556828, q3 ^ 1549556828, O3 ^ 1549556828, F3 ^ 1549556828, N3 ^ 1549556828, j2 ^ 1549556828, L2 ^ 1549556828);
            _2 = i2;
            k2 = n2;
            A2 = a2;
            S2 = s2;
            E2 = o2;
            P2 = c2;
            x2 = u2;
            M2 = h2;
            I2();
            K2(e3 ^ 909522486, t3 ^ 909522486, r3 ^ 909522486, C3 ^ 909522486, D3 ^ 909522486, R3 ^ 909522486, U3 ^ 909522486, B3 ^ 909522486, T3 ^ 909522486, z3 ^ 909522486, q3 ^ 909522486, O3 ^ 909522486, F3 ^ 909522486, N3 ^ 909522486, j2 ^ 909522486, L2 ^ 909522486);
            l2 = i2;
            p2 = n2;
            y2 = a2;
            b2 = s2;
            m2 = o2;
            g2 = c2;
            w2 = u2;
            v2 = h2;
            f2 = 64;
            d2 = 0;
          }
          function F2(e3, t3, r3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            var f3 = 0, d3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0, g3 = 0, w3 = 0;
            if (e3 & 63)
              return -1;
            if (~r3) {
              if (r3 & 31)
                return -1;
            }
            w3 = T2(e3, t3, -1) | 0;
            f3 = i2, d3 = n2, l3 = a2, p3 = s2, y3 = o2, b3 = c2, m3 = u2, g3 = h2;
            q2();
            K2(f3, d3, l3, p3, y3, b3, m3, g3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
            if (~r3)
              R2(r3);
            return w3 | 0;
          }
          function N2(e3, t3, r3, f3, d3) {
            e3 = e3 | 0;
            t3 = t3 | 0;
            r3 = r3 | 0;
            f3 = f3 | 0;
            d3 = d3 | 0;
            var l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0, g3 = 0, w3 = 0, v3 = 0, _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0;
            if (e3 & 63)
              return -1;
            if (~d3) {
              if (d3 & 31)
                return -1;
            }
            C2[e3 + t3 | 0] = r3 >>> 24;
            C2[e3 + t3 + 1 | 0] = r3 >>> 16 & 255;
            C2[e3 + t3 + 2 | 0] = r3 >>> 8 & 255;
            C2[e3 + t3 + 3 | 0] = r3 & 255;
            F2(e3, t3 + 4 | 0, -1) | 0;
            l3 = _3 = i2, p3 = k3 = n2, y3 = A3 = a2, b3 = S3 = s2, m3 = E3 = o2, g3 = P3 = c2, w3 = x3 = u2, v3 = M3 = h2;
            f3 = f3 - 1 | 0;
            while ((f3 | 0) > 0) {
              z2();
              K2(_3, k3, A3, S3, E3, P3, x3, M3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
              _3 = i2, k3 = n2, A3 = a2, S3 = s2, E3 = o2, P3 = c2, x3 = u2, M3 = h2;
              q2();
              K2(_3, k3, A3, S3, E3, P3, x3, M3, 2147483648, 0, 0, 0, 0, 0, 0, 768);
              _3 = i2, k3 = n2, A3 = a2, S3 = s2, E3 = o2, P3 = c2, x3 = u2, M3 = h2;
              l3 = l3 ^ i2;
              p3 = p3 ^ n2;
              y3 = y3 ^ a2;
              b3 = b3 ^ s2;
              m3 = m3 ^ o2;
              g3 = g3 ^ c2;
              w3 = w3 ^ u2;
              v3 = v3 ^ h2;
              f3 = f3 - 1 | 0;
            }
            i2 = l3;
            n2 = p3;
            a2 = y3;
            s2 = b3;
            o2 = m3;
            c2 = g3;
            u2 = w3;
            h2 = v3;
            if (~d3)
              R2(d3);
            return 0;
          }
          return { reset: I2, init: U2, process: B2, finish: T2, hmac_reset: z2, hmac_init: O2, hmac_finish: F2, pbkdf2_generate_block: N2 };
        }({ Uint8Array }, null, this.heap.buffer), this.reset()), { heap: this.heap, asm: this.asm };
      }
      release_asm() {
        this.heap !== void 0 && this.asm !== void 0 && (ht.push(this.heap), ft.push(this.asm)), this.heap = void 0, this.asm = void 0;
      }
      static bytes(e2) {
        return new dt().process(e2).finish().result;
      }
    };
    dt.NAME = "sha256";
    var lt = pt;
    function pt(e2, t2) {
      if (!e2)
        throw Error(t2 || "Assertion failed");
    }
    pt.equal = function(e2, t2, r2) {
      if (e2 != t2)
        throw Error(r2 || "Assertion failed: " + e2 + " != " + t2);
    };
    var yt = e !== void 0 ? e : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
    function bt(e2, t2) {
      return e2(t2 = { exports: {} }, t2.exports), t2.exports;
    }
    var mt = bt(function(e2) {
      e2.exports = typeof Object.create == "function" ? function(e3, t2) {
        e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } });
      } : function(e3, t2) {
        e3.super_ = t2;
        var r2 = function() {
        };
        r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
      };
    });
    var gt = bt(function(e2) {
      try {
        var t2 = p.default;
        if (typeof t2.inherits != "function")
          throw "";
        e2.exports = t2.inherits;
      } catch (t3) {
        e2.exports = mt;
      }
    });
    function wt(e2) {
      return (e2 >>> 24 | e2 >>> 8 & 65280 | e2 << 8 & 16711680 | (255 & e2) << 24) >>> 0;
    }
    function vt(e2) {
      return e2.length === 1 ? "0" + e2 : e2;
    }
    function _t(e2) {
      return e2.length === 7 ? "0" + e2 : e2.length === 6 ? "00" + e2 : e2.length === 5 ? "000" + e2 : e2.length === 4 ? "0000" + e2 : e2.length === 3 ? "00000" + e2 : e2.length === 2 ? "000000" + e2 : e2.length === 1 ? "0000000" + e2 : e2;
    }
    var kt = { inherits: gt, toArray: function(e2, t2) {
      if (Array.isArray(e2))
        return e2.slice();
      if (!e2)
        return [];
      var r2 = [];
      if (typeof e2 == "string")
        if (t2) {
          if (t2 === "hex")
            for ((e2 = e2.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e2 = "0" + e2), i2 = 0; i2 < e2.length; i2 += 2)
              r2.push(parseInt(e2[i2] + e2[i2 + 1], 16));
        } else
          for (var i2 = 0; i2 < e2.length; i2++) {
            var n2 = e2.charCodeAt(i2), a2 = n2 >> 8, s2 = 255 & n2;
            a2 ? r2.push(a2, s2) : r2.push(s2);
          }
      else
        for (i2 = 0; i2 < e2.length; i2++)
          r2[i2] = 0 | e2[i2];
      return r2;
    }, toHex: function(e2) {
      for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
        t2 += vt(e2[r2].toString(16));
      return t2;
    }, htonl: wt, toHex32: function(e2, t2) {
      for (var r2 = "", i2 = 0; i2 < e2.length; i2++) {
        var n2 = e2[i2];
        t2 === "little" && (n2 = wt(n2)), r2 += _t(n2.toString(16));
      }
      return r2;
    }, zero2: vt, zero8: _t, join32: function(e2, t2, r2, i2) {
      var n2 = r2 - t2;
      lt(n2 % 4 == 0);
      for (var a2 = Array(n2 / 4), s2 = 0, o2 = t2; s2 < a2.length; s2++, o2 += 4) {
        var c2;
        c2 = i2 === "big" ? e2[o2] << 24 | e2[o2 + 1] << 16 | e2[o2 + 2] << 8 | e2[o2 + 3] : e2[o2 + 3] << 24 | e2[o2 + 2] << 16 | e2[o2 + 1] << 8 | e2[o2], a2[s2] = c2 >>> 0;
      }
      return a2;
    }, split32: function(e2, t2) {
      for (var r2 = Array(4 * e2.length), i2 = 0, n2 = 0; i2 < e2.length; i2++, n2 += 4) {
        var a2 = e2[i2];
        t2 === "big" ? (r2[n2] = a2 >>> 24, r2[n2 + 1] = a2 >>> 16 & 255, r2[n2 + 2] = a2 >>> 8 & 255, r2[n2 + 3] = 255 & a2) : (r2[n2 + 3] = a2 >>> 24, r2[n2 + 2] = a2 >>> 16 & 255, r2[n2 + 1] = a2 >>> 8 & 255, r2[n2] = 255 & a2);
      }
      return r2;
    }, rotr32: function(e2, t2) {
      return e2 >>> t2 | e2 << 32 - t2;
    }, rotl32: function(e2, t2) {
      return e2 << t2 | e2 >>> 32 - t2;
    }, sum32: function(e2, t2) {
      return e2 + t2 >>> 0;
    }, sum32_3: function(e2, t2, r2) {
      return e2 + t2 + r2 >>> 0;
    }, sum32_4: function(e2, t2, r2, i2) {
      return e2 + t2 + r2 + i2 >>> 0;
    }, sum32_5: function(e2, t2, r2, i2, n2) {
      return e2 + t2 + r2 + i2 + n2 >>> 0;
    }, sum64: function(e2, t2, r2, i2) {
      var n2 = e2[t2], a2 = i2 + e2[t2 + 1] >>> 0, s2 = (a2 < i2 ? 1 : 0) + r2 + n2;
      e2[t2] = s2 >>> 0, e2[t2 + 1] = a2;
    }, sum64_hi: function(e2, t2, r2, i2) {
      return (t2 + i2 >>> 0 < t2 ? 1 : 0) + e2 + r2 >>> 0;
    }, sum64_lo: function(e2, t2, r2, i2) {
      return t2 + i2 >>> 0;
    }, sum64_4_hi: function(e2, t2, r2, i2, n2, a2, s2, o2) {
      var c2 = 0, u2 = t2;
      return c2 += (u2 = u2 + i2 >>> 0) < t2 ? 1 : 0, c2 += (u2 = u2 + a2 >>> 0) < a2 ? 1 : 0, e2 + r2 + n2 + s2 + (c2 += (u2 = u2 + o2 >>> 0) < o2 ? 1 : 0) >>> 0;
    }, sum64_4_lo: function(e2, t2, r2, i2, n2, a2, s2, o2) {
      return t2 + i2 + a2 + o2 >>> 0;
    }, sum64_5_hi: function(e2, t2, r2, i2, n2, a2, s2, o2, c2, u2) {
      var h2 = 0, f2 = t2;
      return h2 += (f2 = f2 + i2 >>> 0) < t2 ? 1 : 0, h2 += (f2 = f2 + a2 >>> 0) < a2 ? 1 : 0, h2 += (f2 = f2 + o2 >>> 0) < o2 ? 1 : 0, e2 + r2 + n2 + s2 + c2 + (h2 += (f2 = f2 + u2 >>> 0) < u2 ? 1 : 0) >>> 0;
    }, sum64_5_lo: function(e2, t2, r2, i2, n2, a2, s2, o2, c2, u2) {
      return t2 + i2 + a2 + o2 + u2 >>> 0;
    }, rotr64_hi: function(e2, t2, r2) {
      return (t2 << 32 - r2 | e2 >>> r2) >>> 0;
    }, rotr64_lo: function(e2, t2, r2) {
      return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
    }, shr64_hi: function(e2, t2, r2) {
      return e2 >>> r2;
    }, shr64_lo: function(e2, t2, r2) {
      return (e2 << 32 - r2 | t2 >>> r2) >>> 0;
    } };
    function At() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    var St = At;
    At.prototype.update = function(e2, t2) {
      if (e2 = kt.toArray(e2, t2), this.pending ? this.pending = this.pending.concat(e2) : this.pending = e2, this.pendingTotal += e2.length, this.pending.length >= this._delta8) {
        var r2 = (e2 = this.pending).length % this._delta8;
        this.pending = e2.slice(e2.length - r2, e2.length), this.pending.length === 0 && (this.pending = null), e2 = kt.join32(e2, 0, e2.length - r2, this.endian);
        for (var i2 = 0; i2 < e2.length; i2 += this._delta32)
          this._update(e2, i2, i2 + this._delta32);
      }
      return this;
    }, At.prototype.digest = function(e2) {
      return this.update(this._pad()), lt(this.pending === null), this._digest(e2);
    }, At.prototype._pad = function() {
      var e2 = this.pendingTotal, t2 = this._delta8, r2 = t2 - (e2 + this.padLength) % t2, i2 = Array(r2 + this.padLength);
      i2[0] = 128;
      for (var n2 = 1; n2 < r2; n2++)
        i2[n2] = 0;
      if (e2 <<= 3, this.endian === "big") {
        for (var a2 = 8; a2 < this.padLength; a2++)
          i2[n2++] = 0;
        i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = e2 >>> 24 & 255, i2[n2++] = e2 >>> 16 & 255, i2[n2++] = e2 >>> 8 & 255, i2[n2++] = 255 & e2;
      } else
        for (i2[n2++] = 255 & e2, i2[n2++] = e2 >>> 8 & 255, i2[n2++] = e2 >>> 16 & 255, i2[n2++] = e2 >>> 24 & 255, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, i2[n2++] = 0, a2 = 8; a2 < this.padLength; a2++)
          i2[n2++] = 0;
      return i2;
    };
    var Et = { BlockHash: St };
    var Pt = kt.rotr32;
    function xt(e2, t2, r2) {
      return e2 & t2 ^ ~e2 & r2;
    }
    function Mt(e2, t2, r2) {
      return e2 & t2 ^ e2 & r2 ^ t2 & r2;
    }
    function Ct(e2, t2, r2) {
      return e2 ^ t2 ^ r2;
    }
    var Kt = { ft_1: function(e2, t2, r2, i2) {
      return e2 === 0 ? xt(t2, r2, i2) : e2 === 1 || e2 === 3 ? Ct(t2, r2, i2) : e2 === 2 ? Mt(t2, r2, i2) : void 0;
    }, ch32: xt, maj32: Mt, p32: Ct, s0_256: function(e2) {
      return Pt(e2, 2) ^ Pt(e2, 13) ^ Pt(e2, 22);
    }, s1_256: function(e2) {
      return Pt(e2, 6) ^ Pt(e2, 11) ^ Pt(e2, 25);
    }, g0_256: function(e2) {
      return Pt(e2, 7) ^ Pt(e2, 18) ^ e2 >>> 3;
    }, g1_256: function(e2) {
      return Pt(e2, 17) ^ Pt(e2, 19) ^ e2 >>> 10;
    } };
    var Dt = kt.sum32;
    var Rt = kt.sum32_4;
    var It = kt.sum32_5;
    var Ut = Kt.ch32;
    var Bt = Kt.maj32;
    var Tt = Kt.s0_256;
    var zt = Kt.s1_256;
    var qt = Kt.g0_256;
    var Ot = Kt.g1_256;
    var Ft = Et.BlockHash;
    var Nt = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function jt() {
      if (!(this instanceof jt))
        return new jt();
      Ft.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = Nt, this.W = Array(64);
    }
    kt.inherits(jt, Ft);
    var Lt = jt;
    function Wt() {
      if (!(this instanceof Wt))
        return new Wt();
      Lt.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    jt.blockSize = 512, jt.outSize = 256, jt.hmacStrength = 192, jt.padLength = 64, jt.prototype._update = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 16; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2++)
        r2[i2] = Rt(Ot(r2[i2 - 2]), r2[i2 - 7], qt(r2[i2 - 15]), r2[i2 - 16]);
      var n2 = this.h[0], a2 = this.h[1], s2 = this.h[2], o2 = this.h[3], c2 = this.h[4], u2 = this.h[5], h2 = this.h[6], f2 = this.h[7];
      for (lt(this.k.length === r2.length), i2 = 0; i2 < r2.length; i2++) {
        var d2 = It(f2, zt(c2), Ut(c2, u2, h2), this.k[i2], r2[i2]), l2 = Dt(Tt(n2), Bt(n2, a2, s2));
        f2 = h2, h2 = u2, u2 = c2, c2 = Dt(o2, d2), o2 = s2, s2 = a2, a2 = n2, n2 = Dt(d2, l2);
      }
      this.h[0] = Dt(this.h[0], n2), this.h[1] = Dt(this.h[1], a2), this.h[2] = Dt(this.h[2], s2), this.h[3] = Dt(this.h[3], o2), this.h[4] = Dt(this.h[4], c2), this.h[5] = Dt(this.h[5], u2), this.h[6] = Dt(this.h[6], h2), this.h[7] = Dt(this.h[7], f2);
    }, jt.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h, "big") : kt.split32(this.h, "big");
    }, kt.inherits(Wt, Lt);
    var Ht = Wt;
    Wt.blockSize = 512, Wt.outSize = 224, Wt.hmacStrength = 192, Wt.padLength = 64, Wt.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h.slice(0, 7), "big") : kt.split32(this.h.slice(0, 7), "big");
    };
    var Gt = kt.rotr64_hi;
    var Vt = kt.rotr64_lo;
    var $t = kt.shr64_hi;
    var Zt = kt.shr64_lo;
    var Yt = kt.sum64;
    var Xt = kt.sum64_hi;
    var Qt = kt.sum64_lo;
    var Jt = kt.sum64_4_hi;
    var er = kt.sum64_4_lo;
    var tr = kt.sum64_5_hi;
    var rr = kt.sum64_5_lo;
    var ir = Et.BlockHash;
    var nr = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function ar() {
      if (!(this instanceof ar))
        return new ar();
      ir.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = nr, this.W = Array(160);
    }
    kt.inherits(ar, ir);
    var sr = ar;
    function or(e2, t2, r2, i2, n2) {
      var a2 = e2 & r2 ^ ~e2 & n2;
      return a2 < 0 && (a2 += 4294967296), a2;
    }
    function cr(e2, t2, r2, i2, n2, a2) {
      var s2 = t2 & i2 ^ ~t2 & a2;
      return s2 < 0 && (s2 += 4294967296), s2;
    }
    function ur(e2, t2, r2, i2, n2) {
      var a2 = e2 & r2 ^ e2 & n2 ^ r2 & n2;
      return a2 < 0 && (a2 += 4294967296), a2;
    }
    function hr(e2, t2, r2, i2, n2, a2) {
      var s2 = t2 & i2 ^ t2 & a2 ^ i2 & a2;
      return s2 < 0 && (s2 += 4294967296), s2;
    }
    function fr(e2, t2) {
      var r2 = Gt(e2, t2, 28) ^ Gt(t2, e2, 2) ^ Gt(t2, e2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function dr(e2, t2) {
      var r2 = Vt(e2, t2, 28) ^ Vt(t2, e2, 2) ^ Vt(t2, e2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function lr(e2, t2) {
      var r2 = Gt(e2, t2, 14) ^ Gt(e2, t2, 18) ^ Gt(t2, e2, 9);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function pr(e2, t2) {
      var r2 = Vt(e2, t2, 14) ^ Vt(e2, t2, 18) ^ Vt(t2, e2, 9);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function yr(e2, t2) {
      var r2 = Gt(e2, t2, 1) ^ Gt(e2, t2, 8) ^ $t(e2, t2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function br(e2, t2) {
      var r2 = Vt(e2, t2, 1) ^ Vt(e2, t2, 8) ^ Zt(e2, t2, 7);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function mr(e2, t2) {
      var r2 = Gt(e2, t2, 19) ^ Gt(t2, e2, 29) ^ $t(e2, t2, 6);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function gr(e2, t2) {
      var r2 = Vt(e2, t2, 19) ^ Vt(t2, e2, 29) ^ Zt(e2, t2, 6);
      return r2 < 0 && (r2 += 4294967296), r2;
    }
    function wr() {
      if (!(this instanceof wr))
        return new wr();
      sr.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    ar.blockSize = 1024, ar.outSize = 512, ar.hmacStrength = 192, ar.padLength = 128, ar.prototype._prepareBlock = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 32; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2 += 2) {
        var n2 = mr(r2[i2 - 4], r2[i2 - 3]), a2 = gr(r2[i2 - 4], r2[i2 - 3]), s2 = r2[i2 - 14], o2 = r2[i2 - 13], c2 = yr(r2[i2 - 30], r2[i2 - 29]), u2 = br(r2[i2 - 30], r2[i2 - 29]), h2 = r2[i2 - 32], f2 = r2[i2 - 31];
        r2[i2] = Jt(n2, a2, s2, o2, c2, u2, h2, f2), r2[i2 + 1] = er(n2, a2, s2, o2, c2, u2, h2, f2);
      }
    }, ar.prototype._update = function(e2, t2) {
      this._prepareBlock(e2, t2);
      var r2 = this.W, i2 = this.h[0], n2 = this.h[1], a2 = this.h[2], s2 = this.h[3], o2 = this.h[4], c2 = this.h[5], u2 = this.h[6], h2 = this.h[7], f2 = this.h[8], d2 = this.h[9], l2 = this.h[10], p2 = this.h[11], y2 = this.h[12], b2 = this.h[13], m2 = this.h[14], g2 = this.h[15];
      lt(this.k.length === r2.length);
      for (var w2 = 0; w2 < r2.length; w2 += 2) {
        var v2 = m2, _2 = g2, k2 = lr(f2, d2), A2 = pr(f2, d2), S2 = or(f2, d2, l2, p2, y2), E2 = cr(f2, d2, l2, p2, y2, b2), P2 = this.k[w2], x2 = this.k[w2 + 1], M2 = r2[w2], C2 = r2[w2 + 1], K2 = tr(v2, _2, k2, A2, S2, E2, P2, x2, M2, C2), D2 = rr(v2, _2, k2, A2, S2, E2, P2, x2, M2, C2);
        v2 = fr(i2, n2), _2 = dr(i2, n2), k2 = ur(i2, n2, a2, s2, o2), A2 = hr(i2, n2, a2, s2, o2, c2);
        var R2 = Xt(v2, _2, k2, A2), I2 = Qt(v2, _2, k2, A2);
        m2 = y2, g2 = b2, y2 = l2, b2 = p2, l2 = f2, p2 = d2, f2 = Xt(u2, h2, K2, D2), d2 = Qt(h2, h2, K2, D2), u2 = o2, h2 = c2, o2 = a2, c2 = s2, a2 = i2, s2 = n2, i2 = Xt(K2, D2, R2, I2), n2 = Qt(K2, D2, R2, I2);
      }
      Yt(this.h, 0, i2, n2), Yt(this.h, 2, a2, s2), Yt(this.h, 4, o2, c2), Yt(this.h, 6, u2, h2), Yt(this.h, 8, f2, d2), Yt(this.h, 10, l2, p2), Yt(this.h, 12, y2, b2), Yt(this.h, 14, m2, g2);
    }, ar.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h, "big") : kt.split32(this.h, "big");
    }, kt.inherits(wr, sr);
    var vr = wr;
    wr.blockSize = 1024, wr.outSize = 384, wr.hmacStrength = 192, wr.padLength = 128, wr.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h.slice(0, 12), "big") : kt.split32(this.h.slice(0, 12), "big");
    };
    var _r = kt.rotl32;
    var kr = kt.sum32;
    var Ar = kt.sum32_3;
    var Sr = kt.sum32_4;
    var Er = Et.BlockHash;
    function Pr() {
      if (!(this instanceof Pr))
        return new Pr();
      Er.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    kt.inherits(Pr, Er);
    var xr = Pr;
    function Mr(e2, t2, r2, i2) {
      return e2 <= 15 ? t2 ^ r2 ^ i2 : e2 <= 31 ? t2 & r2 | ~t2 & i2 : e2 <= 47 ? (t2 | ~r2) ^ i2 : e2 <= 63 ? t2 & i2 | r2 & ~i2 : t2 ^ (r2 | ~i2);
    }
    function Cr(e2) {
      return e2 <= 15 ? 0 : e2 <= 31 ? 1518500249 : e2 <= 47 ? 1859775393 : e2 <= 63 ? 2400959708 : 2840853838;
    }
    function Kr(e2) {
      return e2 <= 15 ? 1352829926 : e2 <= 31 ? 1548603684 : e2 <= 47 ? 1836072691 : e2 <= 63 ? 2053994217 : 0;
    }
    Pr.blockSize = 512, Pr.outSize = 160, Pr.hmacStrength = 192, Pr.padLength = 64, Pr.prototype._update = function(e2, t2) {
      for (var r2 = this.h[0], i2 = this.h[1], n2 = this.h[2], a2 = this.h[3], s2 = this.h[4], o2 = r2, c2 = i2, u2 = n2, h2 = a2, f2 = s2, d2 = 0; d2 < 80; d2++) {
        var l2 = kr(_r(Sr(r2, Mr(d2, i2, n2, a2), e2[Dr[d2] + t2], Cr(d2)), Ir[d2]), s2);
        r2 = s2, s2 = a2, a2 = _r(n2, 10), n2 = i2, i2 = l2, l2 = kr(_r(Sr(o2, Mr(79 - d2, c2, u2, h2), e2[Rr[d2] + t2], Kr(d2)), Ur[d2]), f2), o2 = f2, f2 = h2, h2 = _r(u2, 10), u2 = c2, c2 = l2;
      }
      l2 = Ar(this.h[1], n2, h2), this.h[1] = Ar(this.h[2], a2, f2), this.h[2] = Ar(this.h[3], s2, o2), this.h[3] = Ar(this.h[4], r2, c2), this.h[4] = Ar(this.h[0], i2, u2), this.h[0] = l2;
    }, Pr.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h, "little") : kt.split32(this.h, "little");
    };
    var Dr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
    var Rr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
    var Ir = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
    var Ur = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    var Br = { ripemd160: xr };
    function Tr(e2, t2) {
      let r2 = e2[0], i2 = e2[1], n2 = e2[2], a2 = e2[3];
      r2 = qr(r2, i2, n2, a2, t2[0], 7, -680876936), a2 = qr(a2, r2, i2, n2, t2[1], 12, -389564586), n2 = qr(n2, a2, r2, i2, t2[2], 17, 606105819), i2 = qr(i2, n2, a2, r2, t2[3], 22, -1044525330), r2 = qr(r2, i2, n2, a2, t2[4], 7, -176418897), a2 = qr(a2, r2, i2, n2, t2[5], 12, 1200080426), n2 = qr(n2, a2, r2, i2, t2[6], 17, -1473231341), i2 = qr(i2, n2, a2, r2, t2[7], 22, -45705983), r2 = qr(r2, i2, n2, a2, t2[8], 7, 1770035416), a2 = qr(a2, r2, i2, n2, t2[9], 12, -1958414417), n2 = qr(n2, a2, r2, i2, t2[10], 17, -42063), i2 = qr(i2, n2, a2, r2, t2[11], 22, -1990404162), r2 = qr(r2, i2, n2, a2, t2[12], 7, 1804603682), a2 = qr(a2, r2, i2, n2, t2[13], 12, -40341101), n2 = qr(n2, a2, r2, i2, t2[14], 17, -1502002290), i2 = qr(i2, n2, a2, r2, t2[15], 22, 1236535329), r2 = Or(r2, i2, n2, a2, t2[1], 5, -165796510), a2 = Or(a2, r2, i2, n2, t2[6], 9, -1069501632), n2 = Or(n2, a2, r2, i2, t2[11], 14, 643717713), i2 = Or(i2, n2, a2, r2, t2[0], 20, -373897302), r2 = Or(r2, i2, n2, a2, t2[5], 5, -701558691), a2 = Or(a2, r2, i2, n2, t2[10], 9, 38016083), n2 = Or(n2, a2, r2, i2, t2[15], 14, -660478335), i2 = Or(i2, n2, a2, r2, t2[4], 20, -405537848), r2 = Or(r2, i2, n2, a2, t2[9], 5, 568446438), a2 = Or(a2, r2, i2, n2, t2[14], 9, -1019803690), n2 = Or(n2, a2, r2, i2, t2[3], 14, -187363961), i2 = Or(i2, n2, a2, r2, t2[8], 20, 1163531501), r2 = Or(r2, i2, n2, a2, t2[13], 5, -1444681467), a2 = Or(a2, r2, i2, n2, t2[2], 9, -51403784), n2 = Or(n2, a2, r2, i2, t2[7], 14, 1735328473), i2 = Or(i2, n2, a2, r2, t2[12], 20, -1926607734), r2 = Fr(r2, i2, n2, a2, t2[5], 4, -378558), a2 = Fr(a2, r2, i2, n2, t2[8], 11, -2022574463), n2 = Fr(n2, a2, r2, i2, t2[11], 16, 1839030562), i2 = Fr(i2, n2, a2, r2, t2[14], 23, -35309556), r2 = Fr(r2, i2, n2, a2, t2[1], 4, -1530992060), a2 = Fr(a2, r2, i2, n2, t2[4], 11, 1272893353), n2 = Fr(n2, a2, r2, i2, t2[7], 16, -155497632), i2 = Fr(i2, n2, a2, r2, t2[10], 23, -1094730640), r2 = Fr(r2, i2, n2, a2, t2[13], 4, 681279174), a2 = Fr(a2, r2, i2, n2, t2[0], 11, -358537222), n2 = Fr(n2, a2, r2, i2, t2[3], 16, -722521979), i2 = Fr(i2, n2, a2, r2, t2[6], 23, 76029189), r2 = Fr(r2, i2, n2, a2, t2[9], 4, -640364487), a2 = Fr(a2, r2, i2, n2, t2[12], 11, -421815835), n2 = Fr(n2, a2, r2, i2, t2[15], 16, 530742520), i2 = Fr(i2, n2, a2, r2, t2[2], 23, -995338651), r2 = Nr(r2, i2, n2, a2, t2[0], 6, -198630844), a2 = Nr(a2, r2, i2, n2, t2[7], 10, 1126891415), n2 = Nr(n2, a2, r2, i2, t2[14], 15, -1416354905), i2 = Nr(i2, n2, a2, r2, t2[5], 21, -57434055), r2 = Nr(r2, i2, n2, a2, t2[12], 6, 1700485571), a2 = Nr(a2, r2, i2, n2, t2[3], 10, -1894986606), n2 = Nr(n2, a2, r2, i2, t2[10], 15, -1051523), i2 = Nr(i2, n2, a2, r2, t2[1], 21, -2054922799), r2 = Nr(r2, i2, n2, a2, t2[8], 6, 1873313359), a2 = Nr(a2, r2, i2, n2, t2[15], 10, -30611744), n2 = Nr(n2, a2, r2, i2, t2[6], 15, -1560198380), i2 = Nr(i2, n2, a2, r2, t2[13], 21, 1309151649), r2 = Nr(r2, i2, n2, a2, t2[4], 6, -145523070), a2 = Nr(a2, r2, i2, n2, t2[11], 10, -1120210379), n2 = Nr(n2, a2, r2, i2, t2[2], 15, 718787259), i2 = Nr(i2, n2, a2, r2, t2[9], 21, -343485551), e2[0] = Hr(r2, e2[0]), e2[1] = Hr(i2, e2[1]), e2[2] = Hr(n2, e2[2]), e2[3] = Hr(a2, e2[3]);
    }
    function zr(e2, t2, r2, i2, n2, a2) {
      return t2 = Hr(Hr(t2, e2), Hr(i2, a2)), Hr(t2 << n2 | t2 >>> 32 - n2, r2);
    }
    function qr(e2, t2, r2, i2, n2, a2, s2) {
      return zr(t2 & r2 | ~t2 & i2, e2, t2, n2, a2, s2);
    }
    function Or(e2, t2, r2, i2, n2, a2, s2) {
      return zr(t2 & i2 | r2 & ~i2, e2, t2, n2, a2, s2);
    }
    function Fr(e2, t2, r2, i2, n2, a2, s2) {
      return zr(t2 ^ r2 ^ i2, e2, t2, n2, a2, s2);
    }
    function Nr(e2, t2, r2, i2, n2, a2, s2) {
      return zr(r2 ^ (t2 | ~i2), e2, t2, n2, a2, s2);
    }
    function jr(e2) {
      const t2 = [];
      let r2;
      for (r2 = 0; r2 < 64; r2 += 4)
        t2[r2 >> 2] = e2.charCodeAt(r2) + (e2.charCodeAt(r2 + 1) << 8) + (e2.charCodeAt(r2 + 2) << 16) + (e2.charCodeAt(r2 + 3) << 24);
      return t2;
    }
    var Lr = "0123456789abcdef".split("");
    function Wr(e2) {
      let t2 = "", r2 = 0;
      for (; r2 < 4; r2++)
        t2 += Lr[e2 >> 8 * r2 + 4 & 15] + Lr[e2 >> 8 * r2 & 15];
      return t2;
    }
    function Hr(e2, t2) {
      return e2 + t2 & 4294967295;
    }
    var Gr = ce.getWebCrypto();
    var Vr = ce.getNodeCrypto();
    function $r(e2) {
      return async function(t2) {
        const r2 = Vr.createHash(e2);
        return Y(t2, (e3) => {
          r2.update(e3);
        }, () => new Uint8Array(r2.digest()));
      };
    }
    function Zr(e2, t2) {
      return async function(r2, i2 = ge) {
        if (_(r2) && (r2 = await ie(r2)), !ce.isStream(r2) && Gr && t2 && r2.length >= i2.minBytesForWebCrypto)
          return new Uint8Array(await Gr.digest(t2, r2));
        const n2 = e2();
        return Y(r2, (e3) => {
          n2.update(e3);
        }, () => new Uint8Array(n2.digest()));
      };
    }
    function Yr(e2, t2) {
      return async function(r2, i2 = ge) {
        if (_(r2) && (r2 = await ie(r2)), ce.isStream(r2)) {
          const t3 = new e2();
          return Y(r2, (e3) => {
            t3.process(e3);
          }, () => t3.finish().result);
        }
        return Gr && t2 && r2.length >= i2.minBytesForWebCrypto ? new Uint8Array(await Gr.digest(t2, r2)) : e2.bytes(r2);
      };
    }
    var Xr;
    Xr = Vr ? { md5: $r("md5"), sha1: $r("sha1"), sha224: $r("sha224"), sha256: $r("sha256"), sha384: $r("sha384"), sha512: $r("sha512"), ripemd: $r("ripemd160") } : { md5: async function(e2) {
      const t2 = function(e3) {
        const t3 = e3.length, r2 = [1732584193, -271733879, -1732584194, 271733878];
        let i2;
        for (i2 = 64; i2 <= e3.length; i2 += 64)
          Tr(r2, jr(e3.substring(i2 - 64, i2)));
        e3 = e3.substring(i2 - 64);
        const n2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i2 = 0; i2 < e3.length; i2++)
          n2[i2 >> 2] |= e3.charCodeAt(i2) << (i2 % 4 << 3);
        if (n2[i2 >> 2] |= 128 << (i2 % 4 << 3), i2 > 55)
          for (Tr(r2, n2), i2 = 0; i2 < 16; i2++)
            n2[i2] = 0;
        return n2[14] = 8 * t3, Tr(r2, n2), r2;
      }(ce.uint8ArrayToString(e2));
      return ce.hexToUint8Array(function(e3) {
        for (let t3 = 0; t3 < e3.length; t3++)
          e3[t3] = Wr(e3[t3]);
        return e3.join("");
      }(t2));
    }, sha1: Yr(ut, (!navigator.userAgent || navigator.userAgent.indexOf("Edge") === -1) && "SHA-1"), sha224: Zr(Ht), sha256: Yr(dt, "SHA-256"), sha384: Zr(vr, "SHA-384"), sha512: Zr(sr, "SHA-512"), ripemd: Zr(xr) };
    var Qr = { md5: Xr.md5, sha1: Xr.sha1, sha224: Xr.sha224, sha256: Xr.sha256, sha384: Xr.sha384, sha512: Xr.sha512, ripemd: Xr.ripemd, digest: function(e2, t2) {
      switch (e2) {
        case me.hash.md5:
          return this.md5(t2);
        case me.hash.sha1:
          return this.sha1(t2);
        case me.hash.ripemd:
          return this.ripemd(t2);
        case me.hash.sha256:
          return this.sha256(t2);
        case me.hash.sha384:
          return this.sha384(t2);
        case me.hash.sha512:
          return this.sha512(t2);
        case me.hash.sha224:
          return this.sha224(t2);
        default:
          throw Error("Invalid hash function.");
      }
    }, getHashByteLength: function(e2) {
      switch (e2) {
        case me.hash.md5:
          return 16;
        case me.hash.sha1:
        case me.hash.ripemd:
          return 20;
        case me.hash.sha256:
          return 32;
        case me.hash.sha384:
          return 48;
        case me.hash.sha512:
          return 64;
        case me.hash.sha224:
          return 28;
        default:
          throw Error("Invalid hash algorithm.");
      }
    } };
    var Jr = class {
      static encrypt(e2, t2, r2) {
        return new Jr(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2) {
        return new Jr(t2, r2).decrypt(e2);
      }
      constructor(e2, t2, r2) {
        this.aes = r2 || new Oe(e2, t2, true, "CFB"), delete this.aes.padding;
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    var ei = ce.getWebCrypto();
    var ti = ce.getNodeCrypto();
    var ri = ti ? ti.getCiphers() : [];
    var ii = { idea: ri.includes("idea-cfb") ? "idea-cfb" : void 0, tripledes: ri.includes("des-ede3-cfb") ? "des-ede3-cfb" : void 0, cast5: ri.includes("cast5-cfb") ? "cast5-cfb" : void 0, blowfish: ri.includes("bf-cfb") ? "bf-cfb" : void 0, aes128: ri.includes("aes-128-cfb") ? "aes-128-cfb" : void 0, aes192: ri.includes("aes-192-cfb") ? "aes-192-cfb" : void 0, aes256: ri.includes("aes-256-cfb") ? "aes-256-cfb" : void 0 };
    var ni = /* @__PURE__ */ Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = me.read(me.symmetric, e2);
      if (ce.getNodeCrypto() && ii[a2])
        return function(e3, t3, r3, i3) {
          const n3 = me.read(me.symmetric, e3), a3 = new ti.createCipheriv(ii[n3], t3, i3);
          return Y(r3, (e4) => new Uint8Array(a3.update(e4)));
        }(e2, t2, r2, i2);
      if (a2.substr(0, 3) === "aes")
        return function(e3, t3, r3, i3, n3) {
          if (ce.getWebCrypto() && t3.length !== 24 && !ce.isStream(r3) && r3.length >= 3e3 * n3.minBytesForWebCrypto)
            return async function(e4, t4, r4, i4) {
              const n4 = "AES-CBC", a4 = await ei.importKey("raw", t4, { name: n4 }, false, ["encrypt"]), { blockSize: s3 } = crypto.getCipher(e4), o3 = ce.concatUint8Array([new Uint8Array(s3), r4]), c3 = new Uint8Array(await ei.encrypt({ name: n4, iv: i4 }, a4, o3)).subarray(0, r4.length);
              return function(e5, t5) {
                for (let r5 = 0; r5 < e5.length; r5++)
                  e5[r5] = e5[r5] ^ t5[r5];
              }(c3, r4), c3;
            }(e3, t3, r3, i3);
          const a3 = new Jr(t3, i3);
          return Y(r3, (e4) => a3.aes.AES_Encrypt_process(e4), () => a3.aes.AES_Encrypt_finish());
        }(e2, t2, r2, i2, n2);
      const s2 = new nt[a2](t2), o2 = s2.blockSize, c2 = i2.slice();
      let u2 = new Uint8Array();
      const h2 = (e3) => {
        e3 && (u2 = ce.concatUint8Array([u2, e3]));
        const t3 = new Uint8Array(u2.length);
        let r3, i3 = 0;
        for (; e3 ? u2.length >= o2 : u2.length; ) {
          const e4 = s2.encrypt(c2);
          for (r3 = 0; r3 < o2; r3++)
            c2[r3] = u2[r3] ^ e4[r3], t3[i3++] = c2[r3];
          u2 = u2.subarray(o2);
        }
        return t3.subarray(0, i3);
      };
      return Y(r2, h2, h2);
    }, decrypt: async function(e2, t2, r2, i2) {
      const n2 = me.read(me.symmetric, e2);
      if (ce.getNodeCrypto() && ii[n2])
        return function(e3, t3, r3, i3) {
          const n3 = me.read(me.symmetric, e3), a3 = new ti.createDecipheriv(ii[n3], t3, i3);
          return Y(r3, (e4) => new Uint8Array(a3.update(e4)));
        }(e2, t2, r2, i2);
      if (n2.substr(0, 3) === "aes")
        return function(e3, t3, r3, i3) {
          if (ce.isStream(r3)) {
            const e4 = new Jr(t3, i3);
            return Y(r3, (t4) => e4.aes.AES_Decrypt_process(t4), () => e4.aes.AES_Decrypt_finish());
          }
          return Jr.decrypt(r3, t3, i3);
        }(0, t2, r2, i2);
      const a2 = new nt[n2](t2), s2 = a2.blockSize;
      let o2 = i2, c2 = new Uint8Array();
      const u2 = (e3) => {
        e3 && (c2 = ce.concatUint8Array([c2, e3]));
        const t3 = new Uint8Array(c2.length);
        let r3, i3 = 0;
        for (; e3 ? c2.length >= s2 : c2.length; ) {
          const e4 = a2.encrypt(o2);
          for (o2 = c2, r3 = 0; r3 < s2; r3++)
            t3[i3++] = o2[r3] ^ e4[r3];
          c2 = c2.subarray(s2);
        }
        return t3.subarray(0, i3);
      };
      return Y(r2, u2, u2);
    } });
    var ai = class {
      static encrypt(e2, t2, r2) {
        return new ai(t2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2) {
        return new ai(t2, r2).encrypt(e2);
      }
      constructor(e2, t2, r2) {
        this.aes = r2 || new Oe(e2, void 0, false, "CTR"), delete this.aes.padding, this.AES_CTR_set_options(t2);
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      AES_CTR_set_options(e2, t2, r2) {
        let { asm: i2 } = this.aes.acquire_asm();
        if (r2 !== void 0) {
          if (r2 < 8 || r2 > 48)
            throw new Be("illegal counter size");
          let e3 = Math.pow(2, r2) - 1;
          i2.set_mask(0, 0, e3 / 4294967296 | 0, 0 | e3);
        } else
          r2 = 48, i2.set_mask(0, 0, 65535, 4294967295);
        if (e2 === void 0)
          throw Error("nonce is required");
        {
          let t3 = e2.length;
          if (!t3 || t3 > 16)
            throw new Be("illegal nonce size");
          let r3 = new DataView(new ArrayBuffer(16));
          new Uint8Array(r3.buffer).set(e2), i2.set_nonce(r3.getUint32(0), r3.getUint32(4), r3.getUint32(8), r3.getUint32(12));
        }
        if (t2 !== void 0) {
          if (t2 < 0 || t2 >= Math.pow(2, r2))
            throw new Be("illegal counter value");
          i2.set_counter(0, 0, t2 / 4294967296 | 0, 0 | t2);
        }
      }
    };
    var si = class {
      static encrypt(e2, t2, r2 = true, i2) {
        return new si(t2, i2, r2).encrypt(e2);
      }
      static decrypt(e2, t2, r2 = true, i2) {
        return new si(t2, i2, r2).decrypt(e2);
      }
      constructor(e2, t2, r2 = true, i2) {
        this.aes = i2 || new Oe(e2, t2, r2, "CBC");
      }
      encrypt(e2) {
        return Ie(this.aes.AES_Encrypt_process(e2), this.aes.AES_Encrypt_finish());
      }
      decrypt(e2) {
        return Ie(this.aes.AES_Decrypt_process(e2), this.aes.AES_Decrypt_finish());
      }
    };
    var oi = ce.getWebCrypto();
    var ci = ce.getNodeCrypto();
    function ui(e2, t2) {
      const r2 = e2.length - 16;
      for (let i2 = 0; i2 < 16; i2++)
        e2[i2 + r2] ^= t2[i2];
      return e2;
    }
    var hi = new Uint8Array(16);
    async function fi(e2) {
      const t2 = await async function(e3) {
        if (ce.getWebCrypto() && e3.length !== 24)
          return e3 = await oi.importKey("raw", e3, { name: "AES-CBC", length: 8 * e3.length }, false, ["encrypt"]), async function(t3) {
            const r3 = await oi.encrypt({ name: "AES-CBC", iv: hi, length: 128 }, e3, t3);
            return new Uint8Array(r3).subarray(0, r3.byteLength - 16);
          };
        if (ce.getNodeCrypto())
          return async function(t3) {
            const r3 = new ci.createCipheriv("aes-" + 8 * e3.length + "-cbc", e3, hi).update(t3);
            return new Uint8Array(r3);
          };
        return async function(t3) {
          return si.encrypt(t3, e3, false, hi);
        };
      }(e2), r2 = ce.double(await t2(hi)), i2 = ce.double(r2);
      return async function(e3) {
        return (await t2(function(e4, t3, r3) {
          if (e4.length && e4.length % 16 == 0)
            return ui(e4, t3);
          const i3 = new Uint8Array(e4.length + (16 - e4.length % 16));
          return i3.set(e4), i3[e4.length] = 128, ui(i3, r3);
        }(e3, r2, i2))).subarray(-16);
      };
    }
    var di = ce.getWebCrypto();
    var li = ce.getNodeCrypto();
    var pi = ce.getNodeBuffer();
    var yi = new Uint8Array(16);
    var bi = new Uint8Array(16);
    bi[15] = 1;
    var mi = new Uint8Array(16);
    async function gi(e2) {
      const t2 = await fi(e2);
      return function(e3, r2) {
        return t2(ce.concatUint8Array([e3, r2]));
      };
    }
    async function wi(e2) {
      return !ce.getWebCrypto() || e2.length === 24 || navigator.userAgent && navigator.userAgent.indexOf("Edge") !== -1 ? ce.getNodeCrypto() ? async function(t2, r2) {
        const i2 = new li.createCipheriv("aes-" + 8 * e2.length + "-ctr", e2, r2), n2 = pi.concat([i2.update(t2), i2.final()]);
        return new Uint8Array(n2);
      } : async function(t2, r2) {
        return ai.encrypt(t2, e2, r2);
      } : (e2 = await di.importKey("raw", e2, { name: "AES-CTR", length: 8 * e2.length }, false, ["encrypt"]), async function(t2, r2) {
        const i2 = await di.encrypt({ name: "AES-CTR", counter: r2, length: 128 }, e2, t2);
        return new Uint8Array(i2);
      });
    }
    async function vi(e2, t2) {
      if (e2 !== me.symmetric.aes128 && e2 !== me.symmetric.aes192 && e2 !== me.symmetric.aes256)
        throw Error("EAX mode supports only AES cipher");
      const [r2, i2] = await Promise.all([gi(t2), wi(t2)]);
      return { encrypt: async function(e3, t3, n2) {
        const [a2, s2] = await Promise.all([r2(yi, t3), r2(bi, n2)]), o2 = await i2(e3, a2), c2 = await r2(mi, o2);
        for (let e4 = 0; e4 < 16; e4++)
          c2[e4] ^= s2[e4] ^ a2[e4];
        return ce.concatUint8Array([o2, c2]);
      }, decrypt: async function(e3, t3, n2) {
        if (e3.length < 16)
          throw Error("Invalid EAX ciphertext");
        const a2 = e3.subarray(0, -16), s2 = e3.subarray(-16), [o2, c2, u2] = await Promise.all([r2(yi, t3), r2(bi, n2), r2(mi, a2)]), h2 = u2;
        for (let e4 = 0; e4 < 16; e4++)
          h2[e4] ^= c2[e4] ^ o2[e4];
        if (!ce.equalsUint8Array(s2, h2))
          throw Error("Authentication tag mismatch");
        return await i2(a2, o2);
      } };
    }
    mi[15] = 2, vi.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[8 + e3] ^= t2[e3];
      return r2;
    }, vi.blockLength = 16, vi.ivLength = 16, vi.tagLength = 16;
    function _i(e2) {
      let t2 = 0;
      for (let r2 = 1; (e2 & r2) == 0; r2 <<= 1)
        t2++;
      return t2;
    }
    function ki(e2, t2) {
      for (let r2 = 0; r2 < e2.length; r2++)
        e2[r2] ^= t2[r2];
      return e2;
    }
    function Ai(e2, t2) {
      return ki(e2.slice(), t2);
    }
    var Si = new Uint8Array(16);
    var Ei = new Uint8Array([1]);
    async function Pi(e2, t2) {
      let r2, i2, n2, a2 = 0;
      function s2(e3, t3, i3, s3) {
        const o2 = t3.length / 16 | 0;
        !function(e4, t4) {
          const r3 = ce.nbits(Math.max(e4.length, t4.length) / 16 | 0) - 1;
          for (let e5 = a2 + 1; e5 <= r3; e5++)
            n2[e5] = ce.double(n2[e5 - 1]);
          a2 = r3;
        }(t3, s3);
        const c2 = ce.concatUint8Array([Si.subarray(0, 15 - i3.length), Ei, i3]), u2 = 63 & c2[15];
        c2[15] &= 192;
        const h2 = r2(c2), f2 = ce.concatUint8Array([h2, Ai(h2.subarray(0, 8), h2.subarray(1, 9))]), d2 = ce.shiftRight(f2.subarray(0 + (u2 >> 3), 17 + (u2 >> 3)), 8 - (7 & u2)).subarray(1), l2 = new Uint8Array(16), p2 = new Uint8Array(t3.length + 16);
        let y2, b2 = 0;
        for (y2 = 0; y2 < o2; y2++)
          ki(d2, n2[_i(y2 + 1)]), p2.set(ki(e3(Ai(d2, t3)), d2), b2), ki(l2, e3 === r2 ? t3 : p2.subarray(b2)), t3 = t3.subarray(16), b2 += 16;
        if (t3.length) {
          ki(d2, n2.x);
          const i4 = r2(d2);
          p2.set(Ai(t3, i4), b2);
          const a3 = new Uint8Array(16);
          a3.set(e3 === r2 ? t3 : p2.subarray(b2, -16), 0), a3[t3.length] = 128, ki(l2, a3), b2 += t3.length;
        }
        const m2 = ki(r2(ki(ki(l2, d2), n2.$)), function(e4) {
          if (!e4.length)
            return Si;
          const t4 = e4.length / 16 | 0, i4 = new Uint8Array(16), a3 = new Uint8Array(16);
          for (let s4 = 0; s4 < t4; s4++)
            ki(i4, n2[_i(s4 + 1)]), ki(a3, r2(Ai(i4, e4))), e4 = e4.subarray(16);
          if (e4.length) {
            ki(i4, n2.x);
            const t5 = new Uint8Array(16);
            t5.set(e4, 0), t5[e4.length] = 128, ki(t5, i4), ki(a3, r2(t5));
          }
          return a3;
        }(s3));
        return p2.set(m2, b2), p2;
      }
      return function(e3, t3) {
        const a3 = me.read(me.symmetric, e3), s3 = new nt[a3](t3);
        r2 = s3.encrypt.bind(s3), i2 = s3.decrypt.bind(s3);
        const o2 = r2(Si), c2 = ce.double(o2);
        n2 = [], n2[0] = ce.double(c2), n2.x = o2, n2.$ = c2;
      }(e2, t2), { encrypt: async function(e3, t3, i3) {
        return s2(r2, e3, t3, i3);
      }, decrypt: async function(e3, t3, r3) {
        if (e3.length < 16)
          throw Error("Invalid OCB ciphertext");
        const n3 = e3.subarray(-16);
        e3 = e3.subarray(0, -16);
        const a3 = s2(i2, e3, t3, r3);
        if (ce.equalsUint8Array(n3, a3.subarray(-16)))
          return a3.subarray(0, -16);
        throw Error("Authentication tag mismatch");
      } };
    }
    Pi.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[7 + e3] ^= t2[e3];
      return r2;
    }, Pi.blockLength = 16, Pi.ivLength = 15, Pi.tagLength = 16;
    var xi = class {
      constructor(e2, t2, r2, i2 = 16, n2) {
        this.tagSize = i2, this.gamma0 = 0, this.counter = 1, this.aes = n2 || new Oe(e2, void 0, false, "CTR");
        let { asm: a2, heap: s2 } = this.aes.acquire_asm();
        if (a2.gcm_init(), this.tagSize < 4 || this.tagSize > 16)
          throw new Be("illegal tagSize value");
        const o2 = t2.length || 0, c2 = new Uint8Array(16);
        o2 !== 12 ? (this._gcm_mac_process(t2), s2[0] = 0, s2[1] = 0, s2[2] = 0, s2[3] = 0, s2[4] = 0, s2[5] = 0, s2[6] = 0, s2[7] = 0, s2[8] = 0, s2[9] = 0, s2[10] = 0, s2[11] = o2 >>> 29, s2[12] = o2 >>> 21 & 255, s2[13] = o2 >>> 13 & 255, s2[14] = o2 >>> 5 & 255, s2[15] = o2 << 3 & 255, a2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), a2.get_iv(Ce.HEAP_DATA), a2.set_iv(0, 0, 0, 0), c2.set(s2.subarray(0, 16))) : (c2.set(t2), c2[15] = 1);
        const u2 = new DataView(c2.buffer);
        if (this.gamma0 = u2.getUint32(12), a2.set_nonce(u2.getUint32(0), u2.getUint32(4), u2.getUint32(8), 0), a2.set_mask(0, 0, 0, 4294967295), r2 !== void 0) {
          if (r2.length > 68719476704)
            throw new Be("illegal adata length");
          r2.length ? (this.adata = r2, this._gcm_mac_process(r2)) : this.adata = void 0;
        } else
          this.adata = void 0;
        if (this.counter < 1 || this.counter > 4294967295)
          throw new RangeError("counter must be a positive 32-bit integer");
        a2.set_counter(0, 0, 0, this.gamma0 + this.counter | 0);
      }
      static encrypt(e2, t2, r2, i2, n2) {
        return new xi(t2, r2, i2, n2).encrypt(e2);
      }
      static decrypt(e2, t2, r2, i2, n2) {
        return new xi(t2, r2, i2, n2).decrypt(e2);
      }
      encrypt(e2) {
        return this.AES_GCM_encrypt(e2);
      }
      decrypt(e2) {
        return this.AES_GCM_decrypt(e2);
      }
      AES_GCM_Encrypt_process(e2) {
        let t2 = 0, r2 = e2.length || 0, { asm: i2, heap: n2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.aes.pos, o2 = this.aes.len, c2 = 0, u2 = o2 + r2 & -16, h2 = 0;
        if ((a2 - 1 << 4) + o2 + r2 > 68719476704)
          throw new RangeError("counter overflow");
        const f2 = new Uint8Array(u2);
        for (; r2 > 0; )
          h2 = Re(n2, s2 + o2, e2, t2, r2), o2 += h2, t2 += h2, r2 -= h2, h2 = i2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA + s2, o2), h2 = i2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + s2, h2), h2 && f2.set(n2.subarray(s2, s2 + h2), c2), a2 += h2 >>> 4, c2 += h2, h2 < o2 ? (s2 += h2, o2 -= h2) : (s2 = 0, o2 = 0);
        return this.counter = a2, this.aes.pos = s2, this.aes.len = o2, f2;
      }
      AES_GCM_Encrypt_finish() {
        let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.counter, i2 = this.tagSize, n2 = this.adata, a2 = this.aes.pos, s2 = this.aes.len;
        const o2 = new Uint8Array(s2 + i2);
        e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA + a2, s2 + 15 & -16), s2 && o2.set(t2.subarray(a2, a2 + s2));
        let c2 = s2;
        for (; 15 & c2; c2++)
          t2[a2 + c2] = 0;
        e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + a2, c2);
        const u2 = n2 !== void 0 ? n2.length : 0, h2 = (r2 - 1 << 4) + s2;
        return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = u2 >>> 29, t2[4] = u2 >>> 21, t2[5] = u2 >>> 13 & 255, t2[6] = u2 >>> 5 & 255, t2[7] = u2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = h2 >>> 29, t2[12] = h2 >>> 21 & 255, t2[13] = h2 >>> 13 & 255, t2[14] = h2 >>> 5 & 255, t2[15] = h2 << 3 & 255, e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), e2.get_iv(Ce.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA, 16), o2.set(t2.subarray(0, i2), s2), this.counter = 1, this.aes.pos = 0, this.aes.len = 0, o2;
      }
      AES_GCM_Decrypt_process(e2) {
        let t2 = 0, r2 = e2.length || 0, { asm: i2, heap: n2 } = this.aes.acquire_asm(), a2 = this.counter, s2 = this.tagSize, o2 = this.aes.pos, c2 = this.aes.len, u2 = 0, h2 = c2 + r2 > s2 ? c2 + r2 - s2 & -16 : 0, f2 = c2 + r2 - h2, d2 = 0;
        if ((a2 - 1 << 4) + c2 + r2 > 68719476704)
          throw new RangeError("counter overflow");
        const l2 = new Uint8Array(h2);
        for (; r2 > f2; )
          d2 = Re(n2, o2 + c2, e2, t2, r2 - f2), c2 += d2, t2 += d2, r2 -= d2, d2 = i2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + o2, d2), d2 = i2.cipher(Ce.DEC.CTR, Ce.HEAP_DATA + o2, d2), d2 && l2.set(n2.subarray(o2, o2 + d2), u2), a2 += d2 >>> 4, u2 += d2, o2 = 0, c2 = 0;
        return r2 > 0 && (c2 += Re(n2, 0, e2, t2, r2)), this.counter = a2, this.aes.pos = o2, this.aes.len = c2, l2;
      }
      AES_GCM_Decrypt_finish() {
        let { asm: e2, heap: t2 } = this.aes.acquire_asm(), r2 = this.tagSize, i2 = this.adata, n2 = this.counter, a2 = this.aes.pos, s2 = this.aes.len, o2 = s2 - r2;
        if (s2 < r2)
          throw new Ue("authentication tag not found");
        const c2 = new Uint8Array(o2), u2 = new Uint8Array(t2.subarray(a2 + o2, a2 + s2));
        let h2 = o2;
        for (; 15 & h2; h2++)
          t2[a2 + h2] = 0;
        e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA + a2, h2), e2.cipher(Ce.DEC.CTR, Ce.HEAP_DATA + a2, h2), o2 && c2.set(t2.subarray(a2, a2 + o2));
        const f2 = i2 !== void 0 ? i2.length : 0, d2 = (n2 - 1 << 4) + s2 - r2;
        t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = f2 >>> 29, t2[4] = f2 >>> 21, t2[5] = f2 >>> 13 & 255, t2[6] = f2 >>> 5 & 255, t2[7] = f2 << 3 & 255, t2[8] = t2[9] = t2[10] = 0, t2[11] = d2 >>> 29, t2[12] = d2 >>> 21 & 255, t2[13] = d2 >>> 13 & 255, t2[14] = d2 >>> 5 & 255, t2[15] = d2 << 3 & 255, e2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, 16), e2.get_iv(Ce.HEAP_DATA), e2.set_counter(0, 0, 0, this.gamma0), e2.cipher(Ce.ENC.CTR, Ce.HEAP_DATA, 16);
        let l2 = 0;
        for (let e3 = 0; e3 < r2; ++e3)
          l2 |= u2[e3] ^ t2[e3];
        if (l2)
          throw new Te("data integrity check failed");
        return this.counter = 1, this.aes.pos = 0, this.aes.len = 0, c2;
      }
      AES_GCM_decrypt(e2) {
        const t2 = this.AES_GCM_Decrypt_process(e2), r2 = this.AES_GCM_Decrypt_finish(), i2 = new Uint8Array(t2.length + r2.length);
        return t2.length && i2.set(t2), r2.length && i2.set(r2, t2.length), i2;
      }
      AES_GCM_encrypt(e2) {
        const t2 = this.AES_GCM_Encrypt_process(e2), r2 = this.AES_GCM_Encrypt_finish(), i2 = new Uint8Array(t2.length + r2.length);
        return t2.length && i2.set(t2), r2.length && i2.set(r2, t2.length), i2;
      }
      _gcm_mac_process(e2) {
        let { asm: t2, heap: r2 } = this.aes.acquire_asm(), i2 = 0, n2 = e2.length || 0, a2 = 0;
        for (; n2 > 0; ) {
          for (a2 = Re(r2, 0, e2, i2, n2), i2 += a2, n2 -= a2; 15 & a2; )
            r2[a2++] = 0;
          t2.mac(Ce.MAC.GCM, Ce.HEAP_DATA, a2);
        }
      }
    };
    var Mi = ce.getWebCrypto();
    var Ci = ce.getNodeCrypto();
    var Ki = ce.getNodeBuffer();
    async function Di(e2, t2) {
      if (e2 !== me.symmetric.aes128 && e2 !== me.symmetric.aes192 && e2 !== me.symmetric.aes256)
        throw Error("GCM mode supports only AES cipher");
      if (ce.getWebCrypto() && t2.length !== 24) {
        const e3 = await Mi.importKey("raw", t2, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
        return { encrypt: async function(r2, i2, n2 = new Uint8Array()) {
          if (!r2.length || !n2.length && navigator.userAgent && navigator.userAgent.indexOf("Edge") !== -1)
            return xi.encrypt(r2, t2, i2, n2);
          const a2 = await Mi.encrypt({ name: "AES-GCM", iv: i2, additionalData: n2, tagLength: 128 }, e3, r2);
          return new Uint8Array(a2);
        }, decrypt: async function(r2, i2, n2 = new Uint8Array()) {
          if (r2.length === 16 || !n2.length && navigator.userAgent && navigator.userAgent.indexOf("Edge") !== -1)
            return xi.decrypt(r2, t2, i2, n2);
          const a2 = await Mi.decrypt({ name: "AES-GCM", iv: i2, additionalData: n2, tagLength: 128 }, e3, r2);
          return new Uint8Array(a2);
        } };
      }
      return ce.getNodeCrypto() ? { encrypt: async function(e3, r2, i2 = new Uint8Array()) {
        const n2 = new Ci.createCipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
        n2.setAAD(i2);
        const a2 = Ki.concat([n2.update(e3), n2.final(), n2.getAuthTag()]);
        return new Uint8Array(a2);
      }, decrypt: async function(e3, r2, i2 = new Uint8Array()) {
        const n2 = new Ci.createDecipheriv("aes-" + 8 * t2.length + "-gcm", t2, r2);
        n2.setAAD(i2), n2.setAuthTag(e3.slice(e3.length - 16, e3.length));
        const a2 = Ki.concat([n2.update(e3.slice(0, e3.length - 16)), n2.final()]);
        return new Uint8Array(a2);
      } } : { encrypt: async function(e3, r2, i2) {
        return xi.encrypt(e3, t2, r2, i2);
      }, decrypt: async function(e3, r2, i2) {
        return xi.decrypt(e3, t2, r2, i2);
      } };
    }
    Di.getNonce = function(e2, t2) {
      const r2 = e2.slice();
      for (let e3 = 0; e3 < t2.length; e3++)
        r2[4 + e3] ^= t2[e3];
      return r2;
    }, Di.blockLength = 16, Di.ivLength = 12, Di.tagLength = 16;
    var Ri = { cfb: ni, gcm: Di, experimentalGCM: Di, eax: vi, ocb: Pi };
    var Ii = bt(function(e2) {
      !function(e3) {
        var t2 = function(e4) {
          var t3, r3 = new Float64Array(16);
          if (e4)
            for (t3 = 0; t3 < e4.length; t3++)
              r3[t3] = e4[t3];
          return r3;
        }, r2 = function() {
          throw Error("no PRNG");
        }, i2 = new Uint8Array(32);
        i2[0] = 9;
        var n2 = t2(), a2 = t2([1]), s2 = t2([56129, 1]), o2 = t2([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), c2 = t2([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), u2 = t2([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), h2 = t2([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), d2 = t2([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function l2(e4, t3, r3, i3) {
          return function(e5, t4, r4, i4, n3) {
            var a3, s3 = 0;
            for (a3 = 0; a3 < n3; a3++)
              s3 |= e5[t4 + a3] ^ r4[i4 + a3];
            return (1 & s3 - 1 >>> 8) - 1;
          }(e4, t3, r3, i3, 32);
        }
        function p2(e4, t3) {
          var r3;
          for (r3 = 0; r3 < 16; r3++)
            e4[r3] = 0 | t3[r3];
        }
        function y2(e4) {
          var t3, r3, i3 = 1;
          for (t3 = 0; t3 < 16; t3++)
            r3 = e4[t3] + i3 + 65535, i3 = Math.floor(r3 / 65536), e4[t3] = r3 - 65536 * i3;
          e4[0] += i3 - 1 + 37 * (i3 - 1);
        }
        function b2(e4, t3, r3) {
          for (var i3, n3 = ~(r3 - 1), a3 = 0; a3 < 16; a3++)
            i3 = n3 & (e4[a3] ^ t3[a3]), e4[a3] ^= i3, t3[a3] ^= i3;
        }
        function m2(e4, r3) {
          var i3, n3, a3, s3 = t2(), o3 = t2();
          for (i3 = 0; i3 < 16; i3++)
            o3[i3] = r3[i3];
          for (y2(o3), y2(o3), y2(o3), n3 = 0; n3 < 2; n3++) {
            for (s3[0] = o3[0] - 65517, i3 = 1; i3 < 15; i3++)
              s3[i3] = o3[i3] - 65535 - (s3[i3 - 1] >> 16 & 1), s3[i3 - 1] &= 65535;
            s3[15] = o3[15] - 32767 - (s3[14] >> 16 & 1), a3 = s3[15] >> 16 & 1, s3[14] &= 65535, b2(o3, s3, 1 - a3);
          }
          for (i3 = 0; i3 < 16; i3++)
            e4[2 * i3] = 255 & o3[i3], e4[2 * i3 + 1] = o3[i3] >> 8;
        }
        function g2(e4, t3) {
          var r3 = new Uint8Array(32), i3 = new Uint8Array(32);
          return m2(r3, e4), m2(i3, t3), l2(r3, 0, i3, 0);
        }
        function w2(e4) {
          var t3 = new Uint8Array(32);
          return m2(t3, e4), 1 & t3[0];
        }
        function v2(e4, t3) {
          var r3;
          for (r3 = 0; r3 < 16; r3++)
            e4[r3] = t3[2 * r3] + (t3[2 * r3 + 1] << 8);
          e4[15] &= 32767;
        }
        function _2(e4, t3, r3) {
          for (var i3 = 0; i3 < 16; i3++)
            e4[i3] = t3[i3] + r3[i3];
        }
        function k2(e4, t3, r3) {
          for (var i3 = 0; i3 < 16; i3++)
            e4[i3] = t3[i3] - r3[i3];
        }
        function A2(e4, t3, r3) {
          var i3, n3, a3 = 0, s3 = 0, o3 = 0, c3 = 0, u3 = 0, h3 = 0, f2 = 0, d3 = 0, l3 = 0, p3 = 0, y3 = 0, b3 = 0, m3 = 0, g3 = 0, w3 = 0, v3 = 0, _3 = 0, k3 = 0, A3 = 0, S3 = 0, E3 = 0, P3 = 0, x3 = 0, M3 = 0, C3 = 0, K3 = 0, D3 = 0, R3 = 0, I3 = 0, U3 = 0, B3 = 0, T3 = r3[0], z3 = r3[1], q3 = r3[2], O3 = r3[3], F3 = r3[4], N2 = r3[5], j2 = r3[6], L2 = r3[7], W2 = r3[8], H2 = r3[9], G2 = r3[10], V2 = r3[11], $2 = r3[12], Z2 = r3[13], Y2 = r3[14], X2 = r3[15];
          a3 += (i3 = t3[0]) * T3, s3 += i3 * z3, o3 += i3 * q3, c3 += i3 * O3, u3 += i3 * F3, h3 += i3 * N2, f2 += i3 * j2, d3 += i3 * L2, l3 += i3 * W2, p3 += i3 * H2, y3 += i3 * G2, b3 += i3 * V2, m3 += i3 * $2, g3 += i3 * Z2, w3 += i3 * Y2, v3 += i3 * X2, s3 += (i3 = t3[1]) * T3, o3 += i3 * z3, c3 += i3 * q3, u3 += i3 * O3, h3 += i3 * F3, f2 += i3 * N2, d3 += i3 * j2, l3 += i3 * L2, p3 += i3 * W2, y3 += i3 * H2, b3 += i3 * G2, m3 += i3 * V2, g3 += i3 * $2, w3 += i3 * Z2, v3 += i3 * Y2, _3 += i3 * X2, o3 += (i3 = t3[2]) * T3, c3 += i3 * z3, u3 += i3 * q3, h3 += i3 * O3, f2 += i3 * F3, d3 += i3 * N2, l3 += i3 * j2, p3 += i3 * L2, y3 += i3 * W2, b3 += i3 * H2, m3 += i3 * G2, g3 += i3 * V2, w3 += i3 * $2, v3 += i3 * Z2, _3 += i3 * Y2, k3 += i3 * X2, c3 += (i3 = t3[3]) * T3, u3 += i3 * z3, h3 += i3 * q3, f2 += i3 * O3, d3 += i3 * F3, l3 += i3 * N2, p3 += i3 * j2, y3 += i3 * L2, b3 += i3 * W2, m3 += i3 * H2, g3 += i3 * G2, w3 += i3 * V2, v3 += i3 * $2, _3 += i3 * Z2, k3 += i3 * Y2, A3 += i3 * X2, u3 += (i3 = t3[4]) * T3, h3 += i3 * z3, f2 += i3 * q3, d3 += i3 * O3, l3 += i3 * F3, p3 += i3 * N2, y3 += i3 * j2, b3 += i3 * L2, m3 += i3 * W2, g3 += i3 * H2, w3 += i3 * G2, v3 += i3 * V2, _3 += i3 * $2, k3 += i3 * Z2, A3 += i3 * Y2, S3 += i3 * X2, h3 += (i3 = t3[5]) * T3, f2 += i3 * z3, d3 += i3 * q3, l3 += i3 * O3, p3 += i3 * F3, y3 += i3 * N2, b3 += i3 * j2, m3 += i3 * L2, g3 += i3 * W2, w3 += i3 * H2, v3 += i3 * G2, _3 += i3 * V2, k3 += i3 * $2, A3 += i3 * Z2, S3 += i3 * Y2, E3 += i3 * X2, f2 += (i3 = t3[6]) * T3, d3 += i3 * z3, l3 += i3 * q3, p3 += i3 * O3, y3 += i3 * F3, b3 += i3 * N2, m3 += i3 * j2, g3 += i3 * L2, w3 += i3 * W2, v3 += i3 * H2, _3 += i3 * G2, k3 += i3 * V2, A3 += i3 * $2, S3 += i3 * Z2, E3 += i3 * Y2, P3 += i3 * X2, d3 += (i3 = t3[7]) * T3, l3 += i3 * z3, p3 += i3 * q3, y3 += i3 * O3, b3 += i3 * F3, m3 += i3 * N2, g3 += i3 * j2, w3 += i3 * L2, v3 += i3 * W2, _3 += i3 * H2, k3 += i3 * G2, A3 += i3 * V2, S3 += i3 * $2, E3 += i3 * Z2, P3 += i3 * Y2, x3 += i3 * X2, l3 += (i3 = t3[8]) * T3, p3 += i3 * z3, y3 += i3 * q3, b3 += i3 * O3, m3 += i3 * F3, g3 += i3 * N2, w3 += i3 * j2, v3 += i3 * L2, _3 += i3 * W2, k3 += i3 * H2, A3 += i3 * G2, S3 += i3 * V2, E3 += i3 * $2, P3 += i3 * Z2, x3 += i3 * Y2, M3 += i3 * X2, p3 += (i3 = t3[9]) * T3, y3 += i3 * z3, b3 += i3 * q3, m3 += i3 * O3, g3 += i3 * F3, w3 += i3 * N2, v3 += i3 * j2, _3 += i3 * L2, k3 += i3 * W2, A3 += i3 * H2, S3 += i3 * G2, E3 += i3 * V2, P3 += i3 * $2, x3 += i3 * Z2, M3 += i3 * Y2, C3 += i3 * X2, y3 += (i3 = t3[10]) * T3, b3 += i3 * z3, m3 += i3 * q3, g3 += i3 * O3, w3 += i3 * F3, v3 += i3 * N2, _3 += i3 * j2, k3 += i3 * L2, A3 += i3 * W2, S3 += i3 * H2, E3 += i3 * G2, P3 += i3 * V2, x3 += i3 * $2, M3 += i3 * Z2, C3 += i3 * Y2, K3 += i3 * X2, b3 += (i3 = t3[11]) * T3, m3 += i3 * z3, g3 += i3 * q3, w3 += i3 * O3, v3 += i3 * F3, _3 += i3 * N2, k3 += i3 * j2, A3 += i3 * L2, S3 += i3 * W2, E3 += i3 * H2, P3 += i3 * G2, x3 += i3 * V2, M3 += i3 * $2, C3 += i3 * Z2, K3 += i3 * Y2, D3 += i3 * X2, m3 += (i3 = t3[12]) * T3, g3 += i3 * z3, w3 += i3 * q3, v3 += i3 * O3, _3 += i3 * F3, k3 += i3 * N2, A3 += i3 * j2, S3 += i3 * L2, E3 += i3 * W2, P3 += i3 * H2, x3 += i3 * G2, M3 += i3 * V2, C3 += i3 * $2, K3 += i3 * Z2, D3 += i3 * Y2, R3 += i3 * X2, g3 += (i3 = t3[13]) * T3, w3 += i3 * z3, v3 += i3 * q3, _3 += i3 * O3, k3 += i3 * F3, A3 += i3 * N2, S3 += i3 * j2, E3 += i3 * L2, P3 += i3 * W2, x3 += i3 * H2, M3 += i3 * G2, C3 += i3 * V2, K3 += i3 * $2, D3 += i3 * Z2, R3 += i3 * Y2, I3 += i3 * X2, w3 += (i3 = t3[14]) * T3, v3 += i3 * z3, _3 += i3 * q3, k3 += i3 * O3, A3 += i3 * F3, S3 += i3 * N2, E3 += i3 * j2, P3 += i3 * L2, x3 += i3 * W2, M3 += i3 * H2, C3 += i3 * G2, K3 += i3 * V2, D3 += i3 * $2, R3 += i3 * Z2, I3 += i3 * Y2, U3 += i3 * X2, v3 += (i3 = t3[15]) * T3, s3 += 38 * (k3 += i3 * q3), o3 += 38 * (A3 += i3 * O3), c3 += 38 * (S3 += i3 * F3), u3 += 38 * (E3 += i3 * N2), h3 += 38 * (P3 += i3 * j2), f2 += 38 * (x3 += i3 * L2), d3 += 38 * (M3 += i3 * W2), l3 += 38 * (C3 += i3 * H2), p3 += 38 * (K3 += i3 * G2), y3 += 38 * (D3 += i3 * V2), b3 += 38 * (R3 += i3 * $2), m3 += 38 * (I3 += i3 * Z2), g3 += 38 * (U3 += i3 * Y2), w3 += 38 * (B3 += i3 * X2), a3 = (i3 = (a3 += 38 * (_3 += i3 * z3)) + (n3 = 1) + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), s3 = (i3 = s3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), o3 = (i3 = o3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), c3 = (i3 = c3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), u3 = (i3 = u3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), h3 = (i3 = h3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), f2 = (i3 = f2 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), d3 = (i3 = d3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), l3 = (i3 = l3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), p3 = (i3 = p3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), y3 = (i3 = y3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), b3 = (i3 = b3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), m3 = (i3 = m3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), g3 = (i3 = g3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), w3 = (i3 = w3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), v3 = (i3 = v3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), a3 = (i3 = (a3 += n3 - 1 + 37 * (n3 - 1)) + (n3 = 1) + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), s3 = (i3 = s3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), o3 = (i3 = o3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), c3 = (i3 = c3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), u3 = (i3 = u3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), h3 = (i3 = h3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), f2 = (i3 = f2 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), d3 = (i3 = d3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), l3 = (i3 = l3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), p3 = (i3 = p3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), y3 = (i3 = y3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), b3 = (i3 = b3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), m3 = (i3 = m3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), g3 = (i3 = g3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), w3 = (i3 = w3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), v3 = (i3 = v3 + n3 + 65535) - 65536 * (n3 = Math.floor(i3 / 65536)), a3 += n3 - 1 + 37 * (n3 - 1), e4[0] = a3, e4[1] = s3, e4[2] = o3, e4[3] = c3, e4[4] = u3, e4[5] = h3, e4[6] = f2, e4[7] = d3, e4[8] = l3, e4[9] = p3, e4[10] = y3, e4[11] = b3, e4[12] = m3, e4[13] = g3, e4[14] = w3, e4[15] = v3;
        }
        function S2(e4, t3) {
          A2(e4, t3, t3);
        }
        function E2(e4, r3) {
          var i3, n3 = t2();
          for (i3 = 0; i3 < 16; i3++)
            n3[i3] = r3[i3];
          for (i3 = 253; i3 >= 0; i3--)
            S2(n3, n3), i3 !== 2 && i3 !== 4 && A2(n3, n3, r3);
          for (i3 = 0; i3 < 16; i3++)
            e4[i3] = n3[i3];
        }
        function P2(e4, r3, i3) {
          var n3, a3, o3 = new Uint8Array(32), c3 = new Float64Array(80), u3 = t2(), h3 = t2(), f2 = t2(), d3 = t2(), l3 = t2(), p3 = t2();
          for (a3 = 0; a3 < 31; a3++)
            o3[a3] = r3[a3];
          for (o3[31] = 127 & r3[31] | 64, o3[0] &= 248, v2(c3, i3), a3 = 0; a3 < 16; a3++)
            h3[a3] = c3[a3], d3[a3] = u3[a3] = f2[a3] = 0;
          for (u3[0] = d3[0] = 1, a3 = 254; a3 >= 0; --a3)
            b2(u3, h3, n3 = o3[a3 >>> 3] >>> (7 & a3) & 1), b2(f2, d3, n3), _2(l3, u3, f2), k2(u3, u3, f2), _2(f2, h3, d3), k2(h3, h3, d3), S2(d3, l3), S2(p3, u3), A2(u3, f2, u3), A2(f2, h3, l3), _2(l3, u3, f2), k2(u3, u3, f2), S2(h3, u3), k2(f2, d3, p3), A2(u3, f2, s2), _2(u3, u3, d3), A2(f2, f2, u3), A2(u3, d3, p3), A2(d3, h3, c3), S2(h3, l3), b2(u3, h3, n3), b2(f2, d3, n3);
          for (a3 = 0; a3 < 16; a3++)
            c3[a3 + 16] = u3[a3], c3[a3 + 32] = f2[a3], c3[a3 + 48] = h3[a3], c3[a3 + 64] = d3[a3];
          var y3 = c3.subarray(32), g3 = c3.subarray(16);
          return E2(y3, y3), A2(g3, g3, y3), m2(e4, g3), 0;
        }
        function x2(e4, t3) {
          return P2(e4, t3, i2);
        }
        function M2(e4, r3) {
          var i3 = t2(), n3 = t2(), a3 = t2(), s3 = t2(), o3 = t2(), u3 = t2(), h3 = t2(), f2 = t2(), d3 = t2();
          k2(i3, e4[1], e4[0]), k2(d3, r3[1], r3[0]), A2(i3, i3, d3), _2(n3, e4[0], e4[1]), _2(d3, r3[0], r3[1]), A2(n3, n3, d3), A2(a3, e4[3], r3[3]), A2(a3, a3, c2), A2(s3, e4[2], r3[2]), _2(s3, s3, s3), k2(o3, n3, i3), k2(u3, s3, a3), _2(h3, s3, a3), _2(f2, n3, i3), A2(e4[0], o3, u3), A2(e4[1], f2, h3), A2(e4[2], h3, u3), A2(e4[3], o3, f2);
        }
        function C2(e4, t3, r3) {
          var i3;
          for (i3 = 0; i3 < 4; i3++)
            b2(e4[i3], t3[i3], r3);
        }
        function K2(e4, r3) {
          var i3 = t2(), n3 = t2(), a3 = t2();
          E2(a3, r3[2]), A2(i3, r3[0], a3), A2(n3, r3[1], a3), m2(e4, n3), e4[31] ^= w2(i3) << 7;
        }
        function D2(e4, t3, r3) {
          var i3, s3;
          for (p2(e4[0], n2), p2(e4[1], a2), p2(e4[2], a2), p2(e4[3], n2), s3 = 255; s3 >= 0; --s3)
            C2(e4, t3, i3 = r3[s3 / 8 | 0] >> (7 & s3) & 1), M2(t3, e4), M2(e4, e4), C2(e4, t3, i3);
        }
        function R2(e4, r3) {
          var i3 = [t2(), t2(), t2(), t2()];
          p2(i3[0], u2), p2(i3[1], h2), p2(i3[2], a2), A2(i3[3], u2, h2), D2(e4, i3, r3);
        }
        function I2(i3, n3, a3) {
          var s3, o3, c3 = [t2(), t2(), t2(), t2()];
          for (a3 || r2(n3, 32), (s3 = e3.hash(n3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64, R2(c3, s3), K2(i3, c3), o3 = 0; o3 < 32; o3++)
            n3[o3 + 32] = i3[o3];
          return 0;
        }
        var U2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function B2(e4, t3) {
          var r3, i3, n3, a3;
          for (i3 = 63; i3 >= 32; --i3) {
            for (r3 = 0, n3 = i3 - 32, a3 = i3 - 12; n3 < a3; ++n3)
              t3[n3] += r3 - 16 * t3[i3] * U2[n3 - (i3 - 32)], r3 = Math.floor((t3[n3] + 128) / 256), t3[n3] -= 256 * r3;
            t3[n3] += r3, t3[i3] = 0;
          }
          for (r3 = 0, n3 = 0; n3 < 32; n3++)
            t3[n3] += r3 - (t3[31] >> 4) * U2[n3], r3 = t3[n3] >> 8, t3[n3] &= 255;
          for (n3 = 0; n3 < 32; n3++)
            t3[n3] -= r3 * U2[n3];
          for (i3 = 0; i3 < 32; i3++)
            t3[i3 + 1] += t3[i3] >> 8, e4[i3] = 255 & t3[i3];
        }
        function T2(e4) {
          var t3, r3 = new Float64Array(64);
          for (t3 = 0; t3 < 64; t3++)
            r3[t3] = e4[t3];
          for (t3 = 0; t3 < 64; t3++)
            e4[t3] = 0;
          B2(e4, r3);
        }
        function z2(e4, r3) {
          var i3 = t2(), s3 = t2(), c3 = t2(), u3 = t2(), h3 = t2(), f2 = t2(), l3 = t2();
          return p2(e4[2], a2), v2(e4[1], r3), S2(c3, e4[1]), A2(u3, c3, o2), k2(c3, c3, e4[2]), _2(u3, e4[2], u3), S2(h3, u3), S2(f2, h3), A2(l3, f2, h3), A2(i3, l3, c3), A2(i3, i3, u3), function(e5, r4) {
            var i4, n3 = t2();
            for (i4 = 0; i4 < 16; i4++)
              n3[i4] = r4[i4];
            for (i4 = 250; i4 >= 0; i4--)
              S2(n3, n3), i4 !== 1 && A2(n3, n3, r4);
            for (i4 = 0; i4 < 16; i4++)
              e5[i4] = n3[i4];
          }(i3, i3), A2(i3, i3, c3), A2(i3, i3, u3), A2(i3, i3, u3), A2(e4[0], i3, u3), S2(s3, e4[0]), A2(s3, s3, u3), g2(s3, c3) && A2(e4[0], e4[0], d2), S2(s3, e4[0]), A2(s3, s3, u3), g2(s3, c3) ? -1 : (w2(e4[0]) === r3[31] >> 7 && k2(e4[0], n2, e4[0]), A2(e4[3], e4[0], e4[1]), 0);
        }
        var q2 = 64;
        function O2() {
          for (var e4 = 0; e4 < arguments.length; e4++)
            if (!(arguments[e4] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
        }
        function F2(e4) {
          for (var t3 = 0; t3 < e4.length; t3++)
            e4[t3] = 0;
        }
        e3.scalarMult = function(e4, t3) {
          if (O2(e4, t3), e4.length !== 32)
            throw Error("bad n size");
          if (t3.length !== 32)
            throw Error("bad p size");
          var r3 = new Uint8Array(32);
          return P2(r3, e4, t3), r3;
        }, e3.box = {}, e3.box.keyPair = function() {
          var e4, t3, i3 = new Uint8Array(32), n3 = new Uint8Array(32);
          return e4 = i3, r2(t3 = n3, 32), x2(e4, t3), { publicKey: i3, secretKey: n3 };
        }, e3.box.keyPair.fromSecretKey = function(e4) {
          if (O2(e4), e4.length !== 32)
            throw Error("bad secret key size");
          var t3 = new Uint8Array(32);
          return x2(t3, e4), { publicKey: t3, secretKey: new Uint8Array(e4) };
        }, e3.sign = function(r3, i3) {
          if (O2(r3, i3), i3.length !== 64)
            throw Error("bad secret key size");
          var n3 = new Uint8Array(q2 + r3.length);
          return function(r4, i4, n4, a3) {
            var s3, o3, c3, u3, h3, f2 = new Float64Array(64), d3 = [t2(), t2(), t2(), t2()];
            (s3 = e3.hash(a3.subarray(0, 32)))[0] &= 248, s3[31] &= 127, s3[31] |= 64;
            var l3 = n4 + 64;
            for (u3 = 0; u3 < n4; u3++)
              r4[64 + u3] = i4[u3];
            for (u3 = 0; u3 < 32; u3++)
              r4[32 + u3] = s3[32 + u3];
            for (T2(c3 = e3.hash(r4.subarray(32, l3))), R2(d3, c3), K2(r4, d3), u3 = 32; u3 < 64; u3++)
              r4[u3] = a3[u3];
            for (T2(o3 = e3.hash(r4.subarray(0, l3))), u3 = 0; u3 < 64; u3++)
              f2[u3] = 0;
            for (u3 = 0; u3 < 32; u3++)
              f2[u3] = c3[u3];
            for (u3 = 0; u3 < 32; u3++)
              for (h3 = 0; h3 < 32; h3++)
                f2[u3 + h3] += o3[u3] * s3[h3];
            B2(r4.subarray(32), f2);
          }(n3, r3, r3.length, i3), n3;
        }, e3.sign.detached = function(t3, r3) {
          for (var i3 = e3.sign(t3, r3), n3 = new Uint8Array(q2), a3 = 0; a3 < n3.length; a3++)
            n3[a3] = i3[a3];
          return n3;
        }, e3.sign.detached.verify = function(r3, i3, n3) {
          if (O2(r3, i3, n3), i3.length !== q2)
            throw Error("bad signature size");
          if (n3.length !== 32)
            throw Error("bad public key size");
          var a3, s3 = new Uint8Array(q2 + r3.length), o3 = new Uint8Array(q2 + r3.length);
          for (a3 = 0; a3 < q2; a3++)
            s3[a3] = i3[a3];
          for (a3 = 0; a3 < r3.length; a3++)
            s3[a3 + q2] = r3[a3];
          return function(r4, i4, n4, a4) {
            var s4, o4, c3 = new Uint8Array(32), u3 = [t2(), t2(), t2(), t2()], h3 = [t2(), t2(), t2(), t2()];
            if (n4 < 64)
              return -1;
            if (z2(h3, a4))
              return -1;
            for (s4 = 0; s4 < n4; s4++)
              r4[s4] = i4[s4];
            for (s4 = 0; s4 < 32; s4++)
              r4[s4 + 32] = a4[s4];
            if (T2(o4 = e3.hash(r4.subarray(0, n4))), D2(u3, h3, o4), R2(h3, i4.subarray(32)), M2(u3, h3), K2(c3, u3), n4 -= 64, l2(i4, 0, c3, 0)) {
              for (s4 = 0; s4 < n4; s4++)
                r4[s4] = 0;
              return -1;
            }
            for (s4 = 0; s4 < n4; s4++)
              r4[s4] = i4[s4 + 64];
            return n4;
          }(o3, s3, s3.length, n3) >= 0;
        }, e3.sign.keyPair = function() {
          var e4 = new Uint8Array(32), t3 = new Uint8Array(64);
          return I2(e4, t3), { publicKey: e4, secretKey: t3 };
        }, e3.sign.keyPair.fromSecretKey = function(e4) {
          if (O2(e4), e4.length !== 64)
            throw Error("bad secret key size");
          for (var t3 = new Uint8Array(32), r3 = 0; r3 < t3.length; r3++)
            t3[r3] = e4[32 + r3];
          return { publicKey: t3, secretKey: new Uint8Array(e4) };
        }, e3.sign.keyPair.fromSeed = function(e4) {
          if (O2(e4), e4.length !== 32)
            throw Error("bad seed size");
          for (var t3 = new Uint8Array(32), r3 = new Uint8Array(64), i3 = 0; i3 < 32; i3++)
            r3[i3] = e4[i3];
          return I2(t3, r3, true), { publicKey: t3, secretKey: r3 };
        }, e3.setPRNG = function(e4) {
          r2 = e4;
        }, function() {
          var t3 = typeof self != "undefined" ? self.crypto || self.msCrypto : null;
          if (t3 && t3.getRandomValues) {
            e3.setPRNG(function(e4, r3) {
              var i3, n3 = new Uint8Array(r3);
              for (i3 = 0; i3 < r3; i3 += 65536)
                t3.getRandomValues(n3.subarray(i3, i3 + Math.min(r3 - i3, 65536)));
              for (i3 = 0; i3 < r3; i3++)
                e4[i3] = n3[i3];
              F2(n3);
            });
          } else
            (t3 = f.default) && t3.randomBytes && e3.setPRNG(function(e4, r3) {
              var i3, n3 = t3.randomBytes(r3);
              for (i3 = 0; i3 < r3; i3++)
                e4[i3] = n3[i3];
              F2(n3);
            });
        }();
      }(e2.exports ? e2.exports : self.nacl = self.nacl || {});
    });
    var Ui = ce.getNodeCrypto();
    async function Bi(e2) {
      const t2 = new Uint8Array(e2);
      if (typeof crypto != "undefined" && crypto.getRandomValues)
        crypto.getRandomValues(t2);
      else if (Ui) {
        const e3 = Ui.randomBytes(t2.length);
        t2.set(e3);
      } else {
        if (!zi.buffer)
          throw Error("No secure random number generator available.");
        await zi.get(t2);
      }
      return t2;
    }
    async function Ti(e2, t2) {
      const r2 = await ce.getBigInteger();
      if (t2.lt(e2))
        throw Error("Illegal parameter value: max <= min");
      const i2 = t2.sub(e2), n2 = i2.byteLength();
      return new r2(await Bi(n2 + 8)).mod(i2).add(e2);
    }
    var zi = new class {
      constructor() {
        this.buffer = null, this.size = null, this.callback = null;
      }
      init(e2, t2) {
        this.buffer = new Uint8Array(e2), this.size = 0, this.callback = t2;
      }
      set(e2) {
        if (!this.buffer)
          throw Error("RandomBuffer is not initialized");
        if (!(e2 instanceof Uint8Array))
          throw Error("Invalid type: buf not an Uint8Array");
        const t2 = this.buffer.length - this.size;
        e2.length > t2 && (e2 = e2.subarray(0, t2)), this.buffer.set(e2, this.size), this.size += e2.length;
      }
      async get(e2) {
        if (!this.buffer)
          throw Error("RandomBuffer is not initialized");
        if (!(e2 instanceof Uint8Array))
          throw Error("Invalid type: buf not an Uint8Array");
        if (this.size < e2.length) {
          if (!this.callback)
            throw Error("Random number buffer depleted");
          return await this.callback(), this.get(e2);
        }
        for (let t2 = 0; t2 < e2.length; t2++)
          e2[t2] = this.buffer[--this.size], this.buffer[this.size] = 0;
      }
    }();
    var qi = /* @__PURE__ */ Object.freeze({ __proto__: null, getRandomBytes: Bi, getRandomBigInteger: Ti, randomBuffer: zi });
    async function Oi(e2, t2, r2) {
      const i2 = await ce.getBigInteger(), n2 = new i2(1), a2 = n2.leftShift(new i2(e2 - 1)), s2 = new i2(30), o2 = [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2], c2 = await Ti(a2, a2.leftShift(n2));
      let u2 = c2.mod(s2).toNumber();
      do {
        c2.iadd(new i2(o2[u2])), u2 = (u2 + o2[u2]) % o2.length, c2.bitLength() > e2 && (c2.imod(a2.leftShift(n2)).iadd(a2), u2 = c2.mod(s2).toNumber());
      } while (!await Fi(c2, t2, r2));
      return c2;
    }
    async function Fi(e2, t2, r2) {
      return !(t2 && !e2.dec().gcd(t2).isOne()) && (!!await async function(e3) {
        const t3 = await ce.getBigInteger();
        return Ni.every((r3) => e3.mod(new t3(r3)) !== 0);
      }(e2) && (!!await async function(e3, t3) {
        const r3 = await ce.getBigInteger();
        return (t3 = t3 || new r3(2)).modExp(e3.dec(), e3).isOne();
      }(e2) && !!await async function(e3, t3, r3) {
        const i2 = await ce.getBigInteger(), n2 = e3.bitLength();
        t3 || (t3 = Math.max(1, n2 / 48 | 0));
        const a2 = e3.dec();
        let s2 = 0;
        for (; !a2.getBit(s2); )
          s2++;
        const o2 = e3.rightShift(new i2(s2));
        for (; t3 > 0; t3--) {
          let t4, n3 = (r3 ? r3() : await Ti(new i2(2), a2)).modExp(o2, e3);
          if (!n3.isOne() && !n3.equal(a2)) {
            for (t4 = 1; t4 < s2; t4++) {
              if (n3 = n3.mul(n3).mod(e3), n3.isOne())
                return false;
              if (n3.equal(a2))
                break;
            }
            if (t4 === s2)
              return false;
          }
        }
        return true;
      }(e2, r2)));
    }
    var Ni = [7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999];
    var ji = [];
    async function Li(e2, t2) {
      const r2 = e2.length;
      if (r2 > t2 - 11)
        throw Error("Message too long");
      const i2 = await async function(e3) {
        const t3 = new Uint8Array(e3);
        let r3 = 0;
        for (; r3 < e3; ) {
          const i3 = await Bi(e3 - r3);
          for (let e4 = 0; e4 < i3.length; e4++)
            i3[e4] !== 0 && (t3[r3++] = i3[e4]);
        }
        return t3;
      }(t2 - r2 - 3), n2 = new Uint8Array(t2);
      return n2[1] = 2, n2.set(i2, 2), n2.set(e2, t2 - r2), n2;
    }
    function Wi(e2, t2) {
      let r2 = 2, i2 = 1;
      for (let t3 = r2; t3 < e2.length; t3++)
        i2 &= e2[t3] !== 0, r2 += i2;
      const n2 = r2 - 2, a2 = e2.subarray(r2 + 1), s2 = e2[0] === 0 & e2[1] === 2 & n2 >= 8 & !i2;
      if (t2)
        return ce.selectUint8Array(s2, a2, t2);
      if (s2)
        return a2;
      throw Error("Decryption error");
    }
    async function Hi(e2, t2, r2) {
      let i2;
      if (t2.length !== Qr.getHashByteLength(e2))
        throw Error("Invalid hash length");
      const n2 = new Uint8Array(ji[e2].length);
      for (i2 = 0; i2 < ji[e2].length; i2++)
        n2[i2] = ji[e2][i2];
      const a2 = n2.length + t2.length;
      if (r2 < a2 + 11)
        throw Error("Intended encoded message length too short");
      const s2 = new Uint8Array(r2 - a2 - 3).fill(255), o2 = new Uint8Array(r2);
      return o2[1] = 1, o2.set(s2, 2), o2.set(n2, r2 - a2), o2.set(t2, r2 - t2.length), o2;
    }
    ji[1] = [48, 32, 48, 12, 6, 8, 42, 134, 72, 134, 247, 13, 2, 5, 5, 0, 4, 16], ji[2] = [48, 33, 48, 9, 6, 5, 43, 14, 3, 2, 26, 5, 0, 4, 20], ji[3] = [48, 33, 48, 9, 6, 5, 43, 36, 3, 2, 1, 5, 0, 4, 20], ji[8] = [48, 49, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 5, 0, 4, 32], ji[9] = [48, 65, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 2, 5, 0, 4, 48], ji[10] = [48, 81, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 3, 5, 0, 4, 64], ji[11] = [48, 45, 48, 13, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 4, 5, 0, 4, 28];
    var Gi = /* @__PURE__ */ Object.freeze({ __proto__: null, emeEncode: Li, emeDecode: Wi, emsaEncode: Hi });
    var Vi = ce.getWebCrypto();
    var $i = ce.getNodeCrypto();
    var Zi = $i ? y.default : void 0;
    var Yi = ce.detectNode() ? Zi.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    }) : void 0;
    var Xi = ce.detectNode() ? Zi.define("RSAPubliceKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    }) : void 0;
    var Qi = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2, s2, o2, c2) {
      if (t2 && !ce.isStream(t2)) {
        if (ce.getWebCrypto())
          try {
            return await async function(e3, t3, r3, i3, n3, a3, s3, o3) {
              const c3 = await async function(e4, t4, r4, i4, n4, a4) {
                const s4 = await ce.getBigInteger(), o4 = new s4(i4), c4 = new s4(n4), u3 = new s4(r4);
                let h3 = u3.mod(c4.dec()), f2 = u3.mod(o4.dec());
                return f2 = f2.toUint8Array(), h3 = h3.toUint8Array(), { kty: "RSA", n: ye(e4, true), e: ye(t4, true), d: ye(r4, true), p: ye(n4, true), q: ye(i4, true), dp: ye(h3, true), dq: ye(f2, true), qi: ye(a4, true), ext: true };
              }(r3, i3, n3, a3, s3, o3), u2 = { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, h2 = await Vi.importKey("jwk", c3, u2, false, ["sign"]);
              return new Uint8Array(await Vi.sign({ name: "RSASSA-PKCS1-v1_5", hash: e3 }, h2, t3));
            }(me.read(me.webHash, e2), t2, r2, i2, n2, a2, s2, o2);
          } catch (e3) {
            ce.printDebugError(e3);
          }
        else if (ce.getNodeCrypto())
          return async function(e3, t3, r3, i3, n3, a3, s3, o3) {
            const { default: c3 } = await Promise.resolve().then(function() {
              return Md;
            }), u2 = new c3(a3), h2 = new c3(s3), f2 = new c3(n3), d2 = f2.mod(h2.subn(1)), l2 = f2.mod(u2.subn(1)), p2 = $i.createSign(me.read(me.hash, e3));
            p2.write(t3), p2.end();
            const y2 = { version: 0, modulus: new c3(r3), publicExponent: new c3(i3), privateExponent: new c3(n3), prime1: new c3(s3), prime2: new c3(a3), exponent1: d2, exponent2: l2, coefficient: new c3(o3) };
            if ($i.createPrivateKey !== void 0) {
              const e4 = Yi.encode(y2, "der");
              return new Uint8Array(p2.sign({ key: e4, format: "der", type: "pkcs1" }));
            }
            const b2 = Yi.encode(y2, "pem", { label: "RSA PRIVATE KEY" });
            return new Uint8Array(p2.sign(b2));
          }(e2, t2, r2, i2, n2, a2, s2, o2);
      }
      return async function(e3, t3, r3, i3) {
        const n3 = await ce.getBigInteger();
        t3 = new n3(t3);
        const a3 = new n3(await Hi(e3, i3, t3.byteLength()));
        if (r3 = new n3(r3), a3.gte(t3))
          throw Error("Message size cannot exceed modulus size");
        return a3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
      }(e2, r2, n2, c2);
    }, verify: async function(e2, t2, r2, i2, n2, a2) {
      if (t2 && !ce.isStream(t2)) {
        if (ce.getWebCrypto())
          try {
            return await async function(e3, t3, r3, i3, n3) {
              const a3 = function(e4, t4) {
                return { kty: "RSA", n: ye(e4, true), e: ye(t4, true), ext: true };
              }(i3, n3), s2 = await Vi.importKey("jwk", a3, { name: "RSASSA-PKCS1-v1_5", hash: { name: e3 } }, false, ["verify"]);
              return Vi.verify({ name: "RSASSA-PKCS1-v1_5", hash: e3 }, s2, r3, t3);
            }(me.read(me.webHash, e2), t2, r2, i2, n2);
          } catch (e3) {
            ce.printDebugError(e3);
          }
        else if (ce.getNodeCrypto())
          return async function(e3, t3, r3, i3, n3) {
            const { default: a3 } = await Promise.resolve().then(function() {
              return Md;
            }), s2 = $i.createVerify(me.read(me.hash, e3));
            s2.write(t3), s2.end();
            const o2 = { modulus: new a3(i3), publicExponent: new a3(n3) };
            let c2;
            if ($i.createPrivateKey !== void 0) {
              c2 = { key: Xi.encode(o2, "der"), format: "der", type: "pkcs1" };
            } else
              c2 = Xi.encode(o2, "pem", { label: "RSA PUBLIC KEY" });
            try {
              return await s2.verify(c2, r3);
            } catch (e4) {
              return false;
            }
          }(e2, t2, r2, i2, n2);
      }
      return async function(e3, t3, r3, i3, n3) {
        const a3 = await ce.getBigInteger();
        if (r3 = new a3(r3), t3 = new a3(t3), i3 = new a3(i3), t3.gte(r3))
          throw Error("Signature size cannot exceed modulus size");
        const s2 = t3.modExp(i3, r3).toUint8Array("be", r3.byteLength()), o2 = await Hi(e3, n3, r3.byteLength());
        return ce.equalsUint8Array(s2, o2);
      }(e2, r2, i2, n2, a2);
    }, encrypt: async function(e2, t2, r2) {
      return ce.getNodeCrypto() ? async function(e3, t3, r3) {
        const { default: i2 } = await Promise.resolve().then(function() {
          return Md;
        }), n2 = { modulus: new i2(t3), publicExponent: new i2(r3) };
        let a2;
        if ($i.createPrivateKey !== void 0) {
          a2 = { key: Xi.encode(n2, "der"), format: "der", type: "pkcs1", padding: $i.constants.RSA_PKCS1_PADDING };
        } else {
          a2 = { key: Xi.encode(n2, "pem", { label: "RSA PUBLIC KEY" }), padding: $i.constants.RSA_PKCS1_PADDING };
        }
        return new Uint8Array($i.publicEncrypt(a2, e3));
      }(e2, t2, r2) : async function(e3, t3, r3) {
        const i2 = await ce.getBigInteger();
        if (t3 = new i2(t3), e3 = new i2(await Li(e3, t3.byteLength())), r3 = new i2(r3), e3.gte(t3))
          throw Error("Message size cannot exceed modulus size");
        return e3.modExp(r3, t3).toUint8Array("be", t3.byteLength());
      }(e2, t2, r2);
    }, decrypt: async function(e2, t2, r2, i2, n2, a2, s2, o2) {
      return ce.getNodeCrypto() ? async function(e3, t3, r3, i3, n3, a3, s3, o3) {
        const { default: c2 } = await Promise.resolve().then(function() {
          return Md;
        }), u2 = new c2(n3), h2 = new c2(a3), f2 = new c2(i3), d2 = f2.mod(h2.subn(1)), l2 = f2.mod(u2.subn(1)), p2 = { version: 0, modulus: new c2(t3), publicExponent: new c2(r3), privateExponent: new c2(i3), prime1: new c2(a3), prime2: new c2(n3), exponent1: d2, exponent2: l2, coefficient: new c2(s3) };
        let y2;
        if ($i.createPrivateKey !== void 0) {
          y2 = { key: Yi.encode(p2, "der"), format: "der", type: "pkcs1", padding: $i.constants.RSA_PKCS1_PADDING };
        } else {
          y2 = { key: Yi.encode(p2, "pem", { label: "RSA PRIVATE KEY" }), padding: $i.constants.RSA_PKCS1_PADDING };
        }
        try {
          return new Uint8Array($i.privateDecrypt(y2, e3));
        } catch (e4) {
          if (o3)
            return o3;
          throw Error("Decryption error");
        }
      }(e2, t2, r2, i2, n2, a2, s2, o2) : async function(e3, t3, r3, i3, n3, a3, s3, o3) {
        const c2 = await ce.getBigInteger();
        if (e3 = new c2(e3), t3 = new c2(t3), r3 = new c2(r3), i3 = new c2(i3), n3 = new c2(n3), a3 = new c2(a3), s3 = new c2(s3), e3.gte(t3))
          throw Error("Data too large.");
        const u2 = i3.mod(a3.dec()), h2 = i3.mod(n3.dec()), f2 = (await Ti(new c2(2), t3)).mod(t3), d2 = f2.modInv(t3).modExp(r3, t3), l2 = (e3 = e3.mul(d2).mod(t3)).modExp(h2, n3), p2 = e3.modExp(u2, a3);
        let y2 = s3.mul(p2.sub(l2)).mod(a3).mul(n3).add(l2);
        return y2 = y2.mul(f2).mod(t3), Wi(y2.toUint8Array("be", t3.byteLength()), o3);
      }(e2, t2, r2, i2, n2, a2, s2, o2);
    }, generate: async function(e2, t2) {
      if (t2 = new (await ce.getBigInteger())(t2), ce.getWebCrypto()) {
        const r3 = { name: "RSASSA-PKCS1-v1_5", modulusLength: e2, publicExponent: t2.toUint8Array(), hash: { name: "SHA-1" } }, i3 = await Vi.generateKey(r3, true, ["sign", "verify"]), n3 = await Vi.exportKey("jwk", i3.privateKey);
        return { n: pe(n3.n), e: t2.toUint8Array(), d: pe(n3.d), p: pe(n3.q), q: pe(n3.p), u: pe(n3.qi) };
      }
      if (ce.getNodeCrypto() && $i.generateKeyPair && Yi) {
        const r3 = { modulusLength: e2, publicExponent: t2.toNumber(), publicKeyEncoding: { type: "pkcs1", format: "der" }, privateKeyEncoding: { type: "pkcs1", format: "der" } }, i3 = await new Promise((e3, t3) => $i.generateKeyPair("rsa", r3, (r4, i4, n3) => {
          r4 ? t3(r4) : e3(Yi.decode(n3, "der"));
        }));
        return { n: i3.modulus.toArrayLike(Uint8Array), e: i3.publicExponent.toArrayLike(Uint8Array), d: i3.privateExponent.toArrayLike(Uint8Array), p: i3.prime2.toArrayLike(Uint8Array), q: i3.prime1.toArrayLike(Uint8Array), u: i3.coefficient.toArrayLike(Uint8Array) };
      }
      let r2, i2, n2;
      do {
        i2 = await Oi(e2 - (e2 >> 1), t2, 40), r2 = await Oi(e2 >> 1, t2, 40), n2 = r2.mul(i2);
      } while (n2.bitLength() !== e2);
      const a2 = r2.dec().imul(i2.dec());
      return i2.lt(r2) && ([r2, i2] = [i2, r2]), { n: n2.toUint8Array(), e: t2.toUint8Array(), d: t2.modInv(a2).toUint8Array(), p: r2.toUint8Array(), q: i2.toUint8Array(), u: r2.modInv(i2).toUint8Array() };
    }, validateParams: async function(e2, t2, r2, i2, n2, a2) {
      const s2 = await ce.getBigInteger();
      if (e2 = new s2(e2), i2 = new s2(i2), n2 = new s2(n2), !i2.mul(n2).equal(e2))
        return false;
      const o2 = new s2(2);
      if (a2 = new s2(a2), !i2.mul(a2).mod(n2).isOne())
        return false;
      t2 = new s2(t2), r2 = new s2(r2);
      const c2 = new s2(Math.floor(e2.bitLength() / 3)), u2 = await Ti(o2, o2.leftShift(c2)), h2 = u2.mul(r2).mul(t2);
      return !(!h2.mod(i2.dec()).equal(u2) || !h2.mod(n2.dec()).equal(u2));
    } });
    var Ji = /* @__PURE__ */ Object.freeze({ __proto__: null, encrypt: async function(e2, t2, r2, i2) {
      const n2 = await ce.getBigInteger();
      t2 = new n2(t2), r2 = new n2(r2), i2 = new n2(i2);
      const a2 = new n2(await Li(e2, t2.byteLength())), s2 = await Ti(new n2(1), t2.dec());
      return { c1: r2.modExp(s2, t2).toUint8Array(), c2: i2.modExp(s2, t2).imul(a2).imod(t2).toUint8Array() };
    }, decrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = await ce.getBigInteger();
      return e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), i2 = new a2(i2), Wi(e2.modExp(i2, r2).modInv(r2).imul(t2).imod(r2).toUint8Array("be", r2.byteLength()), n2);
    }, validateParams: async function(e2, t2, r2, i2) {
      const n2 = await ce.getBigInteger();
      e2 = new n2(e2), t2 = new n2(t2), r2 = new n2(r2);
      const a2 = new n2(1);
      if (t2.lte(a2) || t2.gte(e2))
        return false;
      const s2 = new n2(e2.bitLength()), o2 = new n2(1023);
      if (s2.lt(o2))
        return false;
      if (!t2.modExp(e2.dec(), e2).isOne())
        return false;
      let c2 = t2;
      const u2 = new n2(1), h2 = new n2(2).leftShift(new n2(17));
      for (; u2.lt(h2); ) {
        if (c2 = c2.mul(t2).imod(e2), c2.isOne())
          return false;
        u2.iinc();
      }
      i2 = new n2(i2);
      const f2 = new n2(2), d2 = await Ti(f2.leftShift(s2.dec()), f2.leftShift(s2)), l2 = e2.dec().imul(d2).iadd(i2);
      return !!r2.equal(t2.modExp(l2, e2));
    } });
    var en = class {
      constructor(e2) {
        if (e2 instanceof en)
          this.oid = e2.oid;
        else if (ce.isArray(e2) || ce.isUint8Array(e2)) {
          if ((e2 = new Uint8Array(e2))[0] === 6) {
            if (e2[1] !== e2.length - 2)
              throw Error("Length mismatch in DER encoded oid");
            e2 = e2.subarray(2);
          }
          this.oid = e2;
        } else
          this.oid = "";
      }
      read(e2) {
        if (e2.length >= 1) {
          const t2 = e2[0];
          if (e2.length >= 1 + t2)
            return this.oid = e2.subarray(1, 1 + t2), 1 + this.oid.length;
        }
        throw Error("Invalid oid");
      }
      write() {
        return ce.concatUint8Array([new Uint8Array([this.oid.length]), this.oid]);
      }
      toHex() {
        return ce.uint8ArrayToHex(this.oid);
      }
      getName() {
        const e2 = this.toHex();
        if (me.curve[e2])
          return me.write(me.curve, e2);
        throw Error("Unknown curve object identifier.");
      }
    };
    function tn(e2, t2) {
      return e2.keyPair({ priv: t2 });
    }
    function rn(e2, t2) {
      const r2 = e2.keyPair({ pub: t2 });
      if (r2.validate().result !== true)
        throw Error("Invalid elliptic public key");
      return r2;
    }
    async function nn(e2) {
      if (!ge.useIndutnyElliptic)
        throw Error("This curve is only supported in the full build of OpenPGP.js");
      const { default: t2 } = await Promise.resolve().then(function() {
        return Vl;
      });
      return new t2.ec(e2);
    }
    var an = ce.getWebCrypto();
    var sn = ce.getNodeCrypto();
    var on = { p256: "P-256", p384: "P-384", p521: "P-521" };
    var cn = sn ? sn.getCurves() : [];
    var un = sn ? { secp256k1: cn.includes("secp256k1") ? "secp256k1" : void 0, p256: cn.includes("prime256v1") ? "prime256v1" : void 0, p384: cn.includes("secp384r1") ? "secp384r1" : void 0, p521: cn.includes("secp521r1") ? "secp521r1" : void 0, ed25519: cn.includes("ED25519") ? "ED25519" : void 0, curve25519: cn.includes("X25519") ? "X25519" : void 0, brainpoolP256r1: cn.includes("brainpoolP256r1") ? "brainpoolP256r1" : void 0, brainpoolP384r1: cn.includes("brainpoolP384r1") ? "brainpoolP384r1" : void 0, brainpoolP512r1: cn.includes("brainpoolP512r1") ? "brainpoolP512r1" : void 0 } : {};
    var hn = { p256: { oid: [6, 8, 42, 134, 72, 206, 61, 3, 1, 7], keyType: me.publicKey.ecdsa, hash: me.hash.sha256, cipher: me.symmetric.aes128, node: un.p256, web: on.p256, payloadSize: 32, sharedSize: 256 }, p384: { oid: [6, 5, 43, 129, 4, 0, 34], keyType: me.publicKey.ecdsa, hash: me.hash.sha384, cipher: me.symmetric.aes192, node: un.p384, web: on.p384, payloadSize: 48, sharedSize: 384 }, p521: { oid: [6, 5, 43, 129, 4, 0, 35], keyType: me.publicKey.ecdsa, hash: me.hash.sha512, cipher: me.symmetric.aes256, node: un.p521, web: on.p521, payloadSize: 66, sharedSize: 528 }, secp256k1: { oid: [6, 5, 43, 129, 4, 0, 10], keyType: me.publicKey.ecdsa, hash: me.hash.sha256, cipher: me.symmetric.aes128, node: un.secp256k1, payloadSize: 32 }, ed25519: { oid: [6, 9, 43, 6, 1, 4, 1, 218, 71, 15, 1], keyType: me.publicKey.eddsa, hash: me.hash.sha512, node: false, payloadSize: 32 }, curve25519: { oid: [6, 10, 43, 6, 1, 4, 1, 151, 85, 1, 5, 1], keyType: me.publicKey.ecdh, hash: me.hash.sha256, cipher: me.symmetric.aes128, node: false, payloadSize: 32 }, brainpoolP256r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 7], keyType: me.publicKey.ecdsa, hash: me.hash.sha256, cipher: me.symmetric.aes128, node: un.brainpoolP256r1, payloadSize: 32 }, brainpoolP384r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 11], keyType: me.publicKey.ecdsa, hash: me.hash.sha384, cipher: me.symmetric.aes192, node: un.brainpoolP384r1, payloadSize: 48 }, brainpoolP512r1: { oid: [6, 9, 43, 36, 3, 3, 2, 8, 1, 1, 13], keyType: me.publicKey.ecdsa, hash: me.hash.sha512, cipher: me.symmetric.aes256, node: un.brainpoolP512r1, payloadSize: 64 } };
    var fn = class {
      constructor(e2, t2) {
        try {
          (ce.isArray(e2) || ce.isUint8Array(e2)) && (e2 = new en(e2)), e2 instanceof en && (e2 = e2.getName()), this.name = me.write(me.curve, e2);
        } catch (e3) {
          throw Error("Not valid curve");
        }
        t2 = t2 || hn[this.name], this.keyType = t2.keyType, this.oid = t2.oid, this.hash = t2.hash, this.cipher = t2.cipher, this.node = t2.node && hn[this.name], this.web = t2.web && hn[this.name], this.payloadSize = t2.payloadSize, this.web && ce.getWebCrypto() ? this.type = "web" : this.node && ce.getNodeCrypto() ? this.type = "node" : this.name === "curve25519" ? this.type = "curve25519" : this.name === "ed25519" && (this.type = "ed25519");
      }
      async genKeyPair() {
        let e2;
        switch (this.type) {
          case "web":
            try {
              return await async function(e3) {
                const t3 = await an.generateKey({ name: "ECDSA", namedCurve: on[e3] }, true, ["sign", "verify"]), r2 = await an.exportKey("jwk", t3.privateKey);
                return { publicKey: ln(await an.exportKey("jwk", t3.publicKey)), privateKey: pe(r2.d) };
              }(this.name);
            } catch (e3) {
              ce.printDebugError("Browser did not support generating ec key " + e3.message);
              break;
            }
          case "node":
            return async function(e3) {
              const t3 = sn.createECDH(un[e3]);
              return await t3.generateKeys(), { publicKey: new Uint8Array(t3.getPublicKey()), privateKey: new Uint8Array(t3.getPrivateKey()) };
            }(this.name);
          case "curve25519": {
            const t3 = await Bi(32);
            t3[0] = 127 & t3[0] | 64, t3[31] &= 248;
            const r2 = t3.slice().reverse();
            e2 = Ii.box.keyPair.fromSecretKey(r2);
            return { publicKey: ce.concatUint8Array([new Uint8Array([64]), e2.publicKey]), privateKey: t3 };
          }
          case "ed25519": {
            const e3 = await Bi(32), t3 = Ii.sign.keyPair.fromSeed(e3);
            return { publicKey: ce.concatUint8Array([new Uint8Array([64]), t3.publicKey]), privateKey: e3 };
          }
        }
        const t2 = await nn(this.name);
        return e2 = await t2.genKeyPair({ entropy: ce.uint8ArrayToString(await Bi(32)) }), { publicKey: new Uint8Array(e2.getPublic("array", false)), privateKey: e2.getPrivate().toArrayLike(Uint8Array) };
      }
    };
    async function dn(e2, t2, r2, i2) {
      const n2 = { p256: true, p384: true, p521: true, secp256k1: true, curve25519: e2 === me.publicKey.ecdh, brainpoolP256r1: true, brainpoolP384r1: true, brainpoolP512r1: true }, a2 = t2.getName();
      if (!n2[a2])
        return false;
      if (a2 === "curve25519") {
        i2 = i2.slice().reverse();
        const { publicKey: e3 } = Ii.box.keyPair.fromSecretKey(i2);
        r2 = new Uint8Array(r2);
        const t3 = new Uint8Array([64, ...e3]);
        return !!ce.equalsUint8Array(t3, r2);
      }
      const s2 = await nn(a2);
      try {
        r2 = rn(s2, r2).getPublic();
      } catch (e3) {
        return false;
      }
      return !!tn(s2, i2).getPublic().eq(r2);
    }
    function ln(e2) {
      const t2 = pe(e2.x), r2 = pe(e2.y), i2 = new Uint8Array(t2.length + r2.length + 1);
      return i2[0] = 4, i2.set(t2, 1), i2.set(r2, t2.length + 1), i2;
    }
    function pn(e2, t2, r2) {
      const i2 = e2, n2 = r2.slice(1, i2 + 1), a2 = r2.slice(i2 + 1, 2 * i2 + 1);
      return { kty: "EC", crv: t2, x: ye(n2, true), y: ye(a2, true), ext: true };
    }
    function yn(e2, t2, r2, i2) {
      const n2 = pn(e2, t2, r2);
      return n2.d = ye(i2, true), n2;
    }
    var bn = ce.getWebCrypto();
    var mn = ce.getNodeCrypto();
    async function gn(e2, t2, r2, i2, n2, a2) {
      const s2 = new fn(e2);
      if (r2 && !ce.isStream(r2)) {
        const e3 = { publicKey: i2, privateKey: n2 };
        switch (s2.type) {
          case "web":
            try {
              return await async function(e4, t3, r3, i3) {
                const n3 = e4.payloadSize, a3 = yn(e4.payloadSize, on[e4.name], i3.publicKey, i3.privateKey), s3 = await bn.importKey("jwk", a3, { name: "ECDSA", namedCurve: on[e4.name], hash: { name: me.read(me.webHash, e4.hash) } }, false, ["sign"]), o2 = new Uint8Array(await bn.sign({ name: "ECDSA", namedCurve: on[e4.name], hash: { name: me.read(me.webHash, t3) } }, s3, r3));
                return { r: o2.slice(0, n3), s: o2.slice(n3, n3 << 1) };
              }(s2, t2, r2, e3);
            } catch (e4) {
              if (s2.name !== "p521" && (e4.name === "DataError" || e4.name === "OperationError"))
                throw e4;
              ce.printDebugError("Browser did not support signing: " + e4.message);
            }
            break;
          case "node": {
            const i3 = await async function(e4, t3, r3, i4) {
              const n3 = mn.createSign(me.read(me.hash, t3));
              n3.write(r3), n3.end();
              const a3 = kn.encode({ version: 1, parameters: e4.oid, privateKey: Array.from(i4.privateKey), publicKey: { unused: 0, data: Array.from(i4.publicKey) } }, "pem", { label: "EC PRIVATE KEY" });
              return _n.decode(n3.sign(a3), "der");
            }(s2, t2, r2, e3);
            return { r: i3.r.toArrayLike(Uint8Array), s: i3.s.toArrayLike(Uint8Array) };
          }
        }
      }
      return async function(e3, t3, r3) {
        const i3 = await nn(e3.name), n3 = tn(i3, r3).sign(t3);
        return { r: n3.r.toArrayLike(Uint8Array), s: n3.s.toArrayLike(Uint8Array) };
      }(s2, a2, n2);
    }
    async function wn(e2, t2, r2, i2, n2, a2) {
      const s2 = new fn(e2);
      if (i2 && !ce.isStream(i2))
        switch (s2.type) {
          case "web":
            try {
              return await async function(e3, t3, { r: r3, s: i3 }, n3, a3) {
                const s3 = pn(e3.payloadSize, on[e3.name], a3), o2 = await bn.importKey("jwk", s3, { name: "ECDSA", namedCurve: on[e3.name], hash: { name: me.read(me.webHash, e3.hash) } }, false, ["verify"]), c2 = ce.concatUint8Array([r3, i3]).buffer;
                return bn.verify({ name: "ECDSA", namedCurve: on[e3.name], hash: { name: me.read(me.webHash, t3) } }, o2, c2, n3);
              }(s2, t2, r2, i2, n2);
            } catch (e3) {
              if (s2.name !== "p521" && (e3.name === "DataError" || e3.name === "OperationError"))
                throw e3;
              ce.printDebugError("Browser did not support verifying: " + e3.message);
            }
            break;
          case "node":
            return async function(e3, t3, { r: r3, s: i3 }, n3, a3) {
              const { default: s3 } = await Promise.resolve().then(function() {
                return Md;
              }), o2 = mn.createVerify(me.read(me.hash, t3));
              o2.write(n3), o2.end();
              const c2 = Sn.encode({ algorithm: { algorithm: [1, 2, 840, 10045, 2, 1], parameters: e3.oid }, subjectPublicKey: { unused: 0, data: Array.from(a3) } }, "pem", { label: "PUBLIC KEY" }), u2 = _n.encode({ r: new s3(r3), s: new s3(i3) }, "der");
              try {
                return o2.verify(c2, u2);
              } catch (e4) {
                return false;
              }
            }(s2, t2, r2, i2, n2);
        }
      return async function(e3, t3, r3, i3) {
        const n3 = await nn(e3.name);
        return rn(n3, i3).verify(r3, t3);
      }(s2, r2, t2 === void 0 ? i2 : a2, n2);
    }
    var vn = mn ? y.default : void 0;
    var _n = mn ? vn.define("ECDSASignature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    }) : void 0;
    var kn = mn ? vn.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").explicit(0).optional().any(), this.key("publicKey").explicit(1).optional().bitstr());
    }) : void 0;
    var An = mn ? vn.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional().any());
    }) : void 0;
    var Sn = mn ? vn.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(An), this.key("subjectPublicKey").bitstr());
    }) : void 0;
    var En = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: gn, verify: wn, validateParams: async function(e2, t2, r2) {
      const i2 = new fn(e2);
      if (i2.keyType !== me.publicKey.ecdsa)
        return false;
      switch (i2.type) {
        case "web":
        case "node": {
          const i3 = await Bi(8), n2 = me.hash.sha256, a2 = await Qr.digest(n2, i3);
          try {
            const s2 = await gn(e2, n2, i3, t2, r2, a2);
            return await wn(e2, n2, s2, i3, t2, a2);
          } catch (e3) {
            return false;
          }
        }
        default:
          return dn(me.publicKey.ecdsa, e2, t2, r2);
      }
    } });
    Ii.hash = (e2) => new Uint8Array(sr().update(e2).digest());
    var Pn = /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2) {
      if (Qr.getHashByteLength(t2) < Qr.getHashByteLength(me.hash.sha256))
        throw Error("Hash algorithm too weak: sha256 or stronger is required for EdDSA.");
      const s2 = ce.concatUint8Array([n2, i2.subarray(1)]), o2 = Ii.sign.detached(a2, s2);
      return { r: o2.subarray(0, 32), s: o2.subarray(32) };
    }, verify: async function(e2, t2, { r: r2, s: i2 }, n2, a2, s2) {
      const o2 = ce.concatUint8Array([r2, i2]);
      return Ii.sign.detached.verify(s2, o2, a2.subarray(1));
    }, validateParams: async function(e2, t2, r2) {
      if (e2.getName() !== "ed25519")
        return false;
      const { publicKey: i2 } = Ii.sign.keyPair.fromSeed(r2), n2 = new Uint8Array([64, ...i2]);
      return ce.equalsUint8Array(t2, n2);
    } });
    function xn(e2, t2) {
      const r2 = new nt["aes" + 8 * e2.length](e2), i2 = new Uint32Array([2795939494, 2795939494]), n2 = Cn(t2);
      let a2 = i2;
      const s2 = n2, o2 = n2.length / 2, c2 = new Uint32Array([0, 0]);
      let u2 = new Uint32Array(4);
      for (let e3 = 0; e3 <= 5; ++e3)
        for (let t3 = 0; t3 < o2; ++t3)
          c2[1] = o2 * e3 + (1 + t3), u2[0] = a2[0], u2[1] = a2[1], u2[2] = s2[2 * t3], u2[3] = s2[2 * t3 + 1], u2 = Cn(r2.encrypt(Kn(u2))), a2 = u2.subarray(0, 2), a2[0] ^= c2[0], a2[1] ^= c2[1], s2[2 * t3] = u2[2], s2[2 * t3 + 1] = u2[3];
      return Kn(a2, s2);
    }
    function Mn(e2, t2) {
      const r2 = new nt["aes" + 8 * e2.length](e2), i2 = new Uint32Array([2795939494, 2795939494]), n2 = Cn(t2);
      let a2 = n2.subarray(0, 2);
      const s2 = n2.subarray(2), o2 = n2.length / 2 - 1, c2 = new Uint32Array([0, 0]);
      let u2 = new Uint32Array(4);
      for (let e3 = 5; e3 >= 0; --e3)
        for (let t3 = o2 - 1; t3 >= 0; --t3)
          c2[1] = o2 * e3 + (t3 + 1), u2[0] = a2[0] ^ c2[0], u2[1] = a2[1] ^ c2[1], u2[2] = s2[2 * t3], u2[3] = s2[2 * t3 + 1], u2 = Cn(r2.decrypt(Kn(u2))), a2 = u2.subarray(0, 2), s2[2 * t3] = u2[2], s2[2 * t3 + 1] = u2[3];
      if (a2[0] === i2[0] && a2[1] === i2[1])
        return Kn(s2);
      throw Error("Key Data Integrity failed");
    }
    function Cn(e2) {
      const { length: t2 } = e2, r2 = function(e3) {
        if (ce.isString(e3)) {
          const { length: t3 } = e3, r3 = new ArrayBuffer(t3), i3 = new Uint8Array(r3);
          for (let r4 = 0; r4 < t3; ++r4)
            i3[r4] = e3.charCodeAt(r4);
          return r3;
        }
        return new Uint8Array(e3).buffer;
      }(e2), i2 = new DataView(r2), n2 = new Uint32Array(t2 / 4);
      for (let e3 = 0; e3 < t2 / 4; ++e3)
        n2[e3] = i2.getUint32(4 * e3);
      return n2;
    }
    function Kn() {
      let e2 = 0;
      for (let t3 = 0; t3 < arguments.length; ++t3)
        e2 += 4 * arguments[t3].length;
      const t2 = new ArrayBuffer(e2), r2 = new DataView(t2);
      let i2 = 0;
      for (let e3 = 0; e3 < arguments.length; ++e3) {
        for (let t3 = 0; t3 < arguments[e3].length; ++t3)
          r2.setUint32(i2 + 4 * t3, arguments[e3][t3]);
        i2 += 4 * arguments[e3].length;
      }
      return new Uint8Array(t2);
    }
    var Dn = /* @__PURE__ */ Object.freeze({ __proto__: null, wrap: xn, unwrap: Mn });
    function Rn(e2) {
      const t2 = 8 - e2.length % 8, r2 = new Uint8Array(e2.length + t2).fill(t2);
      return r2.set(e2), r2;
    }
    function In(e2) {
      const t2 = e2.length;
      if (t2 > 0) {
        const r2 = e2[t2 - 1];
        if (r2 >= 1) {
          const i2 = e2.subarray(t2 - r2), n2 = new Uint8Array(r2).fill(r2);
          if (ce.equalsUint8Array(i2, n2))
            return e2.subarray(0, t2 - r2);
        }
      }
      throw Error("Invalid padding");
    }
    var Un = /* @__PURE__ */ Object.freeze({ __proto__: null, encode: Rn, decode: In });
    var Bn = class {
      constructor(e2) {
        e2 = e2 === void 0 ? new Uint8Array([]) : ce.isString(e2) ? ce.stringToUint8Array(e2) : new Uint8Array(e2), this.data = e2;
      }
      read(e2) {
        if (e2.length >= 1) {
          const t2 = e2[0];
          if (e2.length >= 1 + t2)
            return this.data = e2.subarray(1, 1 + t2), 1 + this.data.length;
        }
        throw Error("Invalid symmetric key");
      }
      write() {
        return ce.concatUint8Array([new Uint8Array([this.data.length]), this.data]);
      }
    };
    var Tn = class {
      constructor(e2) {
        if (e2) {
          const { hash: t2, cipher: r2 } = e2;
          this.hash = t2, this.cipher = r2;
        } else
          this.hash = null, this.cipher = null;
      }
      read(e2) {
        if (e2.length < 4 || e2[0] !== 3 || e2[1] !== 1)
          throw Error("Cannot read KDFParams");
        return this.hash = e2[2], this.cipher = e2[3], 4;
      }
      write() {
        return new Uint8Array([3, 1, this.hash, this.cipher]);
      }
    };
    function zn(e2) {
      const t2 = me.read(me.symmetric, e2);
      return nt[t2];
    }
    var qn = /* @__PURE__ */ Object.freeze({ __proto__: null, publicKeyEncrypt: async function(e2, t2, r2, i2) {
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign: {
          const { n: e3, e: i3 } = t2;
          return { c: await Gn.rsa.encrypt(r2, e3, i3) };
        }
        case me.publicKey.elgamal: {
          const { p: e3, g: i3, y: n2 } = t2;
          return Gn.elgamal.encrypt(r2, e3, i3, n2);
        }
        case me.publicKey.ecdh: {
          const { oid: e3, Q: n2, kdfParams: a2 } = t2, { publicKey: s2, wrappedKey: o2 } = await Gn.elliptic.ecdh.encrypt(e3, a2, r2, n2, i2);
          return { V: s2, C: new Bn(o2) };
        }
        default:
          return [];
      }
    }, publicKeyDecrypt: async function(e2, t2, r2, i2, n2, a2) {
      switch (e2) {
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaEncrypt: {
          const { c: e3 } = i2, { n: n3, e: s2 } = t2, { d: o2, p: c2, q: u2, u: h2 } = r2;
          return Gn.rsa.decrypt(e3, n3, s2, o2, c2, u2, h2, a2);
        }
        case me.publicKey.elgamal: {
          const { c1: e3, c2: n3 } = i2, s2 = t2.p, o2 = r2.x;
          return Gn.elgamal.decrypt(e3, n3, s2, o2, a2);
        }
        case me.publicKey.ecdh: {
          const { oid: e3, Q: a3, kdfParams: s2 } = t2, { d: o2 } = r2, { V: c2, C: u2 } = i2;
          return Gn.elliptic.ecdh.decrypt(e3, s2, c2, u2.data, a3, o2, n2);
        }
        default:
          throw Error("Invalid public key encryption algorithm.");
      }
    }, parsePublicKeyParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaSign: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = ce.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, { read: r2, publicParams: { n: e3, e: i2 } };
        }
        case me.publicKey.dsa: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = ce.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = ce.readMPI(t2.subarray(r2));
          r2 += n2.length + 2;
          const a2 = ce.readMPI(t2.subarray(r2));
          return r2 += a2.length + 2, { read: r2, publicParams: { p: e3, q: i2, g: n2, y: a2 } };
        }
        case me.publicKey.elgamal: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = ce.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = ce.readMPI(t2.subarray(r2));
          return r2 += n2.length + 2, { read: r2, publicParams: { p: e3, g: i2, y: n2 } };
        }
        case me.publicKey.ecdsa: {
          const e3 = new en();
          r2 += e3.read(t2);
          const i2 = ce.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, { read: r2, publicParams: { oid: e3, Q: i2 } };
        }
        case me.publicKey.eddsa: {
          const e3 = new en();
          r2 += e3.read(t2);
          let i2 = ce.readMPI(t2.subarray(r2));
          return r2 += i2.length + 2, i2 = ce.leftPad(i2, 33), { read: r2, publicParams: { oid: e3, Q: i2 } };
        }
        case me.publicKey.ecdh: {
          const e3 = new en();
          r2 += e3.read(t2);
          const i2 = ce.readMPI(t2.subarray(r2));
          r2 += i2.length + 2;
          const n2 = new Tn();
          return r2 += n2.read(t2.subarray(r2)), { read: r2, publicParams: { oid: e3, Q: i2, kdfParams: n2 } };
        }
        default:
          throw Error("Invalid public key encryption algorithm.");
      }
    }, parsePrivateKeyParams: function(e2, t2, r2) {
      let i2 = 0;
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaSign: {
          const e3 = ce.readMPI(t2.subarray(i2));
          i2 += e3.length + 2;
          const r3 = ce.readMPI(t2.subarray(i2));
          i2 += r3.length + 2;
          const n2 = ce.readMPI(t2.subarray(i2));
          i2 += n2.length + 2;
          const a2 = ce.readMPI(t2.subarray(i2));
          return i2 += a2.length + 2, { read: i2, privateParams: { d: e3, p: r3, q: n2, u: a2 } };
        }
        case me.publicKey.dsa:
        case me.publicKey.elgamal: {
          const e3 = ce.readMPI(t2.subarray(i2));
          return i2 += e3.length + 2, { read: i2, privateParams: { x: e3 } };
        }
        case me.publicKey.ecdsa:
        case me.publicKey.ecdh: {
          const e3 = new fn(r2.oid);
          let n2 = ce.readMPI(t2.subarray(i2));
          return i2 += n2.length + 2, n2 = ce.leftPad(n2, e3.payloadSize), { read: i2, privateParams: { d: n2 } };
        }
        case me.publicKey.eddsa: {
          let e3 = ce.readMPI(t2.subarray(i2));
          return i2 += e3.length + 2, e3 = ce.leftPad(e3, 32), { read: i2, privateParams: { seed: e3 } };
        }
        default:
          throw Error("Invalid public key encryption algorithm.");
      }
    }, parseEncSessionKeyParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign:
          return { c: ce.readMPI(t2.subarray(r2)) };
        case me.publicKey.elgamal: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          return { c1: e3, c2: ce.readMPI(t2.subarray(r2)) };
        }
        case me.publicKey.ecdh: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          const i2 = new Bn();
          return i2.read(t2.subarray(r2)), { V: e3, C: i2 };
        }
        default:
          throw Error("Invalid public key encryption algorithm.");
      }
    }, serializeParams: function(e2, t2) {
      const r2 = Object.keys(t2).map((e3) => {
        const r3 = t2[e3];
        return ce.isUint8Array(r3) ? ce.uint8ArrayToMPI(r3) : r3.write();
      });
      return ce.concatUint8Array(r2);
    }, generateParams: function(e2, t2, r2) {
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaSign:
          return Gn.rsa.generate(t2, 65537).then(({ n: e3, e: t3, d: r3, p: i2, q: n2, u: a2 }) => ({ privateParams: { d: r3, p: i2, q: n2, u: a2 }, publicParams: { n: e3, e: t3 } }));
        case me.publicKey.ecdsa:
          return Gn.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new en(e3), Q: t3 } }));
        case me.publicKey.eddsa:
          return Gn.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3 }) => ({ privateParams: { seed: r3 }, publicParams: { oid: new en(e3), Q: t3 } }));
        case me.publicKey.ecdh:
          return Gn.elliptic.generate(r2).then(({ oid: e3, Q: t3, secret: r3, hash: i2, cipher: n2 }) => ({ privateParams: { d: r3 }, publicParams: { oid: new en(e3), Q: t3, kdfParams: new Tn({ hash: i2, cipher: n2 }) } }));
        case me.publicKey.dsa:
        case me.publicKey.elgamal:
          throw Error("Unsupported algorithm for key generation.");
        default:
          throw Error("Invalid public key algorithm.");
      }
    }, validateParams: async function(e2, t2, r2) {
      if (!t2 || !r2)
        throw Error("Missing key parameters");
      switch (e2) {
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaSign: {
          const { n: e3, e: i2 } = t2, { d: n2, p: a2, q: s2, u: o2 } = r2;
          return Gn.rsa.validateParams(e3, i2, n2, a2, s2, o2);
        }
        case me.publicKey.dsa: {
          const { p: e3, q: i2, g: n2, y: a2 } = t2, { x: s2 } = r2;
          return Gn.dsa.validateParams(e3, i2, n2, a2, s2);
        }
        case me.publicKey.elgamal: {
          const { p: e3, g: i2, y: n2 } = t2, { x: a2 } = r2;
          return Gn.elgamal.validateParams(e3, i2, n2, a2);
        }
        case me.publicKey.ecdsa:
        case me.publicKey.ecdh: {
          const i2 = Gn.elliptic[me.read(me.publicKey, e2)], { oid: n2, Q: a2 } = t2, { d: s2 } = r2;
          return i2.validateParams(n2, a2, s2);
        }
        case me.publicKey.eddsa: {
          const { oid: e3, Q: i2 } = t2, { seed: n2 } = r2;
          return Gn.elliptic.eddsa.validateParams(e3, i2, n2);
        }
        default:
          throw Error("Invalid public key algorithm.");
      }
    }, getPrefixRandom: async function(e2) {
      const { blockSize: t2 } = zn(e2), r2 = await Bi(t2), i2 = new Uint8Array([r2[r2.length - 2], r2[r2.length - 1]]);
      return ce.concat([r2, i2]);
    }, generateSessionKey: function(e2) {
      const { keySize: t2 } = zn(e2);
      return Bi(t2);
    }, getAEADMode: function(e2) {
      const t2 = me.read(me.aead, e2);
      return Ri[t2];
    }, getCipher: zn });
    var On = ce.getWebCrypto();
    var Fn = ce.getNodeCrypto();
    function Nn(e2, t2, r2, i2) {
      return ce.concatUint8Array([t2.write(), new Uint8Array([e2]), r2.write(), ce.stringToUint8Array("Anonymous Sender    "), i2.subarray(0, 20)]);
    }
    async function jn(e2, t2, r2, i2, n2 = false, a2 = false) {
      let s2;
      if (n2) {
        for (s2 = 0; s2 < t2.length && t2[s2] === 0; s2++)
          ;
        t2 = t2.subarray(s2);
      }
      if (a2) {
        for (s2 = t2.length - 1; s2 >= 0 && t2[s2] === 0; s2--)
          ;
        t2 = t2.subarray(0, s2 + 1);
      }
      return (await Qr.digest(e2, ce.concatUint8Array([new Uint8Array([0, 0, 0, 1]), t2, i2]))).subarray(0, r2);
    }
    async function Ln(e2, t2) {
      switch (e2.type) {
        case "curve25519": {
          const r2 = await Bi(32), { secretKey: i2, sharedKey: n2 } = await Wn(e2, t2, null, r2);
          let { publicKey: a2 } = Ii.box.keyPair.fromSecretKey(i2);
          return a2 = ce.concatUint8Array([new Uint8Array([64]), a2]), { publicKey: a2, sharedKey: n2 };
        }
        case "web":
          if (e2.web && ce.getWebCrypto())
            try {
              return await async function(e3, t3) {
                const r2 = pn(e3.payloadSize, e3.web.web, t3);
                let i2 = On.generateKey({ name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]), n2 = On.importKey("jwk", r2, { name: "ECDH", namedCurve: e3.web.web }, false, []);
                [i2, n2] = await Promise.all([i2, n2]);
                let a2 = On.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: n2 }, i2.privateKey, e3.web.sharedSize), s2 = On.exportKey("jwk", i2.publicKey);
                [a2, s2] = await Promise.all([a2, s2]);
                const o2 = new Uint8Array(a2);
                return { publicKey: new Uint8Array(ln(s2)), sharedKey: o2 };
              }(e2, t2);
            } catch (e3) {
              ce.printDebugError(e3);
            }
          break;
        case "node":
          return async function(e3, t3) {
            const r2 = Fn.createECDH(e3.node.node);
            r2.generateKeys();
            const i2 = new Uint8Array(r2.computeSecret(t3));
            return { publicKey: new Uint8Array(r2.getPublicKey()), sharedKey: i2 };
          }(e2, t2);
      }
      return async function(e3, t3) {
        const r2 = await nn(e3.name), i2 = await e3.genKeyPair();
        t3 = rn(r2, t3);
        const n2 = tn(r2, i2.privateKey), a2 = i2.publicKey, s2 = n2.derive(t3.getPublic()), o2 = r2.curve.p.byteLength(), c2 = s2.toArrayLike(Uint8Array, "be", o2);
        return { publicKey: a2, sharedKey: c2 };
      }(e2, t2);
    }
    async function Wn(e2, t2, r2, i2) {
      if (i2.length !== e2.payloadSize) {
        const t3 = new Uint8Array(e2.payloadSize);
        t3.set(i2, e2.payloadSize - i2.length), i2 = t3;
      }
      switch (e2.type) {
        case "curve25519": {
          const e3 = i2.slice().reverse();
          return { secretKey: e3, sharedKey: Ii.scalarMult(e3, t2.subarray(1)) };
        }
        case "web":
          if (e2.web && ce.getWebCrypto())
            try {
              return await async function(e3, t3, r3, i3) {
                const n2 = yn(e3.payloadSize, e3.web.web, r3, i3);
                let a2 = On.importKey("jwk", n2, { name: "ECDH", namedCurve: e3.web.web }, true, ["deriveKey", "deriveBits"]);
                const s2 = pn(e3.payloadSize, e3.web.web, t3);
                let o2 = On.importKey("jwk", s2, { name: "ECDH", namedCurve: e3.web.web }, true, []);
                [a2, o2] = await Promise.all([a2, o2]);
                let c2 = On.deriveBits({ name: "ECDH", namedCurve: e3.web.web, public: o2 }, a2, e3.web.sharedSize), u2 = On.exportKey("jwk", a2);
                [c2, u2] = await Promise.all([c2, u2]);
                const h2 = new Uint8Array(c2);
                return { secretKey: pe(u2.d), sharedKey: h2 };
              }(e2, t2, r2, i2);
            } catch (e3) {
              ce.printDebugError(e3);
            }
          break;
        case "node":
          return async function(e3, t3, r3) {
            const i3 = Fn.createECDH(e3.node.node);
            i3.setPrivateKey(r3);
            const n2 = new Uint8Array(i3.computeSecret(t3));
            return { secretKey: new Uint8Array(i3.getPrivateKey()), sharedKey: n2 };
          }(e2, t2, i2);
      }
      return async function(e3, t3, r3) {
        const i3 = await nn(e3.name);
        t3 = rn(i3, t3), r3 = tn(i3, r3);
        const n2 = new Uint8Array(r3.getPrivate()), a2 = r3.derive(t3.getPublic()), s2 = i3.curve.p.byteLength(), o2 = a2.toArrayLike(Uint8Array, "be", s2);
        return { secretKey: n2, sharedKey: o2 };
      }(e2, t2, i2);
    }
    var Hn = /* @__PURE__ */ Object.freeze({ __proto__: null, validateParams: async function(e2, t2, r2) {
      return dn(me.publicKey.ecdh, e2, t2, r2);
    }, encrypt: async function(e2, t2, r2, i2, n2) {
      const a2 = Rn(r2), s2 = new fn(e2), { publicKey: o2, sharedKey: c2 } = await Ln(s2, i2), u2 = Nn(me.publicKey.ecdh, e2, t2, n2), { keySize: h2 } = zn(t2.cipher);
      return { publicKey: o2, wrappedKey: xn(await jn(t2.hash, c2, h2, u2), a2) };
    }, decrypt: async function(e2, t2, r2, i2, n2, a2, s2) {
      const o2 = new fn(e2), { sharedKey: c2 } = await Wn(o2, r2, n2, a2), u2 = Nn(me.publicKey.ecdh, e2, t2, s2), { keySize: h2 } = zn(t2.cipher);
      let f2;
      for (let e3 = 0; e3 < 3; e3++)
        try {
          return In(Mn(await jn(t2.hash, c2, h2, u2, e3 === 1, e3 === 2), i2));
        } catch (e4) {
          f2 = e4;
        }
      throw f2;
    } });
    var Gn = { rsa: Qi, elgamal: Ji, elliptic: /* @__PURE__ */ Object.freeze({ __proto__: null, Curve: fn, ecdh: Hn, ecdsa: En, eddsa: Pn, generate: async function(e2) {
      const t2 = await ce.getBigInteger();
      e2 = new fn(e2);
      const r2 = await e2.genKeyPair(), i2 = new t2(r2.publicKey).toUint8Array(), n2 = new t2(r2.privateKey).toUint8Array("be", e2.payloadSize);
      return { oid: e2.oid, Q: i2, secret: n2, hash: e2.hash, cipher: e2.cipher };
    }, getPreferredHashAlgo: function(e2) {
      return hn[me.write(me.curve, e2.toHex())].hash;
    } }), dsa: /* @__PURE__ */ Object.freeze({ __proto__: null, sign: async function(e2, t2, r2, i2, n2, a2) {
      const s2 = await ce.getBigInteger(), o2 = new s2(1);
      let c2, u2, h2, f2;
      i2 = new s2(i2), n2 = new s2(n2), r2 = new s2(r2), a2 = new s2(a2), r2 = r2.mod(i2), a2 = a2.mod(n2);
      const d2 = new s2(t2.subarray(0, n2.byteLength())).mod(n2);
      for (; ; ) {
        if (c2 = await Ti(o2, n2), u2 = r2.modExp(c2, i2).imod(n2), u2.isZero())
          continue;
        const e3 = a2.mul(u2).imod(n2);
        if (f2 = d2.add(e3).imod(n2), h2 = c2.modInv(n2).imul(f2).imod(n2), !h2.isZero())
          break;
      }
      return { r: u2.toUint8Array("be", n2.byteLength()), s: h2.toUint8Array("be", n2.byteLength()) };
    }, verify: async function(e2, t2, r2, i2, n2, a2, s2, o2) {
      const c2 = await ce.getBigInteger(), u2 = new c2(0);
      if (t2 = new c2(t2), r2 = new c2(r2), a2 = new c2(a2), s2 = new c2(s2), n2 = new c2(n2), o2 = new c2(o2), t2.lte(u2) || t2.gte(s2) || r2.lte(u2) || r2.gte(s2))
        return ce.printDebug("invalid DSA Signature"), false;
      const h2 = new c2(i2.subarray(0, s2.byteLength())).imod(s2), f2 = r2.modInv(s2);
      if (f2.isZero())
        return ce.printDebug("invalid DSA Signature"), false;
      n2 = n2.mod(a2), o2 = o2.mod(a2);
      const d2 = h2.mul(f2).imod(s2), l2 = t2.mul(f2).imod(s2), p2 = n2.modExp(d2, a2), y2 = o2.modExp(l2, a2);
      return p2.mul(y2).imod(a2).imod(s2).equal(t2);
    }, validateParams: async function(e2, t2, r2, i2, n2) {
      const a2 = await ce.getBigInteger();
      e2 = new a2(e2), t2 = new a2(t2), r2 = new a2(r2), i2 = new a2(i2);
      const s2 = new a2(1);
      if (r2.lte(s2) || r2.gte(e2))
        return false;
      if (!e2.dec().mod(t2).isZero())
        return false;
      if (!r2.modExp(t2, e2).isOne())
        return false;
      const o2 = new a2(t2.bitLength()), c2 = new a2(150);
      if (o2.lt(c2) || !await Fi(t2, null, 32))
        return false;
      n2 = new a2(n2);
      const u2 = new a2(2), h2 = await Ti(u2.leftShift(o2.dec()), u2.leftShift(o2)), f2 = t2.mul(h2).add(n2);
      return !!i2.equal(r2.modExp(f2, e2));
    } }), nacl: Ii };
    var Vn = /* @__PURE__ */ Object.freeze({ __proto__: null, parseSignatureParams: function(e2, t2) {
      let r2 = 0;
      switch (e2) {
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaSign:
          return { s: ce.readMPI(t2.subarray(r2)) };
        case me.publicKey.dsa:
        case me.publicKey.ecdsa: {
          const e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2;
          return { r: e3, s: ce.readMPI(t2.subarray(r2)) };
        }
        case me.publicKey.eddsa: {
          let e3 = ce.readMPI(t2.subarray(r2));
          r2 += e3.length + 2, e3 = ce.leftPad(e3, 32);
          let i2 = ce.readMPI(t2.subarray(r2));
          return i2 = ce.leftPad(i2, 32), { r: e3, s: i2 };
        }
        default:
          throw Error("Invalid signature algorithm.");
      }
    }, verify: async function(e2, t2, r2, i2, n2, a2) {
      switch (e2) {
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaSign: {
          const { n: e3, e: s2 } = i2, o2 = ce.leftPad(r2.s, e3.length);
          return Gn.rsa.verify(t2, n2, o2, e3, s2, a2);
        }
        case me.publicKey.dsa: {
          const { g: e3, p: n3, q: s2, y: o2 } = i2, { r: c2, s: u2 } = r2;
          return Gn.dsa.verify(t2, c2, u2, a2, e3, n3, s2, o2);
        }
        case me.publicKey.ecdsa: {
          const { oid: e3, Q: s2 } = i2, o2 = new Gn.elliptic.Curve(e3).payloadSize, c2 = ce.leftPad(r2.r, o2), u2 = ce.leftPad(r2.s, o2);
          return Gn.elliptic.ecdsa.verify(e3, t2, { r: c2, s: u2 }, n2, s2, a2);
        }
        case me.publicKey.eddsa: {
          const { oid: e3, Q: s2 } = i2;
          return Gn.elliptic.eddsa.verify(e3, t2, r2, n2, s2, a2);
        }
        default:
          throw Error("Invalid signature algorithm.");
      }
    }, sign: async function(e2, t2, r2, i2, n2, a2) {
      if (!r2 || !i2)
        throw Error("Missing key parameters");
      switch (e2) {
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaEncrypt:
        case me.publicKey.rsaSign: {
          const { n: e3, e: s2 } = r2, { d: o2, p: c2, q: u2, u: h2 } = i2;
          return { s: await Gn.rsa.sign(t2, n2, e3, s2, o2, c2, u2, h2, a2) };
        }
        case me.publicKey.dsa: {
          const { g: e3, p: n3, q: s2 } = r2, { x: o2 } = i2;
          return Gn.dsa.sign(t2, a2, e3, n3, s2, o2);
        }
        case me.publicKey.elgamal:
          throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");
        case me.publicKey.ecdsa: {
          const { oid: e3, Q: s2 } = r2, { d: o2 } = i2;
          return Gn.elliptic.ecdsa.sign(e3, t2, n2, s2, o2, a2);
        }
        case me.publicKey.eddsa: {
          const { oid: e3, Q: s2 } = r2, { seed: o2 } = i2;
          return Gn.elliptic.eddsa.sign(e3, t2, n2, s2, o2, a2);
        }
        default:
          throw Error("Invalid signature algorithm.");
      }
    } });
    var $n = { cipher: nt, hash: Qr, mode: Ri, publicKey: Gn, signature: Vn, random: qi, pkcs1: Gi, pkcs5: Un, aesKW: Dn };
    Object.assign($n, qn);
    var Zn = typeof Uint8Array != "undefined" && typeof Uint16Array != "undefined" && typeof Int32Array != "undefined";
    function Yn(e2, t2) {
      return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
    }
    var Xn = { arraySet: function(e2, t2, r2, i2, n2) {
      if (t2.subarray && e2.subarray)
        e2.set(t2.subarray(r2, r2 + i2), n2);
      else
        for (let a2 = 0; a2 < i2; a2++)
          e2[n2 + a2] = t2[r2 + a2];
    }, flattenChunks: function(e2) {
      let t2, r2, i2, n2, a2;
      for (i2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++)
        i2 += e2[t2].length;
      const s2 = new Uint8Array(i2);
      for (n2 = 0, t2 = 0, r2 = e2.length; t2 < r2; t2++)
        a2 = e2[t2], s2.set(a2, n2), n2 += a2.length;
      return s2;
    } };
    var Qn = { arraySet: function(e2, t2, r2, i2, n2) {
      for (let a2 = 0; a2 < i2; a2++)
        e2[n2 + a2] = t2[r2 + a2];
    }, flattenChunks: function(e2) {
      return [].concat.apply([], e2);
    } };
    var Jn = Zn ? Uint8Array : Array;
    var ea = Zn ? Uint16Array : Array;
    var ta = Zn ? Int32Array : Array;
    var ra = Zn ? Xn.flattenChunks : Qn.flattenChunks;
    var ia = Zn ? Xn.arraySet : Qn.arraySet;
    function na(e2) {
      let t2 = e2.length;
      for (; --t2 >= 0; )
        e2[t2] = 0;
    }
    var aa = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var sa = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var oa = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var ca = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var ua = Array(576);
    na(ua);
    var ha = Array(60);
    na(ha);
    var fa = Array(512);
    na(fa);
    var da = Array(256);
    na(da);
    var la = Array(29);
    na(la);
    var pa = Array(30);
    function ya(e2, t2, r2, i2, n2) {
      this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = e2 && e2.length;
    }
    var ba;
    var ma;
    var ga;
    function wa(e2, t2) {
      this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
    }
    function va(e2) {
      return e2 < 256 ? fa[e2] : fa[256 + (e2 >>> 7)];
    }
    function _a(e2, t2) {
      e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
    }
    function ka(e2, t2, r2) {
      e2.bi_valid > 16 - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, _a(e2, e2.bi_buf), e2.bi_buf = t2 >> 16 - e2.bi_valid, e2.bi_valid += r2 - 16) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
    }
    function Aa(e2, t2, r2) {
      ka(e2, r2[2 * t2], r2[2 * t2 + 1]);
    }
    function Sa(e2, t2) {
      let r2 = 0;
      do {
        r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1;
      } while (--t2 > 0);
      return r2 >>> 1;
    }
    function Ea(e2, t2, r2) {
      const i2 = Array(16);
      let n2, a2, s2 = 0;
      for (n2 = 1; n2 <= 15; n2++)
        i2[n2] = s2 = s2 + r2[n2 - 1] << 1;
      for (a2 = 0; a2 <= t2; a2++) {
        const t3 = e2[2 * a2 + 1];
        t3 !== 0 && (e2[2 * a2] = Sa(i2[t3]++, t3));
      }
    }
    function Pa(e2) {
      let t2;
      for (t2 = 0; t2 < 286; t2++)
        e2.dyn_ltree[2 * t2] = 0;
      for (t2 = 0; t2 < 30; t2++)
        e2.dyn_dtree[2 * t2] = 0;
      for (t2 = 0; t2 < 19; t2++)
        e2.bl_tree[2 * t2] = 0;
      e2.dyn_ltree[512] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
    }
    function xa(e2) {
      e2.bi_valid > 8 ? _a(e2, e2.bi_buf) : e2.bi_valid > 0 && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
    }
    function Ma(e2, t2, r2, i2) {
      const n2 = 2 * t2, a2 = 2 * r2;
      return e2[n2] < e2[a2] || e2[n2] === e2[a2] && i2[t2] <= i2[r2];
    }
    function Ca(e2, t2, r2) {
      const i2 = e2.heap[r2];
      let n2 = r2 << 1;
      for (; n2 <= e2.heap_len && (n2 < e2.heap_len && Ma(t2, e2.heap[n2 + 1], e2.heap[n2], e2.depth) && n2++, !Ma(t2, i2, e2.heap[n2], e2.depth)); )
        e2.heap[r2] = e2.heap[n2], r2 = n2, n2 <<= 1;
      e2.heap[r2] = i2;
    }
    function Ka(e2, t2, r2) {
      let i2, n2, a2, s2, o2 = 0;
      if (e2.last_lit !== 0)
        do {
          i2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], n2 = e2.pending_buf[e2.l_buf + o2], o2++, i2 === 0 ? Aa(e2, n2, t2) : (a2 = da[n2], Aa(e2, a2 + 256 + 1, t2), s2 = aa[a2], s2 !== 0 && (n2 -= la[a2], ka(e2, n2, s2)), i2--, a2 = va(i2), Aa(e2, a2, r2), s2 = sa[a2], s2 !== 0 && (i2 -= pa[a2], ka(e2, i2, s2)));
        } while (o2 < e2.last_lit);
      Aa(e2, 256, t2);
    }
    function Da(e2, t2) {
      const r2 = t2.dyn_tree, i2 = t2.stat_desc.static_tree, n2 = t2.stat_desc.has_stree, a2 = t2.stat_desc.elems;
      let s2, o2, c2, u2 = -1;
      for (e2.heap_len = 0, e2.heap_max = 573, s2 = 0; s2 < a2; s2++)
        r2[2 * s2] !== 0 ? (e2.heap[++e2.heap_len] = u2 = s2, e2.depth[s2] = 0) : r2[2 * s2 + 1] = 0;
      for (; e2.heap_len < 2; )
        c2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0, r2[2 * c2] = 1, e2.depth[c2] = 0, e2.opt_len--, n2 && (e2.static_len -= i2[2 * c2 + 1]);
      for (t2.max_code = u2, s2 = e2.heap_len >> 1; s2 >= 1; s2--)
        Ca(e2, r2, s2);
      c2 = a2;
      do {
        s2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], Ca(e2, r2, 1), o2 = e2.heap[1], e2.heap[--e2.heap_max] = s2, e2.heap[--e2.heap_max] = o2, r2[2 * c2] = r2[2 * s2] + r2[2 * o2], e2.depth[c2] = (e2.depth[s2] >= e2.depth[o2] ? e2.depth[s2] : e2.depth[o2]) + 1, r2[2 * s2 + 1] = r2[2 * o2 + 1] = c2, e2.heap[1] = c2++, Ca(e2, r2, 1);
      } while (e2.heap_len >= 2);
      e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
        const r3 = t3.dyn_tree, i3 = t3.max_code, n3 = t3.stat_desc.static_tree, a3 = t3.stat_desc.has_stree, s3 = t3.stat_desc.extra_bits, o3 = t3.stat_desc.extra_base, c3 = t3.stat_desc.max_length;
        let u3, h2, f2, d2, l2, p2, y2 = 0;
        for (d2 = 0; d2 <= 15; d2++)
          e3.bl_count[d2] = 0;
        for (r3[2 * e3.heap[e3.heap_max] + 1] = 0, u3 = e3.heap_max + 1; u3 < 573; u3++)
          h2 = e3.heap[u3], d2 = r3[2 * r3[2 * h2 + 1] + 1] + 1, d2 > c3 && (d2 = c3, y2++), r3[2 * h2 + 1] = d2, h2 > i3 || (e3.bl_count[d2]++, l2 = 0, h2 >= o3 && (l2 = s3[h2 - o3]), p2 = r3[2 * h2], e3.opt_len += p2 * (d2 + l2), a3 && (e3.static_len += p2 * (n3[2 * h2 + 1] + l2)));
        if (y2 !== 0) {
          do {
            for (d2 = c3 - 1; e3.bl_count[d2] === 0; )
              d2--;
            e3.bl_count[d2]--, e3.bl_count[d2 + 1] += 2, e3.bl_count[c3]--, y2 -= 2;
          } while (y2 > 0);
          for (d2 = c3; d2 !== 0; d2--)
            for (h2 = e3.bl_count[d2]; h2 !== 0; )
              f2 = e3.heap[--u3], f2 > i3 || (r3[2 * f2 + 1] !== d2 && (e3.opt_len += (d2 - r3[2 * f2 + 1]) * r3[2 * f2], r3[2 * f2 + 1] = d2), h2--);
        }
      }(e2, t2), Ea(r2, u2, e2.bl_count);
    }
    function Ra(e2, t2, r2) {
      let i2, n2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, u2 = 4;
      for (s2 === 0 && (c2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++)
        n2 = s2, s2 = t2[2 * (i2 + 1) + 1], ++o2 < c2 && n2 === s2 || (o2 < u2 ? e2.bl_tree[2 * n2] += o2 : n2 !== 0 ? (n2 !== a2 && e2.bl_tree[2 * n2]++, e2.bl_tree[32]++) : o2 <= 10 ? e2.bl_tree[34]++ : e2.bl_tree[36]++, o2 = 0, a2 = n2, s2 === 0 ? (c2 = 138, u2 = 3) : n2 === s2 ? (c2 = 6, u2 = 3) : (c2 = 7, u2 = 4));
    }
    function Ia(e2, t2, r2) {
      let i2, n2, a2 = -1, s2 = t2[1], o2 = 0, c2 = 7, u2 = 4;
      for (s2 === 0 && (c2 = 138, u2 = 3), i2 = 0; i2 <= r2; i2++)
        if (n2 = s2, s2 = t2[2 * (i2 + 1) + 1], !(++o2 < c2 && n2 === s2)) {
          if (o2 < u2)
            do {
              Aa(e2, n2, e2.bl_tree);
            } while (--o2 != 0);
          else
            n2 !== 0 ? (n2 !== a2 && (Aa(e2, n2, e2.bl_tree), o2--), Aa(e2, 16, e2.bl_tree), ka(e2, o2 - 3, 2)) : o2 <= 10 ? (Aa(e2, 17, e2.bl_tree), ka(e2, o2 - 3, 3)) : (Aa(e2, 18, e2.bl_tree), ka(e2, o2 - 11, 7));
          o2 = 0, a2 = n2, s2 === 0 ? (c2 = 138, u2 = 3) : n2 === s2 ? (c2 = 6, u2 = 3) : (c2 = 7, u2 = 4);
        }
    }
    na(pa);
    var Ua = false;
    function Ba(e2) {
      Ua || (!function() {
        let e3, t2, r2, i2, n2;
        const a2 = Array(16);
        for (r2 = 0, i2 = 0; i2 < 28; i2++)
          for (la[i2] = r2, e3 = 0; e3 < 1 << aa[i2]; e3++)
            da[r2++] = i2;
        for (da[r2 - 1] = i2, n2 = 0, i2 = 0; i2 < 16; i2++)
          for (pa[i2] = n2, e3 = 0; e3 < 1 << sa[i2]; e3++)
            fa[n2++] = i2;
        for (n2 >>= 7; i2 < 30; i2++)
          for (pa[i2] = n2 << 7, e3 = 0; e3 < 1 << sa[i2] - 7; e3++)
            fa[256 + n2++] = i2;
        for (t2 = 0; t2 <= 15; t2++)
          a2[t2] = 0;
        for (e3 = 0; e3 <= 143; )
          ua[2 * e3 + 1] = 8, e3++, a2[8]++;
        for (; e3 <= 255; )
          ua[2 * e3 + 1] = 9, e3++, a2[9]++;
        for (; e3 <= 279; )
          ua[2 * e3 + 1] = 7, e3++, a2[7]++;
        for (; e3 <= 287; )
          ua[2 * e3 + 1] = 8, e3++, a2[8]++;
        for (Ea(ua, 287, a2), e3 = 0; e3 < 30; e3++)
          ha[2 * e3 + 1] = 5, ha[2 * e3] = Sa(e3, 5);
        ba = new ya(ua, aa, 257, 286, 15), ma = new ya(ha, sa, 0, 30, 15), ga = new ya([], oa, 0, 19, 7);
      }(), Ua = true), e2.l_desc = new wa(e2.dyn_ltree, ba), e2.d_desc = new wa(e2.dyn_dtree, ma), e2.bl_desc = new wa(e2.bl_tree, ga), e2.bi_buf = 0, e2.bi_valid = 0, Pa(e2);
    }
    function Ta(e2, t2, r2, i2) {
      ka(e2, 0 + (i2 ? 1 : 0), 3), function(e3, t3, r3, i3) {
        xa(e3), i3 && (_a(e3, r3), _a(e3, ~r3)), ia(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
      }(e2, t2, r2, true);
    }
    function za(e2) {
      ka(e2, 2, 3), Aa(e2, 256, ua), function(e3) {
        e3.bi_valid === 16 ? (_a(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : e3.bi_valid >= 8 && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
      }(e2);
    }
    function qa(e2, t2, r2, i2) {
      let n2, a2, s2 = 0;
      e2.level > 0 ? (e2.strm.data_type === 2 && (e2.strm.data_type = function(e3) {
        let t3, r3 = 4093624447;
        for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
          if (1 & r3 && e3.dyn_ltree[2 * t3] !== 0)
            return 0;
        if (e3.dyn_ltree[18] !== 0 || e3.dyn_ltree[20] !== 0 || e3.dyn_ltree[26] !== 0)
          return 1;
        for (t3 = 32; t3 < 256; t3++)
          if (e3.dyn_ltree[2 * t3] !== 0)
            return 1;
        return 0;
      }(e2)), Da(e2, e2.l_desc), Da(e2, e2.d_desc), s2 = function(e3) {
        let t3;
        for (Ra(e3, e3.dyn_ltree, e3.l_desc.max_code), Ra(e3, e3.dyn_dtree, e3.d_desc.max_code), Da(e3, e3.bl_desc), t3 = 18; t3 >= 3 && e3.bl_tree[2 * ca[t3] + 1] === 0; t3--)
          ;
        return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
      }(e2), n2 = e2.opt_len + 3 + 7 >>> 3, a2 = e2.static_len + 3 + 7 >>> 3, a2 <= n2 && (n2 = a2)) : n2 = a2 = r2 + 5, r2 + 4 <= n2 && t2 !== -1 ? Ta(e2, t2, r2, i2) : e2.strategy === 4 || a2 === n2 ? (ka(e2, 2 + (i2 ? 1 : 0), 3), Ka(e2, ua, ha)) : (ka(e2, 4 + (i2 ? 1 : 0), 3), function(e3, t3, r3, i3) {
        let n3;
        for (ka(e3, t3 - 257, 5), ka(e3, r3 - 1, 5), ka(e3, i3 - 4, 4), n3 = 0; n3 < i3; n3++)
          ka(e3, e3.bl_tree[2 * ca[n3] + 1], 3);
        Ia(e3, e3.dyn_ltree, t3 - 1), Ia(e3, e3.dyn_dtree, r3 - 1);
      }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, s2 + 1), Ka(e2, e2.dyn_ltree, e2.dyn_dtree)), Pa(e2), i2 && xa(e2);
    }
    function Oa(e2, t2, r2) {
      return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, t2 === 0 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (da[r2] + 256 + 1)]++, e2.dyn_dtree[2 * va(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
    }
    function Fa(e2, t2, r2, i2) {
      let n2 = 65535 & e2 | 0, a2 = e2 >>> 16 & 65535 | 0, s2 = 0;
      for (; r2 !== 0; ) {
        s2 = r2 > 2e3 ? 2e3 : r2, r2 -= s2;
        do {
          n2 = n2 + t2[i2++] | 0, a2 = a2 + n2 | 0;
        } while (--s2);
        n2 %= 65521, a2 %= 65521;
      }
      return n2 | a2 << 16 | 0;
    }
    var Na = function() {
      let e2;
      const t2 = [];
      for (let r2 = 0; r2 < 256; r2++) {
        e2 = r2;
        for (let t3 = 0; t3 < 8; t3++)
          e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
        t2[r2] = e2;
      }
      return t2;
    }();
    function ja(e2, t2, r2, i2) {
      const n2 = Na, a2 = i2 + r2;
      e2 ^= -1;
      for (let r3 = i2; r3 < a2; r3++)
        e2 = e2 >>> 8 ^ n2[255 & (e2 ^ t2[r3])];
      return -1 ^ e2;
    }
    var La = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    function Wa(e2, t2) {
      return e2.msg = La[t2], t2;
    }
    function Ha(e2) {
      return (e2 << 1) - (e2 > 4 ? 9 : 0);
    }
    function Ga(e2) {
      let t2 = e2.length;
      for (; --t2 >= 0; )
        e2[t2] = 0;
    }
    function Va(e2) {
      const t2 = e2.state;
      let r2 = t2.pending;
      r2 > e2.avail_out && (r2 = e2.avail_out), r2 !== 0 && (ia(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, t2.pending === 0 && (t2.pending_out = 0));
    }
    function $a(e2, t2) {
      qa(e2, e2.block_start >= 0 ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, Va(e2.strm);
    }
    function Za(e2, t2) {
      e2.pending_buf[e2.pending++] = t2;
    }
    function Ya(e2, t2) {
      e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
    }
    function Xa(e2, t2, r2, i2) {
      let n2 = e2.avail_in;
      return n2 > i2 && (n2 = i2), n2 === 0 ? 0 : (e2.avail_in -= n2, ia(t2, e2.input, e2.next_in, n2, r2), e2.state.wrap === 1 ? e2.adler = Fa(e2.adler, t2, n2, r2) : e2.state.wrap === 2 && (e2.adler = ja(e2.adler, t2, n2, r2)), e2.next_in += n2, e2.total_in += n2, n2);
    }
    function Qa(e2, t2) {
      let r2, i2, n2 = e2.max_chain_length, a2 = e2.strstart, s2 = e2.prev_length, o2 = e2.nice_match;
      const c2 = e2.strstart > e2.w_size - 262 ? e2.strstart - (e2.w_size - 262) : 0, u2 = e2.window, h2 = e2.w_mask, f2 = e2.prev, d2 = e2.strstart + 258;
      let l2 = u2[a2 + s2 - 1], p2 = u2[a2 + s2];
      e2.prev_length >= e2.good_match && (n2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
      do {
        if (r2 = t2, u2[r2 + s2] === p2 && u2[r2 + s2 - 1] === l2 && u2[r2] === u2[a2] && u2[++r2] === u2[a2 + 1]) {
          a2 += 2, r2++;
          do {
          } while (u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && u2[++a2] === u2[++r2] && a2 < d2);
          if (i2 = 258 - (d2 - a2), a2 = d2 - 258, i2 > s2) {
            if (e2.match_start = t2, s2 = i2, i2 >= o2)
              break;
            l2 = u2[a2 + s2 - 1], p2 = u2[a2 + s2];
          }
        }
      } while ((t2 = f2[t2 & h2]) > c2 && --n2 != 0);
      return s2 <= e2.lookahead ? s2 : e2.lookahead;
    }
    function Ja(e2) {
      const t2 = e2.w_size;
      let r2, i2, n2, a2, s2;
      do {
        if (a2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= t2 + (t2 - 262)) {
          ia(e2.window, e2.window, t2, t2, 0), e2.match_start -= t2, e2.strstart -= t2, e2.block_start -= t2, i2 = e2.hash_size, r2 = i2;
          do {
            n2 = e2.head[--r2], e2.head[r2] = n2 >= t2 ? n2 - t2 : 0;
          } while (--i2);
          i2 = t2, r2 = i2;
          do {
            n2 = e2.prev[--r2], e2.prev[r2] = n2 >= t2 ? n2 - t2 : 0;
          } while (--i2);
          a2 += t2;
        }
        if (e2.strm.avail_in === 0)
          break;
        if (i2 = Xa(e2.strm, e2.window, e2.strstart + e2.lookahead, a2), e2.lookahead += i2, e2.lookahead + e2.insert >= 3)
          for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 3 - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < 3)); )
            ;
      } while (e2.lookahead < 262 && e2.strm.avail_in !== 0);
    }
    function es(e2, t2) {
      let r2, i2;
      for (; ; ) {
        if (e2.lookahead < 262) {
          if (Ja(e2), e2.lookahead < 262 && t2 === 0)
            return 1;
          if (e2.lookahead === 0)
            break;
        }
        if (r2 = 0, e2.lookahead >= 3 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), r2 !== 0 && e2.strstart - r2 <= e2.w_size - 262 && (e2.match_length = Qa(e2, r2)), e2.match_length >= 3)
          if (i2 = Oa(e2, e2.strstart - e2.match_start, e2.match_length - 3), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= 3) {
            e2.match_length--;
            do {
              e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart;
            } while (--e2.match_length != 0);
            e2.strstart++;
          } else
            e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
        else
          i2 = Oa(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
        if (i2 && ($a(e2, false), e2.strm.avail_out === 0))
          return 1;
      }
      return e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === 4 ? ($a(e2, true), e2.strm.avail_out === 0 ? 3 : 4) : e2.last_lit && ($a(e2, false), e2.strm.avail_out === 0) ? 1 : 2;
    }
    function ts(e2, t2) {
      let r2, i2, n2;
      for (; ; ) {
        if (e2.lookahead < 262) {
          if (Ja(e2), e2.lookahead < 262 && t2 === 0)
            return 1;
          if (e2.lookahead === 0)
            break;
        }
        if (r2 = 0, e2.lookahead >= 3 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = 2, r2 !== 0 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - 262 && (e2.match_length = Qa(e2, r2), e2.match_length <= 5 && (e2.strategy === 1 || e2.match_length === 3 && e2.strstart - e2.match_start > 4096) && (e2.match_length = 2)), e2.prev_length >= 3 && e2.match_length <= e2.prev_length) {
          n2 = e2.strstart + e2.lookahead - 3, i2 = Oa(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - 3), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2;
          do {
            ++e2.strstart <= n2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 3 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart);
          } while (--e2.prev_length != 0);
          if (e2.match_available = 0, e2.match_length = 2, e2.strstart++, i2 && ($a(e2, false), e2.strm.avail_out === 0))
            return 1;
        } else if (e2.match_available) {
          if (i2 = Oa(e2, 0, e2.window[e2.strstart - 1]), i2 && $a(e2, false), e2.strstart++, e2.lookahead--, e2.strm.avail_out === 0)
            return 1;
        } else
          e2.match_available = 1, e2.strstart++, e2.lookahead--;
      }
      return e2.match_available && (i2 = Oa(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < 2 ? e2.strstart : 2, t2 === 4 ? ($a(e2, true), e2.strm.avail_out === 0 ? 3 : 4) : e2.last_lit && ($a(e2, false), e2.strm.avail_out === 0) ? 1 : 2;
    }
    var rs = class {
      constructor(e2, t2, r2, i2, n2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
      }
    };
    var is = [new rs(0, 0, 0, 0, function(e2, t2) {
      let r2 = 65535;
      for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
        if (e2.lookahead <= 1) {
          if (Ja(e2), e2.lookahead === 0 && t2 === 0)
            return 1;
          if (e2.lookahead === 0)
            break;
        }
        e2.strstart += e2.lookahead, e2.lookahead = 0;
        const i2 = e2.block_start + r2;
        if ((e2.strstart === 0 || e2.strstart >= i2) && (e2.lookahead = e2.strstart - i2, e2.strstart = i2, $a(e2, false), e2.strm.avail_out === 0))
          return 1;
        if (e2.strstart - e2.block_start >= e2.w_size - 262 && ($a(e2, false), e2.strm.avail_out === 0))
          return 1;
      }
      return e2.insert = 0, t2 === 4 ? ($a(e2, true), e2.strm.avail_out === 0 ? 3 : 4) : (e2.strstart > e2.block_start && ($a(e2, false), e2.strm.avail_out), 1);
    }), new rs(4, 4, 8, 4, es), new rs(4, 5, 16, 8, es), new rs(4, 6, 32, 32, es), new rs(4, 4, 16, 16, ts), new rs(8, 16, 32, 32, ts), new rs(8, 16, 128, 128, ts), new rs(8, 32, 128, 256, ts), new rs(32, 128, 258, 1024, ts), new rs(32, 258, 258, 4096, ts)];
    var ns = class {
      constructor() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new ea(1146), this.dyn_dtree = new ea(122), this.bl_tree = new ea(78), Ga(this.dyn_ltree), Ga(this.dyn_dtree), Ga(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new ea(16), this.heap = new ea(573), Ga(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new ea(573), Ga(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
    };
    function as(e2) {
      const t2 = function(e3) {
        let t3;
        return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = 2, t3 = e3.state, t3.pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? 42 : 113, e3.adler = t3.wrap === 2 ? 0 : 1, t3.last_flush = 0, Ba(t3), 0) : Wa(e3, -2);
      }(e2);
      return t2 === 0 && function(e3) {
        e3.window_size = 2 * e3.w_size, Ga(e3.head), e3.max_lazy_match = is[e3.level].max_lazy, e3.good_match = is[e3.level].good_length, e3.nice_match = is[e3.level].nice_length, e3.max_chain_length = is[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = 2, e3.match_available = 0, e3.ins_h = 0;
      }(e2.state), t2;
    }
    function ss(e2, t2) {
      let r2, i2, n2, a2;
      if (!e2 || !e2.state || t2 > 5 || t2 < 0)
        return e2 ? Wa(e2, -2) : -2;
      if (i2 = e2.state, !e2.output || !e2.input && e2.avail_in !== 0 || i2.status === 666 && t2 !== 4)
        return Wa(e2, e2.avail_out === 0 ? -5 : -2);
      if (i2.strm = e2, r2 = i2.last_flush, i2.last_flush = t2, i2.status === 42)
        if (i2.wrap === 2)
          e2.adler = 0, Za(i2, 31), Za(i2, 139), Za(i2, 8), i2.gzhead ? (Za(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), Za(i2, 255 & i2.gzhead.time), Za(i2, i2.gzhead.time >> 8 & 255), Za(i2, i2.gzhead.time >> 16 & 255), Za(i2, i2.gzhead.time >> 24 & 255), Za(i2, i2.level === 9 ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), Za(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (Za(i2, 255 & i2.gzhead.extra.length), Za(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (Za(i2, 0), Za(i2, 0), Za(i2, 0), Za(i2, 0), Za(i2, 0), Za(i2, i2.level === 9 ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), Za(i2, 3), i2.status = 113);
        else {
          let t3 = 8 + (i2.w_bits - 8 << 4) << 8, r3 = -1;
          r3 = i2.strategy >= 2 || i2.level < 2 ? 0 : i2.level < 6 ? 1 : i2.level === 6 ? 2 : 3, t3 |= r3 << 6, i2.strstart !== 0 && (t3 |= 32), t3 += 31 - t3 % 31, i2.status = 113, Ya(i2, t3), i2.strstart !== 0 && (Ya(i2, e2.adler >>> 16), Ya(i2, 65535 & e2.adler)), e2.adler = 1;
        }
      if (i2.status === 69)
        if (i2.gzhead.extra) {
          for (n2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Va(e2), n2 = i2.pending, i2.pending !== i2.pending_buf_size)); )
            Za(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
        } else
          i2.status = 73;
      if (i2.status === 73)
        if (i2.gzhead.name) {
          n2 = i2.pending;
          do {
            if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Va(e2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
              a2 = 1;
              break;
            }
            a2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, Za(i2, a2);
          } while (a2 !== 0);
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), a2 === 0 && (i2.gzindex = 0, i2.status = 91);
        } else
          i2.status = 91;
      if (i2.status === 91)
        if (i2.gzhead.comment) {
          n2 = i2.pending;
          do {
            if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), Va(e2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
              a2 = 1;
              break;
            }
            a2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, Za(i2, a2);
          } while (a2 !== 0);
          i2.gzhead.hcrc && i2.pending > n2 && (e2.adler = ja(e2.adler, i2.pending_buf, i2.pending - n2, n2)), a2 === 0 && (i2.status = 103);
        } else
          i2.status = 103;
      if (i2.status === 103 && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && Va(e2), i2.pending + 2 <= i2.pending_buf_size && (Za(i2, 255 & e2.adler), Za(i2, e2.adler >> 8 & 255), e2.adler = 0, i2.status = 113)) : i2.status = 113), i2.pending !== 0) {
        if (Va(e2), e2.avail_out === 0)
          return i2.last_flush = -1, 0;
      } else if (e2.avail_in === 0 && Ha(t2) <= Ha(r2) && t2 !== 4)
        return Wa(e2, -5);
      if (i2.status === 666 && e2.avail_in !== 0)
        return Wa(e2, -5);
      if (e2.avail_in !== 0 || i2.lookahead !== 0 || t2 !== 0 && i2.status !== 666) {
        var s2 = i2.strategy === 2 ? function(e3, t3) {
          let r3;
          for (; ; ) {
            if (e3.lookahead === 0 && (Ja(e3), e3.lookahead === 0)) {
              if (t3 === 0)
                return 1;
              break;
            }
            if (e3.match_length = 0, r3 = Oa(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && ($a(e3, false), e3.strm.avail_out === 0))
              return 1;
          }
          return e3.insert = 0, t3 === 4 ? ($a(e3, true), e3.strm.avail_out === 0 ? 3 : 4) : e3.last_lit && ($a(e3, false), e3.strm.avail_out === 0) ? 1 : 2;
        }(i2, t2) : i2.strategy === 3 ? function(e3, t3) {
          let r3, i3, n3, a3;
          const s3 = e3.window;
          for (; ; ) {
            if (e3.lookahead <= 258) {
              if (Ja(e3), e3.lookahead <= 258 && t3 === 0)
                return 1;
              if (e3.lookahead === 0)
                break;
            }
            if (e3.match_length = 0, e3.lookahead >= 3 && e3.strstart > 0 && (n3 = e3.strstart - 1, i3 = s3[n3], i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3])) {
              a3 = e3.strstart + 258;
              do {
              } while (i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && i3 === s3[++n3] && n3 < a3);
              e3.match_length = 258 - (a3 - n3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
            }
            if (e3.match_length >= 3 ? (r3 = Oa(e3, 1, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = Oa(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && ($a(e3, false), e3.strm.avail_out === 0))
              return 1;
          }
          return e3.insert = 0, t3 === 4 ? ($a(e3, true), e3.strm.avail_out === 0 ? 3 : 4) : e3.last_lit && ($a(e3, false), e3.strm.avail_out === 0) ? 1 : 2;
        }(i2, t2) : is[i2.level].func(i2, t2);
        if (s2 !== 3 && s2 !== 4 || (i2.status = 666), s2 === 1 || s2 === 3)
          return e2.avail_out === 0 && (i2.last_flush = -1), 0;
        if (s2 === 2 && (t2 === 1 ? za(i2) : t2 !== 5 && (Ta(i2, 0, 0, false), t2 === 3 && (Ga(i2.head), i2.lookahead === 0 && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), Va(e2), e2.avail_out === 0))
          return i2.last_flush = -1, 0;
      }
      return t2 !== 4 ? 0 : i2.wrap <= 0 ? 1 : (i2.wrap === 2 ? (Za(i2, 255 & e2.adler), Za(i2, e2.adler >> 8 & 255), Za(i2, e2.adler >> 16 & 255), Za(i2, e2.adler >> 24 & 255), Za(i2, 255 & e2.total_in), Za(i2, e2.total_in >> 8 & 255), Za(i2, e2.total_in >> 16 & 255), Za(i2, e2.total_in >> 24 & 255)) : (Ya(i2, e2.adler >>> 16), Ya(i2, 65535 & e2.adler)), Va(e2), i2.wrap > 0 && (i2.wrap = -i2.wrap), i2.pending !== 0 ? 0 : 1);
    }
    try {
      String.fromCharCode.call(null, 0);
    } catch (e2) {
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e2) {
    }
    var os2 = new Jn(256);
    for (let e2 = 0; e2 < 256; e2++)
      os2[e2] = e2 >= 252 ? 6 : e2 >= 248 ? 5 : e2 >= 240 ? 4 : e2 >= 224 ? 3 : e2 >= 192 ? 2 : 1;
    function cs(e2) {
      let t2, r2, i2, n2, a2 = 0;
      const s2 = e2.length;
      for (i2 = 0; i2 < s2; i2++)
        t2 = e2.charCodeAt(i2), (64512 & t2) == 55296 && i2 + 1 < s2 && (r2 = e2.charCodeAt(i2 + 1), (64512 & r2) == 56320 && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), i2++)), a2 += t2 < 128 ? 1 : t2 < 2048 ? 2 : t2 < 65536 ? 3 : 4;
      const o2 = new Jn(a2);
      for (n2 = 0, i2 = 0; n2 < a2; i2++)
        t2 = e2.charCodeAt(i2), (64512 & t2) == 55296 && i2 + 1 < s2 && (r2 = e2.charCodeAt(i2 + 1), (64512 & r2) == 56320 && (t2 = 65536 + (t2 - 55296 << 10) + (r2 - 56320), i2++)), t2 < 128 ? o2[n2++] = t2 : t2 < 2048 ? (o2[n2++] = 192 | t2 >>> 6, o2[n2++] = 128 | 63 & t2) : t2 < 65536 ? (o2[n2++] = 224 | t2 >>> 12, o2[n2++] = 128 | t2 >>> 6 & 63, o2[n2++] = 128 | 63 & t2) : (o2[n2++] = 240 | t2 >>> 18, o2[n2++] = 128 | t2 >>> 12 & 63, o2[n2++] = 128 | t2 >>> 6 & 63, o2[n2++] = 128 | 63 & t2);
      return o2;
    }
    os2[254] = os2[254] = 1;
    var us = class {
      constructor() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      }
    };
    var hs = class {
      constructor(e2) {
        this.options = __spreadValues({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0 }, e2 || {});
        const t2 = this.options;
        t2.raw && t2.windowBits > 0 ? t2.windowBits = -t2.windowBits : t2.gzip && t2.windowBits > 0 && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new us(), this.strm.avail_out = 0;
        var r2, i2, n2 = function(e3, t3, r3, i3, n3, a2) {
          if (!e3)
            return -2;
          let s2 = 1;
          if (t3 === -1 && (t3 = 6), i3 < 0 ? (s2 = 0, i3 = -i3) : i3 > 15 && (s2 = 2, i3 -= 16), n3 < 1 || n3 > 9 || r3 !== 8 || i3 < 8 || i3 > 15 || t3 < 0 || t3 > 9 || a2 < 0 || a2 > 4)
            return Wa(e3, -2);
          i3 === 8 && (i3 = 9);
          const o2 = new ns();
          return e3.state = o2, o2.strm = e3, o2.wrap = s2, o2.gzhead = null, o2.w_bits = i3, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n3 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + 3 - 1) / 3), o2.window = new Jn(2 * o2.w_size), o2.head = new ea(o2.hash_size), o2.prev = new ea(o2.w_size), o2.lit_bufsize = 1 << n3 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new Jn(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t3, o2.strategy = a2, o2.method = r3, as(e3);
        }(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (n2 !== 0)
          throw Error(La[n2]);
        if (t2.header && (r2 = this.strm, i2 = t2.header, r2 && r2.state && (r2.state.wrap !== 2 || (r2.state.gzhead = i2))), t2.dictionary) {
          let e3;
          if (e3 = typeof t2.dictionary == "string" ? cs(t2.dictionary) : t2.dictionary instanceof ArrayBuffer ? new Uint8Array(t2.dictionary) : t2.dictionary, (n2 = function(e4, t3) {
            let r3, i3, n3, a2, s2, o2, c2, u2, h2 = t3.length;
            if (!e4 || !e4.state)
              return -2;
            if (r3 = e4.state, a2 = r3.wrap, a2 === 2 || a2 === 1 && r3.status !== 42 || r3.lookahead)
              return -2;
            for (a2 === 1 && (e4.adler = Fa(e4.adler, t3, h2, 0)), r3.wrap = 0, h2 >= r3.w_size && (a2 === 0 && (Ga(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), u2 = new Jn(r3.w_size), ia(u2, t3, h2 - r3.w_size, r3.w_size, 0), t3 = u2, h2 = r3.w_size), s2 = e4.avail_in, o2 = e4.next_in, c2 = e4.input, e4.avail_in = h2, e4.next_in = 0, e4.input = t3, Ja(r3); r3.lookahead >= 3; ) {
              i3 = r3.strstart, n3 = r3.lookahead - 2;
              do {
                r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[i3 + 3 - 1]) & r3.hash_mask, r3.prev[i3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = i3, i3++;
              } while (--n3);
              r3.strstart = i3, r3.lookahead = 2, Ja(r3);
            }
            return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = 2, r3.match_available = 0, e4.next_in = o2, e4.input = c2, e4.avail_in = s2, r3.wrap = a2, 0;
          }(this.strm, e3)) !== 0)
            throw Error(La[n2]);
          this._dict_set = true;
        }
      }
      push(e2, t2) {
        const { strm: r2, options: { chunkSize: i2 } } = this;
        var n2, a2;
        if (this.ended)
          return false;
        a2 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? r2.input = cs(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
        do {
          if (r2.avail_out === 0 && (r2.output = new Jn(i2), r2.next_out = 0, r2.avail_out = i2), (n2 = ss(r2, a2)) !== 1 && n2 !== 0)
            return this.onEnd(n2), this.ended = true, false;
          r2.avail_out !== 0 && (r2.avail_in !== 0 || a2 !== 4 && a2 !== 2) || this.onData(Yn(r2.output, r2.next_out));
        } while ((r2.avail_in > 0 || r2.avail_out === 0) && n2 !== 1);
        return a2 === 4 ? (n2 = function(e3) {
          let t3;
          return e3 && e3.state ? (t3 = e3.state.status, t3 !== 42 && t3 !== 69 && t3 !== 73 && t3 !== 91 && t3 !== 103 && t3 !== 113 && t3 !== 666 ? Wa(e3, -2) : (e3.state = null, t3 === 113 ? Wa(e3, -3) : 0)) : -2;
        }(this.strm), this.onEnd(n2), this.ended = true, n2 === 0) : a2 !== 2 || (this.onEnd(0), r2.avail_out = 0, true);
      }
      onData(e2) {
        this.chunks.push(e2);
      }
      onEnd(e2) {
        e2 === 0 && (this.result = ra(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }
    };
    function fs(e2, t2) {
      let r2, i2, n2, a2, s2, o2, c2, u2, h2, f2;
      const d2 = e2.state;
      r2 = e2.next_in;
      const l2 = e2.input, p2 = r2 + (e2.avail_in - 5);
      i2 = e2.next_out;
      const y2 = e2.output, b2 = i2 - (t2 - e2.avail_out), m2 = i2 + (e2.avail_out - 257), g2 = d2.dmax, w2 = d2.wsize, v2 = d2.whave, _2 = d2.wnext, k2 = d2.window;
      n2 = d2.hold, a2 = d2.bits;
      const A2 = d2.lencode, S2 = d2.distcode, E2 = (1 << d2.lenbits) - 1, P2 = (1 << d2.distbits) - 1;
      e:
        do {
          a2 < 15 && (n2 += l2[r2++] << a2, a2 += 8, n2 += l2[r2++] << a2, a2 += 8), s2 = A2[n2 & E2];
          t:
            for (; ; ) {
              if (o2 = s2 >>> 24, n2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, o2 === 0)
                y2[i2++] = 65535 & s2;
              else {
                if (!(16 & o2)) {
                  if ((64 & o2) == 0) {
                    s2 = A2[(65535 & s2) + (n2 & (1 << o2) - 1)];
                    continue t;
                  }
                  if (32 & o2) {
                    d2.mode = 12;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", d2.mode = 30;
                  break e;
                }
                c2 = 65535 & s2, o2 &= 15, o2 && (a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8), c2 += n2 & (1 << o2) - 1, n2 >>>= o2, a2 -= o2), a2 < 15 && (n2 += l2[r2++] << a2, a2 += 8, n2 += l2[r2++] << a2, a2 += 8), s2 = S2[n2 & P2];
                r:
                  for (; ; ) {
                    if (o2 = s2 >>> 24, n2 >>>= o2, a2 -= o2, o2 = s2 >>> 16 & 255, !(16 & o2)) {
                      if ((64 & o2) == 0) {
                        s2 = S2[(65535 & s2) + (n2 & (1 << o2) - 1)];
                        continue r;
                      }
                      e2.msg = "invalid distance code", d2.mode = 30;
                      break e;
                    }
                    if (u2 = 65535 & s2, o2 &= 15, a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8, a2 < o2 && (n2 += l2[r2++] << a2, a2 += 8)), u2 += n2 & (1 << o2) - 1, u2 > g2) {
                      e2.msg = "invalid distance too far back", d2.mode = 30;
                      break e;
                    }
                    if (n2 >>>= o2, a2 -= o2, o2 = i2 - b2, u2 > o2) {
                      if (o2 = u2 - o2, o2 > v2 && d2.sane) {
                        e2.msg = "invalid distance too far back", d2.mode = 30;
                        break e;
                      }
                      if (h2 = 0, f2 = k2, _2 === 0) {
                        if (h2 += w2 - o2, o2 < c2) {
                          c2 -= o2;
                          do {
                            y2[i2++] = k2[h2++];
                          } while (--o2);
                          h2 = i2 - u2, f2 = y2;
                        }
                      } else if (_2 < o2) {
                        if (h2 += w2 + _2 - o2, o2 -= _2, o2 < c2) {
                          c2 -= o2;
                          do {
                            y2[i2++] = k2[h2++];
                          } while (--o2);
                          if (h2 = 0, _2 < c2) {
                            o2 = _2, c2 -= o2;
                            do {
                              y2[i2++] = k2[h2++];
                            } while (--o2);
                            h2 = i2 - u2, f2 = y2;
                          }
                        }
                      } else if (h2 += _2 - o2, o2 < c2) {
                        c2 -= o2;
                        do {
                          y2[i2++] = k2[h2++];
                        } while (--o2);
                        h2 = i2 - u2, f2 = y2;
                      }
                      for (; c2 > 2; )
                        y2[i2++] = f2[h2++], y2[i2++] = f2[h2++], y2[i2++] = f2[h2++], c2 -= 3;
                      c2 && (y2[i2++] = f2[h2++], c2 > 1 && (y2[i2++] = f2[h2++]));
                    } else {
                      h2 = i2 - u2;
                      do {
                        y2[i2++] = y2[h2++], y2[i2++] = y2[h2++], y2[i2++] = y2[h2++], c2 -= 3;
                      } while (c2 > 2);
                      c2 && (y2[i2++] = y2[h2++], c2 > 1 && (y2[i2++] = y2[h2++]));
                    }
                    break;
                  }
              }
              break;
            }
        } while (r2 < p2 && i2 < m2);
      c2 = a2 >> 3, r2 -= c2, a2 -= c2 << 3, n2 &= (1 << a2) - 1, e2.next_in = r2, e2.next_out = i2, e2.avail_in = r2 < p2 ? p2 - r2 + 5 : 5 - (r2 - p2), e2.avail_out = i2 < m2 ? m2 - i2 + 257 : 257 - (i2 - m2), d2.hold = n2, d2.bits = a2;
    }
    var ds = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
    var ls = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
    var ps = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
    var ys = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    function bs(e2, t2, r2, i2, n2, a2, s2, o2) {
      const c2 = o2.bits;
      let u2, h2, f2, d2, l2, p2 = 0, y2 = 0, b2 = 0, m2 = 0, g2 = 0, w2 = 0, v2 = 0, _2 = 0, k2 = 0, A2 = 0, S2 = null, E2 = 0;
      const P2 = new ea(16), x2 = new ea(16);
      let M2, C2, K2, D2 = null, R2 = 0;
      for (p2 = 0; p2 <= 15; p2++)
        P2[p2] = 0;
      for (y2 = 0; y2 < i2; y2++)
        P2[t2[r2 + y2]]++;
      for (g2 = c2, m2 = 15; m2 >= 1 && P2[m2] === 0; m2--)
        ;
      if (g2 > m2 && (g2 = m2), m2 === 0)
        return n2[a2++] = 20971520, n2[a2++] = 20971520, o2.bits = 1, 0;
      for (b2 = 1; b2 < m2 && P2[b2] === 0; b2++)
        ;
      for (g2 < b2 && (g2 = b2), _2 = 1, p2 = 1; p2 <= 15; p2++)
        if (_2 <<= 1, _2 -= P2[p2], _2 < 0)
          return -1;
      if (_2 > 0 && (e2 === 0 || m2 !== 1))
        return -1;
      for (x2[1] = 0, p2 = 1; p2 < 15; p2++)
        x2[p2 + 1] = x2[p2] + P2[p2];
      for (y2 = 0; y2 < i2; y2++)
        t2[r2 + y2] !== 0 && (s2[x2[t2[r2 + y2]]++] = y2);
      e2 === 0 ? (S2 = D2 = s2, l2 = 19) : e2 === 1 ? (S2 = ds, E2 -= 257, D2 = ls, R2 -= 257, l2 = 256) : (S2 = ps, D2 = ys, l2 = -1), A2 = 0, y2 = 0, p2 = b2, d2 = a2, w2 = g2, v2 = 0, f2 = -1, k2 = 1 << g2;
      const I2 = k2 - 1;
      if (e2 === 1 && k2 > 852 || e2 === 2 && k2 > 592)
        return 1;
      for (; ; ) {
        M2 = p2 - v2, s2[y2] < l2 ? (C2 = 0, K2 = s2[y2]) : s2[y2] > l2 ? (C2 = D2[R2 + s2[y2]], K2 = S2[E2 + s2[y2]]) : (C2 = 96, K2 = 0), u2 = 1 << p2 - v2, h2 = 1 << w2, b2 = h2;
        do {
          h2 -= u2, n2[d2 + (A2 >> v2) + h2] = M2 << 24 | C2 << 16 | K2 | 0;
        } while (h2 !== 0);
        for (u2 = 1 << p2 - 1; A2 & u2; )
          u2 >>= 1;
        if (u2 !== 0 ? (A2 &= u2 - 1, A2 += u2) : A2 = 0, y2++, --P2[p2] == 0) {
          if (p2 === m2)
            break;
          p2 = t2[r2 + s2[y2]];
        }
        if (p2 > g2 && (A2 & I2) !== f2) {
          for (v2 === 0 && (v2 = g2), d2 += b2, w2 = p2 - v2, _2 = 1 << w2; w2 + v2 < m2 && (_2 -= P2[w2 + v2], !(_2 <= 0)); )
            w2++, _2 <<= 1;
          if (k2 += 1 << w2, e2 === 1 && k2 > 852 || e2 === 2 && k2 > 592)
            return 1;
          f2 = A2 & I2, n2[f2] = g2 << 24 | w2 << 16 | d2 - a2 | 0;
        }
      }
      return A2 !== 0 && (n2[d2 + A2] = p2 - v2 << 24 | 64 << 16 | 0), o2.bits = g2, 0;
    }
    function ms(e2) {
      return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
    }
    var gs = class {
      constructor() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new ea(320), this.work = new ea(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
    };
    function ws(e2) {
      let t2;
      return e2 && e2.state ? (t2 = e2.state, t2.wsize = 0, t2.whave = 0, t2.wnext = 0, function(e3) {
        let t3;
        return e3 && e3.state ? (t3 = e3.state, e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = 1, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new ta(852), t3.distcode = t3.distdyn = new ta(592), t3.sane = 1, t3.back = -1, 0) : -2;
      }(e2)) : -2;
    }
    function vs(e2, t2) {
      let r2, i2;
      return e2 ? (i2 = new gs(), e2.state = i2, i2.window = null, r2 = function(e3, t3) {
        let r3, i3;
        return e3 && e3.state ? (i3 = e3.state, t3 < 0 ? (r3 = 0, t3 = -t3) : (r3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? -2 : (i3.window !== null && i3.wbits !== t3 && (i3.window = null), i3.wrap = r3, i3.wbits = t3, ws(e3))) : -2;
      }(e2, t2), r2 !== 0 && (e2.state = null), r2) : -2;
    }
    var _s;
    var ks;
    var As = true;
    function Ss(e2) {
      if (As) {
        let t2;
        for (_s = new ta(512), ks = new ta(32), t2 = 0; t2 < 144; )
          e2.lens[t2++] = 8;
        for (; t2 < 256; )
          e2.lens[t2++] = 9;
        for (; t2 < 280; )
          e2.lens[t2++] = 7;
        for (; t2 < 288; )
          e2.lens[t2++] = 8;
        for (bs(1, e2.lens, 0, 288, _s, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
          e2.lens[t2++] = 5;
        bs(2, e2.lens, 0, 32, ks, 0, e2.work, { bits: 5 }), As = false;
      }
      e2.lencode = _s, e2.lenbits = 9, e2.distcode = ks, e2.distbits = 5;
    }
    function Es(e2, t2, r2, i2) {
      let n2;
      const a2 = e2.state;
      return a2.window === null && (a2.wsize = 1 << a2.wbits, a2.wnext = 0, a2.whave = 0, a2.window = new Jn(a2.wsize)), i2 >= a2.wsize ? (ia(a2.window, t2, r2 - a2.wsize, a2.wsize, 0), a2.wnext = 0, a2.whave = a2.wsize) : (n2 = a2.wsize - a2.wnext, n2 > i2 && (n2 = i2), ia(a2.window, t2, r2 - i2, n2, a2.wnext), (i2 -= n2) ? (ia(a2.window, t2, r2 - i2, i2, 0), a2.wnext = i2, a2.whave = a2.wsize) : (a2.wnext += n2, a2.wnext === a2.wsize && (a2.wnext = 0), a2.whave < a2.wsize && (a2.whave += n2))), 0;
    }
    function Ps(e2, t2) {
      let r2, i2, n2, a2, s2, o2, c2, u2, h2, f2, d2, l2, p2, y2, b2, m2, g2, w2, v2, _2, k2, A2, S2, E2, P2 = 0, x2 = new Jn(4);
      const M2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!e2 || !e2.state || !e2.output || !e2.input && e2.avail_in !== 0)
        return -2;
      r2 = e2.state, r2.mode === 12 && (r2.mode = 13), s2 = e2.next_out, n2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, i2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, h2 = r2.bits, f2 = o2, d2 = c2, A2 = 0;
      e:
        for (; ; )
          switch (r2.mode) {
            case 1:
              if (r2.wrap === 0) {
                r2.mode = 13;
                break;
              }
              for (; h2 < 16; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (2 & r2.wrap && u2 === 35615) {
                r2.check = 0, x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = ja(r2.check, x2, 2, 0), u2 = 0, h2 = 0, r2.mode = 2;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r2.mode = 30;
                break;
              }
              if ((15 & u2) != 8) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (u2 >>>= 4, h2 -= 4, k2 = 8 + (15 & u2), r2.wbits === 0)
                r2.wbits = k2;
              else if (k2 > r2.wbits) {
                e2.msg = "invalid window size", r2.mode = 30;
                break;
              }
              r2.dmax = 1 << k2, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, u2 = 0, h2 = 0;
              break;
            case 2:
              for (; h2 < 16; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (r2.flags = u2, (255 & r2.flags) != 8) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (57344 & r2.flags) {
                e2.msg = "unknown header flags set", r2.mode = 30;
                break;
              }
              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = ja(r2.check, x2, 2, 0)), u2 = 0, h2 = 0, r2.mode = 3;
            case 3:
              for (; h2 < 32; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              r2.head && (r2.head.time = u2), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, x2[2] = u2 >>> 16 & 255, x2[3] = u2 >>> 24 & 255, r2.check = ja(r2.check, x2, 4, 0)), u2 = 0, h2 = 0, r2.mode = 4;
            case 4:
              for (; h2 < 16; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = ja(r2.check, x2, 2, 0)), u2 = 0, h2 = 0, r2.mode = 5;
            case 5:
              if (1024 & r2.flags) {
                for (; h2 < 16; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (x2[0] = 255 & u2, x2[1] = u2 >>> 8 & 255, r2.check = ja(r2.check, x2, 2, 0)), u2 = 0, h2 = 0;
              } else
                r2.head && (r2.head.extra = null);
              r2.mode = 6;
            case 6:
              if (1024 & r2.flags && (l2 = r2.length, l2 > o2 && (l2 = o2), l2 && (r2.head && (k2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = Array(r2.head.extra_len)), ia(r2.head.extra, i2, a2, l2, k2)), 512 & r2.flags && (r2.check = ja(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, r2.length -= l2), r2.length))
                break e;
              r2.length = 0, r2.mode = 7;
            case 7:
              if (2048 & r2.flags) {
                if (o2 === 0)
                  break e;
                l2 = 0;
                do {
                  k2 = i2[a2 + l2++], r2.head && k2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(k2));
                } while (k2 && l2 < o2);
                if (512 & r2.flags && (r2.check = ja(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, k2)
                  break e;
              } else
                r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = 8;
            case 8:
              if (4096 & r2.flags) {
                if (o2 === 0)
                  break e;
                l2 = 0;
                do {
                  k2 = i2[a2 + l2++], r2.head && k2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k2));
                } while (k2 && l2 < o2);
                if (512 & r2.flags && (r2.check = ja(r2.check, i2, l2, a2)), o2 -= l2, a2 += l2, k2)
                  break e;
              } else
                r2.head && (r2.head.comment = null);
              r2.mode = 9;
            case 9:
              if (512 & r2.flags) {
                for (; h2 < 16; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (u2 !== (65535 & r2.check)) {
                  e2.msg = "header crc mismatch", r2.mode = 30;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
              break;
            case 10:
              for (; h2 < 32; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              e2.adler = r2.check = ms(u2), u2 = 0, h2 = 0, r2.mode = 11;
            case 11:
              if (r2.havedict === 0)
                return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, 2;
              e2.adler = r2.check = 1, r2.mode = 12;
            case 12:
              if (t2 === 5 || t2 === 6)
                break e;
            case 13:
              if (r2.last) {
                u2 >>>= 7 & h2, h2 -= 7 & h2, r2.mode = 27;
                break;
              }
              for (; h2 < 3; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              switch (r2.last = 1 & u2, u2 >>>= 1, h2 -= 1, 3 & u2) {
                case 0:
                  r2.mode = 14;
                  break;
                case 1:
                  if (Ss(r2), r2.mode = 20, t2 === 6) {
                    u2 >>>= 2, h2 -= 2;
                    break e;
                  }
                  break;
                case 2:
                  r2.mode = 17;
                  break;
                case 3:
                  e2.msg = "invalid block type", r2.mode = 30;
              }
              u2 >>>= 2, h2 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & h2, h2 -= 7 & h2; h2 < 32; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r2.mode = 30;
                break;
              }
              if (r2.length = 65535 & u2, u2 = 0, h2 = 0, r2.mode = 15, t2 === 6)
                break e;
            case 15:
              r2.mode = 16;
            case 16:
              if (l2 = r2.length, l2) {
                if (l2 > o2 && (l2 = o2), l2 > c2 && (l2 = c2), l2 === 0)
                  break e;
                ia(n2, i2, a2, l2, s2), o2 -= l2, a2 += l2, c2 -= l2, s2 += l2, r2.length -= l2;
                break;
              }
              r2.mode = 12;
              break;
            case 17:
              for (; h2 < 14; ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, h2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, h2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, h2 -= 4, r2.nlen > 286 || r2.ndist > 30) {
                e2.msg = "too many length or distance symbols", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 18;
            case 18:
              for (; r2.have < r2.ncode; ) {
                for (; h2 < 3; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.lens[M2[r2.have++]] = 7 & u2, u2 >>>= 3, h2 -= 3;
              }
              for (; r2.have < 19; )
                r2.lens[M2[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S2 = { bits: r2.lenbits }, A2 = bs(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, A2) {
                e2.msg = "invalid code lengths set", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 19;
            case 19:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; P2 = r2.lencode[u2 & (1 << r2.lenbits) - 1], b2 = P2 >>> 24, m2 = P2 >>> 16 & 255, g2 = 65535 & P2, !(b2 <= h2); ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (g2 < 16)
                  u2 >>>= b2, h2 -= b2, r2.lens[r2.have++] = g2;
                else {
                  if (g2 === 16) {
                    for (E2 = b2 + 2; h2 < E2; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    if (u2 >>>= b2, h2 -= b2, r2.have === 0) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    k2 = r2.lens[r2.have - 1], l2 = 3 + (3 & u2), u2 >>>= 2, h2 -= 2;
                  } else if (g2 === 17) {
                    for (E2 = b2 + 3; h2 < E2; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    u2 >>>= b2, h2 -= b2, k2 = 0, l2 = 3 + (7 & u2), u2 >>>= 3, h2 -= 3;
                  } else {
                    for (E2 = b2 + 7; h2 < E2; ) {
                      if (o2 === 0)
                        break e;
                      o2--, u2 += i2[a2++] << h2, h2 += 8;
                    }
                    u2 >>>= b2, h2 -= b2, k2 = 0, l2 = 11 + (127 & u2), u2 >>>= 7, h2 -= 7;
                  }
                  if (r2.have + l2 > r2.nlen + r2.ndist) {
                    e2.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  for (; l2--; )
                    r2.lens[r2.have++] = k2;
                }
              }
              if (r2.mode === 30)
                break;
              if (r2.lens[256] === 0) {
                e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                break;
              }
              if (r2.lenbits = 9, S2 = { bits: r2.lenbits }, A2 = bs(1, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, A2) {
                e2.msg = "invalid literal/lengths set", r2.mode = 30;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S2 = { bits: r2.distbits }, A2 = bs(2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S2), r2.distbits = S2.bits, A2) {
                e2.msg = "invalid distances set", r2.mode = 30;
                break;
              }
              if (r2.mode = 20, t2 === 6)
                break e;
            case 20:
              r2.mode = 21;
            case 21:
              if (o2 >= 6 && c2 >= 258) {
                e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, fs(e2, d2), s2 = e2.next_out, n2 = e2.output, c2 = e2.avail_out, a2 = e2.next_in, i2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, h2 = r2.bits, r2.mode === 12 && (r2.back = -1);
                break;
              }
              for (r2.back = 0; P2 = r2.lencode[u2 & (1 << r2.lenbits) - 1], b2 = P2 >>> 24, m2 = P2 >>> 16 & 255, g2 = 65535 & P2, !(b2 <= h2); ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if (m2 && (240 & m2) == 0) {
                for (w2 = b2, v2 = m2, _2 = g2; P2 = r2.lencode[_2 + ((u2 & (1 << w2 + v2) - 1) >> w2)], b2 = P2 >>> 24, m2 = P2 >>> 16 & 255, g2 = 65535 & P2, !(w2 + b2 <= h2); ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                u2 >>>= w2, h2 -= w2, r2.back += w2;
              }
              if (u2 >>>= b2, h2 -= b2, r2.back += b2, r2.length = g2, m2 === 0) {
                r2.mode = 26;
                break;
              }
              if (32 & m2) {
                r2.back = -1, r2.mode = 12;
                break;
              }
              if (64 & m2) {
                e2.msg = "invalid literal/length code", r2.mode = 30;
                break;
              }
              r2.extra = 15 & m2, r2.mode = 22;
            case 22:
              if (r2.extra) {
                for (E2 = r2.extra; h2 < E2; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, h2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = 23;
            case 23:
              for (; P2 = r2.distcode[u2 & (1 << r2.distbits) - 1], b2 = P2 >>> 24, m2 = P2 >>> 16 & 255, g2 = 65535 & P2, !(b2 <= h2); ) {
                if (o2 === 0)
                  break e;
                o2--, u2 += i2[a2++] << h2, h2 += 8;
              }
              if ((240 & m2) == 0) {
                for (w2 = b2, v2 = m2, _2 = g2; P2 = r2.distcode[_2 + ((u2 & (1 << w2 + v2) - 1) >> w2)], b2 = P2 >>> 24, m2 = P2 >>> 16 & 255, g2 = 65535 & P2, !(w2 + b2 <= h2); ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                u2 >>>= w2, h2 -= w2, r2.back += w2;
              }
              if (u2 >>>= b2, h2 -= b2, r2.back += b2, 64 & m2) {
                e2.msg = "invalid distance code", r2.mode = 30;
                break;
              }
              r2.offset = g2, r2.extra = 15 & m2, r2.mode = 24;
            case 24:
              if (r2.extra) {
                for (E2 = r2.extra; h2 < E2; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, h2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e2.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              r2.mode = 25;
            case 25:
              if (c2 === 0)
                break e;
              if (l2 = d2 - c2, r2.offset > l2) {
                if (l2 = r2.offset - l2, l2 > r2.whave && r2.sane) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                l2 > r2.wnext ? (l2 -= r2.wnext, p2 = r2.wsize - l2) : p2 = r2.wnext - l2, l2 > r2.length && (l2 = r2.length), y2 = r2.window;
              } else
                y2 = n2, p2 = s2 - r2.offset, l2 = r2.length;
              l2 > c2 && (l2 = c2), c2 -= l2, r2.length -= l2;
              do {
                n2[s2++] = y2[p2++];
              } while (--l2);
              r2.length === 0 && (r2.mode = 21);
              break;
            case 26:
              if (c2 === 0)
                break e;
              n2[s2++] = r2.length, c2--, r2.mode = 21;
              break;
            case 27:
              if (r2.wrap) {
                for (; h2 < 32; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 |= i2[a2++] << h2, h2 += 8;
                }
                if (d2 -= c2, e2.total_out += d2, r2.total += d2, d2 && (e2.adler = r2.check = r2.flags ? ja(r2.check, n2, d2, s2 - d2) : Fa(r2.check, n2, d2, s2 - d2)), d2 = c2, (r2.flags ? u2 : ms(u2)) !== r2.check) {
                  e2.msg = "incorrect data check", r2.mode = 30;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.mode = 28;
            case 28:
              if (r2.wrap && r2.flags) {
                for (; h2 < 32; ) {
                  if (o2 === 0)
                    break e;
                  o2--, u2 += i2[a2++] << h2, h2 += 8;
                }
                if (u2 !== (4294967295 & r2.total)) {
                  e2.msg = "incorrect length check", r2.mode = 30;
                  break;
                }
                u2 = 0, h2 = 0;
              }
              r2.mode = 29;
            case 29:
              A2 = 1;
              break e;
            case 30:
              A2 = -3;
              break e;
            case 32:
            default:
              return -2;
          }
      return e2.next_out = s2, e2.avail_out = c2, e2.next_in = a2, e2.avail_in = o2, r2.hold = u2, r2.bits = h2, (r2.wsize || d2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || t2 !== 4)) && Es(e2, e2.output, e2.next_out, d2 - e2.avail_out), f2 -= e2.avail_in, d2 -= e2.avail_out, e2.total_in += f2, e2.total_out += d2, r2.total += d2, r2.wrap && d2 && (e2.adler = r2.check = r2.flags ? ja(r2.check, n2, d2, e2.next_out - d2) : Fa(r2.check, n2, d2, e2.next_out - d2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (r2.mode === 12 ? 128 : 0) + (r2.mode === 20 || r2.mode === 15 ? 256 : 0), (f2 === 0 && d2 === 0 || t2 === 4) && A2 === 0 && (A2 = -5), A2;
    }
    function xs(e2, t2) {
      const r2 = t2.length;
      let i2, n2;
      return e2 && e2.state ? (i2 = e2.state, i2.wrap !== 0 && i2.mode !== 11 ? -2 : i2.mode === 11 && (n2 = 1, n2 = Fa(n2, t2, r2, 0), n2 !== i2.check) ? -3 : (Es(e2, t2, r2, r2), i2.havedict = 1, 0)) : -2;
    }
    var Ms = class {
      constructor() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      }
    };
    var Cs = class {
      constructor(e2) {
        this.options = __spreadValues({ chunkSize: 16384, windowBits: 0 }, e2 || {});
        const t2 = this.options;
        t2.raw && t2.windowBits >= 0 && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, t2.windowBits === 0 && (t2.windowBits = -15)), !(t2.windowBits >= 0 && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), t2.windowBits > 15 && t2.windowBits < 48 && (15 & t2.windowBits) == 0 && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new us(), this.strm.avail_out = 0;
        let r2 = vs(this.strm, t2.windowBits);
        if (r2 !== 0)
          throw Error(La[r2]);
        if (this.header = new Ms(), function(e3, t3) {
          let r3;
          e3 && e3.state && (r3 = e3.state, (2 & r3.wrap) == 0 || (r3.head = t3, t3.done = false));
        }(this.strm, this.header), t2.dictionary && (typeof t2.dictionary == "string" ? t2.dictionary = cs(t2.dictionary) : t2.dictionary instanceof ArrayBuffer && (t2.dictionary = new Uint8Array(t2.dictionary)), t2.raw && (r2 = xs(this.strm, t2.dictionary), r2 !== 0)))
          throw Error(La[r2]);
      }
      push(e2, t2) {
        const { strm: r2, options: { chunkSize: i2, dictionary: n2 } } = this;
        let a2, s2, o2 = false;
        if (this.ended)
          return false;
        s2 = t2 === ~~t2 ? t2 : t2 === true ? 4 : 0, typeof e2 == "string" ? r2.input = function(e3) {
          const t3 = new Jn(e3.length);
          for (let r3 = 0, i3 = t3.length; r3 < i3; r3++)
            t3[r3] = e3.charCodeAt(r3);
          return t3;
        }(e2) : e2 instanceof ArrayBuffer ? r2.input = new Uint8Array(e2) : r2.input = e2, r2.next_in = 0, r2.avail_in = r2.input.length;
        do {
          if (r2.avail_out === 0 && (r2.output = new Jn(i2), r2.next_out = 0, r2.avail_out = i2), a2 = Ps(r2, 0), a2 === 2 && n2 && (a2 = xs(this.strm, n2)), a2 === -5 && o2 === true && (a2 = 0, o2 = false), a2 !== 1 && a2 !== 0)
            return this.onEnd(a2), this.ended = true, false;
          r2.next_out && (r2.avail_out !== 0 && a2 !== 1 && (r2.avail_in !== 0 || s2 !== 4 && s2 !== 2) || this.onData(Yn(r2.output, r2.next_out))), r2.avail_in === 0 && r2.avail_out === 0 && (o2 = true);
        } while ((r2.avail_in > 0 || r2.avail_out === 0) && a2 !== 1);
        return a2 === 1 && (s2 = 4), s2 === 4 ? (a2 = function(e3) {
          if (!e3 || !e3.state)
            return -2;
          const t3 = e3.state;
          return t3.window && (t3.window = null), e3.state = null, 0;
        }(this.strm), this.onEnd(a2), this.ended = true, a2 === 0) : s2 !== 2 || (this.onEnd(0), r2.avail_out = 0, true);
      }
      onData(e2) {
        this.chunks.push(e2);
      }
      onEnd(e2) {
        e2 === 0 && (this.result = ra(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }
    };
    var Ks = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    var Ds = function(e2) {
      this.stream = e2, this.bitOffset = 0, this.curByte = 0, this.hasByte = false;
    };
    Ds.prototype._ensureByte = function() {
      this.hasByte || (this.curByte = this.stream.readByte(), this.hasByte = true);
    }, Ds.prototype.read = function(e2) {
      for (var t2 = 0; e2 > 0; ) {
        this._ensureByte();
        var r2 = 8 - this.bitOffset;
        if (e2 >= r2)
          t2 <<= r2, t2 |= Ks[r2] & this.curByte, this.hasByte = false, this.bitOffset = 0, e2 -= r2;
        else {
          t2 <<= e2;
          var i2 = r2 - e2;
          t2 |= (this.curByte & Ks[e2] << i2) >> i2, this.bitOffset += e2, e2 = 0;
        }
      }
      return t2;
    }, Ds.prototype.seek = function(e2) {
      var t2 = e2 % 8, r2 = (e2 - t2) / 8;
      this.bitOffset = t2, this.stream.seek(r2), this.hasByte = false;
    }, Ds.prototype.pi = function() {
      var e2, t2 = new Uint8Array(6);
      for (e2 = 0; e2 < t2.length; e2++)
        t2[e2] = this.read(8);
      return function(e3) {
        return Array.prototype.map.call(e3, (e4) => ("00" + e4.toString(16)).slice(-2)).join("");
      }(t2);
    };
    var Rs = Ds;
    var Is = function() {
    };
    Is.prototype.readByte = function() {
      throw Error("abstract method readByte() not implemented");
    }, Is.prototype.read = function(e2, t2, r2) {
      for (var i2 = 0; i2 < r2; ) {
        var n2 = this.readByte();
        if (n2 < 0)
          return i2 === 0 ? -1 : i2;
        e2[t2++] = n2, i2++;
      }
      return i2;
    }, Is.prototype.seek = function(e2) {
      throw Error("abstract method seek() not implemented");
    }, Is.prototype.writeByte = function(e2) {
      throw Error("abstract method readByte() not implemented");
    }, Is.prototype.write = function(e2, t2, r2) {
      var i2;
      for (i2 = 0; i2 < r2; i2++)
        this.writeByte(e2[t2++]);
      return r2;
    }, Is.prototype.flush = function() {
    };
    var Us;
    var Bs = Is;
    var Ts = (Us = new Uint32Array([0, 79764919, 159529838, 222504665, 319059676, 398814059, 445009330, 507990021, 638119352, 583659535, 797628118, 726387553, 890018660, 835552979, 1015980042, 944750013, 1276238704, 1221641927, 1167319070, 1095957929, 1595256236, 1540665371, 1452775106, 1381403509, 1780037320, 1859660671, 1671105958, 1733955601, 2031960084, 2111593891, 1889500026, 1952343757, 2552477408, 2632100695, 2443283854, 2506133561, 2334638140, 2414271883, 2191915858, 2254759653, 3190512472, 3135915759, 3081330742, 3009969537, 2905550212, 2850959411, 2762807018, 2691435357, 3560074640, 3505614887, 3719321342, 3648080713, 3342211916, 3287746299, 3467911202, 3396681109, 4063920168, 4143685023, 4223187782, 4286162673, 3779000052, 3858754371, 3904687514, 3967668269, 881225847, 809987520, 1023691545, 969234094, 662832811, 591600412, 771767749, 717299826, 311336399, 374308984, 453813921, 533576470, 25881363, 88864420, 134795389, 214552010, 2023205639, 2086057648, 1897238633, 1976864222, 1804852699, 1867694188, 1645340341, 1724971778, 1587496639, 1516133128, 1461550545, 1406951526, 1302016099, 1230646740, 1142491917, 1087903418, 2896545431, 2825181984, 2770861561, 2716262478, 3215044683, 3143675388, 3055782693, 3001194130, 2326604591, 2389456536, 2200899649, 2280525302, 2578013683, 2640855108, 2418763421, 2498394922, 3769900519, 3832873040, 3912640137, 3992402750, 4088425275, 4151408268, 4197601365, 4277358050, 3334271071, 3263032808, 3476998961, 3422541446, 3585640067, 3514407732, 3694837229, 3640369242, 1762451694, 1842216281, 1619975040, 1682949687, 2047383090, 2127137669, 1938468188, 2001449195, 1325665622, 1271206113, 1183200824, 1111960463, 1543535498, 1489069629, 1434599652, 1363369299, 622672798, 568075817, 748617968, 677256519, 907627842, 853037301, 1067152940, 995781531, 51762726, 131386257, 177728840, 240578815, 269590778, 349224269, 429104020, 491947555, 4046411278, 4126034873, 4172115296, 4234965207, 3794477266, 3874110821, 3953728444, 4016571915, 3609705398, 3555108353, 3735388376, 3664026991, 3290680682, 3236090077, 3449943556, 3378572211, 3174993278, 3120533705, 3032266256, 2961025959, 2923101090, 2868635157, 2813903052, 2742672763, 2604032198, 2683796849, 2461293480, 2524268063, 2284983834, 2364738477, 2175806836, 2238787779, 1569362073, 1498123566, 1409854455, 1355396672, 1317987909, 1246755826, 1192025387, 1137557660, 2072149281, 2135122070, 1912620623, 1992383480, 1753615357, 1816598090, 1627664531, 1707420964, 295390185, 358241886, 404320391, 483945776, 43990325, 106832002, 186451547, 266083308, 932423249, 861060070, 1041341759, 986742920, 613929101, 542559546, 756411363, 701822548, 3316196985, 3244833742, 3425377559, 3370778784, 3601682597, 3530312978, 3744426955, 3689838204, 3819031489, 3881883254, 3928223919, 4007849240, 4037393693, 4100235434, 4180117107, 4259748804, 2310601993, 2373574846, 2151335527, 2231098320, 2596047829, 2659030626, 2470359227, 2550115596, 2947551409, 2876312838, 2788305887, 2733848168, 3165939309, 3094707162, 3040238851, 2985771188]), function() {
      var e2 = 4294967295;
      this.getCRC = function() {
        return ~e2 >>> 0;
      }, this.updateCRC = function(t2) {
        e2 = e2 << 8 ^ Us[255 & (e2 >>> 24 ^ t2)];
      }, this.updateCRCRun = function(t2, r2) {
        for (; r2-- > 0; )
          e2 = e2 << 8 ^ Us[255 & (e2 >>> 24 ^ t2)];
      };
    });
    var zs = function(e2, t2) {
      var r2, i2 = e2[t2];
      for (r2 = t2; r2 > 0; r2--)
        e2[r2] = e2[r2 - 1];
      return e2[0] = i2, i2;
    };
    var qs = { OK: 0, LAST_BLOCK: -1, NOT_BZIP_DATA: -2, UNEXPECTED_INPUT_EOF: -3, UNEXPECTED_OUTPUT_EOF: -4, DATA_ERROR: -5, OUT_OF_MEMORY: -6, OBSOLETE_INPUT: -7, END_OF_BLOCK: -8 };
    var Os = {};
    Os[qs.LAST_BLOCK] = "Bad file checksum", Os[qs.NOT_BZIP_DATA] = "Not bzip data", Os[qs.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF", Os[qs.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF", Os[qs.DATA_ERROR] = "Data error", Os[qs.OUT_OF_MEMORY] = "Out of memory", Os[qs.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
    var Fs = function(e2, t2) {
      var r2 = Os[e2] || "unknown error";
      t2 && (r2 += ": " + t2);
      var i2 = new TypeError(r2);
      throw i2.errorCode = e2, i2;
    };
    var Ns = function(e2, t2) {
      this.writePos = this.writeCurrent = this.writeCount = 0, this._start_bunzip(e2, t2);
    };
    Ns.prototype._init_block = function() {
      return this._get_next_block() ? (this.blockCRC = new Ts(), true) : (this.writeCount = -1, false);
    }, Ns.prototype._start_bunzip = function(e2, t2) {
      var r2 = new Uint8Array(4);
      e2.read(r2, 0, 4) === 4 && String.fromCharCode(r2[0], r2[1], r2[2]) === "BZh" || Fs(qs.NOT_BZIP_DATA, "bad magic");
      var i2 = r2[3] - 48;
      (i2 < 1 || i2 > 9) && Fs(qs.NOT_BZIP_DATA, "level out of range"), this.reader = new Rs(e2), this.dbufSize = 1e5 * i2, this.nextoutput = 0, this.outputStream = t2, this.streamCRC = 0;
    }, Ns.prototype._get_next_block = function() {
      var e2, t2, r2, i2 = this.reader, n2 = i2.pi();
      if (n2 === "177245385090")
        return false;
      n2 !== "314159265359" && Fs(qs.NOT_BZIP_DATA), this.targetBlockCRC = i2.read(32) >>> 0, this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0, i2.read(1) && Fs(qs.OBSOLETE_INPUT);
      var a2 = i2.read(24);
      a2 > this.dbufSize && Fs(qs.DATA_ERROR, "initial position out of bounds");
      var s2 = i2.read(16), o2 = new Uint8Array(256), c2 = 0;
      for (e2 = 0; e2 < 16; e2++)
        if (s2 & 1 << 15 - e2) {
          var u2 = 16 * e2;
          for (r2 = i2.read(16), t2 = 0; t2 < 16; t2++)
            r2 & 1 << 15 - t2 && (o2[c2++] = u2 + t2);
        }
      var h2 = i2.read(3);
      (h2 < 2 || h2 > 6) && Fs(qs.DATA_ERROR);
      var f2 = i2.read(15);
      f2 === 0 && Fs(qs.DATA_ERROR);
      var d2 = new Uint8Array(256);
      for (e2 = 0; e2 < h2; e2++)
        d2[e2] = e2;
      var l2 = new Uint8Array(f2);
      for (e2 = 0; e2 < f2; e2++) {
        for (t2 = 0; i2.read(1); t2++)
          t2 >= h2 && Fs(qs.DATA_ERROR);
        l2[e2] = zs(d2, t2);
      }
      var p2, y2 = c2 + 2, b2 = [];
      for (t2 = 0; t2 < h2; t2++) {
        var m2, g2, w2 = new Uint8Array(y2), v2 = new Uint16Array(21);
        for (s2 = i2.read(5), e2 = 0; e2 < y2; e2++) {
          for (; (s2 < 1 || s2 > 20) && Fs(qs.DATA_ERROR), i2.read(1); )
            i2.read(1) ? s2-- : s2++;
          w2[e2] = s2;
        }
        for (m2 = g2 = w2[0], e2 = 1; e2 < y2; e2++)
          w2[e2] > g2 ? g2 = w2[e2] : w2[e2] < m2 && (m2 = w2[e2]);
        p2 = {}, b2.push(p2), p2.permute = new Uint16Array(258), p2.limit = new Uint32Array(22), p2.base = new Uint32Array(21), p2.minLen = m2, p2.maxLen = g2;
        var _2 = 0;
        for (e2 = m2; e2 <= g2; e2++)
          for (v2[e2] = p2.limit[e2] = 0, s2 = 0; s2 < y2; s2++)
            w2[s2] === e2 && (p2.permute[_2++] = s2);
        for (e2 = 0; e2 < y2; e2++)
          v2[w2[e2]]++;
        for (_2 = s2 = 0, e2 = m2; e2 < g2; e2++)
          _2 += v2[e2], p2.limit[e2] = _2 - 1, _2 <<= 1, s2 += v2[e2], p2.base[e2 + 1] = _2 - s2;
        p2.limit[g2 + 1] = Number.MAX_VALUE, p2.limit[g2] = _2 + v2[g2] - 1, p2.base[m2] = 0;
      }
      var k2 = new Uint32Array(256);
      for (e2 = 0; e2 < 256; e2++)
        d2[e2] = e2;
      var A2, S2 = 0, E2 = 0, P2 = 0, x2 = this.dbuf = new Uint32Array(this.dbufSize);
      for (y2 = 0; ; ) {
        for (y2-- || (y2 = 49, P2 >= f2 && Fs(qs.DATA_ERROR), p2 = b2[l2[P2++]]), e2 = p2.minLen, t2 = i2.read(e2); e2 > p2.maxLen && Fs(qs.DATA_ERROR), !(t2 <= p2.limit[e2]); e2++)
          t2 = t2 << 1 | i2.read(1);
        ((t2 -= p2.base[e2]) < 0 || t2 >= 258) && Fs(qs.DATA_ERROR);
        var M2 = p2.permute[t2];
        if (M2 !== 0 && M2 !== 1) {
          if (S2)
            for (S2 = 0, E2 + s2 > this.dbufSize && Fs(qs.DATA_ERROR), k2[A2 = o2[d2[0]]] += s2; s2--; )
              x2[E2++] = A2;
          if (M2 > c2)
            break;
          E2 >= this.dbufSize && Fs(qs.DATA_ERROR), k2[A2 = o2[A2 = zs(d2, e2 = M2 - 1)]]++, x2[E2++] = A2;
        } else
          S2 || (S2 = 1, s2 = 0), s2 += M2 === 0 ? S2 : 2 * S2, S2 <<= 1;
      }
      for ((a2 < 0 || a2 >= E2) && Fs(qs.DATA_ERROR), t2 = 0, e2 = 0; e2 < 256; e2++)
        r2 = t2 + k2[e2], k2[e2] = t2, t2 = r2;
      for (e2 = 0; e2 < E2; e2++)
        x2[k2[A2 = 255 & x2[e2]]] |= e2 << 8, k2[A2]++;
      var C2 = 0, K2 = 0, D2 = 0;
      return E2 && (K2 = 255 & (C2 = x2[a2]), C2 >>= 8, D2 = -1), this.writePos = C2, this.writeCurrent = K2, this.writeCount = E2, this.writeRun = D2, true;
    }, Ns.prototype._read_bunzip = function(e2, t2) {
      var r2, i2, n2;
      if (this.writeCount < 0)
        return 0;
      var a2 = this.dbuf, s2 = this.writePos, o2 = this.writeCurrent, c2 = this.writeCount;
      this.outputsize;
      for (var u2 = this.writeRun; c2; ) {
        for (c2--, i2 = o2, o2 = 255 & (s2 = a2[s2]), s2 >>= 8, u2++ == 3 ? (r2 = o2, n2 = i2, o2 = -1) : (r2 = 1, n2 = o2), this.blockCRC.updateCRCRun(n2, r2); r2--; )
          this.outputStream.writeByte(n2), this.nextoutput++;
        o2 != i2 && (u2 = 0);
      }
      return this.writeCount = c2, this.blockCRC.getCRC() !== this.targetBlockCRC && Fs(qs.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")"), this.nextoutput;
    };
    var js = function(e2) {
      if ("readByte" in e2)
        return e2;
      var t2 = new Bs();
      return t2.pos = 0, t2.readByte = function() {
        return e2[this.pos++];
      }, t2.seek = function(e3) {
        this.pos = e3;
      }, t2.eof = function() {
        return this.pos >= e2.length;
      }, t2;
    };
    var Ls = function(e2) {
      var t2 = new Bs(), r2 = true;
      if (e2)
        if (typeof e2 == "number")
          t2.buffer = new Uint8Array(e2), r2 = false;
        else {
          if ("writeByte" in e2)
            return e2;
          t2.buffer = e2, r2 = false;
        }
      else
        t2.buffer = new Uint8Array(16384);
      return t2.pos = 0, t2.writeByte = function(e3) {
        if (r2 && this.pos >= this.buffer.length) {
          var t3 = new Uint8Array(2 * this.buffer.length);
          t3.set(this.buffer), this.buffer = t3;
        }
        this.buffer[this.pos++] = e3;
      }, t2.getBuffer = function() {
        if (this.pos !== this.buffer.length) {
          if (!r2)
            throw new TypeError("outputsize does not match decoded input");
          var e3 = new Uint8Array(this.pos);
          e3.set(this.buffer.subarray(0, this.pos)), this.buffer = e3;
        }
        return this.buffer;
      }, t2._coerced = true, t2;
    };
    var Ws = function(e2, t2, r2) {
      for (var i2 = js(e2), n2 = Ls(t2), a2 = new Ns(i2, n2); !("eof" in i2) || !i2.eof(); )
        if (a2._init_block())
          a2._read_bunzip();
        else {
          var s2 = a2.reader.read(32) >>> 0;
          if (s2 !== a2.streamCRC && Fs(qs.DATA_ERROR, "Bad stream CRC (got " + a2.streamCRC.toString(16) + " expected " + s2.toString(16) + ")"), !r2 || !("eof" in i2) || i2.eof())
            break;
          a2._start_bunzip(i2, n2);
        }
      if ("getBuffer" in n2)
        return n2.getBuffer();
    };
    var Hs = class {
      static get tag() {
        return me.packet.literalData;
      }
      constructor(e2 = new Date()) {
        this.format = me.literal.utf8, this.date = ce.normalizeDate(e2), this.text = null, this.data = null, this.filename = "";
      }
      setText(e2, t2 = me.literal.utf8) {
        this.format = t2, this.text = e2, this.data = null;
      }
      getText(e2 = false) {
        return (this.text === null || ce.isStream(this.text)) && (this.text = ce.decodeUTF8(ce.nativeEOL(this.getBytes(e2)))), this.text;
      }
      setBytes(e2, t2) {
        this.format = t2, this.data = e2, this.text = null;
      }
      getBytes(e2 = false) {
        return this.data === null && (this.data = ce.canonicalizeEOL(ce.encodeUTF8(this.text))), e2 ? ee(this.data) : this.data;
      }
      setFilename(e2) {
        this.filename = e2;
      }
      getFilename() {
        return this.filename;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte(), r2 = await e3.readByte();
          this.filename = ce.decodeUTF8(await e3.readBytes(r2)), this.date = ce.readDate(await e3.readBytes(4));
          let i2 = e3.remainder();
          _(i2) && (i2 = await ie(i2)), this.setBytes(i2, t2);
        });
      }
      writeHeader() {
        const e2 = ce.encodeUTF8(this.filename), t2 = new Uint8Array([e2.length]), r2 = new Uint8Array([this.format]), i2 = ce.writeDate(this.date);
        return ce.concatUint8Array([r2, t2, e2, i2]);
      }
      write() {
        const e2 = this.writeHeader(), t2 = this.getBytes();
        return ce.concat([e2, t2]);
      }
    };
    function Gs(e2) {
      let t2, r2 = 0;
      const i2 = e2[0];
      return i2 < 192 ? ([r2] = e2, t2 = 1) : i2 < 255 ? (r2 = (e2[0] - 192 << 8) + e2[1] + 192, t2 = 2) : i2 === 255 && (r2 = ce.readNumber(e2.subarray(1, 5)), t2 = 5), { len: r2, offset: t2 };
    }
    function Vs(e2) {
      return e2 < 192 ? new Uint8Array([e2]) : e2 > 191 && e2 < 8384 ? new Uint8Array([192 + (e2 - 192 >> 8), e2 - 192 & 255]) : ce.concatUint8Array([new Uint8Array([255]), ce.writeNumber(e2, 4)]);
    }
    function $s(e2) {
      if (e2 < 0 || e2 > 30)
        throw Error("Partial Length power must be between 1 and 30");
      return new Uint8Array([224 + e2]);
    }
    function Zs(e2) {
      return new Uint8Array([192 | e2]);
    }
    function Ys(e2, t2) {
      return ce.concatUint8Array([Zs(e2), Vs(t2)]);
    }
    function Xs(e2) {
      return [me.packet.literalData, me.packet.compressedData, me.packet.symmetricallyEncryptedData, me.packet.symEncryptedIntegrityProtectedData, me.packet.aeadEncryptedData].includes(e2);
    }
    async function Qs(e2, t2) {
      const r2 = H(e2);
      let i2, n2;
      try {
        const a2 = await r2.peekBytes(2);
        if (!a2 || a2.length < 2 || (128 & a2[0]) == 0)
          throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");
        const s2 = await r2.readByte();
        let o2, c2, u2 = -1, h2 = -1;
        h2 = 0, (64 & s2) != 0 && (h2 = 1), h2 ? u2 = 63 & s2 : (u2 = (63 & s2) >> 2, c2 = 3 & s2);
        const f2 = Xs(u2);
        let d2, l2 = null;
        if (f2) {
          if (ce.isStream(e2) === "array") {
            const e3 = new v();
            i2 = G(e3), l2 = e3;
          } else {
            const e3 = new O();
            i2 = G(e3.writable), l2 = e3.readable;
          }
          n2 = t2({ tag: u2, packet: l2 });
        } else
          l2 = [];
        do {
          if (h2) {
            const e3 = await r2.readByte();
            if (d2 = false, e3 < 192)
              o2 = e3;
            else if (e3 >= 192 && e3 < 224)
              o2 = (e3 - 192 << 8) + await r2.readByte() + 192;
            else if (e3 > 223 && e3 < 255) {
              if (o2 = 1 << (31 & e3), d2 = true, !f2)
                throw new TypeError("This packet type does not support partial lengths.");
            } else
              o2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
          } else
            switch (c2) {
              case 0:
                o2 = await r2.readByte();
                break;
              case 1:
                o2 = await r2.readByte() << 8 | await r2.readByte();
                break;
              case 2:
                o2 = await r2.readByte() << 24 | await r2.readByte() << 16 | await r2.readByte() << 8 | await r2.readByte();
                break;
              default:
                o2 = 1 / 0;
            }
          if (o2 > 0) {
            let e3 = 0;
            for (; ; ) {
              i2 && await i2.ready;
              const { done: t3, value: n3 } = await r2.read();
              if (t3) {
                if (o2 === 1 / 0)
                  break;
                throw Error("Unexpected end of packet");
              }
              const a3 = o2 === 1 / 0 ? n3 : n3.subarray(0, o2 - e3);
              if (i2 ? await i2.write(a3) : l2.push(a3), e3 += n3.length, e3 >= o2) {
                r2.unshift(n3.subarray(o2 - e3 + n3.length));
                break;
              }
            }
          }
        } while (d2);
        const p2 = await r2.peekBytes(f2 ? 1 / 0 : 2);
        return i2 ? (await i2.ready, await i2.close()) : (l2 = ce.concatUint8Array(l2), await t2({ tag: u2, packet: l2 })), !p2 || !p2.length;
      } catch (e3) {
        if (i2)
          return await i2.abort(e3), true;
        throw e3;
      } finally {
        i2 && await n2, r2.releaseLock();
      }
    }
    var Js = class extends Error {
      constructor(...e2) {
        super(...e2), Error.captureStackTrace && Error.captureStackTrace(this, Js), this.name = "UnsupportedError";
      }
    };
    var eo = Symbol("verified");
    var to = /* @__PURE__ */ new Set([me.signatureSubpacket.issuer, me.signatureSubpacket.issuerFingerprint, me.signatureSubpacket.embeddedSignature]);
    var ro = class {
      static get tag() {
        return me.packet.signature;
      }
      constructor() {
        this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.signatureData = null, this.unhashedSubpackets = [], this.signedHashValue = null, this.created = null, this.signatureExpirationTime = null, this.signatureNeverExpires = true, this.exportable = null, this.trustLevel = null, this.trustAmount = null, this.regularExpression = null, this.revocable = null, this.keyExpirationTime = null, this.keyNeverExpires = null, this.preferredSymmetricAlgorithms = null, this.revocationKeyClass = null, this.revocationKeyAlgorithm = null, this.revocationKeyFingerprint = null, this.issuerKeyID = new Me(), this.rawNotations = [], this.notations = {}, this.preferredHashAlgorithms = null, this.preferredCompressionAlgorithms = null, this.keyServerPreferences = null, this.preferredKeyServer = null, this.isPrimaryUserID = null, this.policyURI = null, this.keyFlags = null, this.signersUserID = null, this.reasonForRevocationFlag = null, this.reasonForRevocationString = null, this.features = null, this.signatureTargetPublicKeyAlgorithm = null, this.signatureTargetHashAlgorithm = null, this.signatureTargetHash = null, this.embeddedSignature = null, this.issuerKeyVersion = null, this.issuerFingerprint = null, this.preferredAEADAlgorithms = null, this.revoked = null, this[eo] = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], this.version !== 4 && this.version !== 5)
          throw new Js(`Version ${this.version} of the signature packet is unsupported.`);
        if (this.signatureType = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.hashAlgorithm = e2[t2++], t2 += this.readSubPackets(e2.subarray(t2, e2.length), true), !this.created)
          throw Error("Missing signature creation time subpacket.");
        this.signatureData = e2.subarray(0, t2), t2 += this.readSubPackets(e2.subarray(t2, e2.length), false), this.signedHashValue = e2.subarray(t2, t2 + 2), t2 += 2, this.params = $n.signature.parseSignatureParams(this.publicKeyAlgorithm, e2.subarray(t2, e2.length));
      }
      writeParams() {
        return this.params instanceof Promise ? ae(async () => $n.serializeParams(this.publicKeyAlgorithm, await this.params)) : $n.serializeParams(this.publicKeyAlgorithm, this.params);
      }
      write() {
        const e2 = [];
        return e2.push(this.signatureData), e2.push(this.writeUnhashedSubPackets()), e2.push(this.signedHashValue), e2.push(this.writeParams()), ce.concat(e2);
      }
      async sign(e2, t2, r2 = new Date(), i2 = false) {
        e2.version === 5 ? this.version = 5 : this.version = 4;
        const n2 = [new Uint8Array([this.version, this.signatureType, this.publicKeyAlgorithm, this.hashAlgorithm])];
        this.created = ce.normalizeDate(r2), this.issuerKeyVersion = e2.version, this.issuerFingerprint = e2.getFingerprintBytes(), this.issuerKeyID = e2.getKeyID(), n2.push(this.writeHashedSubPackets()), this.signatureData = ce.concat(n2);
        const a2 = this.toHash(this.signatureType, t2, i2), s2 = await this.hash(this.signatureType, t2, a2, i2);
        this.signedHashValue = re(J(s2), 0, 2);
        const o2 = async () => $n.signature.sign(this.publicKeyAlgorithm, this.hashAlgorithm, e2.publicParams, e2.privateParams, a2, await ie(s2));
        ce.isStream(s2) ? this.params = o2() : (this.params = await o2(), this[eo] = true);
      }
      writeHashedSubPackets() {
        const e2 = me.signatureSubpacket, t2 = [];
        let r2;
        if (this.created === null)
          throw Error("Missing signature creation time");
        t2.push(io(e2.signatureCreationTime, ce.writeDate(this.created))), this.signatureExpirationTime !== null && t2.push(io(e2.signatureExpirationTime, ce.writeNumber(this.signatureExpirationTime, 4))), this.exportable !== null && t2.push(io(e2.exportableCertification, new Uint8Array([this.exportable ? 1 : 0]))), this.trustLevel !== null && (r2 = new Uint8Array([this.trustLevel, this.trustAmount]), t2.push(io(e2.trustSignature, r2))), this.regularExpression !== null && t2.push(io(e2.regularExpression, this.regularExpression)), this.revocable !== null && t2.push(io(e2.revocable, new Uint8Array([this.revocable ? 1 : 0]))), this.keyExpirationTime !== null && t2.push(io(e2.keyExpirationTime, ce.writeNumber(this.keyExpirationTime, 4))), this.preferredSymmetricAlgorithms !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.preferredSymmetricAlgorithms)), t2.push(io(e2.preferredSymmetricAlgorithms, r2))), this.revocationKeyClass !== null && (r2 = new Uint8Array([this.revocationKeyClass, this.revocationKeyAlgorithm]), r2 = ce.concat([r2, this.revocationKeyFingerprint]), t2.push(io(e2.revocationKey, r2))), this.rawNotations.forEach(([{ name: i3, value: n3, humanReadable: a2 }]) => {
          r2 = [new Uint8Array([a2 ? 128 : 0, 0, 0, 0])], r2.push(ce.writeNumber(i3.length, 2)), r2.push(ce.writeNumber(n3.length, 2)), r2.push(ce.stringToUint8Array(i3)), r2.push(n3), r2 = ce.concat(r2), t2.push(io(e2.notationData, r2));
        }), this.preferredHashAlgorithms !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.preferredHashAlgorithms)), t2.push(io(e2.preferredHashAlgorithms, r2))), this.preferredCompressionAlgorithms !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.preferredCompressionAlgorithms)), t2.push(io(e2.preferredCompressionAlgorithms, r2))), this.keyServerPreferences !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.keyServerPreferences)), t2.push(io(e2.keyServerPreferences, r2))), this.preferredKeyServer !== null && t2.push(io(e2.preferredKeyServer, ce.stringToUint8Array(this.preferredKeyServer))), this.isPrimaryUserID !== null && t2.push(io(e2.primaryUserID, new Uint8Array([this.isPrimaryUserID ? 1 : 0]))), this.policyURI !== null && t2.push(io(e2.policyURI, ce.stringToUint8Array(this.policyURI))), this.keyFlags !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.keyFlags)), t2.push(io(e2.keyFlags, r2))), this.signersUserID !== null && t2.push(io(e2.signersUserID, ce.stringToUint8Array(this.signersUserID))), this.reasonForRevocationFlag !== null && (r2 = ce.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag) + this.reasonForRevocationString), t2.push(io(e2.reasonForRevocation, r2))), this.features !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.features)), t2.push(io(e2.features, r2))), this.signatureTargetPublicKeyAlgorithm !== null && (r2 = [new Uint8Array([this.signatureTargetPublicKeyAlgorithm, this.signatureTargetHashAlgorithm])], r2.push(ce.stringToUint8Array(this.signatureTargetHash)), r2 = ce.concat(r2), t2.push(io(e2.signatureTarget, r2))), this.preferredAEADAlgorithms !== null && (r2 = ce.stringToUint8Array(ce.uint8ArrayToString(this.preferredAEADAlgorithms)), t2.push(io(e2.preferredAEADAlgorithms, r2)));
        const i2 = ce.concat(t2), n2 = ce.writeNumber(i2.length, 2);
        return ce.concat([n2, i2]);
      }
      writeUnhashedSubPackets() {
        const e2 = me.signatureSubpacket, t2 = [];
        let r2;
        this.issuerKeyID.isNull() || this.issuerKeyVersion === 5 || t2.push(io(e2.issuer, this.issuerKeyID.write())), this.embeddedSignature !== null && t2.push(io(e2.embeddedSignature, this.embeddedSignature.write())), this.issuerFingerprint !== null && (r2 = [new Uint8Array([this.issuerKeyVersion]), this.issuerFingerprint], r2 = ce.concat(r2), t2.push(io(e2.issuerFingerprint, r2))), this.unhashedSubpackets.forEach((e3) => {
          t2.push(Vs(e3.length)), t2.push(e3);
        });
        const i2 = ce.concat(t2), n2 = ce.writeNumber(i2.length, 2);
        return ce.concat([n2, i2]);
      }
      readSubPacket(e2, t2 = true) {
        let r2 = 0;
        const i2 = 128 & e2[r2], n2 = 127 & e2[r2];
        if (t2 || to.has(n2))
          switch (r2++, n2) {
            case me.signatureSubpacket.signatureCreationTime:
              this.created = ce.readDate(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.signatureExpirationTime: {
              const t3 = ce.readNumber(e2.subarray(r2, e2.length));
              this.signatureNeverExpires = t3 === 0, this.signatureExpirationTime = t3;
              break;
            }
            case me.signatureSubpacket.exportableCertification:
              this.exportable = e2[r2++] === 1;
              break;
            case me.signatureSubpacket.trustSignature:
              this.trustLevel = e2[r2++], this.trustAmount = e2[r2++];
              break;
            case me.signatureSubpacket.regularExpression:
              this.regularExpression = e2[r2];
              break;
            case me.signatureSubpacket.revocable:
              this.revocable = e2[r2++] === 1;
              break;
            case me.signatureSubpacket.keyExpirationTime: {
              const t3 = ce.readNumber(e2.subarray(r2, e2.length));
              this.keyExpirationTime = t3, this.keyNeverExpires = t3 === 0;
              break;
            }
            case me.signatureSubpacket.preferredSymmetricAlgorithms:
              this.preferredSymmetricAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.revocationKey:
              this.revocationKeyClass = e2[r2++], this.revocationKeyAlgorithm = e2[r2++], this.revocationKeyFingerprint = e2.subarray(r2, r2 + 20);
              break;
            case me.signatureSubpacket.issuer:
              this.issuerKeyID.read(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.notationData: {
              const t3 = !!(128 & e2[r2]);
              r2 += 4;
              const n3 = ce.readNumber(e2.subarray(r2, r2 + 2));
              r2 += 2;
              const a2 = ce.readNumber(e2.subarray(r2, r2 + 2));
              r2 += 2;
              const s2 = ce.uint8ArrayToString(e2.subarray(r2, r2 + n3)), o2 = e2.subarray(r2 + n3, r2 + n3 + a2);
              this.rawNotations.push({ name: s2, humanReadable: t3, value: o2, critical: i2 }), t3 && (this.notations[s2] = ce.uint8ArrayToString(o2));
              break;
            }
            case me.signatureSubpacket.preferredHashAlgorithms:
              this.preferredHashAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.preferredCompressionAlgorithms:
              this.preferredCompressionAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.keyServerPreferences:
              this.keyServerPreferences = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.preferredKeyServer:
              this.preferredKeyServer = ce.uint8ArrayToString(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.primaryUserID:
              this.isPrimaryUserID = e2[r2++] !== 0;
              break;
            case me.signatureSubpacket.policyURI:
              this.policyURI = ce.uint8ArrayToString(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.keyFlags:
              this.keyFlags = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.signersUserID:
              this.signersUserID = ce.uint8ArrayToString(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.reasonForRevocation:
              this.reasonForRevocationFlag = e2[r2++], this.reasonForRevocationString = ce.uint8ArrayToString(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.features:
              this.features = [...e2.subarray(r2, e2.length)];
              break;
            case me.signatureSubpacket.signatureTarget: {
              this.signatureTargetPublicKeyAlgorithm = e2[r2++], this.signatureTargetHashAlgorithm = e2[r2++];
              const t3 = $n.getHashByteLength(this.signatureTargetHashAlgorithm);
              this.signatureTargetHash = ce.uint8ArrayToString(e2.subarray(r2, r2 + t3));
              break;
            }
            case me.signatureSubpacket.embeddedSignature:
              this.embeddedSignature = new ro(), this.embeddedSignature.read(e2.subarray(r2, e2.length));
              break;
            case me.signatureSubpacket.issuerFingerprint:
              this.issuerKeyVersion = e2[r2++], this.issuerFingerprint = e2.subarray(r2, e2.length), this.issuerKeyVersion === 5 ? this.issuerKeyID.read(this.issuerFingerprint) : this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));
              break;
            case me.signatureSubpacket.preferredAEADAlgorithms:
              this.preferredAEADAlgorithms = [...e2.subarray(r2, e2.length)];
              break;
            default: {
              const e3 = Error("Unknown signature subpacket type " + n2);
              if (i2)
                throw e3;
              ce.printDebug(e3);
            }
          }
        else
          this.unhashedSubpackets.push(e2.subarray(r2, e2.length));
      }
      readSubPackets(e2, t2 = true, r2) {
        const i2 = ce.readNumber(e2.subarray(0, 2));
        let n2 = 2;
        for (; n2 < 2 + i2; ) {
          const i3 = Gs(e2.subarray(n2, e2.length));
          n2 += i3.offset, this.readSubPacket(e2.subarray(n2, n2 + i3.len), t2, r2), n2 += i3.len;
        }
        return n2;
      }
      toSign(e2, t2) {
        const r2 = me.signature;
        switch (e2) {
          case r2.binary:
            return t2.text !== null ? ce.encodeUTF8(t2.getText(true)) : t2.getBytes(true);
          case r2.text: {
            const e3 = t2.getBytes(true);
            return ce.canonicalizeEOL(e3);
          }
          case r2.standalone:
            return new Uint8Array(0);
          case r2.certGeneric:
          case r2.certPersona:
          case r2.certCasual:
          case r2.certPositive:
          case r2.certRevocation: {
            let e3, i2;
            if (t2.userID)
              i2 = 180, e3 = t2.userID;
            else {
              if (!t2.userAttribute)
                throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");
              i2 = 209, e3 = t2.userAttribute;
            }
            const n2 = e3.write();
            return ce.concat([this.toSign(r2.key, t2), new Uint8Array([i2]), ce.writeNumber(n2.length, 4), n2]);
          }
          case r2.subkeyBinding:
          case r2.subkeyRevocation:
          case r2.keyBinding:
            return ce.concat([this.toSign(r2.key, t2), this.toSign(r2.key, { key: t2.bind })]);
          case r2.key:
            if (t2.key === void 0)
              throw Error("Key packet is required for this signature.");
            return t2.key.writeForHash(this.version);
          case r2.keyRevocation:
            return this.toSign(r2.key, t2);
          case r2.timestamp:
            return new Uint8Array(0);
          case r2.thirdParty:
            throw Error("Not implemented");
          default:
            throw Error("Unknown signature type.");
        }
      }
      calculateTrailer(e2, t2) {
        let r2 = 0;
        return Y(J(this.signatureData), (e3) => {
          r2 += e3.length;
        }, () => {
          const i2 = [];
          return this.version !== 5 || this.signatureType !== me.signature.binary && this.signatureType !== me.signature.text || (t2 ? i2.push(new Uint8Array(6)) : i2.push(e2.writeHeader())), i2.push(new Uint8Array([this.version, 255])), this.version === 5 && i2.push(new Uint8Array(4)), i2.push(ce.writeNumber(r2, 4)), ce.concat(i2);
        });
      }
      toHash(e2, t2, r2 = false) {
        const i2 = this.toSign(e2, t2);
        return ce.concat([i2, this.signatureData, this.calculateTrailer(t2, r2)]);
      }
      async hash(e2, t2, r2, i2 = false) {
        return r2 || (r2 = this.toHash(e2, t2, i2)), $n.hash.digest(this.hashAlgorithm, r2);
      }
      async verify(e2, t2, r2, i2 = new Date(), n2 = false, a2 = ge) {
        if (!this.issuerKeyID.equals(e2.getKeyID()))
          throw Error("Signature was not issued by the given public key");
        if (this.publicKeyAlgorithm !== e2.algorithm)
          throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");
        const s2 = t2 === me.signature.binary || t2 === me.signature.text;
        if (!(this[eo] && !s2)) {
          let i3, a3;
          if (this.hashed ? a3 = await this.hashed : (i3 = this.toHash(t2, r2, n2), a3 = await this.hash(t2, r2, i3)), a3 = await ie(a3), this.signedHashValue[0] !== a3[0] || this.signedHashValue[1] !== a3[1])
            throw Error("Signed digest did not match");
          if (this.params = await this.params, this[eo] = await $n.signature.verify(this.publicKeyAlgorithm, this.hashAlgorithm, this.params, e2.publicParams, i3, a3), !this[eo])
            throw Error("Signature verification failed");
        }
        const o2 = ce.normalizeDate(i2);
        if (o2 && this.created > o2)
          throw Error("Signature creation time is in the future");
        if (o2 && o2 >= this.getExpirationTime())
          throw Error("Signature is expired");
        if (a2.rejectHashAlgorithms.has(this.hashAlgorithm))
          throw Error("Insecure hash algorithm: " + me.read(me.hash, this.hashAlgorithm).toUpperCase());
        if (a2.rejectMessageHashAlgorithms.has(this.hashAlgorithm) && [me.signature.binary, me.signature.text].includes(this.signatureType))
          throw Error("Insecure message hash algorithm: " + me.read(me.hash, this.hashAlgorithm).toUpperCase());
        if (this.rawNotations.forEach(({ name: e3, critical: t3 }) => {
          if (t3 && a2.knownNotations.indexOf(e3) < 0)
            throw Error("Unknown critical notation: " + e3);
        }), this.revocationKeyClass !== null)
          throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.");
      }
      isExpired(e2 = new Date()) {
        const t2 = ce.normalizeDate(e2);
        return t2 !== null && !(this.created <= t2 && t2 < this.getExpirationTime());
      }
      getExpirationTime() {
        return this.signatureNeverExpires ? 1 / 0 : new Date(this.created.getTime() + 1e3 * this.signatureExpirationTime);
      }
    };
    function io(e2, t2) {
      const r2 = [];
      return r2.push(Vs(t2.length + 1)), r2.push(new Uint8Array([e2])), r2.push(t2), ce.concat(r2);
    }
    var no = class {
      static get tag() {
        return me.packet.onePassSignature;
      }
      constructor() {
        this.version = null, this.signatureType = null, this.hashAlgorithm = null, this.publicKeyAlgorithm = null, this.issuerKeyID = null, this.flags = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], this.version !== 3)
          throw new Js(`Version ${this.version} of the one-pass signature packet is unsupported.`);
        return this.signatureType = e2[t2++], this.hashAlgorithm = e2[t2++], this.publicKeyAlgorithm = e2[t2++], this.issuerKeyID = new Me(), this.issuerKeyID.read(e2.subarray(t2, t2 + 8)), t2 += 8, this.flags = e2[t2++], this;
      }
      write() {
        const e2 = new Uint8Array([3, this.signatureType, this.hashAlgorithm, this.publicKeyAlgorithm]), t2 = new Uint8Array([this.flags]);
        return ce.concatUint8Array([e2, this.issuerKeyID.write(), t2]);
      }
      calculateTrailer(...e2) {
        return ae(async () => ro.prototype.calculateTrailer.apply(await this.correspondingSig, e2));
      }
      async verify() {
        const e2 = await this.correspondingSig;
        if (!e2 || e2.constructor.tag !== me.packet.signature)
          throw Error("Corresponding signature packet missing");
        if (e2.signatureType !== this.signatureType || e2.hashAlgorithm !== this.hashAlgorithm || e2.publicKeyAlgorithm !== this.publicKeyAlgorithm || !e2.issuerKeyID.equals(this.issuerKeyID))
          throw Error("Corresponding signature packet does not match one-pass signature packet");
        return e2.hashed = this.hashed, e2.verify.apply(e2, arguments);
      }
    };
    function ao(e2, t2) {
      if (!t2[e2]) {
        let t3;
        try {
          t3 = me.read(me.packet, e2);
        } catch (t4) {
          throw new Js("Unknown packet type with tag: " + e2);
        }
        throw Error("Packet not allowed in this context: " + t3);
      }
      return new t2[e2]();
    }
    no.prototype.hash = ro.prototype.hash, no.prototype.toHash = ro.prototype.toHash, no.prototype.toSign = ro.prototype.toSign;
    var so = class extends Array {
      static async fromBinary(e2, t2, r2 = ge) {
        const i2 = new so();
        return await i2.read(e2, t2, r2), i2;
      }
      async read(e2, t2, r2 = ge) {
        this.stream = X(e2, async (e3, i3) => {
          const n2 = G(i3);
          try {
            for (; ; ) {
              await n2.ready;
              if (await Qs(e3, async (e4) => {
                try {
                  if (e4.tag === me.packet.marker || e4.tag === me.packet.trust)
                    return;
                  const i4 = ao(e4.tag, t2);
                  i4.packets = new so(), i4.fromStream = ce.isStream(e4.packet), await i4.read(e4.packet, r2), await n2.write(i4);
                } catch (t3) {
                  const i4 = !r2.ignoreUnsupportedPackets && t3 instanceof Js, a2 = !(r2.ignoreMalformedPackets || t3 instanceof Js);
                  (i4 || a2 || Xs(e4.tag)) && await n2.abort(t3), ce.printDebugError(t3);
                }
              }))
                return await n2.ready, void await n2.close();
            }
          } catch (e4) {
            await n2.abort(e4);
          }
        });
        const i2 = H(this.stream);
        for (; ; ) {
          const { done: e3, value: t3 } = await i2.read();
          if (e3 ? this.stream = null : this.push(t3), e3 || Xs(t3.constructor.tag))
            break;
        }
        i2.releaseLock();
      }
      write() {
        const e2 = [];
        for (let t2 = 0; t2 < this.length; t2++) {
          const r2 = this[t2].write();
          if (ce.isStream(r2) && Xs(this[t2].constructor.tag)) {
            let i2 = [], n2 = 0;
            const a2 = 512;
            e2.push(Zs(this[t2].constructor.tag)), e2.push(Y(r2, (e3) => {
              if (i2.push(e3), n2 += e3.length, n2 >= a2) {
                const e4 = Math.min(Math.log(n2) / Math.LN2 | 0, 30), t3 = 2 ** e4, r3 = ce.concat([$s(e4)].concat(i2));
                return i2 = [r3.subarray(1 + t3)], n2 = i2[0].length, r3.subarray(0, 1 + t3);
              }
            }, () => ce.concat([Vs(n2)].concat(i2))));
          } else {
            if (ce.isStream(r2)) {
              let i2 = 0;
              e2.push(Y(J(r2), (e3) => {
                i2 += e3.length;
              }, () => Ys(this[t2].constructor.tag, i2)));
            } else
              e2.push(Ys(this[t2].constructor.tag, r2.length));
            e2.push(r2);
          }
        }
        return ce.concat(e2);
      }
      filterByTag(...e2) {
        const t2 = new so(), r2 = (e3) => (t3) => e3 === t3;
        for (let i2 = 0; i2 < this.length; i2++)
          e2.some(r2(this[i2].constructor.tag)) && t2.push(this[i2]);
        return t2;
      }
      findPacket(e2) {
        return this.find((t2) => t2.constructor.tag === e2);
      }
      indexOfTag(...e2) {
        const t2 = [], r2 = this, i2 = (e3) => (t3) => e3 === t3;
        for (let n2 = 0; n2 < this.length; n2++)
          e2.some(i2(r2[n2].constructor.tag)) && t2.push(n2);
        return t2;
      }
    };
    var oo = /* @__PURE__ */ ce.constructAllowedPackets([Hs, no, ro]);
    var co = class {
      static get tag() {
        return me.packet.compressedData;
      }
      constructor(e2 = ge) {
        this.packets = null, this.algorithm = e2.preferredCompressionAlgorithm, this.compressed = null, this.deflateLevel = e2.deflateLevel;
      }
      async read(e2, t2 = ge) {
        await Q(e2, async (e3) => {
          this.algorithm = await e3.readByte(), this.compressed = e3.remainder(), await this.decompress(t2);
        });
      }
      write() {
        return this.compressed === null && this.compress(), ce.concat([new Uint8Array([this.algorithm]), this.compressed]);
      }
      async decompress(e2 = ge) {
        const t2 = me.read(me.compression, this.algorithm), r2 = bo[t2];
        if (!r2)
          throw Error(t2 + " decompression not supported");
        this.packets = await so.fromBinary(r2(this.compressed), oo, e2);
      }
      compress() {
        const e2 = me.read(me.compression, this.algorithm), t2 = yo[e2];
        if (!t2)
          throw Error(e2 + " compression not supported");
        this.compressed = t2(this.packets.write(), this.deflateLevel);
      }
    };
    var uo = ce.getNodeZlib();
    function ho(e2) {
      return e2;
    }
    function fo(e2, t2, r2 = {}) {
      return function(i2) {
        return !ce.isStream(i2) || _(i2) ? ae(() => ie(i2).then((t3) => new Promise((i3, n2) => {
          e2(t3, r2, (e3, t4) => {
            if (e3)
              return n2(e3);
            i3(t4);
          });
        }))) : K(D(i2).pipe(t2(r2)));
      };
    }
    function lo(e2, t2 = {}) {
      return function(r2) {
        const i2 = new e2(t2);
        return Y(r2, (e3) => {
          if (e3.length)
            return i2.push(e3, 2), i2.result;
        }, () => {
          if (e2 === hs)
            return i2.push([], 4), i2.result;
        });
      };
    }
    function po(e2) {
      return function(t2) {
        return ae(async () => e2(await ie(t2)));
      };
    }
    var yo = uo ? { zip: (e2, t2) => fo(uo.deflateRaw, uo.createDeflateRaw, { level: t2 })(e2), zlib: (e2, t2) => fo(uo.deflate, uo.createDeflate, { level: t2 })(e2) } : { zip: (e2, t2) => lo(hs, { raw: true, level: t2 })(e2), zlib: (e2, t2) => lo(hs, { level: t2 })(e2) };
    var bo = uo ? { uncompressed: ho, zip: /* @__PURE__ */ fo(uo.inflateRaw, uo.createInflateRaw), zlib: /* @__PURE__ */ fo(uo.inflate, uo.createInflate), bzip2: /* @__PURE__ */ po(Ws) } : { uncompressed: ho, zip: /* @__PURE__ */ lo(Cs, { raw: true }), zlib: /* @__PURE__ */ lo(Cs), bzip2: /* @__PURE__ */ po(Ws) };
    var mo = /* @__PURE__ */ ce.constructAllowedPackets([Hs, co, no, ro]);
    var go = class {
      static get tag() {
        return me.packet.symEncryptedIntegrityProtectedData;
      }
      constructor() {
        this.version = 1, this.encrypted = null, this.packets = null;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte();
          if (t2 !== 1)
            throw new Js(`Version ${t2} of the SEIP packet is unsupported.`);
          this.encrypted = e3.remainder();
        });
      }
      write() {
        return ce.concat([new Uint8Array([1]), this.encrypted]);
      }
      async encrypt(e2, t2, r2 = ge) {
        const { blockSize: i2 } = $n.getCipher(e2);
        let n2 = this.packets.write();
        _(n2) && (n2 = await ie(n2));
        const a2 = await $n.getPrefixRandom(e2), s2 = new Uint8Array([211, 20]), o2 = ce.concat([a2, n2, s2]), c2 = await $n.hash.sha1(ee(o2)), u2 = ce.concat([o2, c2]);
        return this.encrypted = await $n.mode.cfb.encrypt(e2, t2, u2, new Uint8Array(i2), r2), true;
      }
      async decrypt(e2, t2, r2 = ge) {
        const { blockSize: i2 } = $n.getCipher(e2);
        let n2 = J(this.encrypted);
        _(n2) && (n2 = await ie(n2));
        const a2 = await $n.mode.cfb.decrypt(e2, t2, n2, new Uint8Array(i2)), s2 = re(ee(a2), -20), o2 = re(a2, 0, -20), c2 = Promise.all([ie(await $n.hash.sha1(ee(o2))), ie(s2)]).then(([e3, t3]) => {
          if (!ce.equalsUint8Array(e3, t3))
            throw Error("Modification detected.");
          return new Uint8Array();
        }), u2 = re(o2, i2 + 2);
        let h2 = re(u2, 0, -2);
        return h2 = W([h2, ae(() => c2)]), ce.isStream(n2) && r2.allowUnauthenticatedStream || (h2 = await ie(h2)), this.packets = await so.fromBinary(h2, mo, r2), true;
      }
    };
    var wo = /* @__PURE__ */ ce.constructAllowedPackets([Hs, co, no, ro]);
    var vo = class {
      static get tag() {
        return me.packet.aeadEncryptedData;
      }
      constructor() {
        this.version = 1, this.cipherAlgorithm = null, this.aeadAlgorithm = me.aead.eax, this.chunkSizeByte = null, this.iv = null, this.encrypted = null, this.packets = null;
      }
      async read(e2) {
        await Q(e2, async (e3) => {
          const t2 = await e3.readByte();
          if (t2 !== 1)
            throw new Js(`Version ${t2} of the AEAD-encrypted data packet is not supported.`);
          this.cipherAlgorithm = await e3.readByte(), this.aeadAlgorithm = await e3.readByte(), this.chunkSizeByte = await e3.readByte();
          const r2 = $n.getAEADMode(this.aeadAlgorithm);
          this.iv = await e3.readBytes(r2.ivLength), this.encrypted = e3.remainder();
        });
      }
      write() {
        return ce.concat([new Uint8Array([this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte]), this.iv, this.encrypted]);
      }
      async decrypt(e2, t2, r2 = ge) {
        this.packets = await so.fromBinary(await this.crypt("decrypt", t2, J(this.encrypted)), wo, r2);
      }
      async encrypt(e2, t2, r2 = ge) {
        this.cipherAlgorithm = e2;
        const { ivLength: i2 } = $n.getAEADMode(this.aeadAlgorithm);
        this.iv = await $n.random.getRandomBytes(i2), this.chunkSizeByte = r2.aeadChunkSizeByte;
        const n2 = this.packets.write();
        this.encrypted = await this.crypt("encrypt", t2, n2);
      }
      async crypt(e2, t2, r2) {
        const i2 = $n.getAEADMode(this.aeadAlgorithm), n2 = await i2(this.cipherAlgorithm, t2), a2 = e2 === "decrypt" ? i2.tagLength : 0, s2 = e2 === "encrypt" ? i2.tagLength : 0, o2 = 2 ** (this.chunkSizeByte + 6) + a2, c2 = new ArrayBuffer(21), u2 = new Uint8Array(c2, 0, 13), h2 = new Uint8Array(c2), f2 = new DataView(c2), d2 = new Uint8Array(c2, 5, 8);
        u2.set([192 | vo.tag, this.version, this.cipherAlgorithm, this.aeadAlgorithm, this.chunkSizeByte], 0);
        let l2 = 0, p2 = Promise.resolve(), y2 = 0, b2 = 0;
        const m2 = this.iv;
        return X(r2, async (t3, r3) => {
          if (ce.isStream(t3) !== "array") {
            const e3 = new O({}, { highWaterMark: ce.getHardwareConcurrency() * 2 ** (this.chunkSizeByte + 6), size: (e4) => e4.length });
            V(e3.readable, r3), r3 = e3.writable;
          }
          const c3 = H(t3), g2 = G(r3);
          try {
            for (; ; ) {
              let t4 = await c3.readBytes(o2 + a2) || new Uint8Array();
              const r4 = t4.subarray(t4.length - a2);
              let w2, v2;
              if (t4 = t4.subarray(0, t4.length - a2), !l2 || t4.length ? (c3.unshift(r4), w2 = n2[e2](t4, i2.getNonce(m2, d2), u2), b2 += t4.length - a2 + s2) : (f2.setInt32(17, y2), w2 = n2[e2](r4, i2.getNonce(m2, d2), h2), b2 += s2, v2 = true), y2 += t4.length - a2, p2 = p2.then(() => w2).then(async (e3) => {
                await g2.ready, await g2.write(e3), b2 -= e3.length;
              }).catch((e3) => g2.abort(e3)), (v2 || b2 > g2.desiredSize) && await p2, v2) {
                await g2.close();
                break;
              }
              f2.setInt32(9, ++l2);
            }
          } catch (e3) {
            await g2.abort(e3);
          }
        });
      }
    };
    var _o = class {
      static get tag() {
        return me.packet.publicKeyEncryptedSessionKey;
      }
      constructor() {
        this.version = 3, this.publicKeyID = new Me(), this.publicKeyAlgorithm = null, this.sessionKey = null, this.sessionKeyAlgorithm = null, this.encrypted = {};
      }
      read(e2) {
        if (this.version = e2[0], this.version !== 3)
          throw new Js(`Version ${this.version} of the PKESK packet is unsupported.`);
        this.publicKeyID.read(e2.subarray(1, e2.length)), this.publicKeyAlgorithm = e2[9], this.encrypted = $n.parseEncSessionKeyParams(this.publicKeyAlgorithm, e2.subarray(10));
      }
      write() {
        const e2 = [new Uint8Array([this.version]), this.publicKeyID.write(), new Uint8Array([this.publicKeyAlgorithm]), $n.serializeParams(this.publicKeyAlgorithm, this.encrypted)];
        return ce.concatUint8Array(e2);
      }
      async encrypt(e2) {
        const t2 = ce.concatUint8Array([new Uint8Array([me.write(me.symmetric, this.sessionKeyAlgorithm)]), this.sessionKey, ce.writeChecksum(this.sessionKey)]), r2 = me.write(me.publicKey, this.publicKeyAlgorithm);
        this.encrypted = await $n.publicKeyEncrypt(r2, e2.publicParams, t2, e2.getFingerprintBytes());
      }
      async decrypt(e2, t2) {
        if (this.publicKeyAlgorithm !== e2.algorithm)
          throw Error("Decryption error");
        const r2 = t2 ? ce.concatUint8Array([new Uint8Array([t2.sessionKeyAlgorithm]), t2.sessionKey, ce.writeChecksum(t2.sessionKey)]) : null, i2 = await $n.publicKeyDecrypt(this.publicKeyAlgorithm, e2.publicParams, e2.privateParams, this.encrypted, e2.getFingerprintBytes(), r2), n2 = i2[0], a2 = i2.subarray(1, i2.length - 2), s2 = i2.subarray(i2.length - 2), o2 = ce.writeChecksum(a2), c2 = o2[0] === s2[0] & o2[1] === s2[1];
        if (t2) {
          const e3 = c2 & n2 === t2.sessionKeyAlgorithm & a2.length === t2.sessionKey.length;
          this.sessionKeyAlgorithm = ce.selectUint8(e3, n2, t2.sessionKeyAlgorithm), this.sessionKey = ce.selectUint8Array(e3, a2, t2.sessionKey);
        } else {
          if (!(c2 && me.read(me.symmetric, n2)))
            throw Error("Decryption error");
          this.sessionKey = a2, this.sessionKeyAlgorithm = n2;
        }
      }
    };
    var ko = class {
      constructor(e2 = ge) {
        this.algorithm = me.hash.sha256, this.type = "iterated", this.c = e2.s2kIterationCountByte, this.salt = null;
      }
      getCount() {
        return 16 + (15 & this.c) << 6 + (this.c >> 4);
      }
      read(e2) {
        let t2 = 0;
        switch (this.type = me.read(me.s2k, e2[t2++]), this.algorithm = e2[t2++], this.type) {
          case "simple":
            break;
          case "salted":
            this.salt = e2.subarray(t2, t2 + 8), t2 += 8;
            break;
          case "iterated":
            this.salt = e2.subarray(t2, t2 + 8), t2 += 8, this.c = e2[t2++];
            break;
          case "gnu":
            if (ce.uint8ArrayToString(e2.subarray(t2, t2 + 3)) !== "GNU")
              throw Error("Unknown s2k type.");
            t2 += 3;
            if (1e3 + e2[t2++] !== 1001)
              throw Error("Unknown s2k gnu protection mode.");
            this.type = "gnu-dummy";
            break;
          default:
            throw Error("Unknown s2k type.");
        }
        return t2;
      }
      write() {
        if (this.type === "gnu-dummy")
          return new Uint8Array([101, 0, ...ce.stringToUint8Array("GNU"), 1]);
        const e2 = [new Uint8Array([me.write(me.s2k, this.type), this.algorithm])];
        switch (this.type) {
          case "simple":
            break;
          case "salted":
            e2.push(this.salt);
            break;
          case "iterated":
            e2.push(this.salt), e2.push(new Uint8Array([this.c]));
            break;
          case "gnu":
            throw Error("GNU s2k type not supported.");
          default:
            throw Error("Unknown s2k type.");
        }
        return ce.concatUint8Array(e2);
      }
      async produceKey(e2, t2) {
        e2 = ce.encodeUTF8(e2);
        const r2 = [];
        let i2 = 0, n2 = 0;
        for (; i2 < t2; ) {
          let t3;
          switch (this.type) {
            case "simple":
              t3 = ce.concatUint8Array([new Uint8Array(n2), e2]);
              break;
            case "salted":
              t3 = ce.concatUint8Array([new Uint8Array(n2), this.salt, e2]);
              break;
            case "iterated": {
              const r3 = ce.concatUint8Array([this.salt, e2]);
              let i3 = r3.length;
              const a3 = Math.max(this.getCount(), i3);
              t3 = new Uint8Array(n2 + a3), t3.set(r3, n2);
              for (let e3 = n2 + i3; e3 < a3; e3 += i3, i3 *= 2)
                t3.copyWithin(e3, n2, e3);
              break;
            }
            case "gnu":
              throw Error("GNU s2k type not supported.");
            default:
              throw Error("Unknown s2k type.");
          }
          const a2 = await $n.hash.digest(this.algorithm, t3);
          r2.push(a2), i2 += a2.length, n2++;
        }
        return ce.concatUint8Array(r2).subarray(0, t2);
      }
    };
    var Ao = class {
      static get tag() {
        return me.packet.symEncryptedSessionKey;
      }
      constructor(e2 = ge) {
        this.version = e2.aeadProtect ? 5 : 4, this.sessionKey = null, this.sessionKeyEncryptionAlgorithm = null, this.sessionKeyAlgorithm = me.symmetric.aes256, this.aeadAlgorithm = me.write(me.aead, e2.preferredAEADAlgorithm), this.encrypted = null, this.s2k = null, this.iv = null;
      }
      read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], this.version !== 4 && this.version !== 5)
          throw new Js(`Version ${this.version} of the SKESK packet is unsupported.`);
        const r2 = e2[t2++];
        if (this.version === 5 && (this.aeadAlgorithm = e2[t2++]), this.s2k = new ko(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), this.version === 5) {
          const r3 = $n.getAEADMode(this.aeadAlgorithm);
          this.iv = e2.subarray(t2, t2 += r3.ivLength);
        }
        this.version === 5 || t2 < e2.length ? (this.encrypted = e2.subarray(t2, e2.length), this.sessionKeyEncryptionAlgorithm = r2) : this.sessionKeyAlgorithm = r2;
      }
      write() {
        const e2 = this.encrypted === null ? this.sessionKeyAlgorithm : this.sessionKeyEncryptionAlgorithm;
        let t2;
        return this.version === 5 ? t2 = ce.concatUint8Array([new Uint8Array([this.version, e2, this.aeadAlgorithm]), this.s2k.write(), this.iv, this.encrypted]) : (t2 = ce.concatUint8Array([new Uint8Array([this.version, e2]), this.s2k.write()]), this.encrypted !== null && (t2 = ce.concatUint8Array([t2, this.encrypted]))), t2;
      }
      async decrypt(e2) {
        const t2 = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm, { blockSize: r2, keySize: i2 } = $n.getCipher(t2), n2 = await this.s2k.produceKey(e2, i2);
        if (this.version === 5) {
          const e3 = $n.getAEADMode(this.aeadAlgorithm), r3 = new Uint8Array([192 | Ao.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), i3 = await e3(t2, n2);
          this.sessionKey = await i3.decrypt(this.encrypted, this.iv, r3);
        } else if (this.encrypted !== null) {
          const e3 = await $n.mode.cfb.decrypt(t2, n2, this.encrypted, new Uint8Array(r2));
          this.sessionKeyAlgorithm = me.write(me.symmetric, e3[0]), this.sessionKey = e3.subarray(1, e3.length);
        } else
          this.sessionKey = n2;
      }
      async encrypt(e2, t2 = ge) {
        const r2 = this.sessionKeyEncryptionAlgorithm !== null ? this.sessionKeyEncryptionAlgorithm : this.sessionKeyAlgorithm;
        this.sessionKeyEncryptionAlgorithm = r2, this.s2k = new ko(t2), this.s2k.salt = await $n.random.getRandomBytes(8);
        const { blockSize: i2, keySize: n2 } = $n.getCipher(r2), a2 = await this.s2k.produceKey(e2, n2);
        if (this.sessionKey === null && (this.sessionKey = await $n.generateSessionKey(this.sessionKeyAlgorithm)), this.version === 5) {
          const e3 = $n.getAEADMode(this.aeadAlgorithm);
          this.iv = await $n.random.getRandomBytes(e3.ivLength);
          const t3 = new Uint8Array([192 | Ao.tag, this.version, this.sessionKeyEncryptionAlgorithm, this.aeadAlgorithm]), i3 = await e3(r2, a2);
          this.encrypted = await i3.encrypt(this.sessionKey, this.iv, t3);
        } else {
          const e3 = ce.concatUint8Array([new Uint8Array([this.sessionKeyAlgorithm]), this.sessionKey]);
          this.encrypted = await $n.mode.cfb.encrypt(r2, a2, e3, new Uint8Array(i2), t2);
        }
      }
    };
    var So = class {
      static get tag() {
        return me.packet.publicKey;
      }
      constructor(e2 = new Date(), t2 = ge) {
        this.version = t2.v5Keys ? 5 : 4, this.created = ce.normalizeDate(e2), this.algorithm = null, this.publicParams = null, this.expirationTimeV3 = 0, this.fingerprint = null, this.keyID = null;
      }
      static fromSecretKeyPacket(e2) {
        const t2 = new So(), { version: r2, created: i2, algorithm: n2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
        return t2.version = r2, t2.created = i2, t2.algorithm = n2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
      }
      async read(e2) {
        let t2 = 0;
        if (this.version = e2[t2++], this.version === 4 || this.version === 5) {
          this.created = ce.readDate(e2.subarray(t2, t2 + 4)), t2 += 4, this.algorithm = e2[t2++], this.version === 5 && (t2 += 4);
          try {
            const { read: r2, publicParams: i2 } = $n.parsePublicKeyParams(this.algorithm, e2.subarray(t2));
            this.publicParams = i2, t2 += r2;
          } catch (e3) {
            throw Error("Error reading MPIs");
          }
          return await this.computeFingerprintAndKeyID(), t2;
        }
        throw new Js(`Version ${this.version} of the key packet is unsupported.`);
      }
      write() {
        const e2 = [];
        e2.push(new Uint8Array([this.version])), e2.push(ce.writeDate(this.created)), e2.push(new Uint8Array([this.algorithm]));
        const t2 = $n.serializeParams(this.algorithm, this.publicParams);
        return this.version === 5 && e2.push(ce.writeNumber(t2.length, 4)), e2.push(t2), ce.concatUint8Array(e2);
      }
      writeForHash(e2) {
        const t2 = this.writePublicKey();
        return e2 === 5 ? ce.concatUint8Array([new Uint8Array([154]), ce.writeNumber(t2.length, 4), t2]) : ce.concatUint8Array([new Uint8Array([153]), ce.writeNumber(t2.length, 2), t2]);
      }
      isDecrypted() {
        return null;
      }
      getCreationTime() {
        return this.created;
      }
      getKeyID() {
        return this.keyID;
      }
      async computeFingerprintAndKeyID() {
        if (await this.computeFingerprint(), this.keyID = new Me(), this.version === 5)
          this.keyID.read(this.fingerprint.subarray(0, 8));
        else {
          if (this.version !== 4)
            throw Error("Unsupported key version");
          this.keyID.read(this.fingerprint.subarray(12, 20));
        }
      }
      async computeFingerprint() {
        const e2 = this.writeForHash(this.version);
        if (this.version === 5)
          this.fingerprint = await $n.hash.sha256(e2);
        else {
          if (this.version !== 4)
            throw Error("Unsupported key version");
          this.fingerprint = await $n.hash.sha1(e2);
        }
      }
      getFingerprintBytes() {
        return this.fingerprint;
      }
      getFingerprint() {
        return ce.uint8ArrayToHex(this.getFingerprintBytes());
      }
      hasSameFingerprintAs(e2) {
        return this.version === e2.version && ce.equalsUint8Array(this.writePublicKey(), e2.writePublicKey());
      }
      getAlgorithmInfo() {
        const e2 = {};
        e2.algorithm = me.read(me.publicKey, this.algorithm);
        const t2 = this.publicParams.n || this.publicParams.p;
        return t2 ? e2.bits = ce.uint8ArrayBitLength(t2) : e2.curve = this.publicParams.oid.getName(), e2;
      }
    };
    So.prototype.readPublicKey = So.prototype.read, So.prototype.writePublicKey = So.prototype.write;
    var Eo = /* @__PURE__ */ ce.constructAllowedPackets([Hs, co, no, ro]);
    var Po = class {
      static get tag() {
        return me.packet.symmetricallyEncryptedData;
      }
      constructor() {
        this.encrypted = null, this.packets = null;
      }
      read(e2) {
        this.encrypted = e2;
      }
      write() {
        return this.encrypted;
      }
      async decrypt(e2, t2, r2 = ge) {
        if (!r2.allowUnauthenticatedMessages)
          throw Error("Message is not authenticated.");
        const { blockSize: i2 } = $n.getCipher(e2), n2 = await ie(J(this.encrypted)), a2 = await $n.mode.cfb.decrypt(e2, t2, n2.subarray(i2 + 2), n2.subarray(2, i2 + 2));
        this.packets = await so.fromBinary(a2, Eo, r2);
      }
      async encrypt(e2, t2, r2 = ge) {
        const i2 = this.packets.write(), { blockSize: n2 } = $n.getCipher(e2), a2 = await $n.getPrefixRandom(e2), s2 = await $n.mode.cfb.encrypt(e2, t2, a2, new Uint8Array(n2), r2), o2 = await $n.mode.cfb.encrypt(e2, t2, i2, s2.subarray(2), r2);
        this.encrypted = ce.concat([s2, o2]);
      }
    };
    var xo = class extends So {
      static get tag() {
        return me.packet.publicSubkey;
      }
      constructor(e2, t2) {
        super(e2, t2);
      }
      static fromSecretSubkeyPacket(e2) {
        const t2 = new xo(), { version: r2, created: i2, algorithm: n2, publicParams: a2, keyID: s2, fingerprint: o2 } = e2;
        return t2.version = r2, t2.created = i2, t2.algorithm = n2, t2.publicParams = a2, t2.keyID = s2, t2.fingerprint = o2, t2;
      }
    };
    var Mo = class {
      static get tag() {
        return me.packet.userAttribute;
      }
      constructor() {
        this.attributes = [];
      }
      read(e2) {
        let t2 = 0;
        for (; t2 < e2.length; ) {
          const r2 = Gs(e2.subarray(t2, e2.length));
          t2 += r2.offset, this.attributes.push(ce.uint8ArrayToString(e2.subarray(t2, t2 + r2.len))), t2 += r2.len;
        }
      }
      write() {
        const e2 = [];
        for (let t2 = 0; t2 < this.attributes.length; t2++)
          e2.push(Vs(this.attributes[t2].length)), e2.push(ce.stringToUint8Array(this.attributes[t2]));
        return ce.concatUint8Array(e2);
      }
      equals(e2) {
        return !!(e2 && e2 instanceof Mo) && this.attributes.every(function(t2, r2) {
          return t2 === e2.attributes[r2];
        });
      }
    };
    var Co = class extends So {
      static get tag() {
        return me.packet.secretKey;
      }
      constructor(e2 = new Date(), t2 = ge) {
        super(e2, t2), this.keyMaterial = null, this.isEncrypted = null, this.s2kUsage = 0, this.s2k = null, this.symmetric = null, this.aead = null, this.privateParams = null;
      }
      async read(e2) {
        let t2 = await this.readPublicKey(e2);
        if (this.s2kUsage = e2[t2++], this.version === 5 && t2++, this.s2kUsage === 255 || this.s2kUsage === 254 || this.s2kUsage === 253) {
          if (this.symmetric = e2[t2++], this.s2kUsage === 253 && (this.aead = e2[t2++]), this.s2k = new ko(), t2 += this.s2k.read(e2.subarray(t2, e2.length)), this.s2k.type === "gnu-dummy")
            return;
        } else
          this.s2kUsage && (this.symmetric = this.s2kUsage);
        if (this.s2kUsage && (this.iv = e2.subarray(t2, t2 + $n.getCipher(this.symmetric).blockSize), t2 += this.iv.length), this.version === 5 && (t2 += 4), this.keyMaterial = e2.subarray(t2), this.isEncrypted = !!this.s2kUsage, !this.isEncrypted) {
          const e3 = this.keyMaterial.subarray(0, -2);
          if (!ce.equalsUint8Array(ce.writeChecksum(e3), this.keyMaterial.subarray(-2)))
            throw Error("Key checksum mismatch");
          try {
            const { privateParams: t3 } = $n.parsePrivateKeyParams(this.algorithm, e3, this.publicParams);
            this.privateParams = t3;
          } catch (e4) {
            throw Error("Error reading MPIs");
          }
        }
      }
      write() {
        const e2 = [this.writePublicKey()];
        e2.push(new Uint8Array([this.s2kUsage]));
        const t2 = [];
        return this.s2kUsage !== 255 && this.s2kUsage !== 254 && this.s2kUsage !== 253 || (t2.push(this.symmetric), this.s2kUsage === 253 && t2.push(this.aead), t2.push(...this.s2k.write())), this.s2kUsage && this.s2k.type !== "gnu-dummy" && t2.push(...this.iv), this.version === 5 && e2.push(new Uint8Array([t2.length])), e2.push(new Uint8Array(t2)), this.isDummy() || (this.s2kUsage || (this.keyMaterial = $n.serializeParams(this.algorithm, this.privateParams)), this.version === 5 && e2.push(ce.writeNumber(this.keyMaterial.length, 4)), e2.push(this.keyMaterial), this.s2kUsage || e2.push(ce.writeChecksum(this.keyMaterial))), ce.concatUint8Array(e2);
      }
      isDecrypted() {
        return this.isEncrypted === false;
      }
      isDummy() {
        return !(!this.s2k || this.s2k.type !== "gnu-dummy");
      }
      makeDummy(e2 = ge) {
        this.isDummy() || (this.isDecrypted() && this.clearPrivateParams(), this.isEncrypted = null, this.keyMaterial = null, this.s2k = new ko(e2), this.s2k.algorithm = 0, this.s2k.c = 0, this.s2k.type = "gnu-dummy", this.s2kUsage = 254, this.symmetric = me.symmetric.aes256);
      }
      async encrypt(e2, t2 = ge) {
        if (this.isDummy())
          return;
        if (!this.isDecrypted())
          throw Error("Key packet is already encrypted");
        if (this.isDecrypted() && !e2)
          return void (this.s2kUsage = 0);
        if (!e2)
          throw Error("The key must be decrypted before removing passphrase protection.");
        this.s2k = new ko(t2), this.s2k.salt = await $n.random.getRandomBytes(8);
        const r2 = $n.serializeParams(this.algorithm, this.privateParams);
        this.symmetric = me.symmetric.aes256;
        const i2 = await Ko(this.s2k, e2, this.symmetric), { blockSize: n2 } = $n.getCipher(this.symmetric);
        if (this.iv = await $n.random.getRandomBytes(n2), t2.aeadProtect) {
          this.s2kUsage = 253, this.aead = me.aead.eax;
          const e3 = $n.getAEADMode(this.aead), t3 = await e3(this.symmetric, i2);
          this.keyMaterial = await t3.encrypt(r2, this.iv.subarray(0, e3.ivLength), new Uint8Array());
        } else
          this.s2kUsage = 254, this.keyMaterial = await $n.mode.cfb.encrypt(this.symmetric, i2, ce.concatUint8Array([r2, await $n.hash.sha1(r2, t2)]), this.iv, t2);
      }
      async decrypt(e2) {
        if (this.isDummy())
          return false;
        if (this.isDecrypted())
          throw Error("Key packet is already decrypted.");
        let t2, r2;
        if (this.s2kUsage !== 254 && this.s2kUsage !== 253)
          throw this.s2kUsage === 255 ? Error("Encrypted private key is authenticated using an insecure two-byte hash") : Error("Private key is encrypted using an insecure S2K function: unsalted MD5");
        if (t2 = await Ko(this.s2k, e2, this.symmetric), this.s2kUsage === 253) {
          const e3 = $n.getAEADMode(this.aead), i2 = await e3(this.symmetric, t2);
          try {
            r2 = await i2.decrypt(this.keyMaterial, this.iv.subarray(0, e3.ivLength), new Uint8Array());
          } catch (e4) {
            if (e4.message === "Authentication tag mismatch")
              throw Error("Incorrect key passphrase: " + e4.message);
            throw e4;
          }
        } else {
          const e3 = await $n.mode.cfb.decrypt(this.symmetric, t2, this.keyMaterial, this.iv);
          r2 = e3.subarray(0, -20);
          const i2 = await $n.hash.sha1(r2);
          if (!ce.equalsUint8Array(i2, e3.subarray(-20)))
            throw Error("Incorrect key passphrase");
        }
        try {
          const { privateParams: e3 } = $n.parsePrivateKeyParams(this.algorithm, r2, this.publicParams);
          this.privateParams = e3;
        } catch (e3) {
          throw Error("Error reading MPIs");
        }
        this.isEncrypted = false, this.keyMaterial = null, this.s2kUsage = 0;
      }
      async validate() {
        if (this.isDummy())
          return;
        if (!this.isDecrypted())
          throw Error("Key is not decrypted");
        let e2;
        try {
          e2 = await $n.validateParams(this.algorithm, this.publicParams, this.privateParams);
        } catch (t2) {
          e2 = false;
        }
        if (!e2)
          throw Error("Key is invalid");
      }
      async generate(e2, t2) {
        const { privateParams: r2, publicParams: i2 } = await $n.generateParams(this.algorithm, e2, t2);
        this.privateParams = r2, this.publicParams = i2, this.isEncrypted = false;
      }
      clearPrivateParams() {
        this.isDummy() || (Object.keys(this.privateParams).forEach((e2) => {
          this.privateParams[e2].fill(0), delete this.privateParams[e2];
        }), this.privateParams = null, this.isEncrypted = true);
      }
    };
    async function Ko(e2, t2, r2) {
      const { keySize: i2 } = $n.getCipher(r2);
      return e2.produceKey(t2, i2);
    }
    var Do = bt(function(e2) {
      !function(t2) {
        function r2(e3) {
          function t3() {
            return Ae2 < Se2;
          }
          function r3() {
            return Ae2;
          }
          function n2(e4) {
            Ae2 = e4;
          }
          function a2() {
            Ae2 = 0, Se2 = ke2.length;
          }
          function s2(e4, t4) {
            return { name: e4, tokens: t4 || "", semantic: t4 || "", children: [] };
          }
          function o2(e4, t4) {
            var r4;
            return t4 === null ? null : ((r4 = s2(e4)).tokens = t4.tokens, r4.semantic = t4.semantic, r4.children.push(t4), r4);
          }
          function c2(e4, t4) {
            return t4 !== null && (e4.tokens += t4.tokens, e4.semantic += t4.semantic), e4.children.push(t4), e4;
          }
          function u2(e4) {
            var r4;
            return t3() && e4(r4 = ke2[Ae2]) ? (Ae2 += 1, s2("token", r4)) : null;
          }
          function h2(e4) {
            return function() {
              return o2("literal", u2(function(t4) {
                return t4 === e4;
              }));
            };
          }
          function f2() {
            var e4 = arguments;
            return function() {
              var t4, i3, a3, o3;
              for (o3 = r3(), i3 = s2("and"), t4 = 0; t4 < e4.length; t4 += 1) {
                if ((a3 = e4[t4]()) === null)
                  return n2(o3), null;
                c2(i3, a3);
              }
              return i3;
            };
          }
          function d2() {
            var e4 = arguments;
            return function() {
              var t4, i3, a3;
              for (a3 = r3(), t4 = 0; t4 < e4.length; t4 += 1) {
                if ((i3 = e4[t4]()) !== null)
                  return i3;
                n2(a3);
              }
              return null;
            };
          }
          function l2(e4) {
            return function() {
              var t4, i3;
              return i3 = r3(), (t4 = e4()) !== null ? t4 : (n2(i3), s2("opt"));
            };
          }
          function p2(e4) {
            return function() {
              var t4 = e4();
              return t4 !== null && (t4.semantic = ""), t4;
            };
          }
          function y2(e4) {
            return function() {
              var t4 = e4();
              return t4 !== null && t4.semantic.length > 0 && (t4.semantic = " "), t4;
            };
          }
          function b2(e4, t4) {
            return function() {
              var i3, a3, o3, u3, h3;
              for (u3 = r3(), i3 = s2("star"), o3 = 0, h3 = t4 === void 0 ? 0 : t4; (a3 = e4()) !== null; )
                o3 += 1, c2(i3, a3);
              return o3 >= h3 ? i3 : (n2(u3), null);
            };
          }
          function m2(e4) {
            return e4.charCodeAt(0) >= 128;
          }
          function g2() {
            return o2("cr", h2("\r")());
          }
          function w2() {
            return o2("crlf", f2(g2, k2)());
          }
          function v2() {
            return o2("dquote", h2('"')());
          }
          function _2() {
            return o2("htab", h2("	")());
          }
          function k2() {
            return o2("lf", h2("\n")());
          }
          function A2() {
            return o2("sp", h2(" ")());
          }
          function S2() {
            return o2("vchar", u2(function(t4) {
              var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 126;
              return e3.rfc6532 && (i3 = i3 || m2(t4)), i3;
            }));
          }
          function E2() {
            return o2("wsp", d2(A2, _2)());
          }
          function P2() {
            var e4 = o2("quoted-pair", d2(f2(h2("\\"), d2(S2, E2)), ie2)());
            return e4 === null ? null : (e4.semantic = e4.semantic[1], e4);
          }
          function x2() {
            return o2("fws", d2(ae2, f2(l2(f2(b2(E2), p2(w2))), b2(E2, 1)))());
          }
          function M2() {
            return o2("ctext", d2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 39 || 42 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || m2(t4)), i3;
              });
            }, te2)());
          }
          function C2() {
            return o2("ccontent", d2(M2, P2, K2)());
          }
          function K2() {
            return o2("comment", f2(h2("("), b2(f2(l2(x2), C2)), l2(x2), h2(")"))());
          }
          function D2() {
            return o2("cfws", d2(f2(b2(f2(l2(x2), K2), 1), l2(x2)), x2)());
          }
          function R2() {
            return o2("atext", u2(function(t4) {
              var r4 = "a" <= t4 && t4 <= "z" || "A" <= t4 && t4 <= "Z" || "0" <= t4 && t4 <= "9" || ["!", "#", "$", "%", "&", "'", "*", "+", "-", "/", "=", "?", "^", "_", "`", "{", "|", "}", "~"].indexOf(t4) >= 0;
              return e3.rfc6532 && (r4 = r4 || m2(t4)), r4;
            }));
          }
          function I2() {
            return o2("atom", f2(y2(l2(D2)), b2(R2, 1), y2(l2(D2)))());
          }
          function U2() {
            var e4, t4;
            return (e4 = o2("dot-atom-text", b2(R2, 1)())) === null || (t4 = b2(f2(h2("."), b2(R2, 1)))()) !== null && c2(e4, t4), e4;
          }
          function B2() {
            return o2("dot-atom", f2(p2(l2(D2)), U2, p2(l2(D2)))());
          }
          function T2() {
            return o2("qtext", d2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = r4 === 33 || 35 <= r4 && r4 <= 91 || 93 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || m2(t4)), i3;
              });
            }, re2)());
          }
          function z2() {
            return o2("qcontent", d2(T2, P2)());
          }
          function q2() {
            return o2("quoted-string", f2(p2(l2(D2)), p2(v2), b2(f2(l2(y2(x2)), z2)), l2(p2(x2)), p2(v2), p2(l2(D2)))());
          }
          function O2() {
            return o2("word", d2(I2, q2)());
          }
          function F2() {
            return o2("address", d2(N2, W2)());
          }
          function N2() {
            return o2("mailbox", d2(j2, J2)());
          }
          function j2() {
            return o2("name-addr", f2(l2(H2), L2)());
          }
          function L2() {
            return o2("angle-addr", d2(f2(p2(l2(D2)), h2("<"), J2, h2(">"), p2(l2(D2))), se2)());
          }
          function W2() {
            return o2("group", f2(H2, h2(":"), l2($2), h2(";"), p2(l2(D2)))());
          }
          function H2() {
            return o2("display-name", ((e4 = o2("phrase", d2(ne2, b2(O2, 1))())) !== null && (e4.semantic = function(e5) {
              return e5.replace(/([ \t]|\r\n)+/g, " ").replace(/^\s*/, "").replace(/\s*$/, "");
            }(e4.semantic)), e4));
            var e4;
          }
          function G2() {
            return o2("mailbox-list", d2(f2(N2, b2(f2(h2(","), N2))), ue2)());
          }
          function V2() {
            return o2("address-list", d2(f2(F2, b2(f2(h2(","), F2))), he2)());
          }
          function $2() {
            return o2("group-list", d2(G2, p2(D2), fe2)());
          }
          function Z2() {
            return o2("local-part", d2(de2, B2, q2)());
          }
          function Y2() {
            return o2("dtext", d2(function() {
              return u2(function(t4) {
                var r4 = t4.charCodeAt(0), i3 = 33 <= r4 && r4 <= 90 || 94 <= r4 && r4 <= 126;
                return e3.rfc6532 && (i3 = i3 || m2(t4)), i3;
              });
            }, pe2)());
          }
          function X2() {
            return o2("domain-literal", f2(p2(l2(D2)), h2("["), b2(f2(l2(x2), Y2)), l2(x2), h2("]"), p2(l2(D2)))());
          }
          function Q2() {
            return o2("domain", (t4 = d2(le2, B2, X2)(), e3.rejectTLD && t4 && t4.semantic && t4.semantic.indexOf(".") < 0 ? null : (t4 && (t4.semantic = t4.semantic.replace(/\s+/g, "")), t4)));
            var t4;
          }
          function J2() {
            return o2("addr-spec", f2(Z2, h2("@"), Q2)());
          }
          function ee2() {
            return e3.strict ? null : o2("obs-NO-WS-CTL", u2(function(e4) {
              var t4 = e4.charCodeAt(0);
              return 1 <= t4 && t4 <= 8 || t4 === 11 || t4 === 12 || 14 <= t4 && t4 <= 31 || t4 === 127;
            }));
          }
          function te2() {
            return e3.strict ? null : o2("obs-ctext", ee2());
          }
          function re2() {
            return e3.strict ? null : o2("obs-qtext", ee2());
          }
          function ie2() {
            return e3.strict ? null : o2("obs-qp", f2(h2("\\"), d2(h2("\0"), ee2, k2, g2))());
          }
          function ne2() {
            return e3.strict ? null : e3.atInDisplayName ? o2("obs-phrase", f2(O2, b2(d2(O2, h2("."), h2("@"), y2(D2))))()) : o2("obs-phrase", f2(O2, b2(d2(O2, h2("."), y2(D2))))());
          }
          function ae2() {
            return e3.strict ? null : o2("obs-FWS", b2(f2(p2(l2(w2)), E2), 1)());
          }
          function se2() {
            return e3.strict ? null : o2("obs-angle-addr", f2(p2(l2(D2)), h2("<"), oe2, J2, h2(">"), p2(l2(D2)))());
          }
          function oe2() {
            return e3.strict ? null : o2("obs-route", f2(ce2, h2(":"))());
          }
          function ce2() {
            return e3.strict ? null : o2("obs-domain-list", f2(b2(d2(p2(D2), h2(","))), h2("@"), Q2, b2(f2(h2(","), p2(l2(D2)), l2(f2(h2("@"), Q2)))))());
          }
          function ue2() {
            return e3.strict ? null : o2("obs-mbox-list", f2(b2(f2(p2(l2(D2)), h2(","))), N2, b2(f2(h2(","), l2(f2(N2, p2(D2))))))());
          }
          function he2() {
            return e3.strict ? null : o2("obs-addr-list", f2(b2(f2(p2(l2(D2)), h2(","))), F2, b2(f2(h2(","), l2(f2(F2, p2(D2))))))());
          }
          function fe2() {
            return e3.strict ? null : o2("obs-group-list", f2(b2(f2(p2(l2(D2)), h2(",")), 1), p2(l2(D2)))());
          }
          function de2() {
            return e3.strict ? null : o2("obs-local-part", f2(O2, b2(f2(h2("."), O2)))());
          }
          function le2() {
            return e3.strict ? null : o2("obs-domain", f2(I2, b2(f2(h2("."), I2)))());
          }
          function pe2() {
            return e3.strict ? null : o2("obs-dtext", d2(ee2, P2)());
          }
          function ye2(e4, t4) {
            var r4, i3, n3;
            if (t4 == null)
              return null;
            for (i3 = [t4]; i3.length > 0; ) {
              if ((n3 = i3.pop()).name === e4)
                return n3;
              for (r4 = n3.children.length - 1; r4 >= 0; r4 -= 1)
                i3.push(n3.children[r4]);
            }
            return null;
          }
          function be2(e4, t4) {
            var r4, i3, n3, a3, s3;
            if (t4 == null)
              return null;
            for (i3 = [t4], a3 = [], s3 = {}, r4 = 0; r4 < e4.length; r4 += 1)
              s3[e4[r4]] = true;
            for (; i3.length > 0; )
              if ((n3 = i3.pop()).name in s3)
                a3.push(n3);
              else
                for (r4 = n3.children.length - 1; r4 >= 0; r4 -= 1)
                  i3.push(n3.children[r4]);
            return a3;
          }
          function me2(t4) {
            var r4, i3, n3, a3, s3;
            if (t4 === null)
              return null;
            for (r4 = [], i3 = be2(["group", "mailbox"], t4), n3 = 0; n3 < i3.length; n3 += 1)
              (a3 = i3[n3]).name === "group" ? r4.push(ge2(a3)) : a3.name === "mailbox" && r4.push(we2(a3));
            return s3 = { ast: t4, addresses: r4 }, e3.simple && (s3 = function(e4) {
              var t5;
              if (e4 && e4.addresses)
                for (t5 = 0; t5 < e4.addresses.length; t5 += 1)
                  delete e4.addresses[t5].node;
              return e4;
            }(s3)), e3.oneResult ? function(t5) {
              if (!t5)
                return null;
              if (!e3.partial && t5.addresses.length > 1)
                return null;
              return t5.addresses && t5.addresses[0];
            }(s3) : e3.simple ? s3 && s3.addresses : s3;
          }
          function ge2(e4) {
            var t4, r4 = ye2("display-name", e4), i3 = [], n3 = be2(["mailbox"], e4);
            for (t4 = 0; t4 < n3.length; t4 += 1)
              i3.push(we2(n3[t4]));
            return { node: e4, parts: { name: r4 }, type: e4.name, name: ve2(r4), addresses: i3 };
          }
          function we2(e4) {
            var t4 = ye2("display-name", e4), r4 = ye2("addr-spec", e4), i3 = function(e5, t5) {
              var r5, i4, n4, a4;
              if (t5 == null)
                return null;
              for (i4 = [t5], a4 = []; i4.length > 0; )
                for ((n4 = i4.pop()).name === e5 && a4.push(n4), r5 = n4.children.length - 1; r5 >= 0; r5 -= 1)
                  i4.push(n4.children[r5]);
              return a4;
            }("cfws", e4), n3 = be2(["comment"], e4), a3 = ye2("local-part", r4), s3 = ye2("domain", r4);
            return { node: e4, parts: { name: t4, address: r4, local: a3, domain: s3, comments: i3 }, type: e4.name, name: ve2(t4), address: ve2(r4), local: ve2(a3), domain: ve2(s3), comments: _e2(n3), groupName: ve2(e4.groupName) };
          }
          function ve2(e4) {
            return e4 != null ? e4.semantic : null;
          }
          function _e2(e4) {
            var t4 = "";
            if (e4)
              for (var r4 = 0; r4 < e4.length; r4 += 1)
                t4 += ve2(e4[r4]);
            return t4;
          }
          var ke2, Ae2, Se2, Ee2, Pe2;
          if ((e3 = i2(e3, {})) === null)
            return null;
          if (ke2 = e3.input, Pe2 = { address: F2, "address-list": V2, "angle-addr": L2, from: function() {
            return o2("from", d2(G2, V2)());
          }, group: W2, mailbox: N2, "mailbox-list": G2, "reply-to": function() {
            return o2("reply-to", V2());
          }, sender: function() {
            return o2("sender", d2(N2, F2)());
          } }[e3.startAt] || V2, !e3.strict) {
            if (a2(), e3.strict = true, Ee2 = Pe2(ke2), e3.partial || !t3())
              return me2(Ee2);
            e3.strict = false;
          }
          return a2(), Ee2 = Pe2(ke2), !e3.partial && t3() ? null : me2(Ee2);
        }
        function i2(e3, t3) {
          function r3(e4) {
            return Object.prototype.toString.call(e4) === "[object String]";
          }
          function i3(e4) {
            return e4 == null;
          }
          var n2, a2;
          if (r3(e3))
            e3 = { input: e3 };
          else if (!function(e4) {
            return e4 === Object(e4);
          }(e3))
            return null;
          if (!r3(e3.input))
            return null;
          if (!t3)
            return null;
          for (a2 in n2 = { oneResult: false, partial: false, rejectTLD: false, rfc6532: false, simple: false, startAt: "address-list", strict: false, atInDisplayName: false })
            i3(e3[a2]) && (e3[a2] = i3(t3[a2]) ? n2[a2] : t3[a2]);
          return e3;
        }
        r2.parseOneAddress = function(e3) {
          return r2(i2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "address-list" }));
        }, r2.parseAddressList = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "address-list" }));
        }, r2.parseFrom = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "from" }));
        }, r2.parseSender = function(e3) {
          return r2(i2(e3, { oneResult: true, rfc6532: true, simple: true, startAt: "sender" }));
        }, r2.parseReplyTo = function(e3) {
          return r2(i2(e3, { rfc6532: true, simple: true, startAt: "reply-to" }));
        }, e2.exports = r2;
      }();
    });
    var Ro = class {
      static get tag() {
        return me.packet.userID;
      }
      constructor() {
        this.userID = "", this.name = "", this.email = "", this.comment = "";
      }
      static fromObject(e2) {
        if (ce.isString(e2) || e2.name && !ce.isString(e2.name) || e2.email && !ce.isEmailAddress(e2.email) || e2.comment && !ce.isString(e2.comment))
          throw Error("Invalid user ID format");
        const t2 = new Ro();
        Object.assign(t2, e2);
        const r2 = [];
        return t2.name && r2.push(t2.name), t2.comment && r2.push(`(${t2.comment})`), t2.email && r2.push(`<${t2.email}>`), t2.userID = r2.join(" "), t2;
      }
      read(e2, t2 = ge) {
        const r2 = ce.decodeUTF8(e2);
        if (r2.length > t2.maxUserIDLength)
          throw Error("User ID string is too long");
        try {
          const { name: e3, address: t3, comments: i2 } = Do.parseOneAddress({ input: r2, atInDisplayName: true });
          this.comment = i2.replace(/^\(|\)$/g, ""), this.name = e3, this.email = t3;
        } catch (e3) {
        }
        this.userID = r2;
      }
      write() {
        return ce.encodeUTF8(this.userID);
      }
      equals(e2) {
        return e2 && e2.userID === this.userID;
      }
    };
    var Io = class extends Co {
      static get tag() {
        return me.packet.secretSubkey;
      }
      constructor(e2 = new Date(), t2 = ge) {
        super(e2, t2);
      }
    };
    var Uo = /* @__PURE__ */ ce.constructAllowedPackets([ro]);
    var Bo = class {
      constructor(e2) {
        this.packets = e2 || new so();
      }
      write() {
        return this.packets.write();
      }
      armor(e2 = ge) {
        return xe(me.armor.signature, this.write(), void 0, void 0, void 0, e2);
      }
      getSigningKeyIDs() {
        return this.packets.map((e2) => e2.issuerKeyID);
      }
    };
    async function To(e2, t2) {
      const r2 = new Io(e2.date, t2);
      return r2.packets = null, r2.algorithm = me.write(me.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve), await r2.computeFingerprintAndKeyID(), r2;
    }
    async function zo(e2, t2) {
      const r2 = new Co(e2.date, t2);
      return r2.packets = null, r2.algorithm = me.write(me.publicKey, e2.algorithm), await r2.generate(e2.rsaBits, e2.curve, e2.config), await r2.computeFingerprintAndKeyID(), r2;
    }
    async function qo(e2, t2, r2, i2, n2 = new Date(), a2) {
      let s2, o2;
      for (let c2 = e2.length - 1; c2 >= 0; c2--)
        try {
          (!s2 || e2[c2].created >= s2.created) && (await e2[c2].verify(t2, r2, i2, n2, void 0, a2), s2 = e2[c2]);
        } catch (e3) {
          o2 = e3;
        }
      if (!s2)
        throw ce.wrapError(`Could not find valid ${me.read(me.signature, r2)} signature in key ${t2.getKeyID().toHex()}`.replace("certGeneric ", "self-").replace(/([a-z])([A-Z])/g, (e3, t3, r3) => t3 + " " + r3.toLowerCase()), o2);
      return s2;
    }
    function Oo(e2, t2, r2 = new Date()) {
      const i2 = ce.normalizeDate(r2);
      if (i2 !== null) {
        const r3 = Go(e2, t2);
        return !(e2.created <= i2 && i2 < r3);
      }
      return false;
    }
    async function Fo(e2, t2, r2, i2) {
      const n2 = {};
      n2.key = t2, n2.bind = e2;
      const a2 = new ro();
      return a2.signatureType = me.signature.subkeyBinding, a2.publicKeyAlgorithm = t2.algorithm, a2.hashAlgorithm = await No(null, e2, void 0, void 0, i2), r2.sign ? (a2.keyFlags = [me.keyFlags.signData], a2.embeddedSignature = await Lo(n2, null, e2, { signatureType: me.signature.keyBinding }, r2.date, void 0, void 0, i2)) : a2.keyFlags = [me.keyFlags.encryptCommunication | me.keyFlags.encryptStorage], r2.keyExpirationTime > 0 && (a2.keyExpirationTime = r2.keyExpirationTime, a2.keyNeverExpires = false), await a2.sign(t2, n2, r2.date), a2;
    }
    async function No(e2, t2, r2 = new Date(), i2 = {}, n2) {
      let a2 = n2.preferredHashAlgorithm, s2 = a2;
      if (e2) {
        const t3 = await e2.getPrimaryUser(r2, i2, n2);
        t3.selfCertification.preferredHashAlgorithms && ([s2] = t3.selfCertification.preferredHashAlgorithms, a2 = $n.hash.getHashByteLength(a2) <= $n.hash.getHashByteLength(s2) ? s2 : a2);
      }
      switch (Object.getPrototypeOf(t2)) {
        case Co.prototype:
        case So.prototype:
        case Io.prototype:
        case xo.prototype:
          switch (t2.algorithm) {
            case me.publicKey.ecdh:
            case me.publicKey.ecdsa:
            case me.publicKey.eddsa:
              s2 = $n.publicKey.elliptic.getPreferredHashAlgo(t2.publicParams.oid);
          }
      }
      return $n.hash.getHashByteLength(a2) <= $n.hash.getHashByteLength(s2) ? s2 : a2;
    }
    async function jo(e2, t2 = [], r2 = new Date(), i2 = [], n2 = ge) {
      const a2 = { symmetric: me.symmetric.aes128, aead: me.aead.eax, compression: me.compression.uncompressed }[e2], s2 = { symmetric: n2.preferredSymmetricAlgorithm, aead: n2.preferredAEADAlgorithm, compression: n2.preferredCompressionAlgorithm }[e2], o2 = { symmetric: "preferredSymmetricAlgorithms", aead: "preferredAEADAlgorithms", compression: "preferredCompressionAlgorithms" }[e2];
      return (await Promise.all(t2.map(async function(e3, t3) {
        const a3 = (await e3.getPrimaryUser(r2, i2[t3], n2)).selfCertification[o2];
        return !!a3 && a3.indexOf(s2) >= 0;
      }))).every(Boolean) ? s2 : a2;
    }
    async function Lo(e2, t2, r2, i2, n2, a2, s2 = false, o2) {
      if (r2.isDummy())
        throw Error("Cannot sign with a gnu-dummy key.");
      if (!r2.isDecrypted())
        throw Error("Signing key is not decrypted.");
      const c2 = new ro();
      return Object.assign(c2, i2), c2.publicKeyAlgorithm = r2.algorithm, c2.hashAlgorithm = await No(t2, r2, n2, a2, o2), await c2.sign(r2, e2, n2, s2), c2;
    }
    async function Wo(e2, t2, r2, i2 = new Date(), n2) {
      (e2 = e2[r2]) && (t2[r2].length ? await Promise.all(e2.map(async function(e3) {
        e3.isExpired(i2) || n2 && !await n2(e3) || t2[r2].some(function(t3) {
          return ce.equalsUint8Array(t3.writeParams(), e3.writeParams());
        }) || t2[r2].push(e3);
      })) : t2[r2] = e2);
    }
    async function Ho(e2, t2, r2, i2, n2, a2, s2 = new Date(), o2) {
      a2 = a2 || e2;
      const c2 = [];
      return await Promise.all(i2.map(async function(e3) {
        try {
          n2 && !e3.issuerKeyID.equals(n2.issuerKeyID) || (await e3.verify(a2, t2, r2, o2.revocationsExpire ? s2 : null, false, o2), c2.push(e3.issuerKeyID));
        } catch (e4) {
        }
      })), n2 ? (n2.revoked = !!c2.some((e3) => e3.equals(n2.issuerKeyID)) || (n2.revoked || false), n2.revoked) : c2.length > 0;
    }
    function Go(e2, t2) {
      let r2;
      return t2.keyNeverExpires === false && (r2 = e2.created.getTime() + 1e3 * t2.keyExpirationTime), r2 ? new Date(r2) : 1 / 0;
    }
    function Vo(e2, t2 = {}) {
      switch (e2.type = e2.type || t2.type, e2.curve = e2.curve || t2.curve, e2.rsaBits = e2.rsaBits || t2.rsaBits, e2.keyExpirationTime = e2.keyExpirationTime !== void 0 ? e2.keyExpirationTime : t2.keyExpirationTime, e2.passphrase = ce.isString(e2.passphrase) ? e2.passphrase : t2.passphrase, e2.date = e2.date || t2.date, e2.sign = e2.sign || false, e2.type) {
        case "ecc":
          try {
            e2.curve = me.write(me.curve, e2.curve);
          } catch (e3) {
            throw Error("Invalid curve");
          }
          e2.curve !== me.curve.ed25519 && e2.curve !== me.curve.curve25519 || (e2.curve = e2.sign ? me.curve.ed25519 : me.curve.curve25519), e2.sign ? e2.algorithm = e2.curve === me.curve.ed25519 ? me.publicKey.eddsa : me.publicKey.ecdsa : e2.algorithm = me.publicKey.ecdh;
          break;
        case "rsa":
          e2.algorithm = me.publicKey.rsaEncryptSign;
          break;
        default:
          throw Error("Unsupported key type " + e2.type);
      }
      return e2;
    }
    function $o(e2, t2) {
      const r2 = e2.algorithm;
      return r2 !== me.publicKey.rsaEncrypt && r2 !== me.publicKey.elgamal && r2 !== me.publicKey.ecdh && (!t2.keyFlags || (t2.keyFlags[0] & me.keyFlags.signData) != 0);
    }
    function Zo(e2, t2) {
      const r2 = e2.algorithm;
      return r2 !== me.publicKey.dsa && r2 !== me.publicKey.rsaSign && r2 !== me.publicKey.ecdsa && r2 !== me.publicKey.eddsa && (!t2.keyFlags || (t2.keyFlags[0] & me.keyFlags.encryptCommunication) != 0 || (t2.keyFlags[0] & me.keyFlags.encryptStorage) != 0);
    }
    function Yo(e2, t2) {
      return !!t2.allowInsecureDecryptionWithSigningKeys || (!e2.keyFlags || (e2.keyFlags[0] & me.keyFlags.encryptCommunication) != 0 || (e2.keyFlags[0] & me.keyFlags.encryptStorage) != 0);
    }
    function Xo(e2, t2) {
      const r2 = me.write(me.publicKey, e2.algorithm), i2 = e2.getAlgorithmInfo();
      if (t2.rejectPublicKeyAlgorithms.has(r2))
        throw Error(i2.algorithm + " keys are considered too weak.");
      switch (r2) {
        case me.publicKey.rsaEncryptSign:
        case me.publicKey.rsaSign:
        case me.publicKey.rsaEncrypt:
          if (i2.bits < t2.minRSABits)
            throw Error(`RSA keys shorter than ${t2.minRSABits} bits are considered too weak.`);
          break;
        case me.publicKey.ecdsa:
        case me.publicKey.eddsa:
        case me.publicKey.ecdh:
          if (t2.rejectCurves.has(i2.curve))
            throw Error(`Support for ${i2.algorithm} keys using curve ${i2.curve} is disabled.`);
      }
    }
    var Qo = class {
      constructor(e2, t2) {
        this.userID = e2.constructor.tag === me.packet.userID ? e2 : null, this.userAttribute = e2.constructor.tag === me.packet.userAttribute ? e2 : null, this.selfCertifications = [], this.otherCertifications = [], this.revocationSignatures = [], this.mainKey = t2;
      }
      toPacketList() {
        const e2 = new so();
        return e2.push(this.userID || this.userAttribute), e2.push(...this.revocationSignatures), e2.push(...this.selfCertifications), e2.push(...this.otherCertifications), e2;
      }
      clone() {
        const e2 = new Qo(this.userID || this.userAttribute, this.mainKey);
        return e2.selfCertifications = [...this.selfCertifications], e2.otherCertifications = [...this.otherCertifications], e2.revocationSignatures = [...this.revocationSignatures], e2;
      }
      async certify(e2, t2, r2) {
        const i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 }, a2 = new Qo(n2.userID || n2.userAttribute, this.mainKey);
        return a2.otherCertifications = await Promise.all(e2.map(async function(e3) {
          if (!e3.isPrivate())
            throw Error("Need private key for signing");
          if (e3.hasSameFingerprintAs(i2))
            throw Error("The user's own key can only be used for self-certifications");
          const a3 = await e3.getSigningKey(void 0, t2, void 0, r2);
          return Lo(n2, e3, a3.keyPacket, { signatureType: me.signature.certGeneric, keyFlags: [me.keyFlags.certifyKeys | me.keyFlags.signData] }, t2, void 0, void 0, r2);
        })), await a2.update(this, t2, r2), a2;
      }
      async isRevoked(e2, t2, r2 = new Date(), i2) {
        const n2 = this.mainKey.keyPacket;
        return Ho(n2, me.signature.certRevocation, { key: n2, userID: this.userID, userAttribute: this.userAttribute }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verifyCertificate(e2, t2, r2 = new Date(), i2) {
        const n2 = this, a2 = this.mainKey.keyPacket, s2 = { userID: this.userID, userAttribute: this.userAttribute, key: a2 }, { issuerKeyID: o2 } = e2, c2 = t2.filter((e3) => e3.getKeys(o2).length > 0);
        return c2.length === 0 ? null : (await Promise.all(c2.map(async (t3) => {
          const a3 = await t3.getSigningKey(o2, e2.created, void 0, i2);
          if (e2.revoked || await n2.isRevoked(e2, a3.keyPacket, r2, i2))
            throw Error("User certificate is revoked");
          try {
            await e2.verify(a3.keyPacket, me.signature.certGeneric, s2, r2, void 0, i2);
          } catch (e3) {
            throw ce.wrapError("User certificate is invalid", e3);
          }
        })), true);
      }
      async verifyAllCertifications(e2, t2 = new Date(), r2) {
        const i2 = this, n2 = this.selfCertifications.concat(this.otherCertifications);
        return Promise.all(n2.map(async (n3) => ({ keyID: n3.issuerKeyID, valid: await i2.verifyCertificate(n3, e2, t2, r2).catch(() => false) })));
      }
      async verify(e2 = new Date(), t2) {
        if (!this.selfCertifications.length)
          throw Error("No self-certifications found");
        const r2 = this, i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 };
        let a2;
        for (let s2 = this.selfCertifications.length - 1; s2 >= 0; s2--)
          try {
            const a3 = this.selfCertifications[s2];
            if (a3.revoked || await r2.isRevoked(a3, void 0, e2, t2))
              throw Error("Self-certification is revoked");
            try {
              await a3.verify(i2, me.signature.certGeneric, n2, e2, void 0, t2);
            } catch (e3) {
              throw ce.wrapError("Self-certification is invalid", e3);
            }
            return true;
          } catch (e3) {
            a2 = e3;
          }
        throw a2;
      }
      async update(e2, t2, r2) {
        const i2 = this.mainKey.keyPacket, n2 = { userID: this.userID, userAttribute: this.userAttribute, key: i2 };
        await Wo(e2, this, "selfCertifications", t2, async function(e3) {
          try {
            return await e3.verify(i2, me.signature.certGeneric, n2, t2, false, r2), true;
          } catch (e4) {
            return false;
          }
        }), await Wo(e2, this, "otherCertifications", t2), await Wo(e2, this, "revocationSignatures", t2, function(e3) {
          return Ho(i2, me.signature.certRevocation, n2, [e3], void 0, void 0, t2, r2);
        });
      }
    };
    var Jo = class {
      constructor(e2, t2) {
        this.keyPacket = e2, this.bindingSignatures = [], this.revocationSignatures = [], this.mainKey = t2;
      }
      toPacketList() {
        const e2 = new so();
        return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.bindingSignatures), e2;
      }
      clone() {
        const e2 = new Jo(this.keyPacket, this.mainKey);
        return e2.bindingSignatures = [...this.bindingSignatures], e2.revocationSignatures = [...this.revocationSignatures], e2;
      }
      async isRevoked(e2, t2, r2 = new Date(), i2 = ge) {
        const n2 = this.mainKey.keyPacket;
        return Ho(n2, me.signature.subkeyRevocation, { key: n2, bind: this.keyPacket }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verify(e2 = new Date(), t2 = ge) {
        const r2 = this.mainKey.keyPacket, i2 = { key: r2, bind: this.keyPacket }, n2 = await qo(this.bindingSignatures, r2, me.signature.subkeyBinding, i2, e2, t2);
        if (n2.revoked || await this.isRevoked(n2, null, e2, t2))
          throw Error("Subkey is revoked");
        if (Oo(this.keyPacket, n2, e2))
          throw Error("Subkey is expired");
        return n2;
      }
      async getExpirationTime(e2 = new Date(), t2 = ge) {
        const r2 = this.mainKey.keyPacket, i2 = { key: r2, bind: this.keyPacket };
        let n2;
        try {
          n2 = await qo(this.bindingSignatures, r2, me.signature.subkeyBinding, i2, e2, t2);
        } catch (e3) {
          return null;
        }
        const a2 = Go(this.keyPacket, n2), s2 = n2.getExpirationTime();
        return a2 < s2 ? a2 : s2;
      }
      async update(e2, t2 = new Date(), r2 = ge) {
        const i2 = this.mainKey.keyPacket;
        if (!this.hasSameFingerprintAs(e2))
          throw Error("Subkey update method: fingerprints of subkeys not equal");
        this.keyPacket.constructor.tag === me.packet.publicSubkey && e2.keyPacket.constructor.tag === me.packet.secretSubkey && (this.keyPacket = e2.keyPacket);
        const n2 = this, a2 = { key: i2, bind: n2.keyPacket };
        await Wo(e2, this, "bindingSignatures", t2, async function(e3) {
          for (let t3 = 0; t3 < n2.bindingSignatures.length; t3++)
            if (n2.bindingSignatures[t3].issuerKeyID.equals(e3.issuerKeyID))
              return e3.created > n2.bindingSignatures[t3].created && (n2.bindingSignatures[t3] = e3), false;
          try {
            return await e3.verify(i2, me.signature.subkeyBinding, a2, t2, void 0, r2), true;
          } catch (e4) {
            return false;
          }
        }), await Wo(e2, this, "revocationSignatures", t2, function(e3) {
          return Ho(i2, me.signature.subkeyRevocation, a2, [e3], void 0, void 0, t2, r2);
        });
      }
      async revoke(e2, { flag: t2 = me.reasonForRevocation.noReason, string: r2 = "" } = {}, i2 = new Date(), n2 = ge) {
        const a2 = { key: e2, bind: this.keyPacket }, s2 = new Jo(this.keyPacket, this.mainKey);
        return s2.revocationSignatures.push(await Lo(a2, null, e2, { signatureType: me.signature.subkeyRevocation, reasonForRevocationFlag: me.write(me.reasonForRevocation, t2), reasonForRevocationString: r2 }, i2, void 0, false, n2)), await s2.update(this), s2;
      }
      hasSameFingerprintAs(e2) {
        return this.keyPacket.hasSameFingerprintAs(e2.keyPacket || e2);
      }
    };
    ["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "isDecrypted"].forEach((e2) => {
      Jo.prototype[e2] = function() {
        return this.keyPacket[e2]();
      };
    });
    var ec = /* @__PURE__ */ ce.constructAllowedPackets([ro]);
    var tc2 = class {
      packetListToStructure(e2, t2 = /* @__PURE__ */ new Set()) {
        let r2, i2, n2;
        for (const a2 of e2) {
          const e3 = a2.constructor.tag;
          if (t2.has(e3))
            throw Error("Unexpected packet type: " + e3);
          switch (e3) {
            case me.packet.publicKey:
            case me.packet.secretKey:
              if (this.keyPacket)
                throw Error("Key block contains multiple keys");
              if (this.keyPacket = a2, i2 = this.getKeyID(), !i2)
                throw Error("Missing Key ID");
              break;
            case me.packet.userID:
            case me.packet.userAttribute:
              r2 = new Qo(a2, this), this.users.push(r2);
              break;
            case me.packet.publicSubkey:
            case me.packet.secretSubkey:
              r2 = null, n2 = new Jo(a2, this), this.subkeys.push(n2);
              break;
            case me.packet.signature:
              switch (a2.signatureType) {
                case me.signature.certGeneric:
                case me.signature.certPersona:
                case me.signature.certCasual:
                case me.signature.certPositive:
                  if (!r2) {
                    ce.printDebug("Dropping certification signatures without preceding user packet");
                    continue;
                  }
                  a2.issuerKeyID.equals(i2) ? r2.selfCertifications.push(a2) : r2.otherCertifications.push(a2);
                  break;
                case me.signature.certRevocation:
                  r2 ? r2.revocationSignatures.push(a2) : this.directSignatures.push(a2);
                  break;
                case me.signature.key:
                  this.directSignatures.push(a2);
                  break;
                case me.signature.subkeyBinding:
                  if (!n2) {
                    ce.printDebug("Dropping subkey binding signature without preceding subkey packet");
                    continue;
                  }
                  n2.bindingSignatures.push(a2);
                  break;
                case me.signature.keyRevocation:
                  this.revocationSignatures.push(a2);
                  break;
                case me.signature.subkeyRevocation:
                  if (!n2) {
                    ce.printDebug("Dropping subkey revocation signature without preceding subkey packet");
                    continue;
                  }
                  n2.revocationSignatures.push(a2);
              }
          }
        }
      }
      toPacketList() {
        const e2 = new so();
        return e2.push(this.keyPacket), e2.push(...this.revocationSignatures), e2.push(...this.directSignatures), this.users.map((t2) => e2.push(...t2.toPacketList())), this.subkeys.map((t2) => e2.push(...t2.toPacketList())), e2;
      }
      clone(e2 = false) {
        const t2 = new this.constructor(this.toPacketList());
        return e2 && t2.getKeys().forEach((e3) => {
          if (e3.keyPacket = Object.create(Object.getPrototypeOf(e3.keyPacket), Object.getOwnPropertyDescriptors(e3.keyPacket)), !e3.keyPacket.isDecrypted())
            return;
          const t3 = {};
          Object.keys(e3.keyPacket.privateParams).forEach((r2) => {
            t3[r2] = new Uint8Array(e3.keyPacket.privateParams[r2]);
          }), e3.keyPacket.privateParams = t3;
        }), t2;
      }
      getSubkeys(e2 = null) {
        return this.subkeys.filter((t2) => !e2 || t2.getKeyID().equals(e2, true));
      }
      getKeys(e2 = null) {
        const t2 = [];
        return e2 && !this.getKeyID().equals(e2, true) || t2.push(this), t2.concat(this.getSubkeys(e2));
      }
      getKeyIDs() {
        return this.getKeys().map((e2) => e2.getKeyID());
      }
      getUserIDs() {
        return this.users.map((e2) => e2.userID ? e2.userID.userID : null).filter((e2) => e2 !== null);
      }
      write() {
        return this.toPacketList().write();
      }
      async getSigningKey(e2 = null, t2 = new Date(), r2 = {}, i2 = ge) {
        await this.verifyPrimaryKey(t2, r2, i2);
        const n2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
        let s2;
        for (const r3 of a2)
          if (!e2 || r3.getKeyID().equals(e2))
            try {
              await r3.verify(t2, i2);
              const e3 = { key: n2, bind: r3.keyPacket }, a3 = await qo(r3.bindingSignatures, n2, me.signature.subkeyBinding, e3, t2, i2);
              if (!$o(r3.keyPacket, a3))
                continue;
              if (!a3.embeddedSignature)
                throw Error("Missing embedded signature");
              return await qo([a3.embeddedSignature], r3.keyPacket, me.signature.keyBinding, e3, t2, i2), Xo(r3.keyPacket, i2), r3;
            } catch (e3) {
              s2 = e3;
            }
        try {
          const a3 = await this.getPrimaryUser(t2, r2, i2);
          if ((!e2 || n2.getKeyID().equals(e2)) && $o(n2, a3.selfCertification))
            return Xo(n2, i2), this;
        } catch (e3) {
          s2 = e3;
        }
        throw ce.wrapError("Could not find valid signing key packet in key " + this.getKeyID().toHex(), s2);
      }
      async getEncryptionKey(e2, t2 = new Date(), r2 = {}, i2 = ge) {
        await this.verifyPrimaryKey(t2, r2, i2);
        const n2 = this.keyPacket, a2 = this.subkeys.slice().sort((e3, t3) => t3.keyPacket.created - e3.keyPacket.created);
        let s2;
        for (const r3 of a2)
          if (!e2 || r3.getKeyID().equals(e2))
            try {
              await r3.verify(t2, i2);
              const e3 = { key: n2, bind: r3.keyPacket }, a3 = await qo(r3.bindingSignatures, n2, me.signature.subkeyBinding, e3, t2, i2);
              if (Zo(r3.keyPacket, a3))
                return Xo(r3.keyPacket, i2), r3;
            } catch (e3) {
              s2 = e3;
            }
        try {
          const a3 = await this.getPrimaryUser(t2, r2, i2);
          if ((!e2 || n2.getKeyID().equals(e2)) && Zo(n2, a3.selfCertification))
            return Xo(n2, i2), this;
        } catch (e3) {
          s2 = e3;
        }
        throw ce.wrapError("Could not find valid encryption key packet in key " + this.getKeyID().toHex(), s2);
      }
      async isRevoked(e2, t2, r2 = new Date(), i2 = ge) {
        return Ho(this.keyPacket, me.signature.keyRevocation, { key: this.keyPacket }, this.revocationSignatures, e2, t2, r2, i2);
      }
      async verifyPrimaryKey(e2 = new Date(), t2 = {}, r2 = ge) {
        const i2 = this.keyPacket;
        if (await this.isRevoked(null, null, e2, r2))
          throw Error("Primary key is revoked");
        const { selfCertification: n2 } = await this.getPrimaryUser(e2, t2, r2);
        if (Oo(i2, n2, e2))
          throw Error("Primary key is expired");
        const a2 = await qo(this.directSignatures, i2, me.signature.key, { key: i2 }, e2, r2).catch(() => {
        });
        if (a2 && Oo(i2, a2, e2))
          throw Error("Primary key is expired");
      }
      async getExpirationTime(e2, t2 = ge) {
        let r2;
        try {
          const { selfCertification: i2 } = await this.getPrimaryUser(null, e2, t2), n2 = Go(this.keyPacket, i2), a2 = i2.getExpirationTime(), s2 = await qo(this.directSignatures, this.keyPacket, me.signature.key, { key: this.keyPacket }, null, t2).catch(() => {
          });
          if (s2) {
            const e3 = Go(this.keyPacket, s2);
            r2 = Math.min(n2, a2, e3);
          } else
            r2 = n2 < a2 ? n2 : a2;
        } catch (e3) {
          r2 = null;
        }
        return ce.normalizeDate(r2);
      }
      async getPrimaryUser(e2 = new Date(), t2 = {}, r2 = ge) {
        const i2 = this.keyPacket, n2 = [];
        let a2;
        for (let s3 = 0; s3 < this.users.length; s3++)
          try {
            const a3 = this.users[s3];
            if (!a3.userID)
              continue;
            if (t2.name !== void 0 && a3.userID.name !== t2.name || t2.email !== void 0 && a3.userID.email !== t2.email || t2.comment !== void 0 && a3.userID.comment !== t2.comment)
              throw Error("Could not find user that matches that user ID");
            const o3 = { userID: a3.userID, key: i2 }, c3 = await qo(a3.selfCertifications, i2, me.signature.certGeneric, o3, e2, r2);
            n2.push({ index: s3, user: a3, selfCertification: c3 });
          } catch (e3) {
            a2 = e3;
          }
        if (!n2.length)
          throw a2 || Error("Could not find primary user");
        await Promise.all(n2.map(async function(t3) {
          return t3.user.revoked || t3.user.isRevoked(t3.selfCertification, null, e2, r2);
        }));
        const s2 = n2.sort(function(e3, t3) {
          const r3 = e3.selfCertification, i3 = t3.selfCertification;
          return i3.revoked - r3.revoked || r3.isPrimaryUserID - i3.isPrimaryUserID || r3.created - i3.created;
        }).pop(), { user: o2, selfCertification: c2 } = s2;
        if (c2.revoked || await o2.isRevoked(c2, null, e2, r2))
          throw Error("Primary user is revoked");
        return s2;
      }
      async update(e2, t2 = new Date(), r2 = ge) {
        if (!this.hasSameFingerprintAs(e2))
          throw Error("Primary key fingerprints must be equal to update the key");
        if (!this.isPrivate() && e2.isPrivate()) {
          if (!(this.subkeys.length === e2.subkeys.length && this.subkeys.every((t3) => e2.subkeys.some((e3) => t3.hasSameFingerprintAs(e3)))))
            throw Error("Cannot update public key with private key if subkeys mismatch");
          return e2.update(this, r2);
        }
        const i2 = this.clone();
        return await Wo(e2, i2, "revocationSignatures", t2, (n2) => Ho(i2.keyPacket, me.signature.keyRevocation, i2, [n2], null, e2.keyPacket, t2, r2)), await Wo(e2, i2, "directSignatures", t2), await Promise.all(e2.users.map(async (e3) => {
          const n2 = i2.users.filter((t3) => e3.userID && e3.userID.equals(t3.userID) || e3.userAttribute && e3.userAttribute.equals(t3.userAttribute));
          if (n2.length > 0)
            await Promise.all(n2.map((i3) => i3.update(e3, t2, r2)));
          else {
            const t3 = e3.clone();
            t3.mainKey = i2, i2.users.push(t3);
          }
        })), await Promise.all(e2.subkeys.map(async (e3) => {
          const n2 = i2.subkeys.filter((t3) => t3.hasSameFingerprintAs(e3));
          if (n2.length > 0)
            await Promise.all(n2.map((i3) => i3.update(e3, t2, r2)));
          else {
            const t3 = e3.clone();
            t3.mainKey = i2, i2.subkeys.push(t3);
          }
        })), i2;
      }
      async getRevocationCertificate(e2 = new Date(), t2 = ge) {
        const r2 = { key: this.keyPacket }, i2 = await qo(this.revocationSignatures, this.keyPacket, me.signature.keyRevocation, r2, e2, t2), n2 = new so();
        return n2.push(i2), xe(me.armor.publicKey, n2.write(), null, null, "This is a revocation certificate");
      }
      async applyRevocationCertificate(e2, t2 = new Date(), r2 = ge) {
        const i2 = await Pe(e2, r2), n2 = (await so.fromBinary(i2.data, ec, r2)).findPacket(me.packet.signature);
        if (!n2 || n2.signatureType !== me.signature.keyRevocation)
          throw Error("Could not find revocation signature packet");
        if (!n2.issuerKeyID.equals(this.getKeyID()))
          throw Error("Revocation signature does not match key");
        try {
          await n2.verify(this.keyPacket, me.signature.keyRevocation, { key: this.keyPacket }, t2, void 0, r2);
        } catch (e3) {
          throw ce.wrapError("Could not verify revocation signature", e3);
        }
        const a2 = this.clone();
        return a2.revocationSignatures.push(n2), a2;
      }
      async signPrimaryUser(e2, t2, r2, i2 = ge) {
        const { index: n2, user: a2 } = await this.getPrimaryUser(t2, r2, i2), s2 = await a2.certify(e2, t2, i2), o2 = this.clone();
        return o2.users[n2] = s2, o2;
      }
      async signAllUsers(e2, t2 = new Date(), r2 = ge) {
        const i2 = this.clone();
        return i2.users = await Promise.all(this.users.map(function(i3) {
          return i3.certify(e2, t2, r2);
        })), i2;
      }
      async verifyPrimaryUser(e2, t2 = new Date(), r2, i2 = ge) {
        const n2 = this.keyPacket, { user: a2 } = await this.getPrimaryUser(t2, r2, i2);
        return e2 ? await a2.verifyAllCertifications(e2, t2, i2) : [{ keyID: n2.getKeyID(), valid: await a2.verify(t2, i2).catch(() => false) }];
      }
      async verifyAllUsers(e2, t2 = new Date(), r2 = ge) {
        const i2 = this.keyPacket, n2 = [];
        return await Promise.all(this.users.map(async (a2) => {
          const s2 = e2 ? await a2.verifyAllCertifications(e2, t2, r2) : [{ keyID: i2.getKeyID(), valid: await a2.verify(t2, r2).catch(() => false) }];
          n2.push(...s2.map((e3) => ({ userID: a2.userID.userID, keyID: e3.keyID, valid: e3.valid })));
        })), n2;
      }
    };
    function rc(e2) {
      for (const t2 of e2)
        switch (t2.constructor.tag) {
          case me.packet.secretKey:
            return new nc(e2);
          case me.packet.publicKey:
            return new ic(e2);
        }
      throw Error("No key packet found");
    }
    ["getKeyID", "getFingerprint", "getAlgorithmInfo", "getCreationTime", "hasSameFingerprintAs"].forEach((e2) => {
      tc2.prototype[e2] = Jo.prototype[e2];
    });
    var ic = class extends tc2 {
      constructor(e2) {
        if (super(), this.keyPacket = null, this.revocationSignatures = [], this.directSignatures = [], this.users = [], this.subkeys = [], e2 && (this.packetListToStructure(e2, /* @__PURE__ */ new Set([me.packet.secretKey, me.packet.secretSubkey])), !this.keyPacket))
          throw Error("Invalid key: missing public-key packet");
      }
      isPrivate() {
        return false;
      }
      toPublic() {
        return this;
      }
      armor(e2 = ge) {
        return xe(me.armor.publicKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
      }
    };
    var nc = class extends ic {
      constructor(e2) {
        if (super(), this.packetListToStructure(e2, /* @__PURE__ */ new Set([me.packet.publicKey, me.packet.publicSubkey])), !this.keyPacket)
          throw Error("Invalid key: missing private-key packet");
      }
      isPrivate() {
        return true;
      }
      toPublic() {
        const e2 = new so(), t2 = this.toPacketList();
        for (const r2 of t2)
          switch (r2.constructor.tag) {
            case me.packet.secretKey: {
              const t3 = So.fromSecretKeyPacket(r2);
              e2.push(t3);
              break;
            }
            case me.packet.secretSubkey: {
              const t3 = xo.fromSecretSubkeyPacket(r2);
              e2.push(t3);
              break;
            }
            default:
              e2.push(r2);
          }
        return new ic(e2);
      }
      armor(e2 = ge) {
        return xe(me.armor.privateKey, this.toPacketList().write(), void 0, void 0, void 0, e2);
      }
      async getDecryptionKeys(e2, t2 = new Date(), r2 = {}, i2 = ge) {
        const n2 = this.keyPacket, a2 = [];
        for (let r3 = 0; r3 < this.subkeys.length; r3++)
          if (!e2 || this.subkeys[r3].getKeyID().equals(e2, true))
            try {
              const e3 = { key: n2, bind: this.subkeys[r3].keyPacket };
              Yo(await qo(this.subkeys[r3].bindingSignatures, n2, me.signature.subkeyBinding, e3, t2, i2), i2) && a2.push(this.subkeys[r3]);
            } catch (e3) {
            }
        const s2 = await this.getPrimaryUser(t2, r2, i2);
        return e2 && !n2.getKeyID().equals(e2, true) || !Yo(s2.selfCertification, i2) || a2.push(this), a2;
      }
      isDecrypted() {
        return this.getKeys().some(({ keyPacket: e2 }) => e2.isDecrypted());
      }
      async validate(e2 = ge) {
        if (!this.isPrivate())
          throw Error("Cannot validate a public key");
        let t2;
        if (this.keyPacket.isDummy()) {
          const r2 = await this.getSigningKey(null, null, void 0, __spreadProps(__spreadValues({}, e2), { rejectPublicKeyAlgorithms: /* @__PURE__ */ new Set(), minRSABits: 0 }));
          r2 && !r2.keyPacket.isDummy() && (t2 = r2.keyPacket);
        } else
          t2 = this.keyPacket;
        if (t2)
          return t2.validate();
        {
          const e3 = this.getKeys();
          if (e3.map((e4) => e4.keyPacket.isDummy()).every(Boolean))
            throw Error("Cannot validate an all-gnu-dummy key");
          return Promise.all(e3.map(async (e4) => e4.keyPacket.validate()));
        }
      }
      clearPrivateParams() {
        this.getKeys().forEach(({ keyPacket: e2 }) => {
          e2.isDecrypted() && e2.clearPrivateParams();
        });
      }
      async revoke({ flag: e2 = me.reasonForRevocation.noReason, string: t2 = "" } = {}, r2 = new Date(), i2 = ge) {
        if (!this.isPrivate())
          throw Error("Need private key for revoking");
        const n2 = { key: this.keyPacket }, a2 = this.clone();
        return a2.revocationSignatures.push(await Lo(n2, null, this.keyPacket, { signatureType: me.signature.keyRevocation, reasonForRevocationFlag: me.write(me.reasonForRevocation, e2), reasonForRevocationString: t2 }, r2, void 0, void 0, i2)), a2;
      }
      async addSubkey(e2 = {}) {
        const t2 = __spreadValues(__spreadValues({}, ge), e2.config);
        if (e2.passphrase)
          throw Error("Subkey could not be encrypted here, please encrypt whole key");
        if (e2.rsaBits < t2.minRSABits)
          throw Error(`rsaBits should be at least ${t2.minRSABits}, got: ${e2.rsaBits}`);
        const r2 = this.keyPacket;
        if (r2.isDummy())
          throw Error("Cannot add subkey to gnu-dummy primary key");
        if (!r2.isDecrypted())
          throw Error("Key is not decrypted");
        const i2 = r2.getAlgorithmInfo();
        i2.type = i2.curve ? "ecc" : "rsa", i2.rsaBits = i2.bits || 4096, i2.curve = i2.curve || "curve25519", e2 = Vo(e2, i2);
        const n2 = await To(e2);
        Xo(n2, t2);
        const a2 = await Fo(n2, r2, e2, t2), s2 = this.toPacketList();
        return s2.push(n2, a2), new nc(s2);
      }
    };
    var ac = /* @__PURE__ */ ce.constructAllowedPackets([So, xo, Co, Io, Ro, Mo, ro]);
    async function sc(e2, t2, r2, i2) {
      r2.passphrase && await e2.encrypt(r2.passphrase, i2), await Promise.all(t2.map(async function(e3, t3) {
        const n3 = r2.subkeys[t3].passphrase;
        n3 && await e3.encrypt(n3, i2);
      }));
      const n2 = new so();
      n2.push(e2), await Promise.all(r2.userIDs.map(async function(t3, n3) {
        function a3(e3, t4) {
          return [t4, ...e3.filter((e4) => e4 !== t4)];
        }
        const s2 = Ro.fromObject(t3), o2 = {};
        o2.userID = s2, o2.key = e2;
        const c2 = new ro();
        return c2.signatureType = me.signature.certGeneric, c2.publicKeyAlgorithm = e2.algorithm, c2.hashAlgorithm = await No(null, e2, void 0, void 0, i2), c2.keyFlags = [me.keyFlags.certifyKeys | me.keyFlags.signData], c2.preferredSymmetricAlgorithms = a3([me.symmetric.aes256, me.symmetric.aes128, me.symmetric.aes192], i2.preferredSymmetricAlgorithm), i2.aeadProtect && (c2.preferredAEADAlgorithms = a3([me.aead.eax, me.aead.ocb], i2.preferredAEADAlgorithm)), c2.preferredHashAlgorithms = a3([me.hash.sha256, me.hash.sha512], i2.preferredHashAlgorithm), c2.preferredCompressionAlgorithms = a3([me.compression.zlib, me.compression.zip, me.compression.uncompressed], i2.preferredCompressionAlgorithm), n3 === 0 && (c2.isPrimaryUserID = true), c2.features = [0], c2.features[0] |= me.features.modificationDetection, i2.aeadProtect && (c2.features[0] |= me.features.aead), i2.v5Keys && (c2.features[0] |= me.features.v5Keys), r2.keyExpirationTime > 0 && (c2.keyExpirationTime = r2.keyExpirationTime, c2.keyNeverExpires = false), await c2.sign(e2, o2, r2.date), { userIDPacket: s2, signaturePacket: c2 };
      })).then((e3) => {
        e3.forEach(({ userIDPacket: e4, signaturePacket: t3 }) => {
          n2.push(e4), n2.push(t3);
        });
      }), await Promise.all(t2.map(async function(t3, n3) {
        const a3 = r2.subkeys[n3];
        return { secretSubkeyPacket: t3, subkeySignaturePacket: await Fo(t3, e2, a3, i2) };
      })).then((e3) => {
        e3.forEach(({ secretSubkeyPacket: e4, subkeySignaturePacket: t3 }) => {
          n2.push(e4), n2.push(t3);
        });
      });
      const a2 = { key: e2 };
      return n2.push(await Lo(a2, null, e2, { signatureType: me.signature.keyRevocation, reasonForRevocationFlag: me.reasonForRevocation.noReason, reasonForRevocationString: "" }, r2.date, void 0, void 0, i2)), r2.passphrase && e2.clearPrivateParams(), await Promise.all(t2.map(async function(e3, t3) {
        r2.subkeys[t3].passphrase && e3.clearPrivateParams();
      })), new nc(n2);
    }
    var oc = /* @__PURE__ */ ce.constructAllowedPackets([Hs, co, vo, go, Po, _o, Ao, no, ro]);
    var cc = /* @__PURE__ */ ce.constructAllowedPackets([Ao]);
    var uc = /* @__PURE__ */ ce.constructAllowedPackets([ro]);
    var hc = class {
      constructor(e2) {
        this.packets = e2 || new so();
      }
      getEncryptionKeyIDs() {
        const e2 = [];
        return this.packets.filterByTag(me.packet.publicKeyEncryptedSessionKey).forEach(function(t2) {
          e2.push(t2.publicKeyID);
        }), e2;
      }
      getSigningKeyIDs() {
        const e2 = this.unwrapCompressed(), t2 = e2.packets.filterByTag(me.packet.onePassSignature);
        if (t2.length > 0)
          return t2.map((e3) => e3.issuerKeyID);
        return e2.packets.filterByTag(me.packet.signature).map((e3) => e3.issuerKeyID);
      }
      async decrypt(e2, t2, r2, i2 = new Date(), n2 = ge) {
        const a2 = r2 || await this.decryptSessionKeys(e2, t2, i2, n2), s2 = this.packets.filterByTag(me.packet.symmetricallyEncryptedData, me.packet.symEncryptedIntegrityProtectedData, me.packet.aeadEncryptedData);
        if (s2.length === 0)
          return this;
        const o2 = s2[0];
        let c2 = null;
        const u2 = Promise.all(a2.map(async ({ algorithm: e3, data: t3 }) => {
          if (!ce.isUint8Array(t3) || !ce.isString(e3))
            throw Error("Invalid session key for decryption.");
          try {
            const r3 = me.write(me.symmetric, e3);
            await o2.decrypt(r3, t3, n2);
          } catch (e4) {
            ce.printDebugError(e4), c2 = e4;
          }
        }));
        if (ne(o2.encrypted), o2.encrypted = null, await u2, !o2.packets || !o2.packets.length)
          throw c2 || Error("Decryption failed.");
        const h2 = new hc(o2.packets);
        return o2.packets = new so(), h2;
      }
      async decryptSessionKeys(e2, t2, r2 = new Date(), i2 = ge) {
        let n2, a2 = [];
        if (t2) {
          const e3 = this.packets.filterByTag(me.packet.symEncryptedSessionKey);
          if (e3.length === 0)
            throw Error("No symmetrically encrypted session key packet found.");
          await Promise.all(t2.map(async function(t3, r3) {
            let n3;
            n3 = r3 ? await so.fromBinary(e3.write(), cc, i2) : e3, await Promise.all(n3.map(async function(e4) {
              try {
                await e4.decrypt(t3), a2.push(e4);
              } catch (e5) {
                ce.printDebugError(e5);
              }
            }));
          }));
        } else {
          if (!e2)
            throw Error("No key or password specified.");
          {
            const t3 = this.packets.filterByTag(me.packet.publicKeyEncryptedSessionKey);
            if (t3.length === 0)
              throw Error("No public key encrypted session key packet found.");
            await Promise.all(t3.map(async function(t4) {
              await Promise.all(e2.map(async function(e3) {
                let s2 = [me.symmetric.aes256, me.symmetric.aes128, me.symmetric.tripledes, me.symmetric.cast5];
                try {
                  const t5 = await e3.getPrimaryUser(r2, void 0, i2);
                  t5.selfCertification.preferredSymmetricAlgorithms && (s2 = s2.concat(t5.selfCertification.preferredSymmetricAlgorithms));
                } catch (e4) {
                }
                const o2 = (await e3.getDecryptionKeys(t4.publicKeyID, null, void 0, i2)).map((e4) => e4.keyPacket);
                await Promise.all(o2.map(async function(e4) {
                  if (!e4 || e4.isDummy())
                    return;
                  if (!e4.isDecrypted())
                    throw Error("Decryption key is not decrypted.");
                  if (i2.constantTimePKCS1Decryption && (t4.publicKeyAlgorithm === me.publicKey.rsaEncrypt || t4.publicKeyAlgorithm === me.publicKey.rsaEncryptSign || t4.publicKeyAlgorithm === me.publicKey.rsaSign || t4.publicKeyAlgorithm === me.publicKey.elgamal)) {
                    const r3 = t4.write();
                    await Promise.all(Array.from(i2.constantTimePKCS1DecryptionSupportedSymmetricAlgorithms).map(async (t5) => {
                      const i3 = new _o();
                      i3.read(r3);
                      const s3 = { sessionKeyAlgorithm: t5, sessionKey: await $n.generateSessionKey(t5) };
                      try {
                        await i3.decrypt(e4, s3), a2.push(i3);
                      } catch (e5) {
                        ce.printDebugError(e5), n2 = e5;
                      }
                    }));
                  } else
                    try {
                      if (await t4.decrypt(e4), !s2.includes(me.write(me.symmetric, t4.sessionKeyAlgorithm)))
                        throw Error("A non-preferred symmetric algorithm was used.");
                      a2.push(t4);
                    } catch (e5) {
                      ce.printDebugError(e5), n2 = e5;
                    }
                }));
              })), ne(t4.encrypted), t4.encrypted = null;
            }));
          }
        }
        if (a2.length > 0) {
          if (a2.length > 1) {
            const e3 = /* @__PURE__ */ new Set();
            a2 = a2.filter((t3) => {
              const r3 = t3.sessionKeyAlgorithm + ce.uint8ArrayToString(t3.sessionKey);
              return !e3.has(r3) && (e3.add(r3), true);
            });
          }
          return a2.map((e3) => ({ data: e3.sessionKey, algorithm: me.read(me.symmetric, e3.sessionKeyAlgorithm) }));
        }
        throw n2 || Error("Session key decryption failed.");
      }
      getLiteralData() {
        const e2 = this.unwrapCompressed().packets.findPacket(me.packet.literalData);
        return e2 && e2.getBytes() || null;
      }
      getFilename() {
        const e2 = this.unwrapCompressed().packets.findPacket(me.packet.literalData);
        return e2 && e2.getFilename() || null;
      }
      getText() {
        const e2 = this.unwrapCompressed().packets.findPacket(me.packet.literalData);
        return e2 ? e2.getText() : null;
      }
      static async generateSessionKey(e2 = [], t2 = new Date(), r2 = [], i2 = ge) {
        const n2 = await jo("symmetric", e2, t2, r2, i2), a2 = me.read(me.symmetric, n2), s2 = i2.aeadProtect && await async function(e3, t3 = new Date(), r3 = [], i3 = ge) {
          let n3 = true;
          return await Promise.all(e3.map(async function(e4, a3) {
            const s3 = await e4.getPrimaryUser(t3, r3[a3], i3);
            s3.selfCertification.features && s3.selfCertification.features[0] & me.features.aead || (n3 = false);
          })), n3;
        }(e2, t2, r2, i2) ? me.read(me.aead, await jo("aead", e2, t2, r2, i2)) : void 0;
        return { data: await $n.generateSessionKey(n2), algorithm: a2, aeadAlgorithm: s2 };
      }
      async encrypt(e2, t2, r2, i2 = false, n2 = [], a2 = new Date(), s2 = [], o2 = ge) {
        if (r2) {
          if (!ce.isUint8Array(r2.data) || !ce.isString(r2.algorithm))
            throw Error("Invalid session key for encryption.");
        } else if (e2 && e2.length)
          r2 = await hc.generateSessionKey(e2, a2, s2, o2);
        else {
          if (!t2 || !t2.length)
            throw Error("No keys, passwords, or session key provided.");
          r2 = await hc.generateSessionKey(void 0, void 0, void 0, o2);
        }
        const { data: c2, algorithm: u2, aeadAlgorithm: h2 } = r2, f2 = await hc.encryptSessionKey(c2, u2, h2, e2, t2, i2, n2, a2, s2, o2);
        let d2;
        h2 ? (d2 = new vo(), d2.aeadAlgorithm = me.write(me.aead, h2)) : d2 = new go(), d2.packets = this.packets;
        const l2 = me.write(me.symmetric, u2);
        return await d2.encrypt(l2, c2, o2), f2.packets.push(d2), d2.packets = new so(), f2;
      }
      static async encryptSessionKey(e2, t2, r2, i2, n2, a2 = false, s2 = [], o2 = new Date(), c2 = [], u2 = ge) {
        const h2 = new so(), f2 = me.write(me.symmetric, t2), d2 = r2 && me.write(me.aead, r2);
        if (i2) {
          const t3 = await Promise.all(i2.map(async function(t4, r3) {
            const i3 = await t4.getEncryptionKey(s2[r3], o2, c2, u2), n3 = new _o();
            return n3.publicKeyID = a2 ? Me.wildcard() : i3.getKeyID(), n3.publicKeyAlgorithm = i3.keyPacket.algorithm, n3.sessionKey = e2, n3.sessionKeyAlgorithm = f2, await n3.encrypt(i3.keyPacket), delete n3.sessionKey, n3;
          }));
          h2.push(...t3);
        }
        if (n2) {
          const t3 = async function(e3, t4) {
            try {
              return await e3.decrypt(t4), 1;
            } catch (e4) {
              return 0;
            }
          }, r3 = (e3, t4) => e3 + t4, i3 = async function(e3, a4, s3, o3) {
            const c3 = new Ao(u2);
            if (c3.sessionKey = e3, c3.sessionKeyAlgorithm = a4, s3 && (c3.aeadAlgorithm = s3), await c3.encrypt(o3, u2), u2.passwordCollisionCheck) {
              if ((await Promise.all(n2.map((e4) => t3(c3, e4)))).reduce(r3) !== 1)
                return i3(e3, a4, o3);
            }
            return delete c3.sessionKey, c3;
          }, a3 = await Promise.all(n2.map((t4) => i3(e2, f2, d2, t4)));
          h2.push(...a3);
        }
        return new hc(h2);
      }
      async sign(e2 = [], t2 = null, r2 = [], i2 = new Date(), n2 = [], a2 = ge) {
        const s2 = new so(), o2 = this.packets.findPacket(me.packet.literalData);
        if (!o2)
          throw Error("No literal data packet to sign.");
        let c2, u2;
        const h2 = o2.text === null ? me.signature.binary : me.signature.text;
        if (t2)
          for (u2 = t2.packets.filterByTag(me.packet.signature), c2 = u2.length - 1; c2 >= 0; c2--) {
            const t3 = u2[c2], r3 = new no();
            r3.signatureType = t3.signatureType, r3.hashAlgorithm = t3.hashAlgorithm, r3.publicKeyAlgorithm = t3.publicKeyAlgorithm, r3.issuerKeyID = t3.issuerKeyID, e2.length || c2 !== 0 || (r3.flags = 1), s2.push(r3);
          }
        return await Promise.all(Array.from(e2).reverse().map(async function(t3, s3) {
          if (!t3.isPrivate())
            throw Error("Need private key for signing");
          const o3 = r2[e2.length - 1 - s3], c3 = await t3.getSigningKey(o3, i2, n2, a2), u3 = new no();
          return u3.signatureType = h2, u3.hashAlgorithm = await No(t3, c3.keyPacket, i2, n2, a2), u3.publicKeyAlgorithm = c3.keyPacket.algorithm, u3.issuerKeyID = c3.getKeyID(), s3 === e2.length - 1 && (u3.flags = 1), u3;
        })).then((e3) => {
          e3.forEach((e4) => s2.push(e4));
        }), s2.push(o2), s2.push(...await fc(o2, e2, t2, r2, i2, n2, false, a2)), new hc(s2);
      }
      compress(e2, t2 = ge) {
        if (e2 === me.compression.uncompressed)
          return this;
        const r2 = new co(t2);
        r2.algorithm = e2, r2.packets = this.packets;
        const i2 = new so();
        return i2.push(r2), new hc(i2);
      }
      async signDetached(e2 = [], t2 = null, r2 = [], i2 = new Date(), n2 = [], a2 = ge) {
        const s2 = this.packets.findPacket(me.packet.literalData);
        if (!s2)
          throw Error("No literal data packet to sign.");
        return new Bo(await fc(s2, e2, t2, r2, i2, n2, true, a2));
      }
      async verify(e2, t2 = new Date(), r2 = ge) {
        const i2 = this.unwrapCompressed(), n2 = i2.packets.filterByTag(me.packet.literalData);
        if (n2.length !== 1)
          throw Error("Can only verify message with one literal data packet.");
        _(i2.packets.stream) && i2.packets.push(...await ie(i2.packets.stream, (e3) => e3 || []));
        const a2 = i2.packets.filterByTag(me.packet.onePassSignature).reverse(), s2 = i2.packets.filterByTag(me.packet.signature);
        return a2.length && !s2.length && ce.isStream(i2.packets.stream) && !_(i2.packets.stream) ? (await Promise.all(a2.map(async (e3) => {
          e3.correspondingSig = new Promise((t3, r3) => {
            e3.correspondingSigResolve = t3, e3.correspondingSigReject = r3;
          }), e3.signatureData = ae(async () => (await e3.correspondingSig).signatureData), e3.hashed = ie(await e3.hash(e3.signatureType, n2[0], void 0, false)), e3.hashed.catch(() => {
          });
        })), i2.packets.stream = X(i2.packets.stream, async (e3, t3) => {
          const r3 = H(e3), i3 = G(t3);
          try {
            for (let e4 = 0; e4 < a2.length; e4++) {
              const { value: t4 } = await r3.read();
              a2[e4].correspondingSigResolve(t4);
            }
            await r3.readToEnd(), await i3.ready, await i3.close();
          } catch (e4) {
            a2.forEach((t4) => {
              t4.correspondingSigReject(e4);
            }), await i3.abort(e4);
          }
        }), dc(a2, n2, e2, t2, false, r2)) : dc(s2, n2, e2, t2, false, r2);
      }
      verifyDetached(e2, t2, r2 = new Date(), i2 = ge) {
        const n2 = this.unwrapCompressed().packets.filterByTag(me.packet.literalData);
        if (n2.length !== 1)
          throw Error("Can only verify message with one literal data packet.");
        return dc(e2.packets, n2, t2, r2, true, i2);
      }
      unwrapCompressed() {
        const e2 = this.packets.filterByTag(me.packet.compressedData);
        return e2.length ? new hc(e2[0].packets) : this;
      }
      async appendSignature(e2, t2 = ge) {
        await this.packets.read(ce.isUint8Array(e2) ? e2 : (await Pe(e2)).data, uc, t2);
      }
      write() {
        return this.packets.write();
      }
      armor(e2 = ge) {
        return xe(me.armor.message, this.write(), null, null, null, e2);
      }
    };
    async function fc(e2, t2, r2 = null, i2 = [], n2 = new Date(), a2 = [], s2 = false, o2 = ge) {
      const c2 = new so(), u2 = e2.text === null ? me.signature.binary : me.signature.text;
      if (await Promise.all(t2.map(async (t3, r3) => {
        const c3 = a2[r3];
        if (!t3.isPrivate())
          throw Error("Need private key for signing");
        const h2 = await t3.getSigningKey(i2[r3], n2, c3, o2);
        return Lo(e2, t3, h2.keyPacket, { signatureType: u2 }, n2, c3, s2, o2);
      })).then((e3) => {
        c2.push(...e3);
      }), r2) {
        const e3 = r2.packets.filterByTag(me.packet.signature);
        c2.push(...e3);
      }
      return c2;
    }
    async function dc(e2, t2, r2, i2 = new Date(), n2 = false, a2 = ge) {
      return Promise.all(e2.filter(function(e3) {
        return ["text", "binary"].includes(me.read(me.signature, e3.signatureType));
      }).map(async function(e3) {
        return async function(e4, t3, r3, i3 = new Date(), n3 = false, a3 = ge) {
          let s2, o2;
          for (const t4 of r3) {
            const r4 = t4.getKeys(e4.issuerKeyID);
            if (r4.length > 0) {
              s2 = t4, o2 = r4[0];
              break;
            }
          }
          const c2 = e4 instanceof no ? e4.correspondingSig : e4, u2 = { keyID: e4.issuerKeyID, verified: (async () => {
            if (!o2)
              throw Error("Could not find signing key with key ID " + e4.issuerKeyID.toHex());
            await e4.verify(o2.keyPacket, e4.signatureType, t3[0], i3, n3, a3);
            const r4 = await c2;
            if (o2.getCreationTime() > r4.created)
              throw Error("Key is newer than the signature");
            try {
              await s2.getSigningKey(o2.getKeyID(), r4.created, void 0, a3);
            } catch (e5) {
              if (!a3.allowInsecureVerificationWithReformattedKeys || !e5.message.match(/Signature creation time is in the future/))
                throw e5;
              await s2.getSigningKey(o2.getKeyID(), i3, void 0, a3);
            }
            return true;
          })(), signature: (async () => {
            const e5 = await c2, t4 = new so();
            return e5 && t4.push(e5), new Bo(t4);
          })() };
          return u2.signature.catch(() => {
          }), u2.verified.catch(() => {
          }), u2;
        }(e3, t2, r2, i2, n2, a2);
      }));
    }
    var lc = /* @__PURE__ */ ce.constructAllowedPackets([ro]);
    var pc = class {
      constructor(e2, t2) {
        if (this.text = ce.removeTrailingSpaces(e2).replace(/\r?\n/g, "\r\n"), t2 && !(t2 instanceof Bo))
          throw Error("Invalid signature input");
        this.signature = t2 || new Bo(new so());
      }
      getSigningKeyIDs() {
        const e2 = [];
        return this.signature.packets.forEach(function(t2) {
          e2.push(t2.issuerKeyID);
        }), e2;
      }
      async sign(e2, t2 = null, r2 = [], i2 = new Date(), n2 = [], a2 = ge) {
        const s2 = new Hs();
        s2.setText(this.text);
        const o2 = new Bo(await fc(s2, e2, t2, r2, i2, n2, true, a2));
        return new pc(this.text, o2);
      }
      verify(e2, t2 = new Date(), r2 = ge) {
        const i2 = this.signature.packets, n2 = new Hs();
        return n2.setText(this.text), dc(i2, [n2], e2, t2, true, r2);
      }
      getText() {
        return this.text.replace(/\r\n/g, "\n");
      }
      armor(e2 = ge) {
        let t2 = this.signature.packets.map(function(e3) {
          return me.read(me.hash, e3.hashAlgorithm).toUpperCase();
        });
        t2 = t2.filter(function(e3, t3, r3) {
          return r3.indexOf(e3) === t3;
        });
        const r2 = { hash: t2.join(), text: this.text, data: this.signature.packets.write() };
        return xe(me.armor.signed, r2, void 0, void 0, void 0, e2);
      }
    };
    function yc(e2) {
      if (!(e2 instanceof hc))
        throw Error("Parameter [message] needs to be of type Message");
    }
    function bc(e2) {
      if (!(e2 instanceof pc || e2 instanceof hc))
        throw Error("Parameter [message] needs to be of type Message or CleartextMessage");
    }
    function mc(e2) {
      if (e2 !== "armored" && e2 !== "binary" && e2 !== "object")
        throw Error("Unsupported format " + e2);
    }
    var gc = Object.keys(ge).length;
    function wc(e2) {
      const t2 = Object.keys(e2);
      if (t2.length !== gc) {
        for (const e3 of t2)
          if (ge[e3] === void 0)
            throw Error("Unknown config property: " + e3);
      }
    }
    function vc(e2) {
      return e2 && !ce.isArray(e2) && (e2 = [e2]), e2;
    }
    async function _c(e2, t2, r2 = "utf8") {
      const i2 = ce.isStream(e2);
      return i2 === "array" ? ie(e2) : t2 === "node" ? (e2 = D(e2), r2 !== "binary" && e2.setEncoding(r2), e2) : t2 === "web" && i2 === "ponyfill" ? T(e2) : e2;
    }
    function kc(e2, t2) {
      e2.data = X(t2.packets.stream, async (t3, r2) => {
        await V(e2.data, r2, { preventClose: true });
        const i2 = G(r2);
        try {
          await ie(t3, (e3) => e3), await i2.close();
        } catch (e3) {
          await i2.abort(e3);
        }
      });
    }
    function Ac(e2, t2, r2) {
      switch (t2) {
        case "object":
          return e2;
        case "armored":
          return e2.armor(r2);
        case "binary":
          return e2.write();
        default:
          throw Error("Unsupported format " + t2);
      }
    }
    var Sc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol : (e2) => `Symbol(${e2})`;
    function Ec() {
    }
    var Pc = typeof self != "undefined" ? self : typeof window != "undefined" ? window : typeof global != "undefined" ? global : void 0;
    function xc(e2) {
      return typeof e2 == "object" && e2 !== null || typeof e2 == "function";
    }
    var Mc = Ec;
    var Cc = Promise;
    var Kc = Promise.prototype.then;
    var Dc = Promise.resolve.bind(Cc);
    var Rc = Promise.reject.bind(Cc);
    function Ic(e2) {
      return new Cc(e2);
    }
    function Uc(e2) {
      return Dc(e2);
    }
    function Bc(e2) {
      return Rc(e2);
    }
    function Tc(e2, t2, r2) {
      return Kc.call(e2, t2, r2);
    }
    function zc(e2, t2, r2) {
      Tc(Tc(e2, t2, r2), void 0, Mc);
    }
    function qc(e2, t2) {
      zc(e2, t2);
    }
    function Oc(e2, t2) {
      zc(e2, void 0, t2);
    }
    function Fc(e2, t2, r2) {
      return Tc(e2, t2, r2);
    }
    function Nc(e2) {
      Tc(e2, void 0, Mc);
    }
    var jc = (() => {
      const e2 = Pc && Pc.queueMicrotask;
      if (typeof e2 == "function")
        return e2;
      const t2 = Uc(void 0);
      return (e3) => Tc(t2, e3);
    })();
    function Lc(e2, t2, r2) {
      if (typeof e2 != "function")
        throw new TypeError("Argument is not a function");
      return Function.prototype.apply.call(e2, t2, r2);
    }
    function Wc(e2, t2, r2) {
      try {
        return Uc(Lc(e2, t2, r2));
      } catch (e3) {
        return Bc(e3);
      }
    }
    var Hc = class {
      constructor() {
        this._cursor = 0, this._size = 0, this._front = { _elements: [], _next: void 0 }, this._back = this._front, this._cursor = 0, this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(e2) {
        const t2 = this._back;
        let r2 = t2;
        t2._elements.length === 16383 && (r2 = { _elements: [], _next: void 0 }), t2._elements.push(e2), r2 !== t2 && (this._back = r2, t2._next = r2), ++this._size;
      }
      shift() {
        const e2 = this._front;
        let t2 = e2;
        const r2 = this._cursor;
        let i2 = r2 + 1;
        const n2 = e2._elements, a2 = n2[r2];
        return i2 === 16384 && (t2 = e2._next, i2 = 0), --this._size, this._cursor = i2, e2 !== t2 && (this._front = t2), n2[r2] = void 0, a2;
      }
      forEach(e2) {
        let t2 = this._cursor, r2 = this._front, i2 = r2._elements;
        for (; !(t2 === i2.length && r2._next === void 0 || t2 === i2.length && (r2 = r2._next, i2 = r2._elements, t2 = 0, i2.length === 0)); )
          e2(i2[t2]), ++t2;
      }
      peek() {
        const e2 = this._front, t2 = this._cursor;
        return e2._elements[t2];
      }
    };
    function Gc(e2, t2) {
      e2._ownerReadableStream = t2, t2._reader = e2, t2._state === "readable" ? Yc(e2) : t2._state === "closed" ? function(e3) {
        Yc(e3), Jc(e3);
      }(e2) : Xc(e2, t2._storedError);
    }
    function Vc(e2, t2) {
      return Df(e2._ownerReadableStream, t2);
    }
    function $c(e2) {
      e2._ownerReadableStream._state === "readable" ? Qc(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e3, t2) {
        Xc(e3, t2);
      }(e2, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e2._ownerReadableStream._reader = void 0, e2._ownerReadableStream = void 0;
    }
    function Zc(e2) {
      return new TypeError("Cannot " + e2 + " a stream using a released reader");
    }
    function Yc(e2) {
      e2._closedPromise = Ic((t2, r2) => {
        e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2;
      });
    }
    function Xc(e2, t2) {
      Yc(e2), Qc(e2, t2);
    }
    function Qc(e2, t2) {
      e2._closedPromise_reject !== void 0 && (Nc(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
    }
    function Jc(e2) {
      e2._closedPromise_resolve !== void 0 && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0);
    }
    var eu = Sc("[[AbortSteps]]");
    var tu = Sc("[[ErrorSteps]]");
    var ru = Sc("[[CancelSteps]]");
    var iu = Sc("[[PullSteps]]");
    var nu = Number.isFinite || function(e2) {
      return typeof e2 == "number" && isFinite(e2);
    };
    var au = Math.trunc || function(e2) {
      return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
    };
    function su(e2, t2) {
      if (e2 !== void 0 && (typeof (r2 = e2) != "object" && typeof r2 != "function"))
        throw new TypeError(t2 + " is not an object.");
      var r2;
    }
    function ou(e2, t2) {
      if (typeof e2 != "function")
        throw new TypeError(t2 + " is not a function.");
    }
    function cu(e2, t2) {
      if (!function(e3) {
        return typeof e3 == "object" && e3 !== null || typeof e3 == "function";
      }(e2))
        throw new TypeError(t2 + " is not an object.");
    }
    function uu(e2, t2, r2) {
      if (e2 === void 0)
        throw new TypeError(`Parameter ${t2} is required in '${r2}'.`);
    }
    function hu(e2, t2, r2) {
      if (e2 === void 0)
        throw new TypeError(`${t2} is required in '${r2}'.`);
    }
    function fu(e2) {
      return Number(e2);
    }
    function du(e2) {
      return e2 === 0 ? 0 : e2;
    }
    function lu(e2, t2) {
      const r2 = Number.MAX_SAFE_INTEGER;
      let i2 = Number(e2);
      if (i2 = du(i2), !nu(i2))
        throw new TypeError(t2 + " is not a finite number");
      if (i2 = function(e3) {
        return du(au(e3));
      }(i2), i2 < 0 || i2 > r2)
        throw new TypeError(`${t2} is outside the accepted range of 0 to ${r2}, inclusive`);
      return nu(i2) && i2 !== 0 ? i2 : 0;
    }
    function pu(e2, t2) {
      if (!Cf(e2))
        throw new TypeError(t2 + " is not a ReadableStream.");
    }
    function yu(e2) {
      return new vu(e2);
    }
    function bu(e2, t2) {
      e2._reader._readRequests.push(t2);
    }
    function mu(e2, t2, r2) {
      const i2 = e2._reader._readRequests.shift();
      r2 ? i2._closeSteps() : i2._chunkSteps(t2);
    }
    function gu(e2) {
      return e2._reader._readRequests.length;
    }
    function wu(e2) {
      const t2 = e2._reader;
      return t2 !== void 0 && !!_u(t2);
    }
    var vu = class {
      constructor(e2) {
        if (uu(e2, 1, "ReadableStreamDefaultReader"), pu(e2, "First parameter"), Kf(e2))
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        Gc(this, e2), this._readRequests = new Hc();
      }
      get closed() {
        return _u(this) ? this._closedPromise : Bc(Au("closed"));
      }
      cancel(e2) {
        return _u(this) ? this._ownerReadableStream === void 0 ? Bc(Zc("cancel")) : Vc(this, e2) : Bc(Au("cancel"));
      }
      read() {
        if (!_u(this))
          return Bc(Au("read"));
        if (this._ownerReadableStream === void 0)
          return Bc(Zc("read from"));
        let e2, t2;
        const r2 = Ic((r3, i2) => {
          e2 = r3, t2 = i2;
        });
        return ku(this, { _chunkSteps: (t3) => e2({ value: t3, done: false }), _closeSteps: () => e2({ value: void 0, done: true }), _errorSteps: (e3) => t2(e3) }), r2;
      }
      releaseLock() {
        if (!_u(this))
          throw Au("releaseLock");
        if (this._ownerReadableStream !== void 0) {
          if (this._readRequests.length > 0)
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          $c(this);
        }
      }
    };
    function _u(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readRequests");
    }
    function ku(e2, t2) {
      const r2 = e2._ownerReadableStream;
      r2._disturbed = true, r2._state === "closed" ? t2._closeSteps() : r2._state === "errored" ? t2._errorSteps(r2._storedError) : r2._readableStreamController[iu](t2);
    }
    function Au(e2) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);
    }
    var Su;
    Object.defineProperties(vu.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(vu.prototype, Sc.toStringTag, { value: "ReadableStreamDefaultReader", configurable: true }), typeof Sc.asyncIterator == "symbol" && (Su = { [Sc.asyncIterator]() {
      return this;
    } }, Object.defineProperty(Su, Sc.asyncIterator, { enumerable: false }));
    var Eu = class {
      constructor(e2, t2) {
        this._ongoingPromise = void 0, this._isFinished = false, this._reader = e2, this._preventCancel = t2;
      }
      next() {
        const e2 = () => this._nextSteps();
        return this._ongoingPromise = this._ongoingPromise ? Fc(this._ongoingPromise, e2, e2) : e2(), this._ongoingPromise;
      }
      return(e2) {
        const t2 = () => this._returnSteps(e2);
        return this._ongoingPromise ? Fc(this._ongoingPromise, t2, t2) : t2();
      }
      _nextSteps() {
        if (this._isFinished)
          return Promise.resolve({ value: void 0, done: true });
        const e2 = this._reader;
        if (e2._ownerReadableStream === void 0)
          return Bc(Zc("iterate"));
        let t2, r2;
        const i2 = Ic((e3, i3) => {
          t2 = e3, r2 = i3;
        });
        return ku(e2, { _chunkSteps: (e3) => {
          this._ongoingPromise = void 0, jc(() => t2({ value: e3, done: false }));
        }, _closeSteps: () => {
          this._ongoingPromise = void 0, this._isFinished = true, $c(e2), t2({ value: void 0, done: true });
        }, _errorSteps: (t3) => {
          this._ongoingPromise = void 0, this._isFinished = true, $c(e2), r2(t3);
        } }), i2;
      }
      _returnSteps(e2) {
        if (this._isFinished)
          return Promise.resolve({ value: e2, done: true });
        this._isFinished = true;
        const t2 = this._reader;
        if (t2._ownerReadableStream === void 0)
          return Bc(Zc("finish iterating"));
        if (!this._preventCancel) {
          const r2 = Vc(t2, e2);
          return $c(t2), Fc(r2, () => ({ value: e2, done: true }));
        }
        return $c(t2), Uc({ value: e2, done: true });
      }
    };
    var Pu = { next() {
      return xu(this) ? this._asyncIteratorImpl.next() : Bc(Mu("next"));
    }, return(e2) {
      return xu(this) ? this._asyncIteratorImpl.return(e2) : Bc(Mu("return"));
    } };
    function xu(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_asyncIteratorImpl");
    }
    function Mu(e2) {
      return new TypeError(`ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);
    }
    Su !== void 0 && Object.setPrototypeOf(Pu, Su);
    var Cu = Number.isNaN || function(e2) {
      return e2 != e2;
    };
    function Ku(e2) {
      return !!function(e3) {
        if (typeof e3 != "number")
          return false;
        if (Cu(e3))
          return false;
        if (e3 < 0)
          return false;
        return true;
      }(e2) && e2 !== 1 / 0;
    }
    function Du(e2) {
      const t2 = e2._queue.shift();
      return e2._queueTotalSize -= t2.size, e2._queueTotalSize < 0 && (e2._queueTotalSize = 0), t2.value;
    }
    function Ru(e2, t2, r2) {
      if (!Ku(r2 = Number(r2)))
        throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      e2._queue.push({ value: t2, size: r2 }), e2._queueTotalSize += r2;
    }
    function Iu(e2) {
      e2._queue = new Hc(), e2._queueTotalSize = 0;
    }
    function Uu(e2) {
      return e2.slice();
    }
    var Bu = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!qu(this))
          throw eh("view");
        return this._view;
      }
      respond(e2) {
        if (!qu(this))
          throw eh("respond");
        if (uu(e2, 1, "respond"), e2 = lu(e2, "First parameter"), this._associatedReadableByteStreamController === void 0)
          throw new TypeError("This BYOB request has been invalidated");
        this._view.buffer, function(e3, t2) {
          if (!Ku(t2 = Number(t2)))
            throw new RangeError("bytesWritten must be a finite");
          $u(e3, t2);
        }(this._associatedReadableByteStreamController, e2);
      }
      respondWithNewView(e2) {
        if (!qu(this))
          throw eh("respondWithNewView");
        if (uu(e2, 1, "respondWithNewView"), !ArrayBuffer.isView(e2))
          throw new TypeError("You can only respond with array buffer views");
        if (e2.byteLength === 0)
          throw new TypeError("chunk must have non-zero byteLength");
        if (e2.buffer.byteLength === 0)
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._associatedReadableByteStreamController === void 0)
          throw new TypeError("This BYOB request has been invalidated");
        !function(e3, t2) {
          const r2 = e3._pendingPullIntos.peek();
          if (r2.byteOffset + r2.bytesFilled !== t2.byteOffset)
            throw new RangeError("The region specified by view does not match byobRequest");
          if (r2.byteLength !== t2.byteLength)
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          r2.buffer = t2.buffer, $u(e3, t2.byteLength);
        }(this._associatedReadableByteStreamController, e2);
      }
    };
    Object.defineProperties(Bu.prototype, { respond: { enumerable: true }, respondWithNewView: { enumerable: true }, view: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Bu.prototype, Sc.toStringTag, { value: "ReadableStreamBYOBRequest", configurable: true });
    var Tu = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!zu(this))
          throw th("byobRequest");
        if (this._byobRequest === null && this._pendingPullIntos.length > 0) {
          const e2 = this._pendingPullIntos.peek(), t2 = new Uint8Array(e2.buffer, e2.byteOffset + e2.bytesFilled, e2.byteLength - e2.bytesFilled), r2 = Object.create(Bu.prototype);
          !function(e3, t3, r3) {
            e3._associatedReadableByteStreamController = t3, e3._view = r3;
          }(r2, this, t2), this._byobRequest = r2;
        }
        return this._byobRequest;
      }
      get desiredSize() {
        if (!zu(this))
          throw th("desiredSize");
        return Qu(this);
      }
      close() {
        if (!zu(this))
          throw th("close");
        if (this._closeRequested)
          throw new TypeError("The stream has already been closed; do not close it again!");
        const e2 = this._controlledReadableByteStream._state;
        if (e2 !== "readable")
          throw new TypeError(`The stream (in ${e2} state) is not in the readable state and cannot be closed`);
        !function(e3) {
          const t2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || t2._state !== "readable")
            return;
          if (e3._queueTotalSize > 0)
            return void (e3._closeRequested = true);
          if (e3._pendingPullIntos.length > 0) {
            if (e3._pendingPullIntos.peek().bytesFilled > 0) {
              const t3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              throw Xu(e3, t3), t3;
            }
          }
          Yu(e3), Rf(t2);
        }(this);
      }
      enqueue(e2) {
        if (!zu(this))
          throw th("enqueue");
        if (uu(e2, 1, "enqueue"), !ArrayBuffer.isView(e2))
          throw new TypeError("chunk must be an array buffer view");
        if (e2.byteLength === 0)
          throw new TypeError("chunk must have non-zero byteLength");
        if (e2.buffer.byteLength === 0)
          throw new TypeError("chunk's buffer must have non-zero byteLength");
        if (this._closeRequested)
          throw new TypeError("stream is closed or draining");
        const t2 = this._controlledReadableByteStream._state;
        if (t2 !== "readable")
          throw new TypeError(`The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);
        !function(e3, t3) {
          const r2 = e3._controlledReadableByteStream;
          if (e3._closeRequested || r2._state !== "readable")
            return;
          const i2 = t3.buffer, n2 = t3.byteOffset, a2 = t3.byteLength, s2 = i2;
          if (wu(r2))
            if (gu(r2) === 0)
              ju(e3, s2, n2, a2);
            else {
              mu(r2, new Uint8Array(s2, n2, a2), false);
            }
          else
            nh(r2) ? (ju(e3, s2, n2, a2), Vu(e3)) : ju(e3, s2, n2, a2);
          Ou(e3);
        }(this, e2);
      }
      error(e2) {
        if (!zu(this))
          throw th("error");
        Xu(this, e2);
      }
      [ru](e2) {
        if (this._pendingPullIntos.length > 0) {
          this._pendingPullIntos.peek().bytesFilled = 0;
        }
        Iu(this);
        const t2 = this._cancelAlgorithm(e2);
        return Yu(this), t2;
      }
      [iu](e2) {
        const t2 = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          const t3 = this._queue.shift();
          this._queueTotalSize -= t3.byteLength, Hu(this);
          const r3 = new Uint8Array(t3.buffer, t3.byteOffset, t3.byteLength);
          return void e2._chunkSteps(r3);
        }
        const r2 = this._autoAllocateChunkSize;
        if (r2 !== void 0) {
          let t3;
          try {
            t3 = new ArrayBuffer(r2);
          } catch (t4) {
            return void e2._errorSteps(t4);
          }
          const i2 = { buffer: t3, byteOffset: 0, byteLength: r2, bytesFilled: 0, elementSize: 1, viewConstructor: Uint8Array, readerType: "default" };
          this._pendingPullIntos.push(i2);
        }
        bu(t2, e2), Ou(this);
      }
    };
    function zu(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableByteStream");
    }
    function qu(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_associatedReadableByteStreamController");
    }
    function Ou(e2) {
      if (!function(e3) {
        const t2 = e3._controlledReadableByteStream;
        if (t2._state !== "readable")
          return false;
        if (e3._closeRequested)
          return false;
        if (!e3._started)
          return false;
        if (wu(t2) && gu(t2) > 0)
          return true;
        if (nh(t2) && ih(t2) > 0)
          return true;
        if (Qu(e3) > 0)
          return true;
        return false;
      }(e2))
        return;
      if (e2._pulling)
        return void (e2._pullAgain = true);
      e2._pulling = true;
      zc(e2._pullAlgorithm(), () => {
        e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, Ou(e2));
      }, (t2) => {
        Xu(e2, t2);
      });
    }
    function Fu(e2, t2) {
      let r2 = false;
      e2._state === "closed" && (r2 = true);
      const i2 = Nu(t2);
      t2.readerType === "default" ? mu(e2, i2, r2) : function(e3, t3, r3) {
        const i3 = e3._reader._readIntoRequests.shift();
        r3 ? i3._closeSteps(t3) : i3._chunkSteps(t3);
      }(e2, i2, r2);
    }
    function Nu(e2) {
      const t2 = e2.bytesFilled, r2 = e2.elementSize;
      return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2 / r2);
    }
    function ju(e2, t2, r2, i2) {
      e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: i2 }), e2._queueTotalSize += i2;
    }
    function Lu(e2, t2) {
      const r2 = t2.elementSize, i2 = t2.bytesFilled - t2.bytesFilled % r2, n2 = Math.min(e2._queueTotalSize, t2.byteLength - t2.bytesFilled), a2 = t2.bytesFilled + n2, s2 = a2 - a2 % r2;
      let o2 = n2, c2 = false;
      s2 > i2 && (o2 = s2 - t2.bytesFilled, c2 = true);
      const u2 = e2._queue;
      for (; o2 > 0; ) {
        const r3 = u2.peek(), i3 = Math.min(o2, r3.byteLength), n3 = t2.byteOffset + t2.bytesFilled;
        h2 = t2.buffer, f2 = n3, d2 = r3.buffer, l2 = r3.byteOffset, p2 = i3, new Uint8Array(h2).set(new Uint8Array(d2, l2, p2), f2), r3.byteLength === i3 ? u2.shift() : (r3.byteOffset += i3, r3.byteLength -= i3), e2._queueTotalSize -= i3, Wu(e2, i3, t2), o2 -= i3;
      }
      var h2, f2, d2, l2, p2;
      return c2;
    }
    function Wu(e2, t2, r2) {
      Gu(e2), r2.bytesFilled += t2;
    }
    function Hu(e2) {
      e2._queueTotalSize === 0 && e2._closeRequested ? (Yu(e2), Rf(e2._controlledReadableByteStream)) : Ou(e2);
    }
    function Gu(e2) {
      e2._byobRequest !== null && (e2._byobRequest._associatedReadableByteStreamController = void 0, e2._byobRequest._view = null, e2._byobRequest = null);
    }
    function Vu(e2) {
      for (; e2._pendingPullIntos.length > 0; ) {
        if (e2._queueTotalSize === 0)
          return;
        const t2 = e2._pendingPullIntos.peek();
        Lu(e2, t2) && (Zu(e2), Fu(e2._controlledReadableByteStream, t2));
      }
    }
    function $u(e2, t2) {
      const r2 = e2._pendingPullIntos.peek();
      if (e2._controlledReadableByteStream._state === "closed") {
        if (t2 !== 0)
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        !function(e3, t3) {
          t3.buffer = t3.buffer;
          const r3 = e3._controlledReadableByteStream;
          if (nh(r3))
            for (; ih(r3) > 0; )
              Fu(r3, Zu(e3));
        }(e2, r2);
      } else
        !function(e3, t3, r3) {
          if (r3.bytesFilled + t3 > r3.byteLength)
            throw new RangeError("bytesWritten out of range");
          if (Wu(e3, t3, r3), r3.bytesFilled < r3.elementSize)
            return;
          Zu(e3);
          const i2 = r3.bytesFilled % r3.elementSize;
          if (i2 > 0) {
            const t4 = r3.byteOffset + r3.bytesFilled, n2 = r3.buffer.slice(t4 - i2, t4);
            ju(e3, n2, 0, n2.byteLength);
          }
          r3.buffer = r3.buffer, r3.bytesFilled -= i2, Fu(e3._controlledReadableByteStream, r3), Vu(e3);
        }(e2, t2, r2);
      Ou(e2);
    }
    function Zu(e2) {
      const t2 = e2._pendingPullIntos.shift();
      return Gu(e2), t2;
    }
    function Yu(e2) {
      e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0;
    }
    function Xu(e2, t2) {
      const r2 = e2._controlledReadableByteStream;
      r2._state === "readable" && (!function(e3) {
        Gu(e3), e3._pendingPullIntos = new Hc();
      }(e2), Iu(e2), Yu(e2), If(r2, t2));
    }
    function Qu(e2) {
      const t2 = e2._controlledReadableByteStream._state;
      return t2 === "errored" ? null : t2 === "closed" ? 0 : e2._strategyHWM - e2._queueTotalSize;
    }
    function Ju(e2, t2, r2) {
      const i2 = Object.create(Tu.prototype);
      let n2 = () => {
      }, a2 = () => Uc(void 0), s2 = () => Uc(void 0);
      t2.start !== void 0 && (n2 = () => t2.start(i2)), t2.pull !== void 0 && (a2 = () => t2.pull(i2)), t2.cancel !== void 0 && (s2 = (e3) => t2.cancel(e3));
      const o2 = t2.autoAllocateChunkSize;
      if (o2 === 0)
        throw new TypeError("autoAllocateChunkSize must be greater than 0");
      !function(e3, t3, r3, i3, n3, a3, s3) {
        t3._controlledReadableByteStream = e3, t3._pullAgain = false, t3._pulling = false, t3._byobRequest = null, t3._queue = t3._queueTotalSize = void 0, Iu(t3), t3._closeRequested = false, t3._started = false, t3._strategyHWM = a3, t3._pullAlgorithm = i3, t3._cancelAlgorithm = n3, t3._autoAllocateChunkSize = s3, t3._pendingPullIntos = new Hc(), e3._readableStreamController = t3, zc(Uc(r3()), () => {
          t3._started = true, Ou(t3);
        }, (e4) => {
          Xu(t3, e4);
        });
      }(e2, i2, n2, a2, s2, r2, o2);
    }
    function eh(e2) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);
    }
    function th(e2) {
      return new TypeError(`ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);
    }
    function rh(e2, t2) {
      e2._reader._readIntoRequests.push(t2);
    }
    function ih(e2) {
      return e2._reader._readIntoRequests.length;
    }
    function nh(e2) {
      const t2 = e2._reader;
      return t2 !== void 0 && !!sh(t2);
    }
    Object.defineProperties(Tu.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, byobRequest: { enumerable: true }, desiredSize: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Tu.prototype, Sc.toStringTag, { value: "ReadableByteStreamController", configurable: true });
    var ah = class {
      constructor(e2) {
        if (uu(e2, 1, "ReadableStreamBYOBReader"), pu(e2, "First parameter"), Kf(e2))
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        if (!zu(e2._readableStreamController))
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
        Gc(this, e2), this._readIntoRequests = new Hc();
      }
      get closed() {
        return sh(this) ? this._closedPromise : Bc(oh("closed"));
      }
      cancel(e2) {
        return sh(this) ? this._ownerReadableStream === void 0 ? Bc(Zc("cancel")) : Vc(this, e2) : Bc(oh("cancel"));
      }
      read(e2) {
        if (!sh(this))
          return Bc(oh("read"));
        if (!ArrayBuffer.isView(e2))
          return Bc(new TypeError("view must be an array buffer view"));
        if (e2.byteLength === 0)
          return Bc(new TypeError("view must have non-zero byteLength"));
        if (e2.buffer.byteLength === 0)
          return Bc(new TypeError("view's buffer must have non-zero byteLength"));
        if (this._ownerReadableStream === void 0)
          return Bc(Zc("read from"));
        let t2, r2;
        const i2 = Ic((e3, i3) => {
          t2 = e3, r2 = i3;
        });
        return function(e3, t3, r3) {
          const i3 = e3._ownerReadableStream;
          i3._disturbed = true, i3._state === "errored" ? r3._errorSteps(i3._storedError) : function(e4, t4, r4) {
            const i4 = e4._controlledReadableByteStream;
            let n2 = 1;
            t4.constructor !== DataView && (n2 = t4.constructor.BYTES_PER_ELEMENT);
            const a2 = t4.constructor, s2 = { buffer: t4.buffer, byteOffset: t4.byteOffset, byteLength: t4.byteLength, bytesFilled: 0, elementSize: n2, viewConstructor: a2, readerType: "byob" };
            if (e4._pendingPullIntos.length > 0)
              return e4._pendingPullIntos.push(s2), void rh(i4, r4);
            if (i4._state !== "closed") {
              if (e4._queueTotalSize > 0) {
                if (Lu(e4, s2)) {
                  const t5 = Nu(s2);
                  return Hu(e4), void r4._chunkSteps(t5);
                }
                if (e4._closeRequested) {
                  const t5 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                  return Xu(e4, t5), void r4._errorSteps(t5);
                }
              }
              e4._pendingPullIntos.push(s2), rh(i4, r4), Ou(e4);
            } else {
              const e5 = new a2(s2.buffer, s2.byteOffset, 0);
              r4._closeSteps(e5);
            }
          }(i3._readableStreamController, t3, r3);
        }(this, e2, { _chunkSteps: (e3) => t2({ value: e3, done: false }), _closeSteps: (e3) => t2({ value: e3, done: true }), _errorSteps: (e3) => r2(e3) }), i2;
      }
      releaseLock() {
        if (!sh(this))
          throw oh("releaseLock");
        if (this._ownerReadableStream !== void 0) {
          if (this._readIntoRequests.length > 0)
            throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
          $c(this);
        }
      }
    };
    function sh(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readIntoRequests");
    }
    function oh(e2) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);
    }
    function ch(e2, t2) {
      const { highWaterMark: r2 } = e2;
      if (r2 === void 0)
        return t2;
      if (Cu(r2) || r2 < 0)
        throw new RangeError("Invalid highWaterMark");
      return r2;
    }
    function uh(e2) {
      const { size: t2 } = e2;
      return t2 || (() => 1);
    }
    function hh(e2, t2) {
      su(e2, t2);
      const r2 = e2 == null ? void 0 : e2.highWaterMark, i2 = e2 == null ? void 0 : e2.size;
      return { highWaterMark: r2 === void 0 ? void 0 : fu(r2), size: i2 === void 0 ? void 0 : fh(i2, t2 + " has member 'size' that") };
    }
    function fh(e2, t2) {
      return ou(e2, t2), (t3) => fu(e2(t3));
    }
    function dh(e2, t2, r2) {
      return ou(e2, r2), (r3) => Wc(e2, t2, [r3]);
    }
    function lh(e2, t2, r2) {
      return ou(e2, r2), () => Wc(e2, t2, []);
    }
    function ph(e2, t2, r2) {
      return ou(e2, r2), (r3) => Lc(e2, t2, [r3]);
    }
    function yh(e2, t2, r2) {
      return ou(e2, r2), (r3, i2) => Wc(e2, t2, [r3, i2]);
    }
    function bh(e2, t2) {
      if (!vh(e2))
        throw new TypeError(t2 + " is not a WritableStream.");
    }
    Object.defineProperties(ah.prototype, { cancel: { enumerable: true }, read: { enumerable: true }, releaseLock: { enumerable: true }, closed: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(ah.prototype, Sc.toStringTag, { value: "ReadableStreamBYOBReader", configurable: true });
    var mh = class {
      constructor(e2 = {}, t2 = {}) {
        e2 === void 0 ? e2 = null : cu(e2, "First parameter");
        const r2 = hh(t2, "Second parameter"), i2 = function(e3, t3) {
          su(e3, t3);
          const r3 = e3 == null ? void 0 : e3.abort, i3 = e3 == null ? void 0 : e3.close, n3 = e3 == null ? void 0 : e3.start, a2 = e3 == null ? void 0 : e3.type, s2 = e3 == null ? void 0 : e3.write;
          return { abort: r3 === void 0 ? void 0 : dh(r3, e3, t3 + " has member 'abort' that"), close: i3 === void 0 ? void 0 : lh(i3, e3, t3 + " has member 'close' that"), start: n3 === void 0 ? void 0 : ph(n3, e3, t3 + " has member 'start' that"), write: s2 === void 0 ? void 0 : yh(s2, e3, t3 + " has member 'write' that"), type: a2 };
        }(e2, "First parameter");
        wh(this);
        if (i2.type !== void 0)
          throw new RangeError("Invalid type is specified");
        const n2 = uh(r2);
        !function(e3, t3, r3, i3) {
          const n3 = Object.create(qh.prototype);
          let a2 = () => {
          }, s2 = () => Uc(void 0), o2 = () => Uc(void 0), c2 = () => Uc(void 0);
          t3.start !== void 0 && (a2 = () => t3.start(n3));
          t3.write !== void 0 && (s2 = (e4) => t3.write(e4, n3));
          t3.close !== void 0 && (o2 = () => t3.close());
          t3.abort !== void 0 && (c2 = (e4) => t3.abort(e4));
          Oh(e3, n3, a2, s2, o2, c2, r3, i3);
        }(this, i2, ch(r2, 1), n2);
      }
      get locked() {
        if (!vh(this))
          throw Gh("locked");
        return _h(this);
      }
      abort(e2) {
        return vh(this) ? _h(this) ? Bc(new TypeError("Cannot abort a stream that already has a writer")) : kh(this, e2) : Bc(Gh("abort"));
      }
      close() {
        return vh(this) ? _h(this) ? Bc(new TypeError("Cannot close a stream that already has a writer")) : xh(this) ? Bc(new TypeError("Cannot close an already-closing stream")) : Ah(this) : Bc(Gh("close"));
      }
      getWriter() {
        if (!vh(this))
          throw Gh("getWriter");
        return gh(this);
      }
    };
    function gh(e2) {
      return new Kh(e2);
    }
    function wh(e2) {
      e2._state = "writable", e2._storedError = void 0, e2._writer = void 0, e2._writableStreamController = void 0, e2._writeRequests = new Hc(), e2._inFlightWriteRequest = void 0, e2._closeRequest = void 0, e2._inFlightCloseRequest = void 0, e2._pendingAbortRequest = void 0, e2._backpressure = false;
    }
    function vh(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_writableStreamController");
    }
    function _h(e2) {
      return e2._writer !== void 0;
    }
    function kh(e2, t2) {
      const r2 = e2._state;
      if (r2 === "closed" || r2 === "errored")
        return Uc(void 0);
      if (e2._pendingAbortRequest !== void 0)
        return e2._pendingAbortRequest._promise;
      let i2 = false;
      r2 === "erroring" && (i2 = true, t2 = void 0);
      const n2 = Ic((r3, n3) => {
        e2._pendingAbortRequest = { _promise: void 0, _resolve: r3, _reject: n3, _reason: t2, _wasAlreadyErroring: i2 };
      });
      return e2._pendingAbortRequest._promise = n2, i2 || Eh(e2, t2), n2;
    }
    function Ah(e2) {
      const t2 = e2._state;
      if (t2 === "closed" || t2 === "errored")
        return Bc(new TypeError(`The stream (in ${t2} state) is not in the writable state and cannot be closed`));
      const r2 = Ic((t3, r3) => {
        const i3 = { _resolve: t3, _reject: r3 };
        e2._closeRequest = i3;
      }), i2 = e2._writer;
      var n2;
      return i2 !== void 0 && e2._backpressure && t2 === "writable" && nf(i2), Ru(n2 = e2._writableStreamController, zh, 0), jh(n2), r2;
    }
    function Sh(e2, t2) {
      e2._state !== "writable" ? Ph(e2) : Eh(e2, t2);
    }
    function Eh(e2, t2) {
      const r2 = e2._writableStreamController;
      e2._state = "erroring", e2._storedError = t2;
      const i2 = e2._writer;
      i2 !== void 0 && Uh(i2, t2), !function(e3) {
        if (e3._inFlightWriteRequest === void 0 && e3._inFlightCloseRequest === void 0)
          return false;
        return true;
      }(e2) && r2._started && Ph(e2);
    }
    function Ph(e2) {
      e2._state = "errored", e2._writableStreamController[tu]();
      const t2 = e2._storedError;
      if (e2._writeRequests.forEach((e3) => {
        e3._reject(t2);
      }), e2._writeRequests = new Hc(), e2._pendingAbortRequest === void 0)
        return void Mh(e2);
      const r2 = e2._pendingAbortRequest;
      if (e2._pendingAbortRequest = void 0, r2._wasAlreadyErroring)
        return r2._reject(t2), void Mh(e2);
      zc(e2._writableStreamController[eu](r2._reason), () => {
        r2._resolve(), Mh(e2);
      }, (t3) => {
        r2._reject(t3), Mh(e2);
      });
    }
    function xh(e2) {
      return e2._closeRequest !== void 0 || e2._inFlightCloseRequest !== void 0;
    }
    function Mh(e2) {
      e2._closeRequest !== void 0 && (e2._closeRequest._reject(e2._storedError), e2._closeRequest = void 0);
      const t2 = e2._writer;
      t2 !== void 0 && Xh(t2, e2._storedError);
    }
    function Ch(e2, t2) {
      const r2 = e2._writer;
      r2 !== void 0 && t2 !== e2._backpressure && (t2 ? function(e3) {
        Jh(e3);
      }(r2) : nf(r2)), e2._backpressure = t2;
    }
    Object.defineProperties(mh.prototype, { abort: { enumerable: true }, close: { enumerable: true }, getWriter: { enumerable: true }, locked: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(mh.prototype, Sc.toStringTag, { value: "WritableStream", configurable: true });
    var Kh = class {
      constructor(e2) {
        if (uu(e2, 1, "WritableStreamDefaultWriter"), bh(e2, "First parameter"), _h(e2))
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        this._ownerWritableStream = e2, e2._writer = this;
        const t2 = e2._state;
        if (t2 === "writable")
          !xh(e2) && e2._backpressure ? Jh(this) : tf(this), Zh(this);
        else if (t2 === "erroring")
          ef(this, e2._storedError), Zh(this);
        else if (t2 === "closed")
          tf(this), Zh(r2 = this), Qh(r2);
        else {
          const t3 = e2._storedError;
          ef(this, t3), Yh(this, t3);
        }
        var r2;
      }
      get closed() {
        return Dh(this) ? this._closedPromise : Bc(Vh("closed"));
      }
      get desiredSize() {
        if (!Dh(this))
          throw Vh("desiredSize");
        if (this._ownerWritableStream === void 0)
          throw $h("desiredSize");
        return function(e2) {
          const t2 = e2._ownerWritableStream, r2 = t2._state;
          if (r2 === "errored" || r2 === "erroring")
            return null;
          if (r2 === "closed")
            return 0;
          return Nh(t2._writableStreamController);
        }(this);
      }
      get ready() {
        return Dh(this) ? this._readyPromise : Bc(Vh("ready"));
      }
      abort(e2) {
        return Dh(this) ? this._ownerWritableStream === void 0 ? Bc($h("abort")) : function(e3, t2) {
          return kh(e3._ownerWritableStream, t2);
        }(this, e2) : Bc(Vh("abort"));
      }
      close() {
        if (!Dh(this))
          return Bc(Vh("close"));
        const e2 = this._ownerWritableStream;
        return e2 === void 0 ? Bc($h("close")) : xh(e2) ? Bc(new TypeError("Cannot close an already-closing stream")) : Rh(this);
      }
      releaseLock() {
        if (!Dh(this))
          throw Vh("releaseLock");
        this._ownerWritableStream !== void 0 && Bh(this);
      }
      write(e2) {
        return Dh(this) ? this._ownerWritableStream === void 0 ? Bc($h("write to")) : Th(this, e2) : Bc(Vh("write"));
      }
    };
    function Dh(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_ownerWritableStream");
    }
    function Rh(e2) {
      return Ah(e2._ownerWritableStream);
    }
    function Ih(e2, t2) {
      e2._closedPromiseState === "pending" ? Xh(e2, t2) : function(e3, t3) {
        Yh(e3, t3);
      }(e2, t2);
    }
    function Uh(e2, t2) {
      e2._readyPromiseState === "pending" ? rf(e2, t2) : function(e3, t3) {
        ef(e3, t3);
      }(e2, t2);
    }
    function Bh(e2) {
      const t2 = e2._ownerWritableStream, r2 = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
      Uh(e2, r2), Ih(e2, r2), t2._writer = void 0, e2._ownerWritableStream = void 0;
    }
    function Th(e2, t2) {
      const r2 = e2._ownerWritableStream, i2 = r2._writableStreamController, n2 = function(e3, t3) {
        try {
          return e3._strategySizeAlgorithm(t3);
        } catch (t4) {
          return Lh(e3, t4), 1;
        }
      }(i2, t2);
      if (r2 !== e2._ownerWritableStream)
        return Bc($h("write to"));
      const a2 = r2._state;
      if (a2 === "errored")
        return Bc(r2._storedError);
      if (xh(r2) || a2 === "closed")
        return Bc(new TypeError("The stream is closing or closed and cannot be written to"));
      if (a2 === "erroring")
        return Bc(r2._storedError);
      const s2 = function(e3) {
        return Ic((t3, r3) => {
          const i3 = { _resolve: t3, _reject: r3 };
          e3._writeRequests.push(i3);
        });
      }(r2);
      return function(e3, t3, r3) {
        try {
          Ru(e3, t3, r3);
        } catch (t4) {
          return void Lh(e3, t4);
        }
        const i3 = e3._controlledWritableStream;
        if (!xh(i3) && i3._state === "writable") {
          Ch(i3, Wh(e3));
        }
        jh(e3);
      }(i2, t2, n2), s2;
    }
    Object.defineProperties(Kh.prototype, { abort: { enumerable: true }, close: { enumerable: true }, releaseLock: { enumerable: true }, write: { enumerable: true }, closed: { enumerable: true }, desiredSize: { enumerable: true }, ready: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Kh.prototype, Sc.toStringTag, { value: "WritableStreamDefaultWriter", configurable: true });
    var zh = {};
    var qh = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      error(e2) {
        if (!function(e3) {
          if (!xc(e3))
            return false;
          if (!Object.prototype.hasOwnProperty.call(e3, "_controlledWritableStream"))
            return false;
          return true;
        }(this))
          throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
        this._controlledWritableStream._state === "writable" && Hh(this, e2);
      }
      [eu](e2) {
        const t2 = this._abortAlgorithm(e2);
        return Fh(this), t2;
      }
      [tu]() {
        Iu(this);
      }
    };
    function Oh(e2, t2, r2, i2, n2, a2, s2, o2) {
      t2._controlledWritableStream = e2, e2._writableStreamController = t2, t2._queue = void 0, t2._queueTotalSize = void 0, Iu(t2), t2._started = false, t2._strategySizeAlgorithm = o2, t2._strategyHWM = s2, t2._writeAlgorithm = i2, t2._closeAlgorithm = n2, t2._abortAlgorithm = a2;
      const c2 = Wh(t2);
      Ch(e2, c2);
      zc(Uc(r2()), () => {
        t2._started = true, jh(t2);
      }, (r3) => {
        t2._started = true, Sh(e2, r3);
      });
    }
    function Fh(e2) {
      e2._writeAlgorithm = void 0, e2._closeAlgorithm = void 0, e2._abortAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
    }
    function Nh(e2) {
      return e2._strategyHWM - e2._queueTotalSize;
    }
    function jh(e2) {
      const t2 = e2._controlledWritableStream;
      if (!e2._started)
        return;
      if (t2._inFlightWriteRequest !== void 0)
        return;
      if (t2._state === "erroring")
        return void Ph(t2);
      if (e2._queue.length === 0)
        return;
      const r2 = e2._queue.peek().value;
      r2 === zh ? function(e3) {
        const t3 = e3._controlledWritableStream;
        (function(e4) {
          e4._inFlightCloseRequest = e4._closeRequest, e4._closeRequest = void 0;
        })(t3), Du(e3);
        const r3 = e3._closeAlgorithm();
        Fh(e3), zc(r3, () => {
          !function(e4) {
            e4._inFlightCloseRequest._resolve(void 0), e4._inFlightCloseRequest = void 0, e4._state === "erroring" && (e4._storedError = void 0, e4._pendingAbortRequest !== void 0 && (e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest = void 0)), e4._state = "closed";
            const t4 = e4._writer;
            t4 !== void 0 && Qh(t4);
          }(t3);
        }, (e4) => {
          !function(e5, t4) {
            e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest = void 0, e5._pendingAbortRequest !== void 0 && (e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest = void 0), Sh(e5, t4);
          }(t3, e4);
        });
      }(e2) : function(e3, t3) {
        const r3 = e3._controlledWritableStream;
        !function(e4) {
          e4._inFlightWriteRequest = e4._writeRequests.shift();
        }(r3);
        zc(e3._writeAlgorithm(t3), () => {
          !function(e4) {
            e4._inFlightWriteRequest._resolve(void 0), e4._inFlightWriteRequest = void 0;
          }(r3);
          const t4 = r3._state;
          if (Du(e3), !xh(r3) && t4 === "writable") {
            const t5 = Wh(e3);
            Ch(r3, t5);
          }
          jh(e3);
        }, (t4) => {
          r3._state === "writable" && Fh(e3), function(e4, t5) {
            e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest = void 0, Sh(e4, t5);
          }(r3, t4);
        });
      }(e2, r2);
    }
    function Lh(e2, t2) {
      e2._controlledWritableStream._state === "writable" && Hh(e2, t2);
    }
    function Wh(e2) {
      return Nh(e2) <= 0;
    }
    function Hh(e2, t2) {
      const r2 = e2._controlledWritableStream;
      Fh(e2), Eh(r2, t2);
    }
    function Gh(e2) {
      return new TypeError(`WritableStream.prototype.${e2} can only be used on a WritableStream`);
    }
    function Vh(e2) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);
    }
    function $h(e2) {
      return new TypeError("Cannot " + e2 + " a stream using a released writer");
    }
    function Zh(e2) {
      e2._closedPromise = Ic((t2, r2) => {
        e2._closedPromise_resolve = t2, e2._closedPromise_reject = r2, e2._closedPromiseState = "pending";
      });
    }
    function Yh(e2, t2) {
      Zh(e2), Xh(e2, t2);
    }
    function Xh(e2, t2) {
      e2._closedPromise_reject !== void 0 && (Nc(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "rejected");
    }
    function Qh(e2) {
      e2._closedPromise_resolve !== void 0 && (e2._closedPromise_resolve(void 0), e2._closedPromise_resolve = void 0, e2._closedPromise_reject = void 0, e2._closedPromiseState = "resolved");
    }
    function Jh(e2) {
      e2._readyPromise = Ic((t2, r2) => {
        e2._readyPromise_resolve = t2, e2._readyPromise_reject = r2;
      }), e2._readyPromiseState = "pending";
    }
    function ef(e2, t2) {
      Jh(e2), rf(e2, t2);
    }
    function tf(e2) {
      Jh(e2), nf(e2);
    }
    function rf(e2, t2) {
      e2._readyPromise_reject !== void 0 && (Nc(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "rejected");
    }
    function nf(e2) {
      e2._readyPromise_resolve !== void 0 && (e2._readyPromise_resolve(void 0), e2._readyPromise_resolve = void 0, e2._readyPromise_reject = void 0, e2._readyPromiseState = "fulfilled");
    }
    Object.defineProperties(qh.prototype, { error: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(qh.prototype, Sc.toStringTag, { value: "WritableStreamDefaultController", configurable: true });
    var af = typeof DOMException != "undefined" ? DOMException : void 0;
    var sf = function(e2) {
      if (typeof e2 != "function" && typeof e2 != "object")
        return false;
      try {
        return new e2(), true;
      } catch (e3) {
        return false;
      }
    }(af) ? af : function() {
      const e2 = function(e3, t2) {
        this.message = e3 || "", this.name = t2 || "Error", Error.captureStackTrace && Error.captureStackTrace(this, this.constructor);
      };
      return Object.defineProperty(e2.prototype = Object.create(Error.prototype), "constructor", { value: e2, writable: true, configurable: true }), e2;
    }();
    function of(e2, t2, r2, i2, n2, a2) {
      const s2 = yu(e2), o2 = gh(t2);
      e2._disturbed = true;
      let c2 = false, u2 = Uc(void 0);
      return Ic((h2, f2) => {
        let d2;
        if (a2 !== void 0) {
          if (d2 = () => {
            const r3 = new sf("Aborted", "AbortError"), a3 = [];
            i2 || a3.push(() => t2._state === "writable" ? kh(t2, r3) : Uc(void 0)), n2 || a3.push(() => e2._state === "readable" ? Df(e2, r3) : Uc(void 0)), y2(() => Promise.all(a3.map((e3) => e3())), true, r3);
          }, a2.aborted)
            return void d2();
          a2.addEventListener("abort", d2);
        }
        if (p2(e2, s2._closedPromise, (e3) => {
          i2 ? b2(true, e3) : y2(() => kh(t2, e3), true, e3);
        }), p2(t2, o2._closedPromise, (t3) => {
          n2 ? b2(true, t3) : y2(() => Df(e2, t3), true, t3);
        }), function(e3, t3, r3) {
          e3._state === "closed" ? r3() : qc(t3, r3);
        }(e2, s2._closedPromise, () => {
          r2 ? b2() : y2(() => function(e3) {
            const t3 = e3._ownerWritableStream, r3 = t3._state;
            return xh(t3) || r3 === "closed" ? Uc(void 0) : r3 === "errored" ? Bc(t3._storedError) : Rh(e3);
          }(o2));
        }), xh(t2) || t2._state === "closed") {
          const t3 = new TypeError("the destination writable stream closed before all data could be piped to it");
          n2 ? b2(true, t3) : y2(() => Df(e2, t3), true, t3);
        }
        function l2() {
          const e3 = u2;
          return Tc(u2, () => e3 !== u2 ? l2() : void 0);
        }
        function p2(e3, t3, r3) {
          e3._state === "errored" ? r3(e3._storedError) : Oc(t3, r3);
        }
        function y2(e3, r3, i3) {
          function n3() {
            zc(e3(), () => m2(r3, i3), (e4) => m2(true, e4));
          }
          c2 || (c2 = true, t2._state !== "writable" || xh(t2) ? n3() : qc(l2(), n3));
        }
        function b2(e3, r3) {
          c2 || (c2 = true, t2._state !== "writable" || xh(t2) ? m2(e3, r3) : qc(l2(), () => m2(e3, r3)));
        }
        function m2(e3, t3) {
          Bh(o2), $c(s2), a2 !== void 0 && a2.removeEventListener("abort", d2), e3 ? f2(t3) : h2(void 0);
        }
        Nc(Ic((e3, t3) => {
          !function r3(i3) {
            i3 ? e3() : Tc(c2 ? Uc(true) : Tc(o2._readyPromise, () => Ic((e4, t4) => {
              ku(s2, { _chunkSteps: (t5) => {
                u2 = Tc(Th(o2, t5), void 0, Ec), e4(false);
              }, _closeSteps: () => e4(true), _errorSteps: t4 });
            })), r3, t3);
          }(false);
        }));
      });
    }
    var cf = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!uf(this))
          throw wf("desiredSize");
        return bf(this);
      }
      close() {
        if (!uf(this))
          throw wf("close");
        if (!mf(this))
          throw new TypeError("The stream is not in a state that permits close");
        lf(this);
      }
      enqueue(e2) {
        if (!uf(this))
          throw wf("enqueue");
        if (!mf(this))
          throw new TypeError("The stream is not in a state that permits enqueue");
        return pf(this, e2);
      }
      error(e2) {
        if (!uf(this))
          throw wf("error");
        yf(this, e2);
      }
      [ru](e2) {
        Iu(this);
        const t2 = this._cancelAlgorithm(e2);
        return df(this), t2;
      }
      [iu](e2) {
        const t2 = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const r2 = Du(this);
          this._closeRequested && this._queue.length === 0 ? (df(this), Rf(t2)) : hf(this), e2._chunkSteps(r2);
        } else
          bu(t2, e2), hf(this);
      }
    };
    function uf(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledReadableStream");
    }
    function hf(e2) {
      if (!ff(e2))
        return;
      if (e2._pulling)
        return void (e2._pullAgain = true);
      e2._pulling = true;
      zc(e2._pullAlgorithm(), () => {
        e2._pulling = false, e2._pullAgain && (e2._pullAgain = false, hf(e2));
      }, (t2) => {
        yf(e2, t2);
      });
    }
    function ff(e2) {
      const t2 = e2._controlledReadableStream;
      if (!mf(e2))
        return false;
      if (!e2._started)
        return false;
      if (Kf(t2) && gu(t2) > 0)
        return true;
      return bf(e2) > 0;
    }
    function df(e2) {
      e2._pullAlgorithm = void 0, e2._cancelAlgorithm = void 0, e2._strategySizeAlgorithm = void 0;
    }
    function lf(e2) {
      if (!mf(e2))
        return;
      const t2 = e2._controlledReadableStream;
      e2._closeRequested = true, e2._queue.length === 0 && (df(e2), Rf(t2));
    }
    function pf(e2, t2) {
      if (!mf(e2))
        return;
      const r2 = e2._controlledReadableStream;
      if (Kf(r2) && gu(r2) > 0)
        mu(r2, t2, false);
      else {
        let r3;
        try {
          r3 = e2._strategySizeAlgorithm(t2);
        } catch (t3) {
          throw yf(e2, t3), t3;
        }
        try {
          Ru(e2, t2, r3);
        } catch (t3) {
          throw yf(e2, t3), t3;
        }
      }
      hf(e2);
    }
    function yf(e2, t2) {
      const r2 = e2._controlledReadableStream;
      r2._state === "readable" && (Iu(e2), df(e2), If(r2, t2));
    }
    function bf(e2) {
      const t2 = e2._controlledReadableStream._state;
      return t2 === "errored" ? null : t2 === "closed" ? 0 : e2._strategyHWM - e2._queueTotalSize;
    }
    function mf(e2) {
      const t2 = e2._controlledReadableStream._state;
      return !e2._closeRequested && t2 === "readable";
    }
    function gf(e2, t2, r2, i2, n2, a2, s2) {
      t2._controlledReadableStream = e2, t2._queue = void 0, t2._queueTotalSize = void 0, Iu(t2), t2._started = false, t2._closeRequested = false, t2._pullAgain = false, t2._pulling = false, t2._strategySizeAlgorithm = s2, t2._strategyHWM = a2, t2._pullAlgorithm = i2, t2._cancelAlgorithm = n2, e2._readableStreamController = t2;
      zc(Uc(r2()), () => {
        t2._started = true, hf(t2);
      }, (e3) => {
        yf(t2, e3);
      });
    }
    function wf(e2) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);
    }
    function vf(e2, t2, r2) {
      return ou(e2, r2), (r3) => Wc(e2, t2, [r3]);
    }
    function _f(e2, t2, r2) {
      return ou(e2, r2), (r3) => Wc(e2, t2, [r3]);
    }
    function kf(e2, t2, r2) {
      return ou(e2, r2), (r3) => Lc(e2, t2, [r3]);
    }
    function Af(e2, t2) {
      if ((e2 = "" + e2) !== "bytes")
        throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);
      return e2;
    }
    function Sf(e2, t2) {
      if ((e2 = "" + e2) !== "byob")
        throw new TypeError(`${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);
      return e2;
    }
    function Ef(e2, t2) {
      su(e2, t2);
      const r2 = e2 == null ? void 0 : e2.preventAbort, i2 = e2 == null ? void 0 : e2.preventCancel, n2 = e2 == null ? void 0 : e2.preventClose, a2 = e2 == null ? void 0 : e2.signal;
      return a2 !== void 0 && function(e3, t3) {
        if (!function(e4) {
          if (typeof e4 != "object" || e4 === null)
            return false;
          try {
            return typeof e4.aborted == "boolean";
          } catch (e5) {
            return false;
          }
        }(e3))
          throw new TypeError(t3 + " is not an AbortSignal.");
      }(a2, t2 + " has member 'signal' that"), { preventAbort: !!r2, preventCancel: !!i2, preventClose: !!n2, signal: a2 };
    }
    Object.defineProperties(cf.prototype, { close: { enumerable: true }, enqueue: { enumerable: true }, error: { enumerable: true }, desiredSize: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(cf.prototype, Sc.toStringTag, { value: "ReadableStreamDefaultController", configurable: true });
    var Pf = class {
      constructor(e2 = {}, t2 = {}) {
        e2 === void 0 ? e2 = null : cu(e2, "First parameter");
        const r2 = hh(t2, "Second parameter"), i2 = function(e3, t3) {
          su(e3, t3);
          const r3 = e3, i3 = r3 == null ? void 0 : r3.autoAllocateChunkSize, n2 = r3 == null ? void 0 : r3.cancel, a2 = r3 == null ? void 0 : r3.pull, s2 = r3 == null ? void 0 : r3.start, o2 = r3 == null ? void 0 : r3.type;
          return { autoAllocateChunkSize: i3 === void 0 ? void 0 : lu(i3, t3 + " has member 'autoAllocateChunkSize' that"), cancel: n2 === void 0 ? void 0 : vf(n2, r3, t3 + " has member 'cancel' that"), pull: a2 === void 0 ? void 0 : _f(a2, r3, t3 + " has member 'pull' that"), start: s2 === void 0 ? void 0 : kf(s2, r3, t3 + " has member 'start' that"), type: o2 === void 0 ? void 0 : Af(o2, t3 + " has member 'type' that") };
        }(e2, "First parameter");
        if (Mf(this), i2.type === "bytes") {
          if (r2.size !== void 0)
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          Ju(this, i2, ch(r2, 0));
        } else {
          const e3 = uh(r2);
          !function(e4, t3, r3, i3) {
            const n2 = Object.create(cf.prototype);
            let a2 = () => {
            }, s2 = () => Uc(void 0), o2 = () => Uc(void 0);
            t3.start !== void 0 && (a2 = () => t3.start(n2)), t3.pull !== void 0 && (s2 = () => t3.pull(n2)), t3.cancel !== void 0 && (o2 = (e5) => t3.cancel(e5)), gf(e4, n2, a2, s2, o2, r3, i3);
          }(this, i2, ch(r2, 1), e3);
        }
      }
      get locked() {
        if (!Cf(this))
          throw Uf("locked");
        return Kf(this);
      }
      cancel(e2) {
        return Cf(this) ? Kf(this) ? Bc(new TypeError("Cannot cancel a stream that already has a reader")) : Df(this, e2) : Bc(Uf("cancel"));
      }
      getReader(e2) {
        if (!Cf(this))
          throw Uf("getReader");
        return function(e3, t2) {
          su(e3, t2);
          const r2 = e3 == null ? void 0 : e3.mode;
          return { mode: r2 === void 0 ? void 0 : Sf(r2, t2 + " has member 'mode' that") };
        }(e2, "First parameter").mode === void 0 ? yu(this) : function(e3) {
          return new ah(e3);
        }(this);
      }
      pipeThrough(e2, t2 = {}) {
        if (!Cf(this))
          throw Uf("pipeThrough");
        uu(e2, 1, "pipeThrough");
        const r2 = function(e3, t3) {
          su(e3, t3);
          const r3 = e3 == null ? void 0 : e3.readable;
          hu(r3, "readable", "ReadableWritablePair"), pu(r3, t3 + " has member 'readable' that");
          const i3 = e3 == null ? void 0 : e3.writable;
          return hu(i3, "writable", "ReadableWritablePair"), bh(i3, t3 + " has member 'writable' that"), { readable: r3, writable: i3 };
        }(e2, "First parameter"), i2 = Ef(t2, "Second parameter");
        if (Kf(this))
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        if (_h(r2.writable))
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        return Nc(of(this, r2.writable, i2.preventClose, i2.preventAbort, i2.preventCancel, i2.signal)), r2.readable;
      }
      pipeTo(e2, t2 = {}) {
        if (!Cf(this))
          return Bc(Uf("pipeTo"));
        if (e2 === void 0)
          return Bc("Parameter 1 is required in 'pipeTo'.");
        if (!vh(e2))
          return Bc(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
        let r2;
        try {
          r2 = Ef(t2, "Second parameter");
        } catch (e3) {
          return Bc(e3);
        }
        return Kf(this) ? Bc(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")) : _h(e2) ? Bc(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")) : of(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);
      }
      tee() {
        if (!Cf(this))
          throw Uf("tee");
        const e2 = function(e3, t2) {
          const r2 = yu(e3);
          let i2, n2, a2, s2, o2, c2 = false, u2 = false, h2 = false;
          const f2 = Ic((e4) => {
            o2 = e4;
          });
          function d2() {
            return c2 || (c2 = true, ku(r2, { _chunkSteps: (e4) => {
              jc(() => {
                c2 = false;
                const t3 = e4, r3 = e4;
                u2 || pf(a2._readableStreamController, t3), h2 || pf(s2._readableStreamController, r3);
              });
            }, _closeSteps: () => {
              c2 = false, u2 || lf(a2._readableStreamController), h2 || lf(s2._readableStreamController), u2 && h2 || o2(void 0);
            }, _errorSteps: () => {
              c2 = false;
            } })), Uc(void 0);
          }
          function l2() {
          }
          return a2 = xf(l2, d2, function(t3) {
            if (u2 = true, i2 = t3, h2) {
              const t4 = Uu([i2, n2]), r3 = Df(e3, t4);
              o2(r3);
            }
            return f2;
          }), s2 = xf(l2, d2, function(t3) {
            if (h2 = true, n2 = t3, u2) {
              const t4 = Uu([i2, n2]), r3 = Df(e3, t4);
              o2(r3);
            }
            return f2;
          }), Oc(r2._closedPromise, (e4) => {
            yf(a2._readableStreamController, e4), yf(s2._readableStreamController, e4), u2 && h2 || o2(void 0);
          }), [a2, s2];
        }(this);
        return Uu(e2);
      }
      values(e2) {
        if (!Cf(this))
          throw Uf("values");
        return function(e3, t2) {
          const r2 = yu(e3), i2 = new Eu(r2, t2), n2 = Object.create(Pu);
          return n2._asyncIteratorImpl = i2, n2;
        }(this, function(e3, t2) {
          return su(e3, t2), { preventCancel: !!(e3 == null ? void 0 : e3.preventCancel) };
        }(e2, "First parameter").preventCancel);
      }
    };
    function xf(e2, t2, r2, i2 = 1, n2 = () => 1) {
      const a2 = Object.create(Pf.prototype);
      Mf(a2);
      return gf(a2, Object.create(cf.prototype), e2, t2, r2, i2, n2), a2;
    }
    function Mf(e2) {
      e2._state = "readable", e2._reader = void 0, e2._storedError = void 0, e2._disturbed = false;
    }
    function Cf(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_readableStreamController");
    }
    function Kf(e2) {
      return e2._reader !== void 0;
    }
    function Df(e2, t2) {
      if (e2._disturbed = true, e2._state === "closed")
        return Uc(void 0);
      if (e2._state === "errored")
        return Bc(e2._storedError);
      Rf(e2);
      return Fc(e2._readableStreamController[ru](t2), Ec);
    }
    function Rf(e2) {
      e2._state = "closed";
      const t2 = e2._reader;
      t2 !== void 0 && (Jc(t2), _u(t2) && (t2._readRequests.forEach((e3) => {
        e3._closeSteps();
      }), t2._readRequests = new Hc()));
    }
    function If(e2, t2) {
      e2._state = "errored", e2._storedError = t2;
      const r2 = e2._reader;
      r2 !== void 0 && (Qc(r2, t2), _u(r2) ? (r2._readRequests.forEach((e3) => {
        e3._errorSteps(t2);
      }), r2._readRequests = new Hc()) : (r2._readIntoRequests.forEach((e3) => {
        e3._errorSteps(t2);
      }), r2._readIntoRequests = new Hc()));
    }
    function Uf(e2) {
      return new TypeError(`ReadableStream.prototype.${e2} can only be used on a ReadableStream`);
    }
    function Bf(e2, t2) {
      su(e2, t2);
      const r2 = e2 == null ? void 0 : e2.highWaterMark;
      return hu(r2, "highWaterMark", "QueuingStrategyInit"), { highWaterMark: fu(r2) };
    }
    Object.defineProperties(Pf.prototype, { cancel: { enumerable: true }, getReader: { enumerable: true }, pipeThrough: { enumerable: true }, pipeTo: { enumerable: true }, tee: { enumerable: true }, values: { enumerable: true }, locked: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Pf.prototype, Sc.toStringTag, { value: "ReadableStream", configurable: true }), typeof Sc.asyncIterator == "symbol" && Object.defineProperty(Pf.prototype, Sc.asyncIterator, { value: Pf.prototype.values, writable: true, configurable: true });
    var Tf = function(e2) {
      return e2.byteLength;
    };
    var zf = class {
      constructor(e2) {
        uu(e2, 1, "ByteLengthQueuingStrategy"), e2 = Bf(e2, "First parameter"), this._byteLengthQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!Of(this))
          throw qf("highWaterMark");
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!Of(this))
          throw qf("size");
        return Tf;
      }
    };
    function qf(e2) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);
    }
    function Of(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_byteLengthQueuingStrategyHighWaterMark");
    }
    Object.defineProperties(zf.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(zf.prototype, Sc.toStringTag, { value: "ByteLengthQueuingStrategy", configurable: true });
    var Ff = function() {
      return 1;
    };
    var Nf = class {
      constructor(e2) {
        uu(e2, 1, "CountQueuingStrategy"), e2 = Bf(e2, "First parameter"), this._countQueuingStrategyHighWaterMark = e2.highWaterMark;
      }
      get highWaterMark() {
        if (!Lf(this))
          throw jf("highWaterMark");
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!Lf(this))
          throw jf("size");
        return Ff;
      }
    };
    function jf(e2) {
      return new TypeError(`CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);
    }
    function Lf(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_countQueuingStrategyHighWaterMark");
    }
    function Wf(e2, t2, r2) {
      return ou(e2, r2), (r3) => Wc(e2, t2, [r3]);
    }
    function Hf(e2, t2, r2) {
      return ou(e2, r2), (r3) => Lc(e2, t2, [r3]);
    }
    function Gf(e2, t2, r2) {
      return ou(e2, r2), (r3, i2) => Wc(e2, t2, [r3, i2]);
    }
    Object.defineProperties(Nf.prototype, { highWaterMark: { enumerable: true }, size: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Nf.prototype, Sc.toStringTag, { value: "CountQueuingStrategy", configurable: true });
    var Vf = class {
      constructor(e2 = {}, t2 = {}, r2 = {}) {
        e2 === void 0 && (e2 = null);
        const i2 = hh(t2, "Second parameter"), n2 = hh(r2, "Third parameter"), a2 = function(e3, t3) {
          su(e3, t3);
          const r3 = e3 == null ? void 0 : e3.flush, i3 = e3 == null ? void 0 : e3.readableType, n3 = e3 == null ? void 0 : e3.start, a3 = e3 == null ? void 0 : e3.transform, s3 = e3 == null ? void 0 : e3.writableType;
          return { flush: r3 === void 0 ? void 0 : Wf(r3, e3, t3 + " has member 'flush' that"), readableType: i3, start: n3 === void 0 ? void 0 : Hf(n3, e3, t3 + " has member 'start' that"), transform: a3 === void 0 ? void 0 : Gf(a3, e3, t3 + " has member 'transform' that"), writableType: s3 };
        }(e2, "First parameter");
        if (a2.readableType !== void 0)
          throw new RangeError("Invalid readableType specified");
        if (a2.writableType !== void 0)
          throw new RangeError("Invalid writableType specified");
        const s2 = ch(n2, 0), o2 = uh(n2), c2 = ch(i2, 1), u2 = uh(i2);
        let h2;
        !function(e3, t3, r3, i3, n3, a3) {
          function s3() {
            return t3;
          }
          function o3(t4) {
            return function(e4, t5) {
              const r4 = e4._transformStreamController;
              if (e4._backpressure) {
                return Fc(e4._backpressureChangePromise, () => {
                  const i4 = e4._writable;
                  if (i4._state === "erroring")
                    throw i4._storedError;
                  return rd(r4, t5);
                });
              }
              return rd(r4, t5);
            }(e3, t4);
          }
          function c3(t4) {
            return function(e4, t5) {
              return Zf(e4, t5), Uc(void 0);
            }(e3, t4);
          }
          function u3() {
            return function(e4) {
              const t4 = e4._readable, r4 = e4._transformStreamController, i4 = r4._flushAlgorithm();
              return ed(r4), Fc(i4, () => {
                if (t4._state === "errored")
                  throw t4._storedError;
                lf(t4._readableStreamController);
              }, (r5) => {
                throw Zf(e4, r5), t4._storedError;
              });
            }(e3);
          }
          function h3() {
            return function(e4) {
              return Xf(e4, false), e4._backpressureChangePromise;
            }(e3);
          }
          function f2(t4) {
            return Yf(e3, t4), Uc(void 0);
          }
          e3._writable = function(e4, t4, r4, i4, n4 = 1, a4 = () => 1) {
            const s4 = Object.create(mh.prototype);
            return wh(s4), Oh(s4, Object.create(qh.prototype), e4, t4, r4, i4, n4, a4), s4;
          }(s3, o3, u3, c3, r3, i3), e3._readable = xf(s3, h3, f2, n3, a3), e3._backpressure = void 0, e3._backpressureChangePromise = void 0, e3._backpressureChangePromise_resolve = void 0, Xf(e3, true), e3._transformStreamController = void 0;
        }(this, Ic((e3) => {
          h2 = e3;
        }), c2, u2, s2, o2), function(e3, t3) {
          const r3 = Object.create(Qf.prototype);
          let i3 = (e4) => {
            try {
              return td(r3, e4), Uc(void 0);
            } catch (e5) {
              return Bc(e5);
            }
          }, n3 = () => Uc(void 0);
          t3.transform !== void 0 && (i3 = (e4) => t3.transform(e4, r3));
          t3.flush !== void 0 && (n3 = () => t3.flush(r3));
          !function(e4, t4, r4, i4) {
            t4._controlledTransformStream = e4, e4._transformStreamController = t4, t4._transformAlgorithm = r4, t4._flushAlgorithm = i4;
          }(e3, r3, i3, n3);
        }(this, a2), a2.start !== void 0 ? h2(a2.start(this._transformStreamController)) : h2(void 0);
      }
      get readable() {
        if (!$f(this))
          throw nd("readable");
        return this._readable;
      }
      get writable() {
        if (!$f(this))
          throw nd("writable");
        return this._writable;
      }
    };
    function $f(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_transformStreamController");
    }
    function Zf(e2, t2) {
      yf(e2._readable._readableStreamController, t2), Yf(e2, t2);
    }
    function Yf(e2, t2) {
      ed(e2._transformStreamController), Lh(e2._writable._writableStreamController, t2), e2._backpressure && Xf(e2, false);
    }
    function Xf(e2, t2) {
      e2._backpressureChangePromise !== void 0 && e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise = Ic((t3) => {
        e2._backpressureChangePromise_resolve = t3;
      }), e2._backpressure = t2;
    }
    Object.defineProperties(Vf.prototype, { readable: { enumerable: true }, writable: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Vf.prototype, Sc.toStringTag, { value: "TransformStream", configurable: true });
    var Qf = class {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!Jf(this))
          throw id("desiredSize");
        return bf(this._controlledTransformStream._readable._readableStreamController);
      }
      enqueue(e2) {
        if (!Jf(this))
          throw id("enqueue");
        td(this, e2);
      }
      error(e2) {
        if (!Jf(this))
          throw id("error");
        var t2;
        t2 = e2, Zf(this._controlledTransformStream, t2);
      }
      terminate() {
        if (!Jf(this))
          throw id("terminate");
        !function(e2) {
          const t2 = e2._controlledTransformStream;
          lf(t2._readable._readableStreamController);
          Yf(t2, new TypeError("TransformStream terminated"));
        }(this);
      }
    };
    function Jf(e2) {
      return !!xc(e2) && !!Object.prototype.hasOwnProperty.call(e2, "_controlledTransformStream");
    }
    function ed(e2) {
      e2._transformAlgorithm = void 0, e2._flushAlgorithm = void 0;
    }
    function td(e2, t2) {
      const r2 = e2._controlledTransformStream, i2 = r2._readable._readableStreamController;
      if (!mf(i2))
        throw new TypeError("Readable side is not in a state that permits enqueue");
      try {
        pf(i2, t2);
      } catch (e3) {
        throw Yf(r2, e3), r2._readable._storedError;
      }
      (function(e3) {
        return !ff(e3);
      })(i2) !== r2._backpressure && Xf(r2, true);
    }
    function rd(e2, t2) {
      return Fc(e2._transformAlgorithm(t2), void 0, (t3) => {
        throw Zf(e2._controlledTransformStream, t3), t3;
      });
    }
    function id(e2) {
      return new TypeError(`TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);
    }
    function nd(e2) {
      return new TypeError(`TransformStream.prototype.${e2} can only be used on a TransformStream`);
    }
    Object.defineProperties(Qf.prototype, { enqueue: { enumerable: true }, error: { enumerable: true }, terminate: { enumerable: true }, desiredSize: { enumerable: true } }), typeof Sc.toStringTag == "symbol" && Object.defineProperty(Qf.prototype, Sc.toStringTag, { value: "TransformStreamDefaultController", configurable: true });
    var ad = /* @__PURE__ */ Object.freeze({ __proto__: null, ByteLengthQueuingStrategy: zf, CountQueuingStrategy: Nf, ReadableByteStreamController: Tu, ReadableStream: Pf, ReadableStreamBYOBReader: ah, ReadableStreamBYOBRequest: Bu, ReadableStreamDefaultController: cf, ReadableStreamDefaultReader: vu, TransformStream: Vf, TransformStreamDefaultController: Qf, WritableStream: mh, WritableStreamDefaultController: qh, WritableStreamDefaultWriter: Kh });
    var sd = function(e2, t2) {
      return (sd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
        e3.__proto__ = t3;
      } || function(e3, t3) {
        for (var r2 in t3)
          Object.prototype.hasOwnProperty.call(t3, r2) && (e3[r2] = t3[r2]);
      })(e2, t2);
    };
    function od(e2, t2) {
      if (typeof t2 != "function" && t2 !== null)
        throw new TypeError("Class extends value " + t2 + " is not a constructor or null");
      function r2() {
        this.constructor = e2;
      }
      sd(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (r2.prototype = t2.prototype, new r2());
    }
    function cd(e2) {
      if (!e2)
        throw new TypeError("Assertion failed");
    }
    function ud() {
    }
    function hd(e2) {
      return typeof e2 == "object" && e2 !== null || typeof e2 == "function";
    }
    function fd(e2) {
      if (typeof e2 != "function")
        return false;
      var t2 = false;
      try {
        new e2({ start: function() {
          t2 = true;
        } });
      } catch (e3) {
      }
      return t2;
    }
    function dd(e2) {
      return !!hd(e2) && typeof e2.getReader == "function";
    }
    function ld(e2) {
      return !!hd(e2) && typeof e2.getWriter == "function";
    }
    function pd(e2) {
      return !!hd(e2) && (!!dd(e2.readable) && !!ld(e2.writable));
    }
    function yd(e2) {
      try {
        return e2.getReader({ mode: "byob" }).releaseLock(), true;
      } catch (e3) {
        return false;
      }
    }
    function bd(e2, t2) {
      var r2 = (t2 === void 0 ? {} : t2).type;
      return cd(dd(e2)), cd(e2.locked === false), (r2 = md(r2)) === "bytes" ? new _d(e2) : new wd(e2);
    }
    function md(e2) {
      var t2 = e2 + "";
      if (t2 === "bytes")
        return t2;
      if (e2 === void 0)
        return e2;
      throw new RangeError("Invalid type is specified");
    }
    var gd = function() {
      function e2(e3) {
        this._underlyingReader = void 0, this._readerMode = void 0, this._readableStreamController = void 0, this._pendingRead = void 0, this._underlyingStream = e3, this._attachDefaultReader();
      }
      return e2.prototype.start = function(e3) {
        this._readableStreamController = e3;
      }, e2.prototype.cancel = function(e3) {
        return cd(this._underlyingReader !== void 0), this._underlyingReader.cancel(e3);
      }, e2.prototype._attachDefaultReader = function() {
        if (this._readerMode !== "default") {
          this._detachReader();
          var e3 = this._underlyingStream.getReader();
          this._readerMode = "default", this._attachReader(e3);
        }
      }, e2.prototype._attachReader = function(e3) {
        var t2 = this;
        cd(this._underlyingReader === void 0), this._underlyingReader = e3;
        var r2 = this._underlyingReader.closed;
        r2 && r2.then(function() {
          return t2._finishPendingRead();
        }).then(function() {
          e3 === t2._underlyingReader && t2._readableStreamController.close();
        }, function(r3) {
          e3 === t2._underlyingReader && t2._readableStreamController.error(r3);
        }).catch(ud);
      }, e2.prototype._detachReader = function() {
        this._underlyingReader !== void 0 && (this._underlyingReader.releaseLock(), this._underlyingReader = void 0, this._readerMode = void 0);
      }, e2.prototype._pullWithDefaultReader = function() {
        var e3 = this;
        this._attachDefaultReader();
        var t2 = this._underlyingReader.read().then(function(t3) {
          var r2 = e3._readableStreamController;
          t3.done ? e3._tryClose() : r2.enqueue(t3.value);
        });
        return this._setPendingRead(t2), t2;
      }, e2.prototype._tryClose = function() {
        try {
          this._readableStreamController.close();
        } catch (e3) {
        }
      }, e2.prototype._setPendingRead = function(e3) {
        var t2, r2 = this, i2 = function() {
          r2._pendingRead === t2 && (r2._pendingRead = void 0);
        };
        this._pendingRead = t2 = e3.then(i2, i2);
      }, e2.prototype._finishPendingRead = function() {
        var e3 = this;
        if (this._pendingRead) {
          var t2 = function() {
            return e3._finishPendingRead();
          };
          return this._pendingRead.then(t2, t2);
        }
      }, e2;
    }();
    var wd = function(e2) {
      function t2() {
        return e2 !== null && e2.apply(this, arguments) || this;
      }
      return od(t2, e2), t2.prototype.pull = function() {
        return this._pullWithDefaultReader();
      }, t2;
    }(gd);
    function vd(e2) {
      return new Uint8Array(e2.buffer, e2.byteOffset, e2.byteLength);
    }
    var _d = function(e2) {
      function t2(t3) {
        var r2 = this, i2 = yd(t3);
        return (r2 = e2.call(this, t3) || this)._supportsByob = i2, r2;
      }
      return od(t2, e2), Object.defineProperty(t2.prototype, "type", { get: function() {
        return "bytes";
      }, enumerable: false, configurable: true }), t2.prototype._attachByobReader = function() {
        if (this._readerMode !== "byob") {
          cd(this._supportsByob), this._detachReader();
          var e3 = this._underlyingStream.getReader({ mode: "byob" });
          this._readerMode = "byob", this._attachReader(e3);
        }
      }, t2.prototype.pull = function() {
        if (this._supportsByob) {
          var e3 = this._readableStreamController.byobRequest;
          if (e3)
            return this._pullWithByobRequest(e3);
        }
        return this._pullWithDefaultReader();
      }, t2.prototype._pullWithByobRequest = function(e3) {
        var t3 = this;
        this._attachByobReader();
        var r2 = new Uint8Array(e3.view.byteLength), i2 = this._underlyingReader.read(r2).then(function(r3) {
          var i3, n2, a2;
          t3._readableStreamController, r3.done ? (t3._tryClose(), e3.respond(0)) : (i3 = r3.value, n2 = e3.view, a2 = vd(i3), vd(n2).set(a2, 0), e3.respond(r3.value.byteLength));
        });
        return this._setPendingRead(i2), i2;
      }, t2;
    }(gd);
    function kd(e2) {
      cd(ld(e2)), cd(e2.locked === false);
      var t2 = e2.getWriter();
      return new Ad(t2);
    }
    var Ad = function() {
      function e2(e3) {
        var t2 = this;
        this._writableStreamController = void 0, this._pendingWrite = void 0, this._state = "writable", this._storedError = void 0, this._underlyingWriter = e3, this._errorPromise = new Promise(function(e4, r2) {
          t2._errorPromiseReject = r2;
        }), this._errorPromise.catch(ud);
      }
      return e2.prototype.start = function(e3) {
        var t2 = this;
        this._writableStreamController = e3, this._underlyingWriter.closed.then(function() {
          t2._state = "closed";
        }).catch(function(e4) {
          return t2._finishErroring(e4);
        });
      }, e2.prototype.write = function(e3) {
        var t2 = this, r2 = this._underlyingWriter;
        if (r2.desiredSize === null)
          return r2.ready;
        var i2 = r2.write(e3);
        i2.catch(function(e4) {
          return t2._finishErroring(e4);
        }), r2.ready.catch(function(e4) {
          return t2._startErroring(e4);
        });
        var n2 = Promise.race([i2, this._errorPromise]);
        return this._setPendingWrite(n2), n2;
      }, e2.prototype.close = function() {
        var e3 = this;
        return this._pendingWrite === void 0 ? this._underlyingWriter.close() : this._finishPendingWrite().then(function() {
          return e3.close();
        });
      }, e2.prototype.abort = function(e3) {
        if (this._state !== "errored")
          return this._underlyingWriter.abort(e3);
      }, e2.prototype._setPendingWrite = function(e3) {
        var t2, r2 = this, i2 = function() {
          r2._pendingWrite === t2 && (r2._pendingWrite = void 0);
        };
        this._pendingWrite = t2 = e3.then(i2, i2);
      }, e2.prototype._finishPendingWrite = function() {
        var e3 = this;
        if (this._pendingWrite === void 0)
          return Promise.resolve();
        var t2 = function() {
          return e3._finishPendingWrite();
        };
        return this._pendingWrite.then(t2, t2);
      }, e2.prototype._startErroring = function(e3) {
        var t2 = this;
        if (this._state === "writable") {
          this._state = "erroring", this._storedError = e3;
          var r2 = function() {
            return t2._finishErroring(e3);
          };
          this._pendingWrite === void 0 ? r2() : this._finishPendingWrite().then(r2, r2), this._writableStreamController.error(e3);
        }
      }, e2.prototype._finishErroring = function(e3) {
        this._state === "writable" && this._startErroring(e3), this._state === "erroring" && (this._state = "errored", this._errorPromiseReject(this._storedError));
      }, e2;
    }();
    function Sd(e2) {
      cd(pd(e2));
      var t2 = e2.readable, r2 = e2.writable;
      cd(t2.locked === false), cd(r2.locked === false);
      var i2, n2 = t2.getReader();
      try {
        i2 = r2.getWriter();
      } catch (e3) {
        throw n2.releaseLock(), e3;
      }
      return new Ed(n2, i2);
    }
    var Ed = function() {
      function e2(e3, t2) {
        var r2 = this;
        this._transformStreamController = void 0, this._onRead = function(e4) {
          if (!e4.done)
            return r2._transformStreamController.enqueue(e4.value), r2._reader.read().then(r2._onRead);
        }, this._onError = function(e4) {
          r2._flushReject(e4), r2._transformStreamController.error(e4), r2._reader.cancel(e4).catch(ud), r2._writer.abort(e4).catch(ud);
        }, this._onTerminate = function() {
          r2._flushResolve(), r2._transformStreamController.terminate();
          var e4 = new TypeError("TransformStream terminated");
          r2._writer.abort(e4).catch(ud);
        }, this._reader = e3, this._writer = t2, this._flushPromise = new Promise(function(e4, t3) {
          r2._flushResolve = e4, r2._flushReject = t3;
        });
      }
      return e2.prototype.start = function(e3) {
        this._transformStreamController = e3, this._reader.read().then(this._onRead).then(this._onTerminate, this._onError);
        var t2 = this._reader.closed;
        t2 && t2.then(this._onTerminate, this._onError);
      }, e2.prototype.transform = function(e3) {
        return this._writer.write(e3);
      }, e2.prototype.flush = function() {
        var e3 = this;
        return this._writer.close().then(function() {
          return e3._flushPromise;
        });
      }, e2;
    }();
    var Pd = /* @__PURE__ */ Object.freeze({ __proto__: null, createReadableStreamWrapper: function(e2) {
      cd(function(e3) {
        return !!fd(e3) && !!dd(new e3());
      }(e2));
      var t2 = function(e3) {
        try {
          return new e3({ type: "bytes" }), true;
        } catch (e4) {
          return false;
        }
      }(e2);
      return function(r2, i2) {
        var n2 = (i2 === void 0 ? {} : i2).type;
        if ((n2 = md(n2)) !== "bytes" || t2 || (n2 = void 0), r2.constructor === e2 && (n2 !== "bytes" || yd(r2)))
          return r2;
        if (n2 === "bytes") {
          var a2 = bd(r2, { type: n2 });
          return new e2(a2);
        }
        a2 = bd(r2);
        return new e2(a2);
      };
    }, createTransformStreamWrapper: function(e2) {
      return cd(function(e3) {
        return !!fd(e3) && !!pd(new e3());
      }(e2)), function(t2) {
        if (t2.constructor === e2)
          return t2;
        var r2 = Sd(t2);
        return new e2(r2);
      };
    }, createWrappingReadableSource: bd, createWrappingTransformer: Sd, createWrappingWritableSink: kd, createWritableStreamWrapper: function(e2) {
      return cd(function(e3) {
        return !!fd(e3) && !!ld(new e3());
      }(e2)), function(t2) {
        if (t2.constructor === e2)
          return t2;
        var r2 = kd(t2);
        return new e2(r2);
      };
    } });
    var xd = bt(function(e2) {
      !function(e3, t2) {
        function r2(e4, t3) {
          if (!e4)
            throw Error(t3 || "Assertion failed");
        }
        function i2(e4, t3) {
          e4.super_ = t3;
          var r3 = function() {
          };
          r3.prototype = t3.prototype, e4.prototype = new r3(), e4.prototype.constructor = e4;
        }
        function n2(e4, t3, r3) {
          if (n2.isBN(e4))
            return e4;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, e4 !== null && (t3 !== "le" && t3 !== "be" || (r3 = t3, t3 = 10), this._init(e4 || 0, t3 || 10, r3 || "be"));
        }
        var a2;
        typeof e3 == "object" ? e3.exports = n2 : t2.BN = n2, n2.BN = n2, n2.wordSize = 26;
        try {
          a2 = u.default.Buffer;
        } catch (e4) {
        }
        function s2(e4, t3, r3) {
          for (var i3 = 0, n3 = Math.min(e4.length, r3), a3 = t3; a3 < n3; a3++) {
            var s3 = e4.charCodeAt(a3) - 48;
            i3 <<= 4, i3 |= s3 >= 49 && s3 <= 54 ? s3 - 49 + 10 : s3 >= 17 && s3 <= 22 ? s3 - 17 + 10 : 15 & s3;
          }
          return i3;
        }
        function o2(e4, t3, r3, i3) {
          for (var n3 = 0, a3 = Math.min(e4.length, r3), s3 = t3; s3 < a3; s3++) {
            var o3 = e4.charCodeAt(s3) - 48;
            n3 *= i3, n3 += o3 >= 49 ? o3 - 49 + 10 : o3 >= 17 ? o3 - 17 + 10 : o3;
          }
          return n3;
        }
        n2.isBN = function(e4) {
          return e4 instanceof n2 || e4 !== null && typeof e4 == "object" && e4.constructor.wordSize === n2.wordSize && Array.isArray(e4.words);
        }, n2.max = function(e4, t3) {
          return e4.cmp(t3) > 0 ? e4 : t3;
        }, n2.min = function(e4, t3) {
          return e4.cmp(t3) < 0 ? e4 : t3;
        }, n2.prototype._init = function(e4, t3, i3) {
          if (typeof e4 == "number")
            return this._initNumber(e4, t3, i3);
          if (typeof e4 == "object")
            return this._initArray(e4, t3, i3);
          t3 === "hex" && (t3 = 16), r2(t3 === (0 | t3) && t3 >= 2 && t3 <= 36);
          var n3 = 0;
          (e4 = e4.toString().replace(/\s+/g, ""))[0] === "-" && n3++, t3 === 16 ? this._parseHex(e4, n3) : this._parseBase(e4, t3, n3), e4[0] === "-" && (this.negative = 1), this.strip(), i3 === "le" && this._initArray(this.toArray(), t3, i3);
        }, n2.prototype._initNumber = function(e4, t3, i3) {
          e4 < 0 && (this.negative = 1, e4 = -e4), e4 < 67108864 ? (this.words = [67108863 & e4], this.length = 1) : e4 < 4503599627370496 ? (this.words = [67108863 & e4, e4 / 67108864 & 67108863], this.length = 2) : (r2(e4 < 9007199254740992), this.words = [67108863 & e4, e4 / 67108864 & 67108863, 1], this.length = 3), i3 === "le" && this._initArray(this.toArray(), t3, i3);
        }, n2.prototype._initArray = function(e4, t3, i3) {
          if (r2(typeof e4.length == "number"), e4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(e4.length / 3), this.words = Array(this.length);
          for (var n3 = 0; n3 < this.length; n3++)
            this.words[n3] = 0;
          var a3, s3, o3 = 0;
          if (i3 === "be")
            for (n3 = e4.length - 1, a3 = 0; n3 >= 0; n3 -= 3)
              s3 = e4[n3] | e4[n3 - 1] << 8 | e4[n3 - 2] << 16, this.words[a3] |= s3 << o3 & 67108863, this.words[a3 + 1] = s3 >>> 26 - o3 & 67108863, (o3 += 24) >= 26 && (o3 -= 26, a3++);
          else if (i3 === "le")
            for (n3 = 0, a3 = 0; n3 < e4.length; n3 += 3)
              s3 = e4[n3] | e4[n3 + 1] << 8 | e4[n3 + 2] << 16, this.words[a3] |= s3 << o3 & 67108863, this.words[a3 + 1] = s3 >>> 26 - o3 & 67108863, (o3 += 24) >= 26 && (o3 -= 26, a3++);
          return this.strip();
        }, n2.prototype._parseHex = function(e4, t3) {
          this.length = Math.ceil((e4.length - t3) / 6), this.words = Array(this.length);
          for (var r3 = 0; r3 < this.length; r3++)
            this.words[r3] = 0;
          var i3, n3, a3 = 0;
          for (r3 = e4.length - 6, i3 = 0; r3 >= t3; r3 -= 6)
            n3 = s2(e4, r3, r3 + 6), this.words[i3] |= n3 << a3 & 67108863, this.words[i3 + 1] |= n3 >>> 26 - a3 & 4194303, (a3 += 24) >= 26 && (a3 -= 26, i3++);
          r3 + 6 !== t3 && (n3 = s2(e4, t3, r3 + 6), this.words[i3] |= n3 << a3 & 67108863, this.words[i3 + 1] |= n3 >>> 26 - a3 & 4194303), this.strip();
        }, n2.prototype._parseBase = function(e4, t3, r3) {
          this.words = [0], this.length = 1;
          for (var i3 = 0, n3 = 1; n3 <= 67108863; n3 *= t3)
            i3++;
          i3--, n3 = n3 / t3 | 0;
          for (var a3 = e4.length - r3, s3 = a3 % i3, c3 = Math.min(a3, a3 - s3) + r3, u2 = 0, h3 = r3; h3 < c3; h3 += i3)
            u2 = o2(e4, h3, h3 + i3, t3), this.imuln(n3), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          if (s3 !== 0) {
            var f3 = 1;
            for (u2 = o2(e4, h3, e4.length, t3), h3 = 0; h3 < s3; h3++)
              f3 *= t3;
            this.imuln(f3), this.words[0] + u2 < 67108864 ? this.words[0] += u2 : this._iaddn(u2);
          }
        }, n2.prototype.copy = function(e4) {
          e4.words = Array(this.length);
          for (var t3 = 0; t3 < this.length; t3++)
            e4.words[t3] = this.words[t3];
          e4.length = this.length, e4.negative = this.negative, e4.red = this.red;
        }, n2.prototype.clone = function() {
          var e4 = new n2(null);
          return this.copy(e4), e4;
        }, n2.prototype._expand = function(e4) {
          for (; this.length < e4; )
            this.words[this.length++] = 0;
          return this;
        }, n2.prototype.strip = function() {
          for (; this.length > 1 && this.words[this.length - 1] === 0; )
            this.length--;
          return this._normSign();
        }, n2.prototype._normSign = function() {
          return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
        }, n2.prototype.inspect = function() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var c2 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], f2 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        function d2(e4, t3, r3) {
          r3.negative = t3.negative ^ e4.negative;
          var i3 = e4.length + t3.length | 0;
          r3.length = i3, i3 = i3 - 1 | 0;
          var n3 = 0 | e4.words[0], a3 = 0 | t3.words[0], s3 = n3 * a3, o3 = 67108863 & s3, c3 = s3 / 67108864 | 0;
          r3.words[0] = o3;
          for (var u2 = 1; u2 < i3; u2++) {
            for (var h3 = c3 >>> 26, f3 = 67108863 & c3, d3 = Math.min(u2, t3.length - 1), l3 = Math.max(0, u2 - e4.length + 1); l3 <= d3; l3++) {
              var p3 = u2 - l3 | 0;
              h3 += (s3 = (n3 = 0 | e4.words[p3]) * (a3 = 0 | t3.words[l3]) + f3) / 67108864 | 0, f3 = 67108863 & s3;
            }
            r3.words[u2] = 0 | f3, c3 = 0 | h3;
          }
          return c3 !== 0 ? r3.words[u2] = 0 | c3 : r3.length--, r3.strip();
        }
        n2.prototype.toString = function(e4, t3) {
          var i3;
          if (t3 = 0 | t3 || 1, (e4 = e4 || 10) === 16 || e4 === "hex") {
            i3 = "";
            for (var n3 = 0, a3 = 0, s3 = 0; s3 < this.length; s3++) {
              var o3 = this.words[s3], u2 = (16777215 & (o3 << n3 | a3)).toString(16);
              i3 = (a3 = o3 >>> 24 - n3 & 16777215) !== 0 || s3 !== this.length - 1 ? c2[6 - u2.length] + u2 + i3 : u2 + i3, (n3 += 2) >= 26 && (n3 -= 26, s3--);
            }
            for (a3 !== 0 && (i3 = a3.toString(16) + i3); i3.length % t3 != 0; )
              i3 = "0" + i3;
            return this.negative !== 0 && (i3 = "-" + i3), i3;
          }
          if (e4 === (0 | e4) && e4 >= 2 && e4 <= 36) {
            var d3 = h2[e4], l3 = f2[e4];
            i3 = "";
            var p3 = this.clone();
            for (p3.negative = 0; !p3.isZero(); ) {
              var y3 = p3.modn(l3).toString(e4);
              i3 = (p3 = p3.idivn(l3)).isZero() ? y3 + i3 : c2[d3 - y3.length] + y3 + i3;
            }
            for (this.isZero() && (i3 = "0" + i3); i3.length % t3 != 0; )
              i3 = "0" + i3;
            return this.negative !== 0 && (i3 = "-" + i3), i3;
          }
          r2(false, "Base should be between 2 and 36");
        }, n2.prototype.toNumber = function() {
          var e4 = this.words[0];
          return this.length === 2 ? e4 += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? e4 += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r2(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -e4 : e4;
        }, n2.prototype.toJSON = function() {
          return this.toString(16);
        }, n2.prototype.toBuffer = function(e4, t3) {
          return r2(a2 !== void 0), this.toArrayLike(a2, e4, t3);
        }, n2.prototype.toArray = function(e4, t3) {
          return this.toArrayLike(Array, e4, t3);
        }, n2.prototype.toArrayLike = function(e4, t3, i3) {
          var n3 = this.byteLength(), a3 = i3 || Math.max(1, n3);
          r2(n3 <= a3, "byte array longer than desired length"), r2(a3 > 0, "Requested array length <= 0"), this.strip();
          var s3, o3, c3 = t3 === "le", u2 = new e4(a3), h3 = this.clone();
          if (c3) {
            for (o3 = 0; !h3.isZero(); o3++)
              s3 = h3.andln(255), h3.iushrn(8), u2[o3] = s3;
            for (; o3 < a3; o3++)
              u2[o3] = 0;
          } else {
            for (o3 = 0; o3 < a3 - n3; o3++)
              u2[o3] = 0;
            for (o3 = 0; !h3.isZero(); o3++)
              s3 = h3.andln(255), h3.iushrn(8), u2[a3 - o3 - 1] = s3;
          }
          return u2;
        }, n2.prototype._countBits = Math.clz32 ? function(e4) {
          return 32 - Math.clz32(e4);
        } : function(e4) {
          var t3 = e4, r3 = 0;
          return t3 >= 4096 && (r3 += 13, t3 >>>= 13), t3 >= 64 && (r3 += 7, t3 >>>= 7), t3 >= 8 && (r3 += 4, t3 >>>= 4), t3 >= 2 && (r3 += 2, t3 >>>= 2), r3 + t3;
        }, n2.prototype._zeroBits = function(e4) {
          if (e4 === 0)
            return 26;
          var t3 = e4, r3 = 0;
          return (8191 & t3) == 0 && (r3 += 13, t3 >>>= 13), (127 & t3) == 0 && (r3 += 7, t3 >>>= 7), (15 & t3) == 0 && (r3 += 4, t3 >>>= 4), (3 & t3) == 0 && (r3 += 2, t3 >>>= 2), (1 & t3) == 0 && r3++, r3;
        }, n2.prototype.bitLength = function() {
          var e4 = this.words[this.length - 1], t3 = this._countBits(e4);
          return 26 * (this.length - 1) + t3;
        }, n2.prototype.zeroBits = function() {
          if (this.isZero())
            return 0;
          for (var e4 = 0, t3 = 0; t3 < this.length; t3++) {
            var r3 = this._zeroBits(this.words[t3]);
            if (e4 += r3, r3 !== 26)
              break;
          }
          return e4;
        }, n2.prototype.byteLength = function() {
          return Math.ceil(this.bitLength() / 8);
        }, n2.prototype.toTwos = function(e4) {
          return this.negative !== 0 ? this.abs().inotn(e4).iaddn(1) : this.clone();
        }, n2.prototype.fromTwos = function(e4) {
          return this.testn(e4 - 1) ? this.notn(e4).iaddn(1).ineg() : this.clone();
        }, n2.prototype.isNeg = function() {
          return this.negative !== 0;
        }, n2.prototype.neg = function() {
          return this.clone().ineg();
        }, n2.prototype.ineg = function() {
          return this.isZero() || (this.negative ^= 1), this;
        }, n2.prototype.iuor = function(e4) {
          for (; this.length < e4.length; )
            this.words[this.length++] = 0;
          for (var t3 = 0; t3 < e4.length; t3++)
            this.words[t3] = this.words[t3] | e4.words[t3];
          return this.strip();
        }, n2.prototype.ior = function(e4) {
          return r2((this.negative | e4.negative) == 0), this.iuor(e4);
        }, n2.prototype.or = function(e4) {
          return this.length > e4.length ? this.clone().ior(e4) : e4.clone().ior(this);
        }, n2.prototype.uor = function(e4) {
          return this.length > e4.length ? this.clone().iuor(e4) : e4.clone().iuor(this);
        }, n2.prototype.iuand = function(e4) {
          var t3;
          t3 = this.length > e4.length ? e4 : this;
          for (var r3 = 0; r3 < t3.length; r3++)
            this.words[r3] = this.words[r3] & e4.words[r3];
          return this.length = t3.length, this.strip();
        }, n2.prototype.iand = function(e4) {
          return r2((this.negative | e4.negative) == 0), this.iuand(e4);
        }, n2.prototype.and = function(e4) {
          return this.length > e4.length ? this.clone().iand(e4) : e4.clone().iand(this);
        }, n2.prototype.uand = function(e4) {
          return this.length > e4.length ? this.clone().iuand(e4) : e4.clone().iuand(this);
        }, n2.prototype.iuxor = function(e4) {
          var t3, r3;
          this.length > e4.length ? (t3 = this, r3 = e4) : (t3 = e4, r3 = this);
          for (var i3 = 0; i3 < r3.length; i3++)
            this.words[i3] = t3.words[i3] ^ r3.words[i3];
          if (this !== t3)
            for (; i3 < t3.length; i3++)
              this.words[i3] = t3.words[i3];
          return this.length = t3.length, this.strip();
        }, n2.prototype.ixor = function(e4) {
          return r2((this.negative | e4.negative) == 0), this.iuxor(e4);
        }, n2.prototype.xor = function(e4) {
          return this.length > e4.length ? this.clone().ixor(e4) : e4.clone().ixor(this);
        }, n2.prototype.uxor = function(e4) {
          return this.length > e4.length ? this.clone().iuxor(e4) : e4.clone().iuxor(this);
        }, n2.prototype.inotn = function(e4) {
          r2(typeof e4 == "number" && e4 >= 0);
          var t3 = 0 | Math.ceil(e4 / 26), i3 = e4 % 26;
          this._expand(t3), i3 > 0 && t3--;
          for (var n3 = 0; n3 < t3; n3++)
            this.words[n3] = 67108863 & ~this.words[n3];
          return i3 > 0 && (this.words[n3] = ~this.words[n3] & 67108863 >> 26 - i3), this.strip();
        }, n2.prototype.notn = function(e4) {
          return this.clone().inotn(e4);
        }, n2.prototype.setn = function(e4, t3) {
          r2(typeof e4 == "number" && e4 >= 0);
          var i3 = e4 / 26 | 0, n3 = e4 % 26;
          return this._expand(i3 + 1), this.words[i3] = t3 ? this.words[i3] | 1 << n3 : this.words[i3] & ~(1 << n3), this.strip();
        }, n2.prototype.iadd = function(e4) {
          var t3, r3, i3;
          if (this.negative !== 0 && e4.negative === 0)
            return this.negative = 0, t3 = this.isub(e4), this.negative ^= 1, this._normSign();
          if (this.negative === 0 && e4.negative !== 0)
            return e4.negative = 0, t3 = this.isub(e4), e4.negative = 1, t3._normSign();
          this.length > e4.length ? (r3 = this, i3 = e4) : (r3 = e4, i3 = this);
          for (var n3 = 0, a3 = 0; a3 < i3.length; a3++)
            t3 = (0 | r3.words[a3]) + (0 | i3.words[a3]) + n3, this.words[a3] = 67108863 & t3, n3 = t3 >>> 26;
          for (; n3 !== 0 && a3 < r3.length; a3++)
            t3 = (0 | r3.words[a3]) + n3, this.words[a3] = 67108863 & t3, n3 = t3 >>> 26;
          if (this.length = r3.length, n3 !== 0)
            this.words[this.length] = n3, this.length++;
          else if (r3 !== this)
            for (; a3 < r3.length; a3++)
              this.words[a3] = r3.words[a3];
          return this;
        }, n2.prototype.add = function(e4) {
          var t3;
          return e4.negative !== 0 && this.negative === 0 ? (e4.negative = 0, t3 = this.sub(e4), e4.negative ^= 1, t3) : e4.negative === 0 && this.negative !== 0 ? (this.negative = 0, t3 = e4.sub(this), this.negative = 1, t3) : this.length > e4.length ? this.clone().iadd(e4) : e4.clone().iadd(this);
        }, n2.prototype.isub = function(e4) {
          if (e4.negative !== 0) {
            e4.negative = 0;
            var t3 = this.iadd(e4);
            return e4.negative = 1, t3._normSign();
          }
          if (this.negative !== 0)
            return this.negative = 0, this.iadd(e4), this.negative = 1, this._normSign();
          var r3, i3, n3 = this.cmp(e4);
          if (n3 === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          n3 > 0 ? (r3 = this, i3 = e4) : (r3 = e4, i3 = this);
          for (var a3 = 0, s3 = 0; s3 < i3.length; s3++)
            a3 = (t3 = (0 | r3.words[s3]) - (0 | i3.words[s3]) + a3) >> 26, this.words[s3] = 67108863 & t3;
          for (; a3 !== 0 && s3 < r3.length; s3++)
            a3 = (t3 = (0 | r3.words[s3]) + a3) >> 26, this.words[s3] = 67108863 & t3;
          if (a3 === 0 && s3 < r3.length && r3 !== this)
            for (; s3 < r3.length; s3++)
              this.words[s3] = r3.words[s3];
          return this.length = Math.max(this.length, s3), r3 !== this && (this.negative = 1), this.strip();
        }, n2.prototype.sub = function(e4) {
          return this.clone().isub(e4);
        };
        var l2 = function(e4, t3, r3) {
          var i3, n3, a3, s3 = e4.words, o3 = t3.words, c3 = r3.words, u2 = 0, h3 = 0 | s3[0], f3 = 8191 & h3, d3 = h3 >>> 13, l3 = 0 | s3[1], p3 = 8191 & l3, y3 = l3 >>> 13, b3 = 0 | s3[2], m3 = 8191 & b3, g3 = b3 >>> 13, w3 = 0 | s3[3], v3 = 8191 & w3, _3 = w3 >>> 13, k3 = 0 | s3[4], A3 = 8191 & k3, S2 = k3 >>> 13, E2 = 0 | s3[5], P2 = 8191 & E2, x2 = E2 >>> 13, M2 = 0 | s3[6], C2 = 8191 & M2, K2 = M2 >>> 13, D2 = 0 | s3[7], R2 = 8191 & D2, I2 = D2 >>> 13, U2 = 0 | s3[8], B2 = 8191 & U2, T2 = U2 >>> 13, z2 = 0 | s3[9], q2 = 8191 & z2, O2 = z2 >>> 13, F2 = 0 | o3[0], N2 = 8191 & F2, j2 = F2 >>> 13, L2 = 0 | o3[1], W2 = 8191 & L2, H2 = L2 >>> 13, G2 = 0 | o3[2], V2 = 8191 & G2, $2 = G2 >>> 13, Z2 = 0 | o3[3], Y2 = 8191 & Z2, X2 = Z2 >>> 13, Q2 = 0 | o3[4], J2 = 8191 & Q2, ee2 = Q2 >>> 13, te2 = 0 | o3[5], re2 = 8191 & te2, ie2 = te2 >>> 13, ne2 = 0 | o3[6], ae2 = 8191 & ne2, se2 = ne2 >>> 13, oe2 = 0 | o3[7], ce2 = 8191 & oe2, ue2 = oe2 >>> 13, he2 = 0 | o3[8], fe2 = 8191 & he2, de2 = he2 >>> 13, le2 = 0 | o3[9], pe2 = 8191 & le2, ye2 = le2 >>> 13;
          r3.negative = e4.negative ^ t3.negative, r3.length = 19;
          var be2 = (u2 + (i3 = Math.imul(f3, N2)) | 0) + ((8191 & (n3 = (n3 = Math.imul(f3, j2)) + Math.imul(d3, N2) | 0)) << 13) | 0;
          u2 = ((a3 = Math.imul(d3, j2)) + (n3 >>> 13) | 0) + (be2 >>> 26) | 0, be2 &= 67108863, i3 = Math.imul(p3, N2), n3 = (n3 = Math.imul(p3, j2)) + Math.imul(y3, N2) | 0, a3 = Math.imul(y3, j2);
          var me2 = (u2 + (i3 = i3 + Math.imul(f3, W2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, H2) | 0) + Math.imul(d3, W2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, H2) | 0) + (n3 >>> 13) | 0) + (me2 >>> 26) | 0, me2 &= 67108863, i3 = Math.imul(m3, N2), n3 = (n3 = Math.imul(m3, j2)) + Math.imul(g3, N2) | 0, a3 = Math.imul(g3, j2), i3 = i3 + Math.imul(p3, W2) | 0, n3 = (n3 = n3 + Math.imul(p3, H2) | 0) + Math.imul(y3, W2) | 0, a3 = a3 + Math.imul(y3, H2) | 0;
          var ge2 = (u2 + (i3 = i3 + Math.imul(f3, V2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, $2) | 0) + Math.imul(d3, V2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, $2) | 0) + (n3 >>> 13) | 0) + (ge2 >>> 26) | 0, ge2 &= 67108863, i3 = Math.imul(v3, N2), n3 = (n3 = Math.imul(v3, j2)) + Math.imul(_3, N2) | 0, a3 = Math.imul(_3, j2), i3 = i3 + Math.imul(m3, W2) | 0, n3 = (n3 = n3 + Math.imul(m3, H2) | 0) + Math.imul(g3, W2) | 0, a3 = a3 + Math.imul(g3, H2) | 0, i3 = i3 + Math.imul(p3, V2) | 0, n3 = (n3 = n3 + Math.imul(p3, $2) | 0) + Math.imul(y3, V2) | 0, a3 = a3 + Math.imul(y3, $2) | 0;
          var we2 = (u2 + (i3 = i3 + Math.imul(f3, Y2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, X2) | 0) + Math.imul(d3, Y2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, X2) | 0) + (n3 >>> 13) | 0) + (we2 >>> 26) | 0, we2 &= 67108863, i3 = Math.imul(A3, N2), n3 = (n3 = Math.imul(A3, j2)) + Math.imul(S2, N2) | 0, a3 = Math.imul(S2, j2), i3 = i3 + Math.imul(v3, W2) | 0, n3 = (n3 = n3 + Math.imul(v3, H2) | 0) + Math.imul(_3, W2) | 0, a3 = a3 + Math.imul(_3, H2) | 0, i3 = i3 + Math.imul(m3, V2) | 0, n3 = (n3 = n3 + Math.imul(m3, $2) | 0) + Math.imul(g3, V2) | 0, a3 = a3 + Math.imul(g3, $2) | 0, i3 = i3 + Math.imul(p3, Y2) | 0, n3 = (n3 = n3 + Math.imul(p3, X2) | 0) + Math.imul(y3, Y2) | 0, a3 = a3 + Math.imul(y3, X2) | 0;
          var ve2 = (u2 + (i3 = i3 + Math.imul(f3, J2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, ee2) | 0) + Math.imul(d3, J2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, ee2) | 0) + (n3 >>> 13) | 0) + (ve2 >>> 26) | 0, ve2 &= 67108863, i3 = Math.imul(P2, N2), n3 = (n3 = Math.imul(P2, j2)) + Math.imul(x2, N2) | 0, a3 = Math.imul(x2, j2), i3 = i3 + Math.imul(A3, W2) | 0, n3 = (n3 = n3 + Math.imul(A3, H2) | 0) + Math.imul(S2, W2) | 0, a3 = a3 + Math.imul(S2, H2) | 0, i3 = i3 + Math.imul(v3, V2) | 0, n3 = (n3 = n3 + Math.imul(v3, $2) | 0) + Math.imul(_3, V2) | 0, a3 = a3 + Math.imul(_3, $2) | 0, i3 = i3 + Math.imul(m3, Y2) | 0, n3 = (n3 = n3 + Math.imul(m3, X2) | 0) + Math.imul(g3, Y2) | 0, a3 = a3 + Math.imul(g3, X2) | 0, i3 = i3 + Math.imul(p3, J2) | 0, n3 = (n3 = n3 + Math.imul(p3, ee2) | 0) + Math.imul(y3, J2) | 0, a3 = a3 + Math.imul(y3, ee2) | 0;
          var _e2 = (u2 + (i3 = i3 + Math.imul(f3, re2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, ie2) | 0) + Math.imul(d3, re2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, ie2) | 0) + (n3 >>> 13) | 0) + (_e2 >>> 26) | 0, _e2 &= 67108863, i3 = Math.imul(C2, N2), n3 = (n3 = Math.imul(C2, j2)) + Math.imul(K2, N2) | 0, a3 = Math.imul(K2, j2), i3 = i3 + Math.imul(P2, W2) | 0, n3 = (n3 = n3 + Math.imul(P2, H2) | 0) + Math.imul(x2, W2) | 0, a3 = a3 + Math.imul(x2, H2) | 0, i3 = i3 + Math.imul(A3, V2) | 0, n3 = (n3 = n3 + Math.imul(A3, $2) | 0) + Math.imul(S2, V2) | 0, a3 = a3 + Math.imul(S2, $2) | 0, i3 = i3 + Math.imul(v3, Y2) | 0, n3 = (n3 = n3 + Math.imul(v3, X2) | 0) + Math.imul(_3, Y2) | 0, a3 = a3 + Math.imul(_3, X2) | 0, i3 = i3 + Math.imul(m3, J2) | 0, n3 = (n3 = n3 + Math.imul(m3, ee2) | 0) + Math.imul(g3, J2) | 0, a3 = a3 + Math.imul(g3, ee2) | 0, i3 = i3 + Math.imul(p3, re2) | 0, n3 = (n3 = n3 + Math.imul(p3, ie2) | 0) + Math.imul(y3, re2) | 0, a3 = a3 + Math.imul(y3, ie2) | 0;
          var ke2 = (u2 + (i3 = i3 + Math.imul(f3, ae2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, se2) | 0) + Math.imul(d3, ae2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, se2) | 0) + (n3 >>> 13) | 0) + (ke2 >>> 26) | 0, ke2 &= 67108863, i3 = Math.imul(R2, N2), n3 = (n3 = Math.imul(R2, j2)) + Math.imul(I2, N2) | 0, a3 = Math.imul(I2, j2), i3 = i3 + Math.imul(C2, W2) | 0, n3 = (n3 = n3 + Math.imul(C2, H2) | 0) + Math.imul(K2, W2) | 0, a3 = a3 + Math.imul(K2, H2) | 0, i3 = i3 + Math.imul(P2, V2) | 0, n3 = (n3 = n3 + Math.imul(P2, $2) | 0) + Math.imul(x2, V2) | 0, a3 = a3 + Math.imul(x2, $2) | 0, i3 = i3 + Math.imul(A3, Y2) | 0, n3 = (n3 = n3 + Math.imul(A3, X2) | 0) + Math.imul(S2, Y2) | 0, a3 = a3 + Math.imul(S2, X2) | 0, i3 = i3 + Math.imul(v3, J2) | 0, n3 = (n3 = n3 + Math.imul(v3, ee2) | 0) + Math.imul(_3, J2) | 0, a3 = a3 + Math.imul(_3, ee2) | 0, i3 = i3 + Math.imul(m3, re2) | 0, n3 = (n3 = n3 + Math.imul(m3, ie2) | 0) + Math.imul(g3, re2) | 0, a3 = a3 + Math.imul(g3, ie2) | 0, i3 = i3 + Math.imul(p3, ae2) | 0, n3 = (n3 = n3 + Math.imul(p3, se2) | 0) + Math.imul(y3, ae2) | 0, a3 = a3 + Math.imul(y3, se2) | 0;
          var Ae2 = (u2 + (i3 = i3 + Math.imul(f3, ce2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, ue2) | 0) + Math.imul(d3, ce2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, ue2) | 0) + (n3 >>> 13) | 0) + (Ae2 >>> 26) | 0, Ae2 &= 67108863, i3 = Math.imul(B2, N2), n3 = (n3 = Math.imul(B2, j2)) + Math.imul(T2, N2) | 0, a3 = Math.imul(T2, j2), i3 = i3 + Math.imul(R2, W2) | 0, n3 = (n3 = n3 + Math.imul(R2, H2) | 0) + Math.imul(I2, W2) | 0, a3 = a3 + Math.imul(I2, H2) | 0, i3 = i3 + Math.imul(C2, V2) | 0, n3 = (n3 = n3 + Math.imul(C2, $2) | 0) + Math.imul(K2, V2) | 0, a3 = a3 + Math.imul(K2, $2) | 0, i3 = i3 + Math.imul(P2, Y2) | 0, n3 = (n3 = n3 + Math.imul(P2, X2) | 0) + Math.imul(x2, Y2) | 0, a3 = a3 + Math.imul(x2, X2) | 0, i3 = i3 + Math.imul(A3, J2) | 0, n3 = (n3 = n3 + Math.imul(A3, ee2) | 0) + Math.imul(S2, J2) | 0, a3 = a3 + Math.imul(S2, ee2) | 0, i3 = i3 + Math.imul(v3, re2) | 0, n3 = (n3 = n3 + Math.imul(v3, ie2) | 0) + Math.imul(_3, re2) | 0, a3 = a3 + Math.imul(_3, ie2) | 0, i3 = i3 + Math.imul(m3, ae2) | 0, n3 = (n3 = n3 + Math.imul(m3, se2) | 0) + Math.imul(g3, ae2) | 0, a3 = a3 + Math.imul(g3, se2) | 0, i3 = i3 + Math.imul(p3, ce2) | 0, n3 = (n3 = n3 + Math.imul(p3, ue2) | 0) + Math.imul(y3, ce2) | 0, a3 = a3 + Math.imul(y3, ue2) | 0;
          var Se2 = (u2 + (i3 = i3 + Math.imul(f3, fe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, de2) | 0) + Math.imul(d3, fe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, de2) | 0) + (n3 >>> 13) | 0) + (Se2 >>> 26) | 0, Se2 &= 67108863, i3 = Math.imul(q2, N2), n3 = (n3 = Math.imul(q2, j2)) + Math.imul(O2, N2) | 0, a3 = Math.imul(O2, j2), i3 = i3 + Math.imul(B2, W2) | 0, n3 = (n3 = n3 + Math.imul(B2, H2) | 0) + Math.imul(T2, W2) | 0, a3 = a3 + Math.imul(T2, H2) | 0, i3 = i3 + Math.imul(R2, V2) | 0, n3 = (n3 = n3 + Math.imul(R2, $2) | 0) + Math.imul(I2, V2) | 0, a3 = a3 + Math.imul(I2, $2) | 0, i3 = i3 + Math.imul(C2, Y2) | 0, n3 = (n3 = n3 + Math.imul(C2, X2) | 0) + Math.imul(K2, Y2) | 0, a3 = a3 + Math.imul(K2, X2) | 0, i3 = i3 + Math.imul(P2, J2) | 0, n3 = (n3 = n3 + Math.imul(P2, ee2) | 0) + Math.imul(x2, J2) | 0, a3 = a3 + Math.imul(x2, ee2) | 0, i3 = i3 + Math.imul(A3, re2) | 0, n3 = (n3 = n3 + Math.imul(A3, ie2) | 0) + Math.imul(S2, re2) | 0, a3 = a3 + Math.imul(S2, ie2) | 0, i3 = i3 + Math.imul(v3, ae2) | 0, n3 = (n3 = n3 + Math.imul(v3, se2) | 0) + Math.imul(_3, ae2) | 0, a3 = a3 + Math.imul(_3, se2) | 0, i3 = i3 + Math.imul(m3, ce2) | 0, n3 = (n3 = n3 + Math.imul(m3, ue2) | 0) + Math.imul(g3, ce2) | 0, a3 = a3 + Math.imul(g3, ue2) | 0, i3 = i3 + Math.imul(p3, fe2) | 0, n3 = (n3 = n3 + Math.imul(p3, de2) | 0) + Math.imul(y3, fe2) | 0, a3 = a3 + Math.imul(y3, de2) | 0;
          var Ee2 = (u2 + (i3 = i3 + Math.imul(f3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(f3, ye2) | 0) + Math.imul(d3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(d3, ye2) | 0) + (n3 >>> 13) | 0) + (Ee2 >>> 26) | 0, Ee2 &= 67108863, i3 = Math.imul(q2, W2), n3 = (n3 = Math.imul(q2, H2)) + Math.imul(O2, W2) | 0, a3 = Math.imul(O2, H2), i3 = i3 + Math.imul(B2, V2) | 0, n3 = (n3 = n3 + Math.imul(B2, $2) | 0) + Math.imul(T2, V2) | 0, a3 = a3 + Math.imul(T2, $2) | 0, i3 = i3 + Math.imul(R2, Y2) | 0, n3 = (n3 = n3 + Math.imul(R2, X2) | 0) + Math.imul(I2, Y2) | 0, a3 = a3 + Math.imul(I2, X2) | 0, i3 = i3 + Math.imul(C2, J2) | 0, n3 = (n3 = n3 + Math.imul(C2, ee2) | 0) + Math.imul(K2, J2) | 0, a3 = a3 + Math.imul(K2, ee2) | 0, i3 = i3 + Math.imul(P2, re2) | 0, n3 = (n3 = n3 + Math.imul(P2, ie2) | 0) + Math.imul(x2, re2) | 0, a3 = a3 + Math.imul(x2, ie2) | 0, i3 = i3 + Math.imul(A3, ae2) | 0, n3 = (n3 = n3 + Math.imul(A3, se2) | 0) + Math.imul(S2, ae2) | 0, a3 = a3 + Math.imul(S2, se2) | 0, i3 = i3 + Math.imul(v3, ce2) | 0, n3 = (n3 = n3 + Math.imul(v3, ue2) | 0) + Math.imul(_3, ce2) | 0, a3 = a3 + Math.imul(_3, ue2) | 0, i3 = i3 + Math.imul(m3, fe2) | 0, n3 = (n3 = n3 + Math.imul(m3, de2) | 0) + Math.imul(g3, fe2) | 0, a3 = a3 + Math.imul(g3, de2) | 0;
          var Pe2 = (u2 + (i3 = i3 + Math.imul(p3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(p3, ye2) | 0) + Math.imul(y3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(y3, ye2) | 0) + (n3 >>> 13) | 0) + (Pe2 >>> 26) | 0, Pe2 &= 67108863, i3 = Math.imul(q2, V2), n3 = (n3 = Math.imul(q2, $2)) + Math.imul(O2, V2) | 0, a3 = Math.imul(O2, $2), i3 = i3 + Math.imul(B2, Y2) | 0, n3 = (n3 = n3 + Math.imul(B2, X2) | 0) + Math.imul(T2, Y2) | 0, a3 = a3 + Math.imul(T2, X2) | 0, i3 = i3 + Math.imul(R2, J2) | 0, n3 = (n3 = n3 + Math.imul(R2, ee2) | 0) + Math.imul(I2, J2) | 0, a3 = a3 + Math.imul(I2, ee2) | 0, i3 = i3 + Math.imul(C2, re2) | 0, n3 = (n3 = n3 + Math.imul(C2, ie2) | 0) + Math.imul(K2, re2) | 0, a3 = a3 + Math.imul(K2, ie2) | 0, i3 = i3 + Math.imul(P2, ae2) | 0, n3 = (n3 = n3 + Math.imul(P2, se2) | 0) + Math.imul(x2, ae2) | 0, a3 = a3 + Math.imul(x2, se2) | 0, i3 = i3 + Math.imul(A3, ce2) | 0, n3 = (n3 = n3 + Math.imul(A3, ue2) | 0) + Math.imul(S2, ce2) | 0, a3 = a3 + Math.imul(S2, ue2) | 0, i3 = i3 + Math.imul(v3, fe2) | 0, n3 = (n3 = n3 + Math.imul(v3, de2) | 0) + Math.imul(_3, fe2) | 0, a3 = a3 + Math.imul(_3, de2) | 0;
          var xe2 = (u2 + (i3 = i3 + Math.imul(m3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(m3, ye2) | 0) + Math.imul(g3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(g3, ye2) | 0) + (n3 >>> 13) | 0) + (xe2 >>> 26) | 0, xe2 &= 67108863, i3 = Math.imul(q2, Y2), n3 = (n3 = Math.imul(q2, X2)) + Math.imul(O2, Y2) | 0, a3 = Math.imul(O2, X2), i3 = i3 + Math.imul(B2, J2) | 0, n3 = (n3 = n3 + Math.imul(B2, ee2) | 0) + Math.imul(T2, J2) | 0, a3 = a3 + Math.imul(T2, ee2) | 0, i3 = i3 + Math.imul(R2, re2) | 0, n3 = (n3 = n3 + Math.imul(R2, ie2) | 0) + Math.imul(I2, re2) | 0, a3 = a3 + Math.imul(I2, ie2) | 0, i3 = i3 + Math.imul(C2, ae2) | 0, n3 = (n3 = n3 + Math.imul(C2, se2) | 0) + Math.imul(K2, ae2) | 0, a3 = a3 + Math.imul(K2, se2) | 0, i3 = i3 + Math.imul(P2, ce2) | 0, n3 = (n3 = n3 + Math.imul(P2, ue2) | 0) + Math.imul(x2, ce2) | 0, a3 = a3 + Math.imul(x2, ue2) | 0, i3 = i3 + Math.imul(A3, fe2) | 0, n3 = (n3 = n3 + Math.imul(A3, de2) | 0) + Math.imul(S2, fe2) | 0, a3 = a3 + Math.imul(S2, de2) | 0;
          var Me2 = (u2 + (i3 = i3 + Math.imul(v3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(v3, ye2) | 0) + Math.imul(_3, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(_3, ye2) | 0) + (n3 >>> 13) | 0) + (Me2 >>> 26) | 0, Me2 &= 67108863, i3 = Math.imul(q2, J2), n3 = (n3 = Math.imul(q2, ee2)) + Math.imul(O2, J2) | 0, a3 = Math.imul(O2, ee2), i3 = i3 + Math.imul(B2, re2) | 0, n3 = (n3 = n3 + Math.imul(B2, ie2) | 0) + Math.imul(T2, re2) | 0, a3 = a3 + Math.imul(T2, ie2) | 0, i3 = i3 + Math.imul(R2, ae2) | 0, n3 = (n3 = n3 + Math.imul(R2, se2) | 0) + Math.imul(I2, ae2) | 0, a3 = a3 + Math.imul(I2, se2) | 0, i3 = i3 + Math.imul(C2, ce2) | 0, n3 = (n3 = n3 + Math.imul(C2, ue2) | 0) + Math.imul(K2, ce2) | 0, a3 = a3 + Math.imul(K2, ue2) | 0, i3 = i3 + Math.imul(P2, fe2) | 0, n3 = (n3 = n3 + Math.imul(P2, de2) | 0) + Math.imul(x2, fe2) | 0, a3 = a3 + Math.imul(x2, de2) | 0;
          var Ce2 = (u2 + (i3 = i3 + Math.imul(A3, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(A3, ye2) | 0) + Math.imul(S2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(S2, ye2) | 0) + (n3 >>> 13) | 0) + (Ce2 >>> 26) | 0, Ce2 &= 67108863, i3 = Math.imul(q2, re2), n3 = (n3 = Math.imul(q2, ie2)) + Math.imul(O2, re2) | 0, a3 = Math.imul(O2, ie2), i3 = i3 + Math.imul(B2, ae2) | 0, n3 = (n3 = n3 + Math.imul(B2, se2) | 0) + Math.imul(T2, ae2) | 0, a3 = a3 + Math.imul(T2, se2) | 0, i3 = i3 + Math.imul(R2, ce2) | 0, n3 = (n3 = n3 + Math.imul(R2, ue2) | 0) + Math.imul(I2, ce2) | 0, a3 = a3 + Math.imul(I2, ue2) | 0, i3 = i3 + Math.imul(C2, fe2) | 0, n3 = (n3 = n3 + Math.imul(C2, de2) | 0) + Math.imul(K2, fe2) | 0, a3 = a3 + Math.imul(K2, de2) | 0;
          var Ke2 = (u2 + (i3 = i3 + Math.imul(P2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(P2, ye2) | 0) + Math.imul(x2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(x2, ye2) | 0) + (n3 >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, i3 = Math.imul(q2, ae2), n3 = (n3 = Math.imul(q2, se2)) + Math.imul(O2, ae2) | 0, a3 = Math.imul(O2, se2), i3 = i3 + Math.imul(B2, ce2) | 0, n3 = (n3 = n3 + Math.imul(B2, ue2) | 0) + Math.imul(T2, ce2) | 0, a3 = a3 + Math.imul(T2, ue2) | 0, i3 = i3 + Math.imul(R2, fe2) | 0, n3 = (n3 = n3 + Math.imul(R2, de2) | 0) + Math.imul(I2, fe2) | 0, a3 = a3 + Math.imul(I2, de2) | 0;
          var De2 = (u2 + (i3 = i3 + Math.imul(C2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(C2, ye2) | 0) + Math.imul(K2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(K2, ye2) | 0) + (n3 >>> 13) | 0) + (De2 >>> 26) | 0, De2 &= 67108863, i3 = Math.imul(q2, ce2), n3 = (n3 = Math.imul(q2, ue2)) + Math.imul(O2, ce2) | 0, a3 = Math.imul(O2, ue2), i3 = i3 + Math.imul(B2, fe2) | 0, n3 = (n3 = n3 + Math.imul(B2, de2) | 0) + Math.imul(T2, fe2) | 0, a3 = a3 + Math.imul(T2, de2) | 0;
          var Re2 = (u2 + (i3 = i3 + Math.imul(R2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(R2, ye2) | 0) + Math.imul(I2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(I2, ye2) | 0) + (n3 >>> 13) | 0) + (Re2 >>> 26) | 0, Re2 &= 67108863, i3 = Math.imul(q2, fe2), n3 = (n3 = Math.imul(q2, de2)) + Math.imul(O2, fe2) | 0, a3 = Math.imul(O2, de2);
          var Ie2 = (u2 + (i3 = i3 + Math.imul(B2, pe2) | 0) | 0) + ((8191 & (n3 = (n3 = n3 + Math.imul(B2, ye2) | 0) + Math.imul(T2, pe2) | 0)) << 13) | 0;
          u2 = ((a3 = a3 + Math.imul(T2, ye2) | 0) + (n3 >>> 13) | 0) + (Ie2 >>> 26) | 0, Ie2 &= 67108863;
          var Ue2 = (u2 + (i3 = Math.imul(q2, pe2)) | 0) + ((8191 & (n3 = (n3 = Math.imul(q2, ye2)) + Math.imul(O2, pe2) | 0)) << 13) | 0;
          return u2 = ((a3 = Math.imul(O2, ye2)) + (n3 >>> 13) | 0) + (Ue2 >>> 26) | 0, Ue2 &= 67108863, c3[0] = be2, c3[1] = me2, c3[2] = ge2, c3[3] = we2, c3[4] = ve2, c3[5] = _e2, c3[6] = ke2, c3[7] = Ae2, c3[8] = Se2, c3[9] = Ee2, c3[10] = Pe2, c3[11] = xe2, c3[12] = Me2, c3[13] = Ce2, c3[14] = Ke2, c3[15] = De2, c3[16] = Re2, c3[17] = Ie2, c3[18] = Ue2, u2 !== 0 && (c3[19] = u2, r3.length++), r3;
        };
        function p2(e4, t3, r3) {
          return new y2().mulp(e4, t3, r3);
        }
        function y2(e4, t3) {
          this.x = e4, this.y = t3;
        }
        Math.imul || (l2 = d2), n2.prototype.mulTo = function(e4, t3) {
          var r3 = this.length + e4.length;
          return this.length === 10 && e4.length === 10 ? l2(this, e4, t3) : r3 < 63 ? d2(this, e4, t3) : r3 < 1024 ? function(e5, t4, r4) {
            r4.negative = t4.negative ^ e5.negative, r4.length = e5.length + t4.length;
            for (var i3 = 0, n3 = 0, a3 = 0; a3 < r4.length - 1; a3++) {
              var s3 = n3;
              n3 = 0;
              for (var o3 = 67108863 & i3, c3 = Math.min(a3, t4.length - 1), u2 = Math.max(0, a3 - e5.length + 1); u2 <= c3; u2++) {
                var h3 = a3 - u2, f3 = (0 | e5.words[h3]) * (0 | t4.words[u2]), d3 = 67108863 & f3;
                o3 = 67108863 & (d3 = d3 + o3 | 0), n3 += (s3 = (s3 = s3 + (f3 / 67108864 | 0) | 0) + (d3 >>> 26) | 0) >>> 26, s3 &= 67108863;
              }
              r4.words[a3] = o3, i3 = s3, s3 = n3;
            }
            return i3 !== 0 ? r4.words[a3] = i3 : r4.length--, r4.strip();
          }(this, e4, t3) : p2(this, e4, t3);
        }, y2.prototype.makeRBT = function(e4) {
          for (var t3 = Array(e4), r3 = n2.prototype._countBits(e4) - 1, i3 = 0; i3 < e4; i3++)
            t3[i3] = this.revBin(i3, r3, e4);
          return t3;
        }, y2.prototype.revBin = function(e4, t3, r3) {
          if (e4 === 0 || e4 === r3 - 1)
            return e4;
          for (var i3 = 0, n3 = 0; n3 < t3; n3++)
            i3 |= (1 & e4) << t3 - n3 - 1, e4 >>= 1;
          return i3;
        }, y2.prototype.permute = function(e4, t3, r3, i3, n3, a3) {
          for (var s3 = 0; s3 < a3; s3++)
            i3[s3] = t3[e4[s3]], n3[s3] = r3[e4[s3]];
        }, y2.prototype.transform = function(e4, t3, r3, i3, n3, a3) {
          this.permute(a3, e4, t3, r3, i3, n3);
          for (var s3 = 1; s3 < n3; s3 <<= 1)
            for (var o3 = s3 << 1, c3 = Math.cos(2 * Math.PI / o3), u2 = Math.sin(2 * Math.PI / o3), h3 = 0; h3 < n3; h3 += o3)
              for (var f3 = c3, d3 = u2, l3 = 0; l3 < s3; l3++) {
                var p3 = r3[h3 + l3], y3 = i3[h3 + l3], b3 = r3[h3 + l3 + s3], m3 = i3[h3 + l3 + s3], g3 = f3 * b3 - d3 * m3;
                m3 = f3 * m3 + d3 * b3, b3 = g3, r3[h3 + l3] = p3 + b3, i3[h3 + l3] = y3 + m3, r3[h3 + l3 + s3] = p3 - b3, i3[h3 + l3 + s3] = y3 - m3, l3 !== o3 && (g3 = c3 * f3 - u2 * d3, d3 = c3 * d3 + u2 * f3, f3 = g3);
              }
        }, y2.prototype.guessLen13b = function(e4, t3) {
          var r3 = 1 | Math.max(t3, e4), i3 = 1 & r3, n3 = 0;
          for (r3 = r3 / 2 | 0; r3; r3 >>>= 1)
            n3++;
          return 1 << n3 + 1 + i3;
        }, y2.prototype.conjugate = function(e4, t3, r3) {
          if (!(r3 <= 1))
            for (var i3 = 0; i3 < r3 / 2; i3++) {
              var n3 = e4[i3];
              e4[i3] = e4[r3 - i3 - 1], e4[r3 - i3 - 1] = n3, n3 = t3[i3], t3[i3] = -t3[r3 - i3 - 1], t3[r3 - i3 - 1] = -n3;
            }
        }, y2.prototype.normalize13b = function(e4, t3) {
          for (var r3 = 0, i3 = 0; i3 < t3 / 2; i3++) {
            var n3 = 8192 * Math.round(e4[2 * i3 + 1] / t3) + Math.round(e4[2 * i3] / t3) + r3;
            e4[i3] = 67108863 & n3, r3 = n3 < 67108864 ? 0 : n3 / 67108864 | 0;
          }
          return e4;
        }, y2.prototype.convert13b = function(e4, t3, i3, n3) {
          for (var a3 = 0, s3 = 0; s3 < t3; s3++)
            a3 += 0 | e4[s3], i3[2 * s3] = 8191 & a3, a3 >>>= 13, i3[2 * s3 + 1] = 8191 & a3, a3 >>>= 13;
          for (s3 = 2 * t3; s3 < n3; ++s3)
            i3[s3] = 0;
          r2(a3 === 0), r2((-8192 & a3) == 0);
        }, y2.prototype.stub = function(e4) {
          for (var t3 = Array(e4), r3 = 0; r3 < e4; r3++)
            t3[r3] = 0;
          return t3;
        }, y2.prototype.mulp = function(e4, t3, r3) {
          var i3 = 2 * this.guessLen13b(e4.length, t3.length), n3 = this.makeRBT(i3), a3 = this.stub(i3), s3 = Array(i3), o3 = Array(i3), c3 = Array(i3), u2 = Array(i3), h3 = Array(i3), f3 = Array(i3), d3 = r3.words;
          d3.length = i3, this.convert13b(e4.words, e4.length, s3, i3), this.convert13b(t3.words, t3.length, u2, i3), this.transform(s3, a3, o3, c3, i3, n3), this.transform(u2, a3, h3, f3, i3, n3);
          for (var l3 = 0; l3 < i3; l3++) {
            var p3 = o3[l3] * h3[l3] - c3[l3] * f3[l3];
            c3[l3] = o3[l3] * f3[l3] + c3[l3] * h3[l3], o3[l3] = p3;
          }
          return this.conjugate(o3, c3, i3), this.transform(o3, c3, d3, a3, i3, n3), this.conjugate(d3, a3, i3), this.normalize13b(d3, i3), r3.negative = e4.negative ^ t3.negative, r3.length = e4.length + t3.length, r3.strip();
        }, n2.prototype.mul = function(e4) {
          var t3 = new n2(null);
          return t3.words = Array(this.length + e4.length), this.mulTo(e4, t3);
        }, n2.prototype.mulf = function(e4) {
          var t3 = new n2(null);
          return t3.words = Array(this.length + e4.length), p2(this, e4, t3);
        }, n2.prototype.imul = function(e4) {
          return this.clone().mulTo(e4, this);
        }, n2.prototype.imuln = function(e4) {
          r2(typeof e4 == "number"), r2(e4 < 67108864);
          for (var t3 = 0, i3 = 0; i3 < this.length; i3++) {
            var n3 = (0 | this.words[i3]) * e4, a3 = (67108863 & n3) + (67108863 & t3);
            t3 >>= 26, t3 += n3 / 67108864 | 0, t3 += a3 >>> 26, this.words[i3] = 67108863 & a3;
          }
          return t3 !== 0 && (this.words[i3] = t3, this.length++), this;
        }, n2.prototype.muln = function(e4) {
          return this.clone().imuln(e4);
        }, n2.prototype.sqr = function() {
          return this.mul(this);
        }, n2.prototype.isqr = function() {
          return this.imul(this.clone());
        }, n2.prototype.pow = function(e4) {
          var t3 = function(e5) {
            for (var t4 = Array(e5.bitLength()), r4 = 0; r4 < t4.length; r4++) {
              var i4 = r4 / 26 | 0, n3 = r4 % 26;
              t4[r4] = (e5.words[i4] & 1 << n3) >>> n3;
            }
            return t4;
          }(e4);
          if (t3.length === 0)
            return new n2(1);
          for (var r3 = this, i3 = 0; i3 < t3.length && t3[i3] === 0; i3++, r3 = r3.sqr())
            ;
          if (++i3 < t3.length)
            for (var a3 = r3.sqr(); i3 < t3.length; i3++, a3 = a3.sqr())
              t3[i3] !== 0 && (r3 = r3.mul(a3));
          return r3;
        }, n2.prototype.iushln = function(e4) {
          r2(typeof e4 == "number" && e4 >= 0);
          var t3, i3 = e4 % 26, n3 = (e4 - i3) / 26, a3 = 67108863 >>> 26 - i3 << 26 - i3;
          if (i3 !== 0) {
            var s3 = 0;
            for (t3 = 0; t3 < this.length; t3++) {
              var o3 = this.words[t3] & a3, c3 = (0 | this.words[t3]) - o3 << i3;
              this.words[t3] = c3 | s3, s3 = o3 >>> 26 - i3;
            }
            s3 && (this.words[t3] = s3, this.length++);
          }
          if (n3 !== 0) {
            for (t3 = this.length - 1; t3 >= 0; t3--)
              this.words[t3 + n3] = this.words[t3];
            for (t3 = 0; t3 < n3; t3++)
              this.words[t3] = 0;
            this.length += n3;
          }
          return this.strip();
        }, n2.prototype.ishln = function(e4) {
          return r2(this.negative === 0), this.iushln(e4);
        }, n2.prototype.iushrn = function(e4, t3, i3) {
          var n3;
          r2(typeof e4 == "number" && e4 >= 0), n3 = t3 ? (t3 - t3 % 26) / 26 : 0;
          var a3 = e4 % 26, s3 = Math.min((e4 - a3) / 26, this.length), o3 = 67108863 ^ 67108863 >>> a3 << a3, c3 = i3;
          if (n3 = Math.max(0, n3 -= s3), c3) {
            for (var u2 = 0; u2 < s3; u2++)
              c3.words[u2] = this.words[u2];
            c3.length = s3;
          }
          if (s3 === 0)
            ;
          else if (this.length > s3)
            for (this.length -= s3, u2 = 0; u2 < this.length; u2++)
              this.words[u2] = this.words[u2 + s3];
          else
            this.words[0] = 0, this.length = 1;
          var h3 = 0;
          for (u2 = this.length - 1; u2 >= 0 && (h3 !== 0 || u2 >= n3); u2--) {
            var f3 = 0 | this.words[u2];
            this.words[u2] = h3 << 26 - a3 | f3 >>> a3, h3 = f3 & o3;
          }
          return c3 && h3 !== 0 && (c3.words[c3.length++] = h3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
        }, n2.prototype.ishrn = function(e4, t3, i3) {
          return r2(this.negative === 0), this.iushrn(e4, t3, i3);
        }, n2.prototype.shln = function(e4) {
          return this.clone().ishln(e4);
        }, n2.prototype.ushln = function(e4) {
          return this.clone().iushln(e4);
        }, n2.prototype.shrn = function(e4) {
          return this.clone().ishrn(e4);
        }, n2.prototype.ushrn = function(e4) {
          return this.clone().iushrn(e4);
        }, n2.prototype.testn = function(e4) {
          r2(typeof e4 == "number" && e4 >= 0);
          var t3 = e4 % 26, i3 = (e4 - t3) / 26, n3 = 1 << t3;
          return !(this.length <= i3) && !!(this.words[i3] & n3);
        }, n2.prototype.imaskn = function(e4) {
          r2(typeof e4 == "number" && e4 >= 0);
          var t3 = e4 % 26, i3 = (e4 - t3) / 26;
          if (r2(this.negative === 0, "imaskn works only with positive numbers"), this.length <= i3)
            return this;
          if (t3 !== 0 && i3++, this.length = Math.min(i3, this.length), t3 !== 0) {
            var n3 = 67108863 ^ 67108863 >>> t3 << t3;
            this.words[this.length - 1] &= n3;
          }
          return this.strip();
        }, n2.prototype.maskn = function(e4) {
          return this.clone().imaskn(e4);
        }, n2.prototype.iaddn = function(e4) {
          return r2(typeof e4 == "number"), r2(e4 < 67108864), e4 < 0 ? this.isubn(-e4) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < e4 ? (this.words[0] = e4 - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e4), this.negative = 1, this) : this._iaddn(e4);
        }, n2.prototype._iaddn = function(e4) {
          this.words[0] += e4;
          for (var t3 = 0; t3 < this.length && this.words[t3] >= 67108864; t3++)
            this.words[t3] -= 67108864, t3 === this.length - 1 ? this.words[t3 + 1] = 1 : this.words[t3 + 1]++;
          return this.length = Math.max(this.length, t3 + 1), this;
        }, n2.prototype.isubn = function(e4) {
          if (r2(typeof e4 == "number"), r2(e4 < 67108864), e4 < 0)
            return this.iaddn(-e4);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(e4), this.negative = 1, this;
          if (this.words[0] -= e4, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var t3 = 0; t3 < this.length && this.words[t3] < 0; t3++)
              this.words[t3] += 67108864, this.words[t3 + 1] -= 1;
          return this.strip();
        }, n2.prototype.addn = function(e4) {
          return this.clone().iaddn(e4);
        }, n2.prototype.subn = function(e4) {
          return this.clone().isubn(e4);
        }, n2.prototype.iabs = function() {
          return this.negative = 0, this;
        }, n2.prototype.abs = function() {
          return this.clone().iabs();
        }, n2.prototype._ishlnsubmul = function(e4, t3, i3) {
          var n3, a3, s3 = e4.length + i3;
          this._expand(s3);
          var o3 = 0;
          for (n3 = 0; n3 < e4.length; n3++) {
            a3 = (0 | this.words[n3 + i3]) + o3;
            var c3 = (0 | e4.words[n3]) * t3;
            o3 = ((a3 -= 67108863 & c3) >> 26) - (c3 / 67108864 | 0), this.words[n3 + i3] = 67108863 & a3;
          }
          for (; n3 < this.length - i3; n3++)
            o3 = (a3 = (0 | this.words[n3 + i3]) + o3) >> 26, this.words[n3 + i3] = 67108863 & a3;
          if (o3 === 0)
            return this.strip();
          for (r2(o3 === -1), o3 = 0, n3 = 0; n3 < this.length; n3++)
            o3 = (a3 = -(0 | this.words[n3]) + o3) >> 26, this.words[n3] = 67108863 & a3;
          return this.negative = 1, this.strip();
        }, n2.prototype._wordDiv = function(e4, t3) {
          var r3 = (this.length, e4.length), i3 = this.clone(), a3 = e4, s3 = 0 | a3.words[a3.length - 1];
          (r3 = 26 - this._countBits(s3)) !== 0 && (a3 = a3.ushln(r3), i3.iushln(r3), s3 = 0 | a3.words[a3.length - 1]);
          var o3, c3 = i3.length - a3.length;
          if (t3 !== "mod") {
            (o3 = new n2(null)).length = c3 + 1, o3.words = Array(o3.length);
            for (var u2 = 0; u2 < o3.length; u2++)
              o3.words[u2] = 0;
          }
          var h3 = i3.clone()._ishlnsubmul(a3, 1, c3);
          h3.negative === 0 && (i3 = h3, o3 && (o3.words[c3] = 1));
          for (var f3 = c3 - 1; f3 >= 0; f3--) {
            var d3 = 67108864 * (0 | i3.words[a3.length + f3]) + (0 | i3.words[a3.length + f3 - 1]);
            for (d3 = Math.min(d3 / s3 | 0, 67108863), i3._ishlnsubmul(a3, d3, f3); i3.negative !== 0; )
              d3--, i3.negative = 0, i3._ishlnsubmul(a3, 1, f3), i3.isZero() || (i3.negative ^= 1);
            o3 && (o3.words[f3] = d3);
          }
          return o3 && o3.strip(), i3.strip(), t3 !== "div" && r3 !== 0 && i3.iushrn(r3), { div: o3 || null, mod: i3 };
        }, n2.prototype.divmod = function(e4, t3, i3) {
          return r2(!e4.isZero()), this.isZero() ? { div: new n2(0), mod: new n2(0) } : this.negative !== 0 && e4.negative === 0 ? (o3 = this.neg().divmod(e4, t3), t3 !== "mod" && (a3 = o3.div.neg()), t3 !== "div" && (s3 = o3.mod.neg(), i3 && s3.negative !== 0 && s3.iadd(e4)), { div: a3, mod: s3 }) : this.negative === 0 && e4.negative !== 0 ? (o3 = this.divmod(e4.neg(), t3), t3 !== "mod" && (a3 = o3.div.neg()), { div: a3, mod: o3.mod }) : (this.negative & e4.negative) != 0 ? (o3 = this.neg().divmod(e4.neg(), t3), t3 !== "div" && (s3 = o3.mod.neg(), i3 && s3.negative !== 0 && s3.isub(e4)), { div: o3.div, mod: s3 }) : e4.length > this.length || this.cmp(e4) < 0 ? { div: new n2(0), mod: this } : e4.length === 1 ? t3 === "div" ? { div: this.divn(e4.words[0]), mod: null } : t3 === "mod" ? { div: null, mod: new n2(this.modn(e4.words[0])) } : { div: this.divn(e4.words[0]), mod: new n2(this.modn(e4.words[0])) } : this._wordDiv(e4, t3);
          var a3, s3, o3;
        }, n2.prototype.div = function(e4) {
          return this.divmod(e4, "div", false).div;
        }, n2.prototype.mod = function(e4) {
          return this.divmod(e4, "mod", false).mod;
        }, n2.prototype.umod = function(e4) {
          return this.divmod(e4, "mod", true).mod;
        }, n2.prototype.divRound = function(e4) {
          var t3 = this.divmod(e4);
          if (t3.mod.isZero())
            return t3.div;
          var r3 = t3.div.negative !== 0 ? t3.mod.isub(e4) : t3.mod, i3 = e4.ushrn(1), n3 = e4.andln(1), a3 = r3.cmp(i3);
          return a3 < 0 || n3 === 1 && a3 === 0 ? t3.div : t3.div.negative !== 0 ? t3.div.isubn(1) : t3.div.iaddn(1);
        }, n2.prototype.modn = function(e4) {
          r2(e4 <= 67108863);
          for (var t3 = (1 << 26) % e4, i3 = 0, n3 = this.length - 1; n3 >= 0; n3--)
            i3 = (t3 * i3 + (0 | this.words[n3])) % e4;
          return i3;
        }, n2.prototype.idivn = function(e4) {
          r2(e4 <= 67108863);
          for (var t3 = 0, i3 = this.length - 1; i3 >= 0; i3--) {
            var n3 = (0 | this.words[i3]) + 67108864 * t3;
            this.words[i3] = n3 / e4 | 0, t3 = n3 % e4;
          }
          return this.strip();
        }, n2.prototype.divn = function(e4) {
          return this.clone().idivn(e4);
        }, n2.prototype.egcd = function(e4) {
          r2(e4.negative === 0), r2(!e4.isZero());
          var t3 = this, i3 = e4.clone();
          t3 = t3.negative !== 0 ? t3.umod(e4) : t3.clone();
          for (var a3 = new n2(1), s3 = new n2(0), o3 = new n2(0), c3 = new n2(1), u2 = 0; t3.isEven() && i3.isEven(); )
            t3.iushrn(1), i3.iushrn(1), ++u2;
          for (var h3 = i3.clone(), f3 = t3.clone(); !t3.isZero(); ) {
            for (var d3 = 0, l3 = 1; (t3.words[0] & l3) == 0 && d3 < 26; ++d3, l3 <<= 1)
              ;
            if (d3 > 0)
              for (t3.iushrn(d3); d3-- > 0; )
                (a3.isOdd() || s3.isOdd()) && (a3.iadd(h3), s3.isub(f3)), a3.iushrn(1), s3.iushrn(1);
            for (var p3 = 0, y3 = 1; (i3.words[0] & y3) == 0 && p3 < 26; ++p3, y3 <<= 1)
              ;
            if (p3 > 0)
              for (i3.iushrn(p3); p3-- > 0; )
                (o3.isOdd() || c3.isOdd()) && (o3.iadd(h3), c3.isub(f3)), o3.iushrn(1), c3.iushrn(1);
            t3.cmp(i3) >= 0 ? (t3.isub(i3), a3.isub(o3), s3.isub(c3)) : (i3.isub(t3), o3.isub(a3), c3.isub(s3));
          }
          return { a: o3, b: c3, gcd: i3.iushln(u2) };
        }, n2.prototype._invmp = function(e4) {
          r2(e4.negative === 0), r2(!e4.isZero());
          var t3 = this, i3 = e4.clone();
          t3 = t3.negative !== 0 ? t3.umod(e4) : t3.clone();
          for (var a3, s3 = new n2(1), o3 = new n2(0), c3 = i3.clone(); t3.cmpn(1) > 0 && i3.cmpn(1) > 0; ) {
            for (var u2 = 0, h3 = 1; (t3.words[0] & h3) == 0 && u2 < 26; ++u2, h3 <<= 1)
              ;
            if (u2 > 0)
              for (t3.iushrn(u2); u2-- > 0; )
                s3.isOdd() && s3.iadd(c3), s3.iushrn(1);
            for (var f3 = 0, d3 = 1; (i3.words[0] & d3) == 0 && f3 < 26; ++f3, d3 <<= 1)
              ;
            if (f3 > 0)
              for (i3.iushrn(f3); f3-- > 0; )
                o3.isOdd() && o3.iadd(c3), o3.iushrn(1);
            t3.cmp(i3) >= 0 ? (t3.isub(i3), s3.isub(o3)) : (i3.isub(t3), o3.isub(s3));
          }
          return (a3 = t3.cmpn(1) === 0 ? s3 : o3).cmpn(0) < 0 && a3.iadd(e4), a3;
        }, n2.prototype.gcd = function(e4) {
          if (this.isZero())
            return e4.abs();
          if (e4.isZero())
            return this.abs();
          var t3 = this.clone(), r3 = e4.clone();
          t3.negative = 0, r3.negative = 0;
          for (var i3 = 0; t3.isEven() && r3.isEven(); i3++)
            t3.iushrn(1), r3.iushrn(1);
          for (; ; ) {
            for (; t3.isEven(); )
              t3.iushrn(1);
            for (; r3.isEven(); )
              r3.iushrn(1);
            var n3 = t3.cmp(r3);
            if (n3 < 0) {
              var a3 = t3;
              t3 = r3, r3 = a3;
            } else if (n3 === 0 || r3.cmpn(1) === 0)
              break;
            t3.isub(r3);
          }
          return r3.iushln(i3);
        }, n2.prototype.invm = function(e4) {
          return this.egcd(e4).a.umod(e4);
        }, n2.prototype.isEven = function() {
          return (1 & this.words[0]) == 0;
        }, n2.prototype.isOdd = function() {
          return (1 & this.words[0]) == 1;
        }, n2.prototype.andln = function(e4) {
          return this.words[0] & e4;
        }, n2.prototype.bincn = function(e4) {
          r2(typeof e4 == "number");
          var t3 = e4 % 26, i3 = (e4 - t3) / 26, n3 = 1 << t3;
          if (this.length <= i3)
            return this._expand(i3 + 1), this.words[i3] |= n3, this;
          for (var a3 = n3, s3 = i3; a3 !== 0 && s3 < this.length; s3++) {
            var o3 = 0 | this.words[s3];
            a3 = (o3 += a3) >>> 26, o3 &= 67108863, this.words[s3] = o3;
          }
          return a3 !== 0 && (this.words[s3] = a3, this.length++), this;
        }, n2.prototype.isZero = function() {
          return this.length === 1 && this.words[0] === 0;
        }, n2.prototype.cmpn = function(e4) {
          var t3, i3 = e4 < 0;
          if (this.negative !== 0 && !i3)
            return -1;
          if (this.negative === 0 && i3)
            return 1;
          if (this.strip(), this.length > 1)
            t3 = 1;
          else {
            i3 && (e4 = -e4), r2(e4 <= 67108863, "Number is too big");
            var n3 = 0 | this.words[0];
            t3 = n3 === e4 ? 0 : n3 < e4 ? -1 : 1;
          }
          return this.negative !== 0 ? 0 | -t3 : t3;
        }, n2.prototype.cmp = function(e4) {
          if (this.negative !== 0 && e4.negative === 0)
            return -1;
          if (this.negative === 0 && e4.negative !== 0)
            return 1;
          var t3 = this.ucmp(e4);
          return this.negative !== 0 ? 0 | -t3 : t3;
        }, n2.prototype.ucmp = function(e4) {
          if (this.length > e4.length)
            return 1;
          if (this.length < e4.length)
            return -1;
          for (var t3 = 0, r3 = this.length - 1; r3 >= 0; r3--) {
            var i3 = 0 | this.words[r3], n3 = 0 | e4.words[r3];
            if (i3 !== n3) {
              i3 < n3 ? t3 = -1 : i3 > n3 && (t3 = 1);
              break;
            }
          }
          return t3;
        }, n2.prototype.gtn = function(e4) {
          return this.cmpn(e4) === 1;
        }, n2.prototype.gt = function(e4) {
          return this.cmp(e4) === 1;
        }, n2.prototype.gten = function(e4) {
          return this.cmpn(e4) >= 0;
        }, n2.prototype.gte = function(e4) {
          return this.cmp(e4) >= 0;
        }, n2.prototype.ltn = function(e4) {
          return this.cmpn(e4) === -1;
        }, n2.prototype.lt = function(e4) {
          return this.cmp(e4) === -1;
        }, n2.prototype.lten = function(e4) {
          return this.cmpn(e4) <= 0;
        }, n2.prototype.lte = function(e4) {
          return this.cmp(e4) <= 0;
        }, n2.prototype.eqn = function(e4) {
          return this.cmpn(e4) === 0;
        }, n2.prototype.eq = function(e4) {
          return this.cmp(e4) === 0;
        }, n2.red = function(e4) {
          return new k2(e4);
        }, n2.prototype.toRed = function(e4) {
          return r2(!this.red, "Already a number in reduction context"), r2(this.negative === 0, "red works only with positives"), e4.convertTo(this)._forceRed(e4);
        }, n2.prototype.fromRed = function() {
          return r2(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, n2.prototype._forceRed = function(e4) {
          return this.red = e4, this;
        }, n2.prototype.forceRed = function(e4) {
          return r2(!this.red, "Already a number in reduction context"), this._forceRed(e4);
        }, n2.prototype.redAdd = function(e4) {
          return r2(this.red, "redAdd works only with red numbers"), this.red.add(this, e4);
        }, n2.prototype.redIAdd = function(e4) {
          return r2(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e4);
        }, n2.prototype.redSub = function(e4) {
          return r2(this.red, "redSub works only with red numbers"), this.red.sub(this, e4);
        }, n2.prototype.redISub = function(e4) {
          return r2(this.red, "redISub works only with red numbers"), this.red.isub(this, e4);
        }, n2.prototype.redShl = function(e4) {
          return r2(this.red, "redShl works only with red numbers"), this.red.shl(this, e4);
        }, n2.prototype.redMul = function(e4) {
          return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.mul(this, e4);
        }, n2.prototype.redIMul = function(e4) {
          return r2(this.red, "redMul works only with red numbers"), this.red._verify2(this, e4), this.red.imul(this, e4);
        }, n2.prototype.redSqr = function() {
          return r2(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, n2.prototype.redISqr = function() {
          return r2(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, n2.prototype.redSqrt = function() {
          return r2(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, n2.prototype.redInvm = function() {
          return r2(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, n2.prototype.redNeg = function() {
          return r2(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, n2.prototype.redPow = function(e4) {
          return r2(this.red && !e4.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e4);
        };
        var b2 = { k256: null, p224: null, p192: null, p25519: null };
        function m2(e4, t3) {
          this.name = e4, this.p = new n2(t3, 16), this.n = this.p.bitLength(), this.k = new n2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        function g2() {
          m2.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        function w2() {
          m2.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        function v2() {
          m2.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        function _2() {
          m2.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        function k2(e4) {
          if (typeof e4 == "string") {
            var t3 = n2._prime(e4);
            this.m = t3.p, this.prime = t3;
          } else
            r2(e4.gtn(1), "modulus must be greater than 1"), this.m = e4, this.prime = null;
        }
        function A2(e4) {
          k2.call(this, e4), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        m2.prototype._tmp = function() {
          var e4 = new n2(null);
          return e4.words = Array(Math.ceil(this.n / 13)), e4;
        }, m2.prototype.ireduce = function(e4) {
          var t3, r3 = e4;
          do {
            this.split(r3, this.tmp), t3 = (r3 = (r3 = this.imulK(r3)).iadd(this.tmp)).bitLength();
          } while (t3 > this.n);
          var i3 = t3 < this.n ? -1 : r3.ucmp(this.p);
          return i3 === 0 ? (r3.words[0] = 0, r3.length = 1) : i3 > 0 ? r3.isub(this.p) : r3.strip(), r3;
        }, m2.prototype.split = function(e4, t3) {
          e4.iushrn(this.n, 0, t3);
        }, m2.prototype.imulK = function(e4) {
          return e4.imul(this.k);
        }, i2(g2, m2), g2.prototype.split = function(e4, t3) {
          for (var r3 = 4194303, i3 = Math.min(e4.length, 9), n3 = 0; n3 < i3; n3++)
            t3.words[n3] = e4.words[n3];
          if (t3.length = i3, e4.length <= 9)
            return e4.words[0] = 0, void (e4.length = 1);
          var a3 = e4.words[9];
          for (t3.words[t3.length++] = a3 & r3, n3 = 10; n3 < e4.length; n3++) {
            var s3 = 0 | e4.words[n3];
            e4.words[n3 - 10] = (s3 & r3) << 4 | a3 >>> 22, a3 = s3;
          }
          a3 >>>= 22, e4.words[n3 - 10] = a3, a3 === 0 && e4.length > 10 ? e4.length -= 10 : e4.length -= 9;
        }, g2.prototype.imulK = function(e4) {
          e4.words[e4.length] = 0, e4.words[e4.length + 1] = 0, e4.length += 2;
          for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
            var i3 = 0 | e4.words[r3];
            t3 += 977 * i3, e4.words[r3] = 67108863 & t3, t3 = 64 * i3 + (t3 / 67108864 | 0);
          }
          return e4.words[e4.length - 1] === 0 && (e4.length--, e4.words[e4.length - 1] === 0 && e4.length--), e4;
        }, i2(w2, m2), i2(v2, m2), i2(_2, m2), _2.prototype.imulK = function(e4) {
          for (var t3 = 0, r3 = 0; r3 < e4.length; r3++) {
            var i3 = 19 * (0 | e4.words[r3]) + t3, n3 = 67108863 & i3;
            i3 >>>= 26, e4.words[r3] = n3, t3 = i3;
          }
          return t3 !== 0 && (e4.words[e4.length++] = t3), e4;
        }, n2._prime = function(e4) {
          if (b2[e4])
            return b2[e4];
          var t3;
          if (e4 === "k256")
            t3 = new g2();
          else if (e4 === "p224")
            t3 = new w2();
          else if (e4 === "p192")
            t3 = new v2();
          else {
            if (e4 !== "p25519")
              throw Error("Unknown prime " + e4);
            t3 = new _2();
          }
          return b2[e4] = t3, t3;
        }, k2.prototype._verify1 = function(e4) {
          r2(e4.negative === 0, "red works only with positives"), r2(e4.red, "red works only with red numbers");
        }, k2.prototype._verify2 = function(e4, t3) {
          r2((e4.negative | t3.negative) == 0, "red works only with positives"), r2(e4.red && e4.red === t3.red, "red works only with red numbers");
        }, k2.prototype.imod = function(e4) {
          return this.prime ? this.prime.ireduce(e4)._forceRed(this) : e4.umod(this.m)._forceRed(this);
        }, k2.prototype.neg = function(e4) {
          return e4.isZero() ? e4.clone() : this.m.sub(e4)._forceRed(this);
        }, k2.prototype.add = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.add(t3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3._forceRed(this);
        }, k2.prototype.iadd = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.iadd(t3);
          return r3.cmp(this.m) >= 0 && r3.isub(this.m), r3;
        }, k2.prototype.sub = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.sub(t3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3._forceRed(this);
        }, k2.prototype.isub = function(e4, t3) {
          this._verify2(e4, t3);
          var r3 = e4.isub(t3);
          return r3.cmpn(0) < 0 && r3.iadd(this.m), r3;
        }, k2.prototype.shl = function(e4, t3) {
          return this._verify1(e4), this.imod(e4.ushln(t3));
        }, k2.prototype.imul = function(e4, t3) {
          return this._verify2(e4, t3), this.imod(e4.imul(t3));
        }, k2.prototype.mul = function(e4, t3) {
          return this._verify2(e4, t3), this.imod(e4.mul(t3));
        }, k2.prototype.isqr = function(e4) {
          return this.imul(e4, e4.clone());
        }, k2.prototype.sqr = function(e4) {
          return this.mul(e4, e4);
        }, k2.prototype.sqrt = function(e4) {
          if (e4.isZero())
            return e4.clone();
          var t3 = this.m.andln(3);
          if (r2(t3 % 2 == 1), t3 === 3) {
            var i3 = this.m.add(new n2(1)).iushrn(2);
            return this.pow(e4, i3);
          }
          for (var a3 = this.m.subn(1), s3 = 0; !a3.isZero() && a3.andln(1) === 0; )
            s3++, a3.iushrn(1);
          r2(!a3.isZero());
          var o3 = new n2(1).toRed(this), c3 = o3.redNeg(), u2 = this.m.subn(1).iushrn(1), h3 = this.m.bitLength();
          for (h3 = new n2(2 * h3 * h3).toRed(this); this.pow(h3, u2).cmp(c3) !== 0; )
            h3.redIAdd(c3);
          for (var f3 = this.pow(h3, a3), d3 = this.pow(e4, a3.addn(1).iushrn(1)), l3 = this.pow(e4, a3), p3 = s3; l3.cmp(o3) !== 0; ) {
            for (var y3 = l3, b3 = 0; y3.cmp(o3) !== 0; b3++)
              y3 = y3.redSqr();
            r2(b3 < p3);
            var m3 = this.pow(f3, new n2(1).iushln(p3 - b3 - 1));
            d3 = d3.redMul(m3), f3 = m3.redSqr(), l3 = l3.redMul(f3), p3 = b3;
          }
          return d3;
        }, k2.prototype.invm = function(e4) {
          var t3 = e4._invmp(this.m);
          return t3.negative !== 0 ? (t3.negative = 0, this.imod(t3).redNeg()) : this.imod(t3);
        }, k2.prototype.pow = function(e4, t3) {
          if (t3.isZero())
            return new n2(1).toRed(this);
          if (t3.cmpn(1) === 0)
            return e4.clone();
          var r3 = Array(16);
          r3[0] = new n2(1).toRed(this), r3[1] = e4;
          for (var i3 = 2; i3 < r3.length; i3++)
            r3[i3] = this.mul(r3[i3 - 1], e4);
          var a3 = r3[0], s3 = 0, o3 = 0, c3 = t3.bitLength() % 26;
          for (c3 === 0 && (c3 = 26), i3 = t3.length - 1; i3 >= 0; i3--) {
            for (var u2 = t3.words[i3], h3 = c3 - 1; h3 >= 0; h3--) {
              var f3 = u2 >> h3 & 1;
              a3 !== r3[0] && (a3 = this.sqr(a3)), f3 !== 0 || s3 !== 0 ? (s3 <<= 1, s3 |= f3, (++o3 === 4 || i3 === 0 && h3 === 0) && (a3 = this.mul(a3, r3[s3]), o3 = 0, s3 = 0)) : o3 = 0;
            }
            c3 = 26;
          }
          return a3;
        }, k2.prototype.convertTo = function(e4) {
          var t3 = e4.umod(this.m);
          return t3 === e4 ? t3.clone() : t3;
        }, k2.prototype.convertFrom = function(e4) {
          var t3 = e4.clone();
          return t3.red = null, t3;
        }, n2.mont = function(e4) {
          return new A2(e4);
        }, i2(A2, k2), A2.prototype.convertTo = function(e4) {
          return this.imod(e4.ushln(this.shift));
        }, A2.prototype.convertFrom = function(e4) {
          var t3 = this.imod(e4.mul(this.rinv));
          return t3.red = null, t3;
        }, A2.prototype.imul = function(e4, t3) {
          if (e4.isZero() || t3.isZero())
            return e4.words[0] = 0, e4.length = 1, e4;
          var r3 = e4.imul(t3), i3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), n3 = r3.isub(i3).iushrn(this.shift), a3 = n3;
          return n3.cmp(this.m) >= 0 ? a3 = n3.isub(this.m) : n3.cmpn(0) < 0 && (a3 = n3.iadd(this.m)), a3._forceRed(this);
        }, A2.prototype.mul = function(e4, t3) {
          if (e4.isZero() || t3.isZero())
            return new n2(0)._forceRed(this);
          var r3 = e4.mul(t3), i3 = r3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), a3 = r3.isub(i3).iushrn(this.shift), s3 = a3;
          return a3.cmp(this.m) >= 0 ? s3 = a3.isub(this.m) : a3.cmpn(0) < 0 && (s3 = a3.iadd(this.m)), s3._forceRed(this);
        }, A2.prototype.invm = function(e4) {
          return this.imod(e4._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(e2, yt);
    });
    var Md = /* @__PURE__ */ Object.freeze({ __proto__: null, default: xd, __moduleExports: xd });
    var Cd = class {
      constructor(e2) {
        if (e2 === void 0)
          throw Error("Invalid BigInteger input");
        this.value = new xd(e2);
      }
      clone() {
        const e2 = new Cd(null);
        return this.value.copy(e2.value), e2;
      }
      iinc() {
        return this.value.iadd(new xd(1)), this;
      }
      inc() {
        return this.clone().iinc();
      }
      idec() {
        return this.value.isub(new xd(1)), this;
      }
      dec() {
        return this.clone().idec();
      }
      iadd(e2) {
        return this.value.iadd(e2.value), this;
      }
      add(e2) {
        return this.clone().iadd(e2);
      }
      isub(e2) {
        return this.value.isub(e2.value), this;
      }
      sub(e2) {
        return this.clone().isub(e2);
      }
      imul(e2) {
        return this.value.imul(e2.value), this;
      }
      mul(e2) {
        return this.clone().imul(e2);
      }
      imod(e2) {
        return this.value = this.value.umod(e2.value), this;
      }
      mod(e2) {
        return this.clone().imod(e2);
      }
      modExp(e2, t2) {
        const r2 = t2.isEven() ? xd.red(t2.value) : xd.mont(t2.value), i2 = this.clone();
        return i2.value = i2.value.toRed(r2).redPow(e2.value).fromRed(), i2;
      }
      modInv(e2) {
        if (!this.gcd(e2).isOne())
          throw Error("Inverse does not exist");
        return new Cd(this.value.invm(e2.value));
      }
      gcd(e2) {
        return new Cd(this.value.gcd(e2.value));
      }
      ileftShift(e2) {
        return this.value.ishln(e2.value.toNumber()), this;
      }
      leftShift(e2) {
        return this.clone().ileftShift(e2);
      }
      irightShift(e2) {
        return this.value.ishrn(e2.value.toNumber()), this;
      }
      rightShift(e2) {
        return this.clone().irightShift(e2);
      }
      equal(e2) {
        return this.value.eq(e2.value);
      }
      lt(e2) {
        return this.value.lt(e2.value);
      }
      lte(e2) {
        return this.value.lte(e2.value);
      }
      gt(e2) {
        return this.value.gt(e2.value);
      }
      gte(e2) {
        return this.value.gte(e2.value);
      }
      isZero() {
        return this.value.isZero();
      }
      isOne() {
        return this.value.eq(new xd(1));
      }
      isNegative() {
        return this.value.isNeg();
      }
      isEven() {
        return this.value.isEven();
      }
      abs() {
        const e2 = this.clone();
        return e2.value = e2.value.abs(), e2;
      }
      toString() {
        return this.value.toString();
      }
      toNumber() {
        return this.value.toNumber();
      }
      getBit(e2) {
        return this.value.testn(e2) ? 1 : 0;
      }
      bitLength() {
        return this.value.bitLength();
      }
      byteLength() {
        return this.value.byteLength();
      }
      toUint8Array(e2 = "be", t2) {
        return this.value.toArrayLike(Uint8Array, e2, t2);
      }
    };
    var Kd;
    var Dd = /* @__PURE__ */ Object.freeze({ __proto__: null, default: Cd });
    var Rd = bt(function(e2, t2) {
      var r2 = t2;
      function i2(e3) {
        return e3.length === 1 ? "0" + e3 : e3;
      }
      function n2(e3) {
        for (var t3 = "", r3 = 0; r3 < e3.length; r3++)
          t3 += i2(e3[r3].toString(16));
        return t3;
      }
      r2.toArray = function(e3, t3) {
        if (Array.isArray(e3))
          return e3.slice();
        if (!e3)
          return [];
        var r3 = [];
        if (typeof e3 != "string") {
          for (var i3 = 0; i3 < e3.length; i3++)
            r3[i3] = 0 | e3[i3];
          return r3;
        }
        if (t3 === "hex") {
          (e3 = e3.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e3 = "0" + e3);
          for (i3 = 0; i3 < e3.length; i3 += 2)
            r3.push(parseInt(e3[i3] + e3[i3 + 1], 16));
        } else
          for (i3 = 0; i3 < e3.length; i3++) {
            var n3 = e3.charCodeAt(i3), a2 = n3 >> 8, s2 = 255 & n3;
            a2 ? r3.push(a2, s2) : r3.push(s2);
          }
        return r3;
      }, r2.zero2 = i2, r2.toHex = n2, r2.encode = function(e3, t3) {
        return t3 === "hex" ? n2(e3) : e3;
      };
    });
    var Id = bt(function(e2, t2) {
      var r2 = t2;
      r2.assert = lt, r2.toArray = Rd.toArray, r2.zero2 = Rd.zero2, r2.toHex = Rd.toHex, r2.encode = Rd.encode, r2.getNAF = function(e3, t3) {
        for (var r3 = [], i2 = 1 << t3 + 1, n2 = e3.clone(); n2.cmpn(1) >= 0; ) {
          var a2;
          if (n2.isOdd()) {
            var s2 = n2.andln(i2 - 1);
            a2 = s2 > (i2 >> 1) - 1 ? (i2 >> 1) - s2 : s2, n2.isubn(a2);
          } else
            a2 = 0;
          r3.push(a2);
          for (var o2 = n2.cmpn(0) !== 0 && n2.andln(i2 - 1) === 0 ? t3 + 1 : 1, c2 = 1; c2 < o2; c2++)
            r3.push(0);
          n2.iushrn(o2);
        }
        return r3;
      }, r2.getJSF = function(e3, t3) {
        var r3 = [[], []];
        e3 = e3.clone(), t3 = t3.clone();
        for (var i2 = 0, n2 = 0; e3.cmpn(-i2) > 0 || t3.cmpn(-n2) > 0; ) {
          var a2, s2, o2, c2 = e3.andln(3) + i2 & 3, u2 = t3.andln(3) + n2 & 3;
          if (c2 === 3 && (c2 = -1), u2 === 3 && (u2 = -1), (1 & c2) == 0)
            a2 = 0;
          else
            a2 = (o2 = e3.andln(7) + i2 & 7) !== 3 && o2 !== 5 || u2 !== 2 ? c2 : -c2;
          if (r3[0].push(a2), (1 & u2) == 0)
            s2 = 0;
          else
            s2 = (o2 = t3.andln(7) + n2 & 7) !== 3 && o2 !== 5 || c2 !== 2 ? u2 : -u2;
          r3[1].push(s2), 2 * i2 === a2 + 1 && (i2 = 1 - i2), 2 * n2 === s2 + 1 && (n2 = 1 - n2), e3.iushrn(1), t3.iushrn(1);
        }
        return r3;
      }, r2.cachedProperty = function(e3, t3, r3) {
        var i2 = "_" + t3;
        e3.prototype[t3] = function() {
          return this[i2] !== void 0 ? this[i2] : this[i2] = r3.call(this);
        };
      }, r2.parseBytes = function(e3) {
        return typeof e3 == "string" ? r2.toArray(e3, "hex") : e3;
      }, r2.intFromLE = function(e3) {
        return new xd(e3, "hex", "le");
      };
    });
    var Ud = function(e2) {
      return Kd || (Kd = new Bd(null)), Kd.generate(e2);
    };
    function Bd(e2) {
      this.rand = e2;
    }
    var Td = Bd;
    if (Bd.prototype.generate = function(e2) {
      return this._rand(e2);
    }, Bd.prototype._rand = function(e2) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e2);
      for (var t2 = new Uint8Array(e2), r2 = 0; r2 < t2.length; r2++)
        t2[r2] = this.rand.getByte();
      return t2;
    }, typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Bd.prototype._rand = function(e2) {
        var t2 = new Uint8Array(e2);
        return self.crypto.getRandomValues(t2), t2;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Bd.prototype._rand = function(e2) {
        var t2 = new Uint8Array(e2);
        return self.msCrypto.getRandomValues(t2), t2;
      } : typeof window == "object" && (Bd.prototype._rand = function() {
        throw Error("Not implemented yet");
      });
    else
      try {
        zd = f.default;
        if (typeof zd.randomBytes != "function")
          throw Error("Not supported");
        Bd.prototype._rand = function(e2) {
          return zd.randomBytes(e2);
        };
      } catch (e2) {
      }
    var zd;
    Ud.Rand = Td;
    var qd = Id.getNAF;
    var Od = Id.getJSF;
    var Fd = Id.assert;
    function Nd(e2, t2) {
      this.type = e2, this.p = new xd(t2.p, 16), this.red = t2.prime ? xd.red(t2.prime) : xd.mont(this.p), this.zero = new xd(0).toRed(this.red), this.one = new xd(1).toRed(this.red), this.two = new xd(2).toRed(this.red), this.n = t2.n && new xd(t2.n, 16), this.g = t2.g && this.pointFromJSON(t2.g, t2.gRed), this._wnafT1 = [, , , ,], this._wnafT2 = [, , , ,], this._wnafT3 = [, , , ,], this._wnafT4 = [, , , ,];
      var r2 = this.n && this.p.div(this.n);
      !r2 || r2.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    var jd = Nd;
    function Ld(e2, t2) {
      this.curve = e2, this.type = t2, this.precomputed = null;
    }
    Nd.prototype.point = function() {
      throw Error("Not implemented");
    }, Nd.prototype.validate = function() {
      throw Error("Not implemented");
    }, Nd.prototype._fixedNafMul = function(e2, t2) {
      Fd(e2.precomputed);
      var r2 = e2._getDoubles(), i2 = qd(t2, 1), n2 = (1 << r2.step + 1) - (r2.step % 2 == 0 ? 2 : 1);
      n2 /= 3;
      for (var a2 = [], s2 = 0; s2 < i2.length; s2 += r2.step) {
        var o2 = 0;
        for (t2 = s2 + r2.step - 1; t2 >= s2; t2--)
          o2 = (o2 << 1) + i2[t2];
        a2.push(o2);
      }
      for (var c2 = this.jpoint(null, null, null), u2 = this.jpoint(null, null, null), h2 = n2; h2 > 0; h2--) {
        for (s2 = 0; s2 < a2.length; s2++) {
          (o2 = a2[s2]) === h2 ? u2 = u2.mixedAdd(r2.points[s2]) : o2 === -h2 && (u2 = u2.mixedAdd(r2.points[s2].neg()));
        }
        c2 = c2.add(u2);
      }
      return c2.toP();
    }, Nd.prototype._wnafMul = function(e2, t2) {
      var r2 = 4, i2 = e2._getNAFPoints(r2);
      r2 = i2.wnd;
      for (var n2 = i2.points, a2 = qd(t2, r2), s2 = this.jpoint(null, null, null), o2 = a2.length - 1; o2 >= 0; o2--) {
        for (t2 = 0; o2 >= 0 && a2[o2] === 0; o2--)
          t2++;
        if (o2 >= 0 && t2++, s2 = s2.dblp(t2), o2 < 0)
          break;
        var c2 = a2[o2];
        Fd(c2 !== 0), s2 = e2.type === "affine" ? c2 > 0 ? s2.mixedAdd(n2[c2 - 1 >> 1]) : s2.mixedAdd(n2[-c2 - 1 >> 1].neg()) : c2 > 0 ? s2.add(n2[c2 - 1 >> 1]) : s2.add(n2[-c2 - 1 >> 1].neg());
      }
      return e2.type === "affine" ? s2.toP() : s2;
    }, Nd.prototype._wnafMulAdd = function(e2, t2, r2, i2, n2) {
      for (var a2 = this._wnafT1, s2 = this._wnafT2, o2 = this._wnafT3, c2 = 0, u2 = 0; u2 < i2; u2++) {
        var h2 = (A2 = t2[u2])._getNAFPoints(e2);
        a2[u2] = h2.wnd, s2[u2] = h2.points;
      }
      for (u2 = i2 - 1; u2 >= 1; u2 -= 2) {
        var f2 = u2 - 1, d2 = u2;
        if (a2[f2] === 1 && a2[d2] === 1) {
          var l2 = [t2[f2], null, null, t2[d2]];
          t2[f2].y.cmp(t2[d2].y) === 0 ? (l2[1] = t2[f2].add(t2[d2]), l2[2] = t2[f2].toJ().mixedAdd(t2[d2].neg())) : t2[f2].y.cmp(t2[d2].y.redNeg()) === 0 ? (l2[1] = t2[f2].toJ().mixedAdd(t2[d2]), l2[2] = t2[f2].add(t2[d2].neg())) : (l2[1] = t2[f2].toJ().mixedAdd(t2[d2]), l2[2] = t2[f2].toJ().mixedAdd(t2[d2].neg()));
          var p2 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], y2 = Od(r2[f2], r2[d2]);
          c2 = Math.max(y2[0].length, c2), o2[f2] = Array(c2), o2[d2] = Array(c2);
          for (var b2 = 0; b2 < c2; b2++) {
            var m2 = 0 | y2[0][b2], g2 = 0 | y2[1][b2];
            o2[f2][b2] = p2[3 * (m2 + 1) + (g2 + 1)], o2[d2][b2] = 0, s2[f2] = l2;
          }
        } else
          o2[f2] = qd(r2[f2], a2[f2]), o2[d2] = qd(r2[d2], a2[d2]), c2 = Math.max(o2[f2].length, c2), c2 = Math.max(o2[d2].length, c2);
      }
      var w2 = this.jpoint(null, null, null), v2 = this._wnafT4;
      for (u2 = c2; u2 >= 0; u2--) {
        for (var _2 = 0; u2 >= 0; ) {
          var k2 = true;
          for (b2 = 0; b2 < i2; b2++)
            v2[b2] = 0 | o2[b2][u2], v2[b2] !== 0 && (k2 = false);
          if (!k2)
            break;
          _2++, u2--;
        }
        if (u2 >= 0 && _2++, w2 = w2.dblp(_2), u2 < 0)
          break;
        for (b2 = 0; b2 < i2; b2++) {
          var A2, S2 = v2[b2];
          S2 !== 0 && (S2 > 0 ? A2 = s2[b2][S2 - 1 >> 1] : S2 < 0 && (A2 = s2[b2][-S2 - 1 >> 1].neg()), w2 = A2.type === "affine" ? w2.mixedAdd(A2) : w2.add(A2));
        }
      }
      for (u2 = 0; u2 < i2; u2++)
        s2[u2] = null;
      return n2 ? w2 : w2.toP();
    }, Nd.BasePoint = Ld, Ld.prototype.eq = function() {
      throw Error("Not implemented");
    }, Ld.prototype.validate = function() {
      return this.curve.validate(this);
    }, Nd.prototype.decodePoint = function(e2, t2) {
      e2 = Id.toArray(e2, t2);
      var r2 = this.p.byteLength();
      if ((e2[0] === 4 || e2[0] === 6 || e2[0] === 7) && e2.length - 1 == 2 * r2)
        return e2[0] === 6 ? Fd(e2[e2.length - 1] % 2 == 0) : e2[0] === 7 && Fd(e2[e2.length - 1] % 2 == 1), this.point(e2.slice(1, 1 + r2), e2.slice(1 + r2, 1 + 2 * r2));
      if ((e2[0] === 2 || e2[0] === 3) && e2.length - 1 === r2)
        return this.pointFromX(e2.slice(1, 1 + r2), e2[0] === 3);
      throw Error("Unknown point format");
    }, Ld.prototype.encodeCompressed = function(e2) {
      return this.encode(e2, true);
    }, Ld.prototype._encode = function(e2) {
      var t2 = this.curve.p.byteLength(), r2 = this.getX().toArray("be", t2);
      return e2 ? [this.getY().isEven() ? 2 : 3].concat(r2) : [4].concat(r2, this.getY().toArray("be", t2));
    }, Ld.prototype.encode = function(e2, t2) {
      return Id.encode(this._encode(t2), e2);
    }, Ld.prototype.precompute = function(e2) {
      if (this.precomputed)
        return this;
      var t2 = { doubles: null, naf: null, beta: null };
      return t2.naf = this._getNAFPoints(8), t2.doubles = this._getDoubles(4, e2), t2.beta = this._getBeta(), this.precomputed = t2, this;
    }, Ld.prototype._hasDoubles = function(e2) {
      if (!this.precomputed)
        return false;
      var t2 = this.precomputed.doubles;
      return !!t2 && t2.points.length >= Math.ceil((e2.bitLength() + 1) / t2.step);
    }, Ld.prototype._getDoubles = function(e2, t2) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var r2 = [this], i2 = this, n2 = 0; n2 < t2; n2 += e2) {
        for (var a2 = 0; a2 < e2; a2++)
          i2 = i2.dbl();
        r2.push(i2);
      }
      return { step: e2, points: r2 };
    }, Ld.prototype._getNAFPoints = function(e2) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var t2 = [this], r2 = (1 << e2) - 1, i2 = r2 === 1 ? null : this.dbl(), n2 = 1; n2 < r2; n2++)
        t2[n2] = t2[n2 - 1].add(i2);
      return { wnd: e2, points: t2 };
    }, Ld.prototype._getBeta = function() {
      return null;
    }, Ld.prototype.dblp = function(e2) {
      for (var t2 = this, r2 = 0; r2 < e2; r2++)
        t2 = t2.dbl();
      return t2;
    };
    var Wd = Id.assert;
    function Hd(e2) {
      jd.call(this, "short", e2), this.a = new xd(e2.a, 16).toRed(this.red), this.b = new xd(e2.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e2), this._endoWnafT1 = [, , , ,], this._endoWnafT2 = [, , , ,];
    }
    gt(Hd, jd);
    var Gd = Hd;
    function Vd(e2, t2, r2, i2) {
      jd.BasePoint.call(this, e2, "affine"), t2 === null && r2 === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new xd(t2, 16), this.y = new xd(r2, 16), i2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    function $d(e2, t2, r2, i2) {
      jd.BasePoint.call(this, e2, "jacobian"), t2 === null && r2 === null && i2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new xd(0)) : (this.x = new xd(t2, 16), this.y = new xd(r2, 16), this.z = new xd(i2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    function Zd(e2) {
      jd.call(this, "mont", e2), this.a = new xd(e2.a, 16).toRed(this.red), this.b = new xd(e2.b, 16).toRed(this.red), this.i4 = new xd(4).toRed(this.red).redInvm(), this.two = new xd(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    Hd.prototype._getEndomorphism = function(e2) {
      if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
        var t2, r2;
        if (e2.beta)
          t2 = new xd(e2.beta, 16).toRed(this.red);
        else {
          var i2 = this._getEndoRoots(this.p);
          t2 = (t2 = i2[0].cmp(i2[1]) < 0 ? i2[0] : i2[1]).toRed(this.red);
        }
        if (e2.lambda)
          r2 = new xd(e2.lambda, 16);
        else {
          var n2 = this._getEndoRoots(this.n);
          this.g.mul(n2[0]).x.cmp(this.g.x.redMul(t2)) === 0 ? r2 = n2[0] : (r2 = n2[1], Wd(this.g.mul(r2).x.cmp(this.g.x.redMul(t2)) === 0));
        }
        return { beta: t2, lambda: r2, basis: e2.basis ? e2.basis.map(function(e3) {
          return { a: new xd(e3.a, 16), b: new xd(e3.b, 16) };
        }) : this._getEndoBasis(r2) };
      }
    }, Hd.prototype._getEndoRoots = function(e2) {
      var t2 = e2 === this.p ? this.red : xd.mont(e2), r2 = new xd(2).toRed(t2).redInvm(), i2 = r2.redNeg(), n2 = new xd(3).toRed(t2).redNeg().redSqrt().redMul(r2);
      return [i2.redAdd(n2).fromRed(), i2.redSub(n2).fromRed()];
    }, Hd.prototype._getEndoBasis = function(e2) {
      for (var t2, r2, i2, n2, a2, s2, o2, c2, u2, h2 = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), f2 = e2, d2 = this.n.clone(), l2 = new xd(1), p2 = new xd(0), y2 = new xd(0), b2 = new xd(1), m2 = 0; f2.cmpn(0) !== 0; ) {
        var g2 = d2.div(f2);
        c2 = d2.sub(g2.mul(f2)), u2 = y2.sub(g2.mul(l2));
        var w2 = b2.sub(g2.mul(p2));
        if (!i2 && c2.cmp(h2) < 0)
          t2 = o2.neg(), r2 = l2, i2 = c2.neg(), n2 = u2;
        else if (i2 && ++m2 == 2)
          break;
        o2 = c2, d2 = f2, f2 = c2, y2 = l2, l2 = u2, b2 = p2, p2 = w2;
      }
      a2 = c2.neg(), s2 = u2;
      var v2 = i2.sqr().add(n2.sqr());
      return a2.sqr().add(s2.sqr()).cmp(v2) >= 0 && (a2 = t2, s2 = r2), i2.negative && (i2 = i2.neg(), n2 = n2.neg()), a2.negative && (a2 = a2.neg(), s2 = s2.neg()), [{ a: i2, b: n2 }, { a: a2, b: s2 }];
    }, Hd.prototype._endoSplit = function(e2) {
      var t2 = this.endo.basis, r2 = t2[0], i2 = t2[1], n2 = i2.b.mul(e2).divRound(this.n), a2 = r2.b.neg().mul(e2).divRound(this.n), s2 = n2.mul(r2.a), o2 = a2.mul(i2.a), c2 = n2.mul(r2.b), u2 = a2.mul(i2.b);
      return { k1: e2.sub(s2).sub(o2), k2: c2.add(u2).neg() };
    }, Hd.prototype.pointFromX = function(e2, t2) {
      (e2 = new xd(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr().redMul(e2).redIAdd(e2.redMul(this.a)).redIAdd(this.b), i2 = r2.redSqrt();
      if (i2.redSqr().redSub(r2).cmp(this.zero) !== 0)
        throw Error("invalid point");
      var n2 = i2.fromRed().isOdd();
      return (t2 && !n2 || !t2 && n2) && (i2 = i2.redNeg()), this.point(e2, i2);
    }, Hd.prototype.validate = function(e2) {
      if (e2.inf)
        return true;
      var t2 = e2.x, r2 = e2.y, i2 = this.a.redMul(t2), n2 = t2.redSqr().redMul(t2).redIAdd(i2).redIAdd(this.b);
      return r2.redSqr().redISub(n2).cmpn(0) === 0;
    }, Hd.prototype._endoWnafMulAdd = function(e2, t2, r2) {
      for (var i2 = this._endoWnafT1, n2 = this._endoWnafT2, a2 = 0; a2 < e2.length; a2++) {
        var s2 = this._endoSplit(t2[a2]), o2 = e2[a2], c2 = o2._getBeta();
        s2.k1.negative && (s2.k1.ineg(), o2 = o2.neg(true)), s2.k2.negative && (s2.k2.ineg(), c2 = c2.neg(true)), i2[2 * a2] = o2, i2[2 * a2 + 1] = c2, n2[2 * a2] = s2.k1, n2[2 * a2 + 1] = s2.k2;
      }
      for (var u2 = this._wnafMulAdd(1, i2, n2, 2 * a2, r2), h2 = 0; h2 < 2 * a2; h2++)
        i2[h2] = null, n2[h2] = null;
      return u2;
    }, gt(Vd, jd.BasePoint), Hd.prototype.point = function(e2, t2, r2) {
      return new Vd(this, e2, t2, r2);
    }, Hd.prototype.pointFromJSON = function(e2, t2) {
      return Vd.fromJSON(this, e2, t2);
    }, Vd.prototype._getBeta = function() {
      if (this.curve.endo) {
        var e2 = this.precomputed;
        if (e2 && e2.beta)
          return e2.beta;
        var t2 = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e2) {
          var r2 = this.curve, i2 = function(e3) {
            return r2.point(e3.x.redMul(r2.endo.beta), e3.y);
          };
          e2.beta = t2, t2.precomputed = { beta: null, naf: e2.naf && { wnd: e2.naf.wnd, points: e2.naf.points.map(i2) }, doubles: e2.doubles && { step: e2.doubles.step, points: e2.doubles.points.map(i2) } };
        }
        return t2;
      }
    }, Vd.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    }, Vd.fromJSON = function(e2, t2, r2) {
      typeof t2 == "string" && (t2 = JSON.parse(t2));
      var i2 = e2.point(t2[0], t2[1], r2);
      if (!t2[2])
        return i2;
      function n2(t3) {
        return e2.point(t3[0], t3[1], r2);
      }
      var a2 = t2[2];
      return i2.precomputed = { beta: null, doubles: a2.doubles && { step: a2.doubles.step, points: [i2].concat(a2.doubles.points.map(n2)) }, naf: a2.naf && { wnd: a2.naf.wnd, points: [i2].concat(a2.naf.points.map(n2)) } }, i2;
    }, Vd.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    }, Vd.prototype.isInfinity = function() {
      return this.inf;
    }, Vd.prototype.add = function(e2) {
      if (this.inf)
        return e2;
      if (e2.inf)
        return this;
      if (this.eq(e2))
        return this.dbl();
      if (this.neg().eq(e2))
        return this.curve.point(null, null);
      if (this.x.cmp(e2.x) === 0)
        return this.curve.point(null, null);
      var t2 = this.y.redSub(e2.y);
      t2.cmpn(0) !== 0 && (t2 = t2.redMul(this.x.redSub(e2.x).redInvm()));
      var r2 = t2.redSqr().redISub(this.x).redISub(e2.x), i2 = t2.redMul(this.x.redSub(r2)).redISub(this.y);
      return this.curve.point(r2, i2);
    }, Vd.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e2 = this.y.redAdd(this.y);
      if (e2.cmpn(0) === 0)
        return this.curve.point(null, null);
      var t2 = this.curve.a, r2 = this.x.redSqr(), i2 = e2.redInvm(), n2 = r2.redAdd(r2).redIAdd(r2).redIAdd(t2).redMul(i2), a2 = n2.redSqr().redISub(this.x.redAdd(this.x)), s2 = n2.redMul(this.x.redSub(a2)).redISub(this.y);
      return this.curve.point(a2, s2);
    }, Vd.prototype.getX = function() {
      return this.x.fromRed();
    }, Vd.prototype.getY = function() {
      return this.y.fromRed();
    }, Vd.prototype.mul = function(e2) {
      return e2 = new xd(e2, 16), this.isInfinity() ? this : this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e2]) : this.curve._wnafMul(this, e2);
    }, Vd.prototype.mulAdd = function(e2, t2, r2) {
      var i2 = [this, t2], n2 = [e2, r2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(i2, n2) : this.curve._wnafMulAdd(1, i2, n2, 2);
    }, Vd.prototype.jmulAdd = function(e2, t2, r2) {
      var i2 = [this, t2], n2 = [e2, r2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(i2, n2, true) : this.curve._wnafMulAdd(1, i2, n2, 2, true);
    }, Vd.prototype.eq = function(e2) {
      return this === e2 || this.inf === e2.inf && (this.inf || this.x.cmp(e2.x) === 0 && this.y.cmp(e2.y) === 0);
    }, Vd.prototype.neg = function(e2) {
      if (this.inf)
        return this;
      var t2 = this.curve.point(this.x, this.y.redNeg());
      if (e2 && this.precomputed) {
        var r2 = this.precomputed, i2 = function(e3) {
          return e3.neg();
        };
        t2.precomputed = { naf: r2.naf && { wnd: r2.naf.wnd, points: r2.naf.points.map(i2) }, doubles: r2.doubles && { step: r2.doubles.step, points: r2.doubles.points.map(i2) } };
      }
      return t2;
    }, Vd.prototype.toJ = function() {
      return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
    }, gt($d, jd.BasePoint), Hd.prototype.jpoint = function(e2, t2, r2) {
      return new $d(this, e2, t2, r2);
    }, $d.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e2 = this.z.redInvm(), t2 = e2.redSqr(), r2 = this.x.redMul(t2), i2 = this.y.redMul(t2).redMul(e2);
      return this.curve.point(r2, i2);
    }, $d.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }, $d.prototype.add = function(e2) {
      if (this.isInfinity())
        return e2;
      if (e2.isInfinity())
        return this;
      var t2 = e2.z.redSqr(), r2 = this.z.redSqr(), i2 = this.x.redMul(t2), n2 = e2.x.redMul(r2), a2 = this.y.redMul(t2.redMul(e2.z)), s2 = e2.y.redMul(r2.redMul(this.z)), o2 = i2.redSub(n2), c2 = a2.redSub(s2);
      if (o2.cmpn(0) === 0)
        return c2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var u2 = o2.redSqr(), h2 = u2.redMul(o2), f2 = i2.redMul(u2), d2 = c2.redSqr().redIAdd(h2).redISub(f2).redISub(f2), l2 = c2.redMul(f2.redISub(d2)).redISub(a2.redMul(h2)), p2 = this.z.redMul(e2.z).redMul(o2);
      return this.curve.jpoint(d2, l2, p2);
    }, $d.prototype.mixedAdd = function(e2) {
      if (this.isInfinity())
        return e2.toJ();
      if (e2.isInfinity())
        return this;
      var t2 = this.z.redSqr(), r2 = this.x, i2 = e2.x.redMul(t2), n2 = this.y, a2 = e2.y.redMul(t2).redMul(this.z), s2 = r2.redSub(i2), o2 = n2.redSub(a2);
      if (s2.cmpn(0) === 0)
        return o2.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var c2 = s2.redSqr(), u2 = c2.redMul(s2), h2 = r2.redMul(c2), f2 = o2.redSqr().redIAdd(u2).redISub(h2).redISub(h2), d2 = o2.redMul(h2.redISub(f2)).redISub(n2.redMul(u2)), l2 = this.z.redMul(s2);
      return this.curve.jpoint(f2, d2, l2);
    }, $d.prototype.dblp = function(e2) {
      if (e2 === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e2)
        return this.dbl();
      if (this.curve.zeroA || this.curve.threeA) {
        for (var t2 = this, r2 = 0; r2 < e2; r2++)
          t2 = t2.dbl();
        return t2;
      }
      var i2 = this.curve.a, n2 = this.curve.tinv, a2 = this.x, s2 = this.y, o2 = this.z, c2 = o2.redSqr().redSqr(), u2 = s2.redAdd(s2);
      for (r2 = 0; r2 < e2; r2++) {
        var h2 = a2.redSqr(), f2 = u2.redSqr(), d2 = f2.redSqr(), l2 = h2.redAdd(h2).redIAdd(h2).redIAdd(i2.redMul(c2)), p2 = a2.redMul(f2), y2 = l2.redSqr().redISub(p2.redAdd(p2)), b2 = p2.redISub(y2), m2 = l2.redMul(b2);
        m2 = m2.redIAdd(m2).redISub(d2);
        var g2 = u2.redMul(o2);
        r2 + 1 < e2 && (c2 = c2.redMul(d2)), a2 = y2, o2 = g2, u2 = m2;
      }
      return this.curve.jpoint(a2, u2.redMul(n2), o2);
    }, $d.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    }, $d.prototype._zeroDbl = function() {
      var e2, t2, r2;
      if (this.zOne) {
        var i2 = this.x.redSqr(), n2 = this.y.redSqr(), a2 = n2.redSqr(), s2 = this.x.redAdd(n2).redSqr().redISub(i2).redISub(a2);
        s2 = s2.redIAdd(s2);
        var o2 = i2.redAdd(i2).redIAdd(i2), c2 = o2.redSqr().redISub(s2).redISub(s2), u2 = a2.redIAdd(a2);
        u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), e2 = c2, t2 = o2.redMul(s2.redISub(c2)).redISub(u2), r2 = this.y.redAdd(this.y);
      } else {
        var h2 = this.x.redSqr(), f2 = this.y.redSqr(), d2 = f2.redSqr(), l2 = this.x.redAdd(f2).redSqr().redISub(h2).redISub(d2);
        l2 = l2.redIAdd(l2);
        var p2 = h2.redAdd(h2).redIAdd(h2), y2 = p2.redSqr(), b2 = d2.redIAdd(d2);
        b2 = (b2 = b2.redIAdd(b2)).redIAdd(b2), e2 = y2.redISub(l2).redISub(l2), t2 = p2.redMul(l2.redISub(e2)).redISub(b2), r2 = (r2 = this.y.redMul(this.z)).redIAdd(r2);
      }
      return this.curve.jpoint(e2, t2, r2);
    }, $d.prototype._threeDbl = function() {
      var e2, t2, r2;
      if (this.zOne) {
        var i2 = this.x.redSqr(), n2 = this.y.redSqr(), a2 = n2.redSqr(), s2 = this.x.redAdd(n2).redSqr().redISub(i2).redISub(a2);
        s2 = s2.redIAdd(s2);
        var o2 = i2.redAdd(i2).redIAdd(i2).redIAdd(this.curve.a), c2 = o2.redSqr().redISub(s2).redISub(s2);
        e2 = c2;
        var u2 = a2.redIAdd(a2);
        u2 = (u2 = u2.redIAdd(u2)).redIAdd(u2), t2 = o2.redMul(s2.redISub(c2)).redISub(u2), r2 = this.y.redAdd(this.y);
      } else {
        var h2 = this.z.redSqr(), f2 = this.y.redSqr(), d2 = this.x.redMul(f2), l2 = this.x.redSub(h2).redMul(this.x.redAdd(h2));
        l2 = l2.redAdd(l2).redIAdd(l2);
        var p2 = d2.redIAdd(d2), y2 = (p2 = p2.redIAdd(p2)).redAdd(p2);
        e2 = l2.redSqr().redISub(y2), r2 = this.y.redAdd(this.z).redSqr().redISub(f2).redISub(h2);
        var b2 = f2.redSqr();
        b2 = (b2 = (b2 = b2.redIAdd(b2)).redIAdd(b2)).redIAdd(b2), t2 = l2.redMul(p2.redISub(e2)).redISub(b2);
      }
      return this.curve.jpoint(e2, t2, r2);
    }, $d.prototype._dbl = function() {
      var e2 = this.curve.a, t2 = this.x, r2 = this.y, i2 = this.z, n2 = i2.redSqr().redSqr(), a2 = t2.redSqr(), s2 = r2.redSqr(), o2 = a2.redAdd(a2).redIAdd(a2).redIAdd(e2.redMul(n2)), c2 = t2.redAdd(t2), u2 = (c2 = c2.redIAdd(c2)).redMul(s2), h2 = o2.redSqr().redISub(u2.redAdd(u2)), f2 = u2.redISub(h2), d2 = s2.redSqr();
      d2 = (d2 = (d2 = d2.redIAdd(d2)).redIAdd(d2)).redIAdd(d2);
      var l2 = o2.redMul(f2).redISub(d2), p2 = r2.redAdd(r2).redMul(i2);
      return this.curve.jpoint(h2, l2, p2);
    }, $d.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e2 = this.x.redSqr(), t2 = this.y.redSqr(), r2 = this.z.redSqr(), i2 = t2.redSqr(), n2 = e2.redAdd(e2).redIAdd(e2), a2 = n2.redSqr(), s2 = this.x.redAdd(t2).redSqr().redISub(e2).redISub(i2), o2 = (s2 = (s2 = (s2 = s2.redIAdd(s2)).redAdd(s2).redIAdd(s2)).redISub(a2)).redSqr(), c2 = i2.redIAdd(i2);
      c2 = (c2 = (c2 = c2.redIAdd(c2)).redIAdd(c2)).redIAdd(c2);
      var u2 = n2.redIAdd(s2).redSqr().redISub(a2).redISub(o2).redISub(c2), h2 = t2.redMul(u2);
      h2 = (h2 = h2.redIAdd(h2)).redIAdd(h2);
      var f2 = this.x.redMul(o2).redISub(h2);
      f2 = (f2 = f2.redIAdd(f2)).redIAdd(f2);
      var d2 = this.y.redMul(u2.redMul(c2.redISub(u2)).redISub(s2.redMul(o2)));
      d2 = (d2 = (d2 = d2.redIAdd(d2)).redIAdd(d2)).redIAdd(d2);
      var l2 = this.z.redAdd(s2).redSqr().redISub(r2).redISub(o2);
      return this.curve.jpoint(f2, d2, l2);
    }, $d.prototype.mul = function(e2, t2) {
      return e2 = new xd(e2, t2), this.curve._wnafMul(this, e2);
    }, $d.prototype.eq = function(e2) {
      if (e2.type === "affine")
        return this.eq(e2.toJ());
      if (this === e2)
        return true;
      var t2 = this.z.redSqr(), r2 = e2.z.redSqr();
      if (this.x.redMul(r2).redISub(e2.x.redMul(t2)).cmpn(0) !== 0)
        return false;
      var i2 = t2.redMul(this.z), n2 = r2.redMul(e2.z);
      return this.y.redMul(n2).redISub(e2.y.redMul(i2)).cmpn(0) === 0;
    }, $d.prototype.eqXToP = function(e2) {
      var t2 = this.z.redSqr(), r2 = e2.toRed(this.curve.red).redMul(t2);
      if (this.x.cmp(r2) === 0)
        return true;
      for (var i2 = e2.clone(), n2 = this.curve.redN.redMul(t2); ; ) {
        if (i2.iadd(this.curve.n), i2.cmp(this.curve.p) >= 0)
          return false;
        if (r2.redIAdd(n2), this.x.cmp(r2) === 0)
          return true;
      }
    }, $d.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    }, $d.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    }, gt(Zd, jd);
    var Yd = Zd;
    function Xd(e2, t2, r2) {
      jd.BasePoint.call(this, e2, "projective"), t2 === null && r2 === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new xd(t2, 16), this.z = new xd(r2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    Zd.prototype.validate = function(e2) {
      var t2 = e2.normalize().x, r2 = t2.redSqr(), i2 = r2.redMul(t2).redAdd(r2.redMul(this.a)).redAdd(t2);
      return i2.redSqrt().redSqr().cmp(i2) === 0;
    }, gt(Xd, jd.BasePoint), Zd.prototype.decodePoint = function(e2, t2) {
      if ((e2 = Id.toArray(e2, t2)).length === 33 && e2[0] === 64 && (e2 = e2.slice(1, 33).reverse()), e2.length !== 32)
        throw Error("Unknown point compression format");
      return this.point(e2, 1);
    }, Zd.prototype.point = function(e2, t2) {
      return new Xd(this, e2, t2);
    }, Zd.prototype.pointFromJSON = function(e2) {
      return Xd.fromJSON(this, e2);
    }, Xd.prototype.precompute = function() {
    }, Xd.prototype._encode = function(e2) {
      var t2 = this.curve.p.byteLength();
      return e2 ? [64].concat(this.getX().toArray("le", t2)) : this.getX().toArray("be", t2);
    }, Xd.fromJSON = function(e2, t2) {
      return new Xd(e2, t2[0], t2[1] || e2.one);
    }, Xd.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, Xd.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    }, Xd.prototype.dbl = function() {
      var e2 = this.x.redAdd(this.z).redSqr(), t2 = this.x.redSub(this.z).redSqr(), r2 = e2.redSub(t2), i2 = e2.redMul(t2), n2 = r2.redMul(t2.redAdd(this.curve.a24.redMul(r2)));
      return this.curve.point(i2, n2);
    }, Xd.prototype.add = function() {
      throw Error("Not supported on Montgomery curve");
    }, Xd.prototype.diffAdd = function(e2, t2) {
      var r2 = this.x.redAdd(this.z), i2 = this.x.redSub(this.z), n2 = e2.x.redAdd(e2.z), a2 = e2.x.redSub(e2.z).redMul(r2), s2 = n2.redMul(i2), o2 = t2.z.redMul(a2.redAdd(s2).redSqr()), c2 = t2.x.redMul(a2.redISub(s2).redSqr());
      return this.curve.point(o2, c2);
    }, Xd.prototype.mul = function(e2) {
      for (var t2 = (e2 = new xd(e2, 16)).clone(), r2 = this, i2 = this.curve.point(null, null), n2 = []; t2.cmpn(0) !== 0; t2.iushrn(1))
        n2.push(t2.andln(1));
      for (var a2 = n2.length - 1; a2 >= 0; a2--)
        n2[a2] === 0 ? (r2 = r2.diffAdd(i2, this), i2 = i2.dbl()) : (i2 = r2.diffAdd(i2, this), r2 = r2.dbl());
      return i2;
    }, Xd.prototype.mulAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, Xd.prototype.jumlAdd = function() {
      throw Error("Not supported on Montgomery curve");
    }, Xd.prototype.eq = function(e2) {
      return this.getX().cmp(e2.getX()) === 0;
    }, Xd.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    }, Xd.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    var Qd = Id.assert;
    function Jd(e2) {
      this.twisted = (0 | e2.a) != 1, this.mOneA = this.twisted && (0 | e2.a) == -1, this.extended = this.mOneA, jd.call(this, "edwards", e2), this.a = new xd(e2.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new xd(e2.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new xd(e2.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Qd(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | e2.c) == 1;
    }
    gt(Jd, jd);
    var el = Jd;
    function tl(e2, t2, r2, i2, n2) {
      jd.BasePoint.call(this, e2, "projective"), t2 === null && r2 === null && i2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new xd(t2, 16), this.y = new xd(r2, 16), this.z = i2 ? new xd(i2, 16) : this.curve.one, this.t = n2 && new xd(n2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    Jd.prototype._mulA = function(e2) {
      return this.mOneA ? e2.redNeg() : this.a.redMul(e2);
    }, Jd.prototype._mulC = function(e2) {
      return this.oneC ? e2 : this.c.redMul(e2);
    }, Jd.prototype.jpoint = function(e2, t2, r2, i2) {
      return this.point(e2, t2, r2, i2);
    }, Jd.prototype.pointFromX = function(e2, t2) {
      (e2 = new xd(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr(), i2 = this.c2.redSub(this.a.redMul(r2)), n2 = this.one.redSub(this.c2.redMul(this.d).redMul(r2)), a2 = i2.redMul(n2.redInvm()), s2 = a2.redSqrt();
      if (s2.redSqr().redSub(a2).cmp(this.zero) !== 0)
        throw Error("invalid point");
      var o2 = s2.fromRed().isOdd();
      return (t2 && !o2 || !t2 && o2) && (s2 = s2.redNeg()), this.point(e2, s2);
    }, Jd.prototype.pointFromY = function(e2, t2) {
      (e2 = new xd(e2, 16)).red || (e2 = e2.toRed(this.red));
      var r2 = e2.redSqr(), i2 = r2.redSub(this.c2), n2 = r2.redMul(this.d).redMul(this.c2).redSub(this.a), a2 = i2.redMul(n2.redInvm());
      if (a2.cmp(this.zero) === 0) {
        if (t2)
          throw Error("invalid point");
        return this.point(this.zero, e2);
      }
      var s2 = a2.redSqrt();
      if (s2.redSqr().redSub(a2).cmp(this.zero) !== 0)
        throw Error("invalid point");
      return s2.fromRed().isOdd() !== t2 && (s2 = s2.redNeg()), this.point(s2, e2);
    }, Jd.prototype.validate = function(e2) {
      if (e2.isInfinity())
        return true;
      e2.normalize();
      var t2 = e2.x.redSqr(), r2 = e2.y.redSqr(), i2 = t2.redMul(this.a).redAdd(r2), n2 = this.c2.redMul(this.one.redAdd(this.d.redMul(t2).redMul(r2)));
      return i2.cmp(n2) === 0;
    }, gt(tl, jd.BasePoint), Jd.prototype.pointFromJSON = function(e2) {
      return tl.fromJSON(this, e2);
    }, Jd.prototype.point = function(e2, t2, r2, i2) {
      return new tl(this, e2, t2, r2, i2);
    }, tl.fromJSON = function(e2, t2) {
      return new tl(e2, t2[0], t2[1], t2[2]);
    }, tl.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    }, tl.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    }, tl.prototype._extDbl = function() {
      var e2 = this.x.redSqr(), t2 = this.y.redSqr(), r2 = this.z.redSqr();
      r2 = r2.redIAdd(r2);
      var i2 = this.curve._mulA(e2), n2 = this.x.redAdd(this.y).redSqr().redISub(e2).redISub(t2), a2 = i2.redAdd(t2), s2 = a2.redSub(r2), o2 = i2.redSub(t2), c2 = n2.redMul(s2), u2 = a2.redMul(o2), h2 = n2.redMul(o2), f2 = s2.redMul(a2);
      return this.curve.point(c2, u2, f2, h2);
    }, tl.prototype._projDbl = function() {
      var e2, t2, r2, i2 = this.x.redAdd(this.y).redSqr(), n2 = this.x.redSqr(), a2 = this.y.redSqr();
      if (this.curve.twisted) {
        var s2 = (u2 = this.curve._mulA(n2)).redAdd(a2);
        if (this.zOne)
          e2 = i2.redSub(n2).redSub(a2).redMul(s2.redSub(this.curve.two)), t2 = s2.redMul(u2.redSub(a2)), r2 = s2.redSqr().redSub(s2).redSub(s2);
        else {
          var o2 = this.z.redSqr(), c2 = s2.redSub(o2).redISub(o2);
          e2 = i2.redSub(n2).redISub(a2).redMul(c2), t2 = s2.redMul(u2.redSub(a2)), r2 = s2.redMul(c2);
        }
      } else {
        var u2 = n2.redAdd(a2);
        o2 = this.curve._mulC(this.z).redSqr(), c2 = u2.redSub(o2).redSub(o2);
        e2 = this.curve._mulC(i2.redISub(u2)).redMul(c2), t2 = this.curve._mulC(u2).redMul(n2.redISub(a2)), r2 = u2.redMul(c2);
      }
      return this.curve.point(e2, t2, r2);
    }, tl.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    }, tl.prototype._extAdd = function(e2) {
      var t2 = this.y.redSub(this.x).redMul(e2.y.redSub(e2.x)), r2 = this.y.redAdd(this.x).redMul(e2.y.redAdd(e2.x)), i2 = this.t.redMul(this.curve.dd).redMul(e2.t), n2 = this.z.redMul(e2.z.redAdd(e2.z)), a2 = r2.redSub(t2), s2 = n2.redSub(i2), o2 = n2.redAdd(i2), c2 = r2.redAdd(t2), u2 = a2.redMul(s2), h2 = o2.redMul(c2), f2 = a2.redMul(c2), d2 = s2.redMul(o2);
      return this.curve.point(u2, h2, d2, f2);
    }, tl.prototype._projAdd = function(e2) {
      var t2, r2, i2 = this.z.redMul(e2.z), n2 = i2.redSqr(), a2 = this.x.redMul(e2.x), s2 = this.y.redMul(e2.y), o2 = this.curve.d.redMul(a2).redMul(s2), c2 = n2.redSub(o2), u2 = n2.redAdd(o2), h2 = this.x.redAdd(this.y).redMul(e2.x.redAdd(e2.y)).redISub(a2).redISub(s2), f2 = i2.redMul(c2).redMul(h2);
      return this.curve.twisted ? (t2 = i2.redMul(u2).redMul(s2.redSub(this.curve._mulA(a2))), r2 = c2.redMul(u2)) : (t2 = i2.redMul(u2).redMul(s2.redSub(a2)), r2 = this.curve._mulC(c2).redMul(u2)), this.curve.point(f2, t2, r2);
    }, tl.prototype.add = function(e2) {
      return this.isInfinity() ? e2 : e2.isInfinity() ? this : this.curve.extended ? this._extAdd(e2) : this._projAdd(e2);
    }, tl.prototype.mul = function(e2) {
      return this._hasDoubles(e2) ? this.curve._fixedNafMul(this, e2) : this.curve._wnafMul(this, e2);
    }, tl.prototype.mulAdd = function(e2, t2, r2) {
      return this.curve._wnafMulAdd(1, [this, t2], [e2, r2], 2, false);
    }, tl.prototype.jmulAdd = function(e2, t2, r2) {
      return this.curve._wnafMulAdd(1, [this, t2], [e2, r2], 2, true);
    }, tl.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e2 = this.z.redInvm();
      return this.x = this.x.redMul(e2), this.y = this.y.redMul(e2), this.t && (this.t = this.t.redMul(e2)), this.z = this.curve.one, this.zOne = true, this;
    }, tl.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    }, tl.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    }, tl.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    }, tl.prototype.eq = function(e2) {
      return this === e2 || this.getX().cmp(e2.getX()) === 0 && this.getY().cmp(e2.getY()) === 0;
    }, tl.prototype.eqXToP = function(e2) {
      var t2 = e2.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(t2) === 0)
        return true;
      for (var r2 = e2.clone(), i2 = this.curve.redN.redMul(this.z); ; ) {
        if (r2.iadd(this.curve.n), r2.cmp(this.curve.p) >= 0)
          return false;
        if (t2.redIAdd(i2), this.x.cmp(t2) === 0)
          return true;
      }
    }, tl.prototype.toP = tl.prototype.normalize, tl.prototype.mixedAdd = tl.prototype.add;
    var rl = bt(function(e2, t2) {
      var r2 = t2;
      r2.base = jd, r2.short = Gd, r2.mont = Yd, r2.edwards = el;
    });
    var il = kt.rotl32;
    var nl = kt.sum32;
    var al = kt.sum32_5;
    var sl = Kt.ft_1;
    var ol = Et.BlockHash;
    var cl = [1518500249, 1859775393, 2400959708, 3395469782];
    function ul() {
      if (!(this instanceof ul))
        return new ul();
      ol.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = Array(80);
    }
    kt.inherits(ul, ol);
    var hl = ul;
    ul.blockSize = 512, ul.outSize = 160, ul.hmacStrength = 80, ul.padLength = 64, ul.prototype._update = function(e2, t2) {
      for (var r2 = this.W, i2 = 0; i2 < 16; i2++)
        r2[i2] = e2[t2 + i2];
      for (; i2 < r2.length; i2++)
        r2[i2] = il(r2[i2 - 3] ^ r2[i2 - 8] ^ r2[i2 - 14] ^ r2[i2 - 16], 1);
      var n2 = this.h[0], a2 = this.h[1], s2 = this.h[2], o2 = this.h[3], c2 = this.h[4];
      for (i2 = 0; i2 < r2.length; i2++) {
        var u2 = ~~(i2 / 20), h2 = al(il(n2, 5), sl(u2, a2, s2, o2), c2, r2[i2], cl[u2]);
        c2 = o2, o2 = s2, s2 = il(a2, 30), a2 = n2, n2 = h2;
      }
      this.h[0] = nl(this.h[0], n2), this.h[1] = nl(this.h[1], a2), this.h[2] = nl(this.h[2], s2), this.h[3] = nl(this.h[3], o2), this.h[4] = nl(this.h[4], c2);
    }, ul.prototype._digest = function(e2) {
      return e2 === "hex" ? kt.toHex32(this.h, "big") : kt.split32(this.h, "big");
    };
    var fl = { sha1: hl, sha224: Ht, sha256: Lt, sha384: vr, sha512: sr };
    function dl(e2, t2, r2) {
      if (!(this instanceof dl))
        return new dl(e2, t2, r2);
      this.Hash = e2, this.blockSize = e2.blockSize / 8, this.outSize = e2.outSize / 8, this.inner = null, this.outer = null, this._init(kt.toArray(t2, r2));
    }
    var ll = dl;
    dl.prototype._init = function(e2) {
      e2.length > this.blockSize && (e2 = new this.Hash().update(e2).digest()), lt(e2.length <= this.blockSize);
      for (var t2 = e2.length; t2 < this.blockSize; t2++)
        e2.push(0);
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] ^= 54;
      for (this.inner = new this.Hash().update(e2), t2 = 0; t2 < e2.length; t2++)
        e2[t2] ^= 106;
      this.outer = new this.Hash().update(e2);
    }, dl.prototype.update = function(e2, t2) {
      return this.inner.update(e2, t2), this;
    }, dl.prototype.digest = function(e2) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e2);
    };
    var pl = bt(function(e2, t2) {
      var r2 = t2;
      r2.utils = kt, r2.common = Et, r2.sha = fl, r2.ripemd = Br, r2.hmac = ll, r2.sha1 = r2.sha.sha1, r2.sha256 = r2.sha.sha256, r2.sha224 = r2.sha.sha224, r2.sha384 = r2.sha.sha384, r2.sha512 = r2.sha.sha512, r2.ripemd160 = r2.ripemd.ripemd160;
    });
    var yl = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    var bl = bt(function(e2, t2) {
      var r2, i2 = t2, n2 = Id.assert;
      function a2(e3) {
        if (e3.type === "short")
          this.curve = new rl.short(e3);
        else if (e3.type === "edwards")
          this.curve = new rl.edwards(e3);
        else {
          if (e3.type !== "mont")
            throw Error("Unknown curve type.");
          this.curve = new rl.mont(e3);
        }
        this.g = this.curve.g, this.n = this.curve.n, this.hash = e3.hash, n2(this.g.validate(), "Invalid curve"), n2(this.g.mul(this.n).isInfinity(), "Invalid curve, n*G != O");
      }
      function s2(e3, t3) {
        Object.defineProperty(i2, e3, { configurable: true, enumerable: true, get: function() {
          var r3 = new a2(t3);
          return Object.defineProperty(i2, e3, { configurable: true, enumerable: true, value: r3 }), r3;
        } });
      }
      i2.PresetCurve = a2, s2("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: pl.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), s2("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: pl.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), s2("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: pl.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), s2("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: pl.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), s2("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: pl.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), s2("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", cofactor: "8", hash: pl.sha256, gRed: false, g: ["9"] }), s2("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", cofactor: "8", hash: pl.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] }), s2("brainpoolP256r1", { type: "short", prime: null, p: "A9FB57DB A1EEA9BC 3E660A90 9D838D72 6E3BF623 D5262028 2013481D 1F6E5377", a: "7D5A0975 FC2C3057 EEF67530 417AFFE7 FB8055C1 26DC5C6C E94A4B44 F330B5D9", b: "26DC5C6C E94A4B44 F330B5D9 BBD77CBF 95841629 5CF7E1CE 6BCCDC18 FF8C07B6", n: "A9FB57DB A1EEA9BC 3E660A90 9D838D71 8C397AA3 B561A6F7 901E0E82 974856A7", hash: pl.sha256, gRed: false, g: ["8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262", "547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997"] }), s2("brainpoolP384r1", { type: "short", prime: null, p: "8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B4 12B1DA19 7FB71123ACD3A729 901D1A71 87470013 3107EC53", a: "7BC382C6 3D8C150C 3C72080A CE05AFA0 C2BEA28E 4FB22787 139165EF BA91F90F8AA5814A 503AD4EB 04A8C7DD 22CE2826", b: "04A8C7DD 22CE2826 8B39B554 16F0447C 2FB77DE1 07DCD2A6 2E880EA5 3EEB62D57CB43902 95DBC994 3AB78696 FA504C11", n: "8CB91E82 A3386D28 0F5D6F7E 50E641DF 152F7109 ED5456B3 1F166E6C AC0425A7CF3AB6AF 6B7FC310 3B883202 E9046565", hash: pl.sha384, gRed: false, g: ["1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E", "8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315"] }), s2("brainpoolP512r1", { type: "short", prime: null, p: "AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 703308717D4D9B00 9BC66842 AECDA12A E6A380E6 2881FF2F 2D82C685 28AA6056 583A48F3", a: "7830A331 8B603B89 E2327145 AC234CC5 94CBDD8D 3DF91610 A83441CA EA9863BC2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A7 2BF2C7B9 E7C1AC4D 77FC94CA", b: "3DF91610 A83441CA EA9863BC 2DED5D5A A8253AA1 0A2EF1C9 8B9AC8B5 7F1117A72BF2C7B9 E7C1AC4D 77FC94CA DC083E67 984050B7 5EBAE5DD 2809BD63 8016F723", n: "AADD9DB8 DBE9C48B 3FD4E6AE 33C9FC07 CB308DB3 B3C9D20E D6639CCA 70330870553E5C41 4CA92619 41866119 7FAC1047 1DB1D381 085DDADD B5879682 9CA90069", hash: pl.sha512, gRed: false, g: ["81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822", "7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892"] });
      try {
        r2 = yl;
      } catch (e3) {
        r2 = void 0;
      }
      s2("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: pl.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", r2] });
    });
    function ml(e2) {
      if (!(this instanceof ml))
        return new ml(e2);
      this.hash = e2.hash, this.predResist = !!e2.predResist, this.outLen = this.hash.outSize, this.minEntropy = e2.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var t2 = Rd.toArray(e2.entropy, e2.entropyEnc || "hex"), r2 = Rd.toArray(e2.nonce, e2.nonceEnc || "hex"), i2 = Rd.toArray(e2.pers, e2.persEnc || "hex");
      lt(t2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t2, r2, i2);
    }
    var gl = ml;
    ml.prototype._init = function(e2, t2, r2) {
      var i2 = e2.concat(t2).concat(r2);
      this.K = Array(this.outLen / 8), this.V = Array(this.outLen / 8);
      for (var n2 = 0; n2 < this.V.length; n2++)
        this.K[n2] = 0, this.V[n2] = 1;
      this._update(i2), this._reseed = 1, this.reseedInterval = 281474976710656;
    }, ml.prototype._hmac = function() {
      return new pl.hmac(this.hash, this.K);
    }, ml.prototype._update = function(e2) {
      var t2 = this._hmac().update(this.V).update([0]);
      e2 && (t2 = t2.update(e2)), this.K = t2.digest(), this.V = this._hmac().update(this.V).digest(), e2 && (this.K = this._hmac().update(this.V).update([1]).update(e2).digest(), this.V = this._hmac().update(this.V).digest());
    }, ml.prototype.reseed = function(e2, t2, r2, i2) {
      typeof t2 != "string" && (i2 = r2, r2 = t2, t2 = null), e2 = Rd.toArray(e2, t2), r2 = Rd.toArray(r2, i2), lt(e2.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e2.concat(r2 || [])), this._reseed = 1;
    }, ml.prototype.generate = function(e2, t2, r2, i2) {
      if (this._reseed > this.reseedInterval)
        throw Error("Reseed is required");
      typeof t2 != "string" && (i2 = r2, r2 = t2, t2 = null), r2 && (r2 = Rd.toArray(r2, i2 || "hex"), this._update(r2));
      for (var n2 = []; n2.length < e2; )
        this.V = this._hmac().update(this.V).digest(), n2 = n2.concat(this.V);
      var a2 = n2.slice(0, e2);
      return this._update(r2), this._reseed++, Rd.encode(a2, t2);
    };
    var wl = Id.assert;
    function vl(e2, t2) {
      this.ec = e2, this.priv = null, this.pub = null, t2.priv && this._importPrivate(t2.priv, t2.privEnc), t2.pub && this._importPublic(t2.pub, t2.pubEnc);
    }
    var _l = vl;
    vl.fromPublic = function(e2, t2, r2) {
      return t2 instanceof vl ? t2 : new vl(e2, { pub: t2, pubEnc: r2 });
    }, vl.fromPrivate = function(e2, t2, r2) {
      return t2 instanceof vl ? t2 : new vl(e2, { priv: t2, privEnc: r2 });
    }, vl.prototype.validate = function() {
      var e2 = this.getPublic();
      return e2.isInfinity() ? { result: false, reason: "Invalid public key" } : e2.validate() ? e2.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    }, vl.prototype.getPublic = function(e2, t2) {
      return this.pub || (this.pub = this.ec.g.mul(this.priv)), e2 ? this.pub.encode(e2, t2) : this.pub;
    }, vl.prototype.getPrivate = function(e2) {
      return e2 === "hex" ? this.priv.toString(16, 2) : this.priv;
    }, vl.prototype._importPrivate = function(e2, t2) {
      if (this.priv = new xd(e2, t2 || 16), this.ec.curve.type === "mont") {
        var r2 = this.ec.curve.one, i2 = r2.ushln(252).sub(r2).ushln(3);
        this.priv = this.priv.or(r2.ushln(254)), this.priv = this.priv.and(i2);
      } else
        this.priv = this.priv.umod(this.ec.curve.n);
    }, vl.prototype._importPublic = function(e2, t2) {
      if (e2.x || e2.y)
        return this.ec.curve.type === "mont" ? wl(e2.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || wl(e2.x && e2.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(e2.x, e2.y));
      this.pub = this.ec.curve.decodePoint(e2, t2);
    }, vl.prototype.derive = function(e2) {
      return e2.mul(this.priv).getX();
    }, vl.prototype.sign = function(e2, t2, r2) {
      return this.ec.sign(e2, this, t2, r2);
    }, vl.prototype.verify = function(e2, t2) {
      return this.ec.verify(e2, t2, this);
    }, vl.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
    var kl = Id.assert;
    function Al(e2, t2) {
      if (e2 instanceof Al)
        return e2;
      this._importDER(e2, t2) || (kl(e2.r && e2.s, "Signature without r or s"), this.r = new xd(e2.r, 16), this.s = new xd(e2.s, 16), e2.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e2.recoveryParam);
    }
    var Sl = Al;
    function El() {
      this.place = 0;
    }
    function Pl(e2, t2) {
      var r2 = e2[t2.place++];
      if (!(128 & r2))
        return r2;
      for (var i2 = 15 & r2, n2 = 0, a2 = 0, s2 = t2.place; a2 < i2; a2++, s2++)
        n2 <<= 8, n2 |= e2[s2];
      return t2.place = s2, n2;
    }
    function xl(e2) {
      for (var t2 = 0, r2 = e2.length - 1; !e2[t2] && !(128 & e2[t2 + 1]) && t2 < r2; )
        t2++;
      return t2 === 0 ? e2 : e2.slice(t2);
    }
    function Ml(e2, t2) {
      if (t2 < 128)
        e2.push(t2);
      else {
        var r2 = 1 + (Math.log(t2) / Math.LN2 >>> 3);
        for (e2.push(128 | r2); --r2; )
          e2.push(t2 >>> (r2 << 3) & 255);
        e2.push(t2);
      }
    }
    Al.prototype._importDER = function(e2, t2) {
      e2 = Id.toArray(e2, t2);
      var r2 = new El();
      if (e2[r2.place++] !== 48)
        return false;
      if (Pl(e2, r2) + r2.place !== e2.length)
        return false;
      if (e2[r2.place++] !== 2)
        return false;
      var i2 = Pl(e2, r2), n2 = e2.slice(r2.place, i2 + r2.place);
      if (r2.place += i2, e2[r2.place++] !== 2)
        return false;
      var a2 = Pl(e2, r2);
      if (e2.length !== a2 + r2.place)
        return false;
      var s2 = e2.slice(r2.place, a2 + r2.place);
      return n2[0] === 0 && 128 & n2[1] && (n2 = n2.slice(1)), s2[0] === 0 && 128 & s2[1] && (s2 = s2.slice(1)), this.r = new xd(n2), this.s = new xd(s2), this.recoveryParam = null, true;
    }, Al.prototype.toDER = function(e2) {
      var t2 = this.r.toArray(), r2 = this.s.toArray();
      for (128 & t2[0] && (t2 = [0].concat(t2)), 128 & r2[0] && (r2 = [0].concat(r2)), t2 = xl(t2), r2 = xl(r2); !(r2[0] || 128 & r2[1]); )
        r2 = r2.slice(1);
      var i2 = [2];
      Ml(i2, t2.length), (i2 = i2.concat(t2)).push(2), Ml(i2, r2.length);
      var n2 = i2.concat(r2), a2 = [48];
      return Ml(a2, n2.length), a2 = a2.concat(n2), Id.encode(a2, e2);
    };
    var Cl = Id.assert;
    function Kl(e2) {
      if (!(this instanceof Kl))
        return new Kl(e2);
      typeof e2 == "string" && (Cl(bl.hasOwnProperty(e2), "Unknown curve " + e2), e2 = bl[e2]), e2 instanceof bl.PresetCurve && (e2 = { curve: e2 }), this.curve = e2.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e2.curve.g, this.g.precompute(e2.curve.n.bitLength() + 1), this.hash = e2.hash || e2.curve.hash;
    }
    var Dl = Kl;
    Kl.prototype.keyPair = function(e2) {
      return new _l(this, e2);
    }, Kl.prototype.keyFromPrivate = function(e2, t2) {
      return _l.fromPrivate(this, e2, t2);
    }, Kl.prototype.keyFromPublic = function(e2, t2) {
      return _l.fromPublic(this, e2, t2);
    }, Kl.prototype.genKeyPair = function(e2) {
      e2 || (e2 = {});
      var t2 = new gl({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || Ud(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.n.toArray() });
      if (this.curve.type === "mont") {
        var r2 = new xd(t2.generate(32));
        return this.keyFromPrivate(r2);
      }
      for (var i2 = this.n.byteLength(), n2 = this.n.sub(new xd(2)); ; ) {
        if (!((r2 = new xd(t2.generate(i2))).cmp(n2) > 0))
          return r2.iaddn(1), this.keyFromPrivate(r2);
      }
    }, Kl.prototype._truncateToN = function(e2, t2, r2) {
      var i2 = (r2 = r2 || 8 * e2.byteLength()) - this.n.bitLength();
      return i2 > 0 && (e2 = e2.ushrn(i2)), !t2 && e2.cmp(this.n) >= 0 ? e2.sub(this.n) : e2;
    }, Kl.prototype.truncateMsg = function(e2) {
      var t2;
      return e2 instanceof Uint8Array ? (t2 = 8 * e2.byteLength, e2 = this._truncateToN(new xd(e2, 16), false, t2)) : typeof e2 == "string" ? (t2 = 4 * e2.length, e2 = this._truncateToN(new xd(e2, 16), false, t2)) : e2 = this._truncateToN(new xd(e2, 16)), e2;
    }, Kl.prototype.sign = function(e2, t2, r2, i2) {
      typeof r2 == "object" && (i2 = r2, r2 = null), i2 || (i2 = {}), t2 = this.keyFromPrivate(t2, r2), e2 = this.truncateMsg(e2);
      for (var n2 = this.n.byteLength(), a2 = t2.getPrivate().toArray("be", n2), s2 = e2.toArray("be", n2), o2 = new gl({ hash: this.hash, entropy: a2, nonce: s2, pers: i2.pers, persEnc: i2.persEnc || "utf8" }), c2 = this.n.sub(new xd(1)), u2 = 0; ; u2++) {
        var h2 = i2.k ? i2.k(u2) : new xd(o2.generate(this.n.byteLength()));
        if (!((h2 = this._truncateToN(h2, true)).cmpn(1) <= 0 || h2.cmp(c2) >= 0)) {
          var f2 = this.g.mul(h2);
          if (!f2.isInfinity()) {
            var d2 = f2.getX(), l2 = d2.umod(this.n);
            if (l2.cmpn(0) !== 0) {
              var p2 = h2.invm(this.n).mul(l2.mul(t2.getPrivate()).iadd(e2));
              if ((p2 = p2.umod(this.n)).cmpn(0) !== 0) {
                var y2 = (f2.getY().isOdd() ? 1 : 0) | (d2.cmp(l2) !== 0 ? 2 : 0);
                return i2.canonical && p2.cmp(this.nh) > 0 && (p2 = this.n.sub(p2), y2 ^= 1), new Sl({ r: l2, s: p2, recoveryParam: y2 });
              }
            }
          }
        }
      }
    }, Kl.prototype.verify = function(e2, t2, r2, i2) {
      return r2 = this.keyFromPublic(r2, i2), t2 = new Sl(t2, "hex"), this._verify(this.truncateMsg(e2), t2, r2) || this._verify(this._truncateToN(new xd(e2, 16)), t2, r2);
    }, Kl.prototype._verify = function(e2, t2, r2) {
      var i2 = t2.r, n2 = t2.s;
      if (i2.cmpn(1) < 0 || i2.cmp(this.n) >= 0)
        return false;
      if (n2.cmpn(1) < 0 || n2.cmp(this.n) >= 0)
        return false;
      var a2, s2 = n2.invm(this.n), o2 = s2.mul(e2).umod(this.n), c2 = s2.mul(i2).umod(this.n);
      return this.curve._maxwellTrick ? !(a2 = this.g.jmulAdd(o2, r2.getPublic(), c2)).isInfinity() && a2.eqXToP(i2) : !(a2 = this.g.mulAdd(o2, r2.getPublic(), c2)).isInfinity() && a2.getX().umod(this.n).cmp(i2) === 0;
    }, Kl.prototype.recoverPubKey = function(e2, t2, r2, i2) {
      Cl((3 & r2) === r2, "The recovery param is more than two bits"), t2 = new Sl(t2, i2);
      var n2 = this.n, a2 = new xd(e2), s2 = t2.r, o2 = t2.s, c2 = 1 & r2, u2 = r2 >> 1;
      if (s2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && u2)
        throw Error("Unable to find sencond key candinate");
      s2 = u2 ? this.curve.pointFromX(s2.add(this.curve.n), c2) : this.curve.pointFromX(s2, c2);
      var h2 = t2.r.invm(n2), f2 = n2.sub(a2).mul(h2).umod(n2), d2 = o2.mul(h2).umod(n2);
      return this.g.mulAdd(f2, s2, d2);
    }, Kl.prototype.getKeyRecoveryParam = function(e2, t2, r2, i2) {
      if ((t2 = new Sl(t2, i2)).recoveryParam !== null)
        return t2.recoveryParam;
      for (var n2 = 0; n2 < 4; n2++) {
        var a2;
        try {
          a2 = this.recoverPubKey(e2, t2, n2);
        } catch (e3) {
          continue;
        }
        if (a2.eq(r2))
          return n2;
      }
      throw Error("Unable to find valid recovery factor");
    };
    var Rl = Id.assert;
    var Il = Id.parseBytes;
    var Ul = Id.cachedProperty;
    function Bl(e2, t2) {
      if (this.eddsa = e2, t2.hasOwnProperty("secret") && (this._secret = Il(t2.secret)), e2.isPoint(t2.pub))
        this._pub = t2.pub;
      else if (this._pubBytes = Il(t2.pub), this._pubBytes && this._pubBytes.length === 33 && this._pubBytes[0] === 64 && (this._pubBytes = this._pubBytes.slice(1, 33)), this._pubBytes && this._pubBytes.length !== 32)
        throw Error("Unknown point compression format");
    }
    Bl.fromPublic = function(e2, t2) {
      return t2 instanceof Bl ? t2 : new Bl(e2, { pub: t2 });
    }, Bl.fromSecret = function(e2, t2) {
      return t2 instanceof Bl ? t2 : new Bl(e2, { secret: t2 });
    }, Bl.prototype.secret = function() {
      return this._secret;
    }, Ul(Bl, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    }), Ul(Bl, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    }), Ul(Bl, "privBytes", function() {
      var e2 = this.eddsa, t2 = this.hash(), r2 = e2.encodingLength - 1, i2 = t2.slice(0, e2.encodingLength);
      return i2[0] &= 248, i2[r2] &= 127, i2[r2] |= 64, i2;
    }), Ul(Bl, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    }), Ul(Bl, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    }), Ul(Bl, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    }), Bl.prototype.sign = function(e2) {
      return Rl(this._secret, "KeyPair can only verify"), this.eddsa.sign(e2, this);
    }, Bl.prototype.verify = function(e2, t2) {
      return this.eddsa.verify(e2, t2, this);
    }, Bl.prototype.getSecret = function(e2) {
      return Rl(this._secret, "KeyPair is public only"), Id.encode(this.secret(), e2);
    }, Bl.prototype.getPublic = function(e2, t2) {
      return Id.encode((t2 ? [64] : []).concat(this.pubBytes()), e2);
    };
    var Tl = Bl;
    var zl = Id.assert;
    var ql = Id.cachedProperty;
    var Ol = Id.parseBytes;
    function Fl(e2, t2) {
      this.eddsa = e2, typeof t2 != "object" && (t2 = Ol(t2)), Array.isArray(t2) && (t2 = { R: t2.slice(0, e2.encodingLength), S: t2.slice(e2.encodingLength) }), zl(t2.R && t2.S, "Signature without R or S"), e2.isPoint(t2.R) && (this._R = t2.R), t2.S instanceof xd && (this._S = t2.S), this._Rencoded = Array.isArray(t2.R) ? t2.R : t2.Rencoded, this._Sencoded = Array.isArray(t2.S) ? t2.S : t2.Sencoded;
    }
    ql(Fl, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    }), ql(Fl, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    }), ql(Fl, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    }), ql(Fl, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    }), Fl.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    }, Fl.prototype.toHex = function() {
      return Id.encode(this.toBytes(), "hex").toUpperCase();
    };
    var Nl = Fl;
    var jl = Id.assert;
    var Ll = Id.parseBytes;
    function Wl(e2) {
      if (jl(e2 === "ed25519", "only tested with ed25519 so far"), !(this instanceof Wl))
        return new Wl(e2);
      e2 = bl[e2].curve;
      this.curve = e2, this.g = e2.g, this.g.precompute(e2.n.bitLength() + 1), this.pointClass = e2.point().constructor, this.encodingLength = Math.ceil(e2.n.bitLength() / 8), this.hash = pl.sha512;
    }
    var Hl = Wl;
    Wl.prototype.sign = function(e2, t2) {
      e2 = Ll(e2);
      var r2 = this.keyFromSecret(t2), i2 = this.hashInt(r2.messagePrefix(), e2), n2 = this.g.mul(i2), a2 = this.encodePoint(n2), s2 = this.hashInt(a2, r2.pubBytes(), e2).mul(r2.priv()), o2 = i2.add(s2).umod(this.curve.n);
      return this.makeSignature({ R: n2, S: o2, Rencoded: a2 });
    }, Wl.prototype.verify = function(e2, t2, r2) {
      e2 = Ll(e2), t2 = this.makeSignature(t2);
      var i2 = this.keyFromPublic(r2), n2 = this.hashInt(t2.Rencoded(), i2.pubBytes(), e2), a2 = this.g.mul(t2.S());
      return t2.R().add(i2.pub().mul(n2)).eq(a2);
    }, Wl.prototype.hashInt = function() {
      for (var e2 = this.hash(), t2 = 0; t2 < arguments.length; t2++)
        e2.update(arguments[t2]);
      return Id.intFromLE(e2.digest()).umod(this.curve.n);
    }, Wl.prototype.keyPair = function(e2) {
      return new Tl(this, e2);
    }, Wl.prototype.keyFromPublic = function(e2) {
      return Tl.fromPublic(this, e2);
    }, Wl.prototype.keyFromSecret = function(e2) {
      return Tl.fromSecret(this, e2);
    }, Wl.prototype.genKeyPair = function(e2) {
      e2 || (e2 = {});
      var t2 = new gl({ hash: this.hash, pers: e2.pers, persEnc: e2.persEnc || "utf8", entropy: e2.entropy || Ud(this.hash.hmacStrength), entropyEnc: e2.entropy && e2.entropyEnc || "utf8", nonce: this.curve.n.toArray() });
      return this.keyFromSecret(t2.generate(32));
    }, Wl.prototype.makeSignature = function(e2) {
      return e2 instanceof Nl ? e2 : new Nl(this, e2);
    }, Wl.prototype.encodePoint = function(e2) {
      var t2 = e2.getY().toArray("le", this.encodingLength);
      return t2[this.encodingLength - 1] |= e2.getX().isOdd() ? 128 : 0, t2;
    }, Wl.prototype.decodePoint = function(e2) {
      var t2 = (e2 = Id.parseBytes(e2)).length - 1, r2 = e2.slice(0, t2).concat(-129 & e2[t2]), i2 = (128 & e2[t2]) != 0, n2 = Id.intFromLE(r2);
      return this.curve.pointFromY(n2, i2);
    }, Wl.prototype.encodeInt = function(e2) {
      return e2.toArray("le", this.encodingLength);
    }, Wl.prototype.decodeInt = function(e2) {
      return Id.intFromLE(e2);
    }, Wl.prototype.isPoint = function(e2) {
      return e2 instanceof this.pointClass;
    };
    var Gl = bt(function(e2, t2) {
      var r2 = t2;
      r2.utils = Id, r2.rand = Ud, r2.curve = rl, r2.curves = bl, r2.ec = Dl, r2.eddsa = Hl;
    });
    var Vl = /* @__PURE__ */ Object.freeze({ __proto__: null, default: Gl, __moduleExports: Gl });
    exports2.AEADEncryptedDataPacket = vo, exports2.CleartextMessage = pc, exports2.CompressedDataPacket = co, exports2.LiteralDataPacket = Hs, exports2.MarkerPacket = class {
      static get tag() {
        return me.packet.marker;
      }
      read(e2) {
        return e2[0] === 80 && e2[1] === 71 && e2[2] === 80;
      }
      write() {
        return new Uint8Array([80, 71, 80]);
      }
    }, exports2.Message = hc, exports2.OnePassSignaturePacket = no, exports2.PacketList = so, exports2.PrivateKey = nc, exports2.PublicKey = ic, exports2.PublicKeyEncryptedSessionKeyPacket = _o, exports2.PublicKeyPacket = So, exports2.PublicSubkeyPacket = xo, exports2.SecretKeyPacket = Co, exports2.SecretSubkeyPacket = Io, exports2.Signature = Bo, exports2.SignaturePacket = ro, exports2.Subkey = Jo, exports2.SymEncryptedIntegrityProtectedDataPacket = go, exports2.SymEncryptedSessionKeyPacket = Ao, exports2.SymmetricallyEncryptedDataPacket = Po, exports2.TrustPacket = class {
      static get tag() {
        return me.packet.trust;
      }
      read() {
        throw new Js("Trust packets are not supported");
      }
      write() {
        throw new Js("Trust packets are not supported");
      }
    }, exports2.UserAttributePacket = Mo, exports2.UserIDPacket = Ro, exports2.armor = xe, exports2.config = ge, exports2.createCleartextMessage = async function(_a2) {
      var _b = _a2, { text: e2 } = _b, t2 = __objRest(_b, ["text"]);
      if (!e2)
        throw Error("createCleartextMessage: must pass options object containing `text`");
      if (!ce.isString(e2))
        throw Error("createCleartextMessage: options.text must be a string");
      const r2 = Object.keys(t2);
      if (r2.length > 0)
        throw Error("Unknown option: " + r2.join(", "));
      return new pc(e2);
    }, exports2.createMessage = async function(_c2) {
      var _d2 = _c2, { text: e2, binary: t2, filename: r2, date: i2 = new Date(), format: n2 = e2 !== void 0 ? "utf8" : "binary" } = _d2, a2 = __objRest(_d2, ["text", "binary", "filename", "date", "format"]);
      let s2 = e2 !== void 0 ? e2 : t2;
      if (s2 === void 0)
        throw Error("createMessage: must pass options object containing `text` or `binary`");
      if (e2 && !ce.isString(e2) && !ce.isStream(e2))
        throw Error("createMessage: options.text must be a string or stream");
      if (t2 && !ce.isUint8Array(t2) && !ce.isStream(t2))
        throw Error("createMessage: options.binary must be a Uint8Array or stream");
      const o2 = Object.keys(a2);
      if (o2.length > 0)
        throw Error("Unknown option: " + o2.join(", "));
      const c2 = ce.isStream(s2);
      c2 && (await F(), s2 = j(s2));
      const u2 = new Hs(i2);
      e2 !== void 0 ? u2.setText(s2, me.write(me.literal, n2)) : u2.setBytes(s2, me.write(me.literal, n2)), r2 !== void 0 && u2.setFilename(r2);
      const h2 = new so();
      h2.push(u2);
      const f2 = new hc(h2);
      return f2.fromStream = c2, f2;
    }, exports2.decrypt = async function(_e2) {
      var _f2 = _e2, { message: e2, decryptionKeys: t2, passwords: r2, sessionKeys: i2, verificationKeys: n2, expectSigned: a2 = false, format: s2 = "utf8", signature: o2 = null, date: c2 = new Date(), config: u2 } = _f2, h2 = __objRest(_f2, ["message", "decryptionKeys", "passwords", "sessionKeys", "verificationKeys", "expectSigned", "format", "signature", "date", "config"]);
      if (wc(u2 = __spreadValues(__spreadValues({}, ge), u2)), yc(e2), n2 = vc(n2), t2 = vc(t2), r2 = vc(r2), i2 = vc(i2), h2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.decrypt, pass `decryptionKeys` instead");
      if (h2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.decrypt, pass `verificationKeys` instead");
      const f2 = Object.keys(h2);
      if (f2.length > 0)
        throw Error("Unknown option: " + f2.join(", "));
      try {
        const h3 = await e2.decrypt(t2, r2, i2, c2, u2);
        n2 || (n2 = []);
        const f3 = {};
        if (f3.signatures = o2 ? await h3.verifyDetached(o2, n2, c2, u2) : await h3.verify(n2, c2, u2), f3.data = s2 === "binary" ? h3.getLiteralData() : h3.getText(), f3.filename = h3.getFilename(), kc(f3, e2), a2) {
          if (n2.length === 0)
            throw Error("Verification keys are required to verify message signatures");
          if (f3.signatures.length === 0)
            throw Error("Message is not signed");
          f3.data = W([f3.data, ae(async () => {
            await ce.anyPromise(f3.signatures.map((e3) => e3.verified));
          })]);
        }
        return f3.data = await _c(f3.data, e2.fromStream, s2), f3;
      } catch (e3) {
        throw ce.wrapError("Error decrypting message", e3);
      }
    }, exports2.decryptKey = async function(_g) {
      var _h2 = _g, { privateKey: e2, passphrase: t2, config: r2 } = _h2, i2 = __objRest(_h2, ["privateKey", "passphrase", "config"]);
      wc(r2 = __spreadValues(__spreadValues({}, ge), r2));
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      if (!e2.isPrivate())
        throw Error("Cannot decrypt a public key");
      const a2 = e2.clone(true), s2 = ce.isArray(t2) ? t2 : [t2];
      try {
        return await Promise.all(a2.getKeys().map((e3) => ce.anyPromise(s2.map((t3) => e3.keyPacket.decrypt(t3))))), await a2.validate(r2), a2;
      } catch (e3) {
        throw a2.clearPrivateParams(), ce.wrapError("Error decrypting private key", e3);
      }
    }, exports2.decryptSessionKeys = async function(_i2) {
      var _j = _i2, { message: e2, decryptionKeys: t2, passwords: r2, date: i2 = new Date(), config: n2 } = _j, a2 = __objRest(_j, ["message", "decryptionKeys", "passwords", "date", "config"]);
      if (wc(n2 = __spreadValues(__spreadValues({}, ge), n2)), yc(e2), t2 = vc(t2), r2 = vc(r2), a2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.decryptSessionKeys, pass `decryptionKeys` instead");
      const s2 = Object.keys(a2);
      if (s2.length > 0)
        throw Error("Unknown option: " + s2.join(", "));
      try {
        return await e2.decryptSessionKeys(t2, r2, i2, n2);
      } catch (e3) {
        throw ce.wrapError("Error decrypting session keys", e3);
      }
    }, exports2.encrypt = async function(_k) {
      var _l2 = _k, { message: e2, encryptionKeys: t2, signingKeys: r2, passwords: i2, sessionKey: n2, format: a2 = "armored", signature: s2 = null, wildcard: o2 = false, signingKeyIDs: c2 = [], encryptionKeyIDs: u2 = [], date: h2 = new Date(), signingUserIDs: f2 = [], encryptionUserIDs: d2 = [], config: l2 } = _l2, p2 = __objRest(_l2, ["message", "encryptionKeys", "signingKeys", "passwords", "sessionKey", "format", "signature", "wildcard", "signingKeyIDs", "encryptionKeyIDs", "date", "signingUserIDs", "encryptionUserIDs", "config"]);
      if (wc(l2 = __spreadValues(__spreadValues({}, ge), l2)), yc(e2), mc(a2), t2 = vc(t2), r2 = vc(r2), i2 = vc(i2), c2 = vc(c2), u2 = vc(u2), f2 = vc(f2), d2 = vc(d2), p2.detached)
        throw Error("The `detached` option has been removed from openpgp.encrypt, separately call openpgp.sign instead. Don't forget to remove the `privateKeys` option as well.");
      if (p2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.encrypt, pass `encryptionKeys` instead");
      if (p2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.encrypt, pass `signingKeys` instead");
      if (p2.armor !== void 0)
        throw Error("The `armor` option has been removed from openpgp.encrypt, pass `format` instead.");
      const y2 = Object.keys(p2);
      if (y2.length > 0)
        throw Error("Unknown option: " + y2.join(", "));
      r2 || (r2 = []);
      const b2 = e2.fromStream;
      try {
        if ((r2.length || s2) && (e2 = await e2.sign(r2, s2, c2, h2, f2, l2)), e2 = e2.compress(await jo("compression", t2, h2, d2, l2), l2), e2 = await e2.encrypt(t2, i2, n2, o2, u2, h2, d2, l2), a2 === "object")
          return e2;
        const p3 = a2 === "armored";
        return _c(p3 ? e2.armor(l2) : e2.write(), b2, p3 ? "utf8" : "binary");
      } catch (e3) {
        throw ce.wrapError("Error encrypting message", e3);
      }
    }, exports2.encryptKey = async function(_m) {
      var _n2 = _m, { privateKey: e2, passphrase: t2, config: r2 } = _n2, i2 = __objRest(_n2, ["privateKey", "passphrase", "config"]);
      wc(r2 = __spreadValues(__spreadValues({}, ge), r2));
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      if (!e2.isPrivate())
        throw Error("Cannot encrypt a public key");
      const a2 = e2.clone(true), s2 = a2.getKeys(), o2 = ce.isArray(t2) ? t2 : Array(s2.length).fill(t2);
      if (o2.length !== s2.length)
        throw Error("Invalid number of passphrases given for key encryption");
      try {
        return await Promise.all(s2.map(async (e3, t3) => {
          const { keyPacket: i3 } = e3;
          await i3.encrypt(o2[t3], r2), i3.clearPrivateParams();
        })), a2;
      } catch (e3) {
        throw a2.clearPrivateParams(), ce.wrapError("Error encrypting private key", e3);
      }
    }, exports2.encryptSessionKey = async function(_o2) {
      var _p = _o2, { data: e2, algorithm: t2, aeadAlgorithm: r2, encryptionKeys: i2, passwords: n2, format: a2 = "armored", wildcard: s2 = false, encryptionKeyIDs: o2 = [], date: c2 = new Date(), encryptionUserIDs: u2 = [], config: h2 } = _p, f2 = __objRest(_p, ["data", "algorithm", "aeadAlgorithm", "encryptionKeys", "passwords", "format", "wildcard", "encryptionKeyIDs", "date", "encryptionUserIDs", "config"]);
      if (wc(h2 = __spreadValues(__spreadValues({}, ge), h2)), function(e3, t3) {
        if (!ce.isUint8Array(e3))
          throw Error("Parameter [" + (t3 || "data") + "] must be of type Uint8Array");
      }(e2), function(e3, t3) {
        if (!ce.isString(e3))
          throw Error("Parameter [" + (t3 || "data") + "] must be of type String");
      }(t2, "algorithm"), mc(a2), i2 = vc(i2), n2 = vc(n2), o2 = vc(o2), u2 = vc(u2), f2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.encryptSessionKey, pass `encryptionKeys` instead");
      const d2 = Object.keys(f2);
      if (d2.length > 0)
        throw Error("Unknown option: " + d2.join(", "));
      try {
        return Ac(await hc.encryptSessionKey(e2, t2, r2, i2, n2, s2, o2, c2, u2, h2), a2, h2);
      } catch (e3) {
        throw ce.wrapError("Error encrypting session key", e3);
      }
    }, exports2.enums = me, exports2.generateKey = async function(_q) {
      var _r2 = _q, { userIDs: e2 = [], passphrase: t2 = "", type: r2 = "ecc", rsaBits: i2 = 4096, curve: n2 = "curve25519", keyExpirationTime: a2 = 0, date: s2 = new Date(), subkeys: o2 = [{}], format: c2 = "armored", config: u2 } = _r2, h2 = __objRest(_r2, ["userIDs", "passphrase", "type", "rsaBits", "curve", "keyExpirationTime", "date", "subkeys", "format", "config"]);
      wc(u2 = __spreadValues(__spreadValues({}, ge), u2)), e2 = vc(e2);
      const f2 = Object.keys(h2);
      if (f2.length > 0)
        throw Error("Unknown option: " + f2.join(", "));
      if (e2.length === 0)
        throw Error("UserIDs are required for key generation");
      if (r2 === "rsa" && i2 < u2.minRSABits)
        throw Error(`rsaBits should be at least ${u2.minRSABits}, got: ${i2}`);
      const d2 = { userIDs: e2, passphrase: t2, type: r2, rsaBits: i2, curve: n2, keyExpirationTime: a2, date: s2, subkeys: o2 };
      try {
        const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
          e4.sign = true, (e4 = Vo(e4)).subkeys = e4.subkeys.map((t5, r4) => Vo(e4.subkeys[r4], e4));
          let r3 = [zo(e4, t4)];
          r3 = r3.concat(e4.subkeys.map((e5) => To(e5, t4)));
          const i3 = await Promise.all(r3), n3 = await sc(i3[0], i3.slice(1), e4, t4), a3 = await n3.getRevocationCertificate(e4.date, t4);
          return n3.revocationSignatures = [], { key: n3, revocationCertificate: a3 };
        }(d2, u2);
        return e3.getKeys().forEach(({ keyPacket: e4 }) => Xo(e4, u2)), { privateKey: Ac(e3, c2, u2), publicKey: Ac(e3.toPublic(), c2, u2), revocationCertificate: t3 };
      } catch (e3) {
        throw ce.wrapError("Error generating keypair", e3);
      }
    }, exports2.generateSessionKey = async function(_s2) {
      var _t2 = _s2, { encryptionKeys: e2, date: t2 = new Date(), encryptionUserIDs: r2 = [], config: i2 } = _t2, n2 = __objRest(_t2, ["encryptionKeys", "date", "encryptionUserIDs", "config"]);
      if (wc(i2 = __spreadValues(__spreadValues({}, ge), i2)), e2 = vc(e2), r2 = vc(r2), n2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.generateSessionKey, pass `encryptionKeys` instead");
      const a2 = Object.keys(n2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      try {
        return await hc.generateSessionKey(e2, t2, r2, i2);
      } catch (e3) {
        throw ce.wrapError("Error generating session key", e3);
      }
    }, exports2.readCleartextMessage = async function(_u2) {
      var _v = _u2, { cleartextMessage: e2, config: t2 } = _v, r2 = __objRest(_v, ["cleartextMessage", "config"]);
      if (t2 = __spreadValues(__spreadValues({}, ge), t2), !e2)
        throw Error("readCleartextMessage: must pass options object containing `cleartextMessage`");
      if (!ce.isString(e2))
        throw Error("readCleartextMessage: options.cleartextMessage must be a string");
      const i2 = Object.keys(r2);
      if (i2.length > 0)
        throw Error("Unknown option: " + i2.join(", "));
      const n2 = await Pe(e2);
      if (n2.type !== me.armor.signed)
        throw Error("No cleartext signed message.");
      const a2 = await so.fromBinary(n2.data, lc, t2);
      !function(e3, t3) {
        const r3 = function(e4) {
          const r4 = (e5) => (t4) => e5.hashAlgorithm === t4;
          for (let i4 = 0; i4 < t3.length; i4++)
            if (t3[i4].constructor.tag === me.packet.signature && !e4.some(r4(t3[i4])))
              return false;
          return true;
        };
        let i3 = null, n3 = [];
        if (e3.forEach(function(e4) {
          if (i3 = e4.match(/Hash: (.+)/), !i3)
            throw Error('Only "Hash" header allowed in cleartext signed message');
          i3 = i3[1].replace(/\s/g, ""), i3 = i3.split(","), i3 = i3.map(function(e5) {
            e5 = e5.toLowerCase();
            try {
              return me.write(me.hash, e5);
            } catch (t4) {
              throw Error("Unknown hash algorithm in armor header: " + e5);
            }
          }), n3 = n3.concat(i3);
        }), !n3.length && !r3([me.hash.md5]))
          throw Error('If no "Hash" header in cleartext signed message, then only MD5 signatures allowed');
        if (n3.length && !r3(n3))
          throw Error("Hash algorithm mismatch in armor header and signature");
      }(n2.headers, a2);
      const s2 = new Bo(a2);
      return new pc(n2.text, s2);
    }, exports2.readKey = async function(_w) {
      var _x = _w, { armoredKey: e2, binaryKey: t2, config: r2 } = _x, i2 = __objRest(_x, ["armoredKey", "binaryKey", "config"]);
      if (r2 = __spreadValues(__spreadValues({}, ge), r2), !e2 && !t2)
        throw Error("readKey: must pass options object containing `armoredKey` or `binaryKey`");
      if (e2 && !ce.isString(e2))
        throw Error("readKey: options.armoredKey must be a string");
      if (t2 && !ce.isUint8Array(t2))
        throw Error("readKey: options.binaryKey must be a Uint8Array");
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      let a2;
      if (e2) {
        const { type: t3, data: i3 } = await Pe(e2, r2);
        if (t3 !== me.armor.publicKey && t3 !== me.armor.privateKey)
          throw Error("Armored text not of type key");
        a2 = i3;
      } else
        a2 = t2;
      return rc(await so.fromBinary(a2, ac, r2));
    }, exports2.readKeys = async function(_y) {
      var _z = _y, { armoredKeys: e2, binaryKeys: t2, config: r2 } = _z, i2 = __objRest(_z, ["armoredKeys", "binaryKeys", "config"]);
      r2 = __spreadValues(__spreadValues({}, ge), r2);
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
      if (e2 && !ce.isString(e2))
        throw Error("readKeys: options.armoredKeys must be a string");
      if (t2 && !ce.isUint8Array(t2))
        throw Error("readKeys: options.binaryKeys must be a Uint8Array");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      if (e2) {
        const { type: t3, data: i3 } = await Pe(e2, r2);
        if (t3 !== me.armor.publicKey && t3 !== me.armor.privateKey)
          throw Error("Armored text not of type key");
        n2 = i3;
      }
      const s2 = [], o2 = await so.fromBinary(n2, ac, r2), c2 = o2.indexOfTag(me.packet.publicKey, me.packet.secretKey);
      if (c2.length === 0)
        throw Error("No key packet found");
      for (let e3 = 0; e3 < c2.length; e3++) {
        const t3 = rc(o2.slice(c2[e3], c2[e3 + 1]));
        s2.push(t3);
      }
      return s2;
    }, exports2.readMessage = async function(_A) {
      var _B = _A, { armoredMessage: e2, binaryMessage: t2, config: r2 } = _B, i2 = __objRest(_B, ["armoredMessage", "binaryMessage", "config"]);
      r2 = __spreadValues(__spreadValues({}, ge), r2);
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readMessage: must pass options object containing `armoredMessage` or `binaryMessage`");
      if (e2 && !ce.isString(e2) && !ce.isStream(e2))
        throw Error("readMessage: options.armoredMessage must be a string or stream");
      if (t2 && !ce.isUint8Array(t2) && !ce.isStream(t2))
        throw Error("readMessage: options.binaryMessage must be a Uint8Array or stream");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      const s2 = ce.isStream(n2);
      if (s2 && (await F(), n2 = j(n2)), e2) {
        const { type: e3, data: t3 } = await Pe(n2, r2);
        if (e3 !== me.armor.message)
          throw Error("Armored text not of type message");
        n2 = t3;
      }
      const o2 = await so.fromBinary(n2, oc, r2), c2 = new hc(o2);
      return c2.fromStream = s2, c2;
    }, exports2.readPrivateKey = async function(_C) {
      var _D = _C, { armoredKey: e2, binaryKey: t2, config: r2 } = _D, i2 = __objRest(_D, ["armoredKey", "binaryKey", "config"]);
      if (r2 = __spreadValues(__spreadValues({}, ge), r2), !e2 && !t2)
        throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");
      if (e2 && !ce.isString(e2))
        throw Error("readPrivateKey: options.armoredKey must be a string");
      if (t2 && !ce.isUint8Array(t2))
        throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");
      const n2 = Object.keys(i2);
      if (n2.length > 0)
        throw Error("Unknown option: " + n2.join(", "));
      let a2;
      if (e2) {
        const { type: t3, data: i3 } = await Pe(e2, r2);
        if (t3 !== me.armor.privateKey)
          throw Error("Armored text not of type private key");
        a2 = i3;
      } else
        a2 = t2;
      const s2 = await so.fromBinary(a2, ac, r2);
      return new nc(s2);
    }, exports2.readPrivateKeys = async function({ armoredKeys: e2, binaryKeys: t2, config: r2 }) {
      r2 = __spreadValues(__spreadValues({}, ge), r2);
      let i2 = e2 || t2;
      if (!i2)
        throw Error("readPrivateKeys: must pass options object containing `armoredKeys` or `binaryKeys`");
      if (e2 && !ce.isString(e2))
        throw Error("readPrivateKeys: options.armoredKeys must be a string");
      if (t2 && !ce.isUint8Array(t2))
        throw Error("readPrivateKeys: options.binaryKeys must be a Uint8Array");
      if (e2) {
        const { type: t3, data: n3 } = await Pe(e2, r2);
        if (t3 !== me.armor.privateKey)
          throw Error("Armored text not of type private key");
        i2 = n3;
      }
      const n2 = [], a2 = await so.fromBinary(i2, ac, r2), s2 = a2.indexOfTag(me.packet.secretKey);
      if (s2.length === 0)
        throw Error("No secret key packet found");
      for (let e3 = 0; e3 < s2.length; e3++) {
        const t3 = a2.slice(s2[e3], s2[e3 + 1]), r3 = new nc(t3);
        n2.push(r3);
      }
      return n2;
    }, exports2.readSignature = async function(_E) {
      var _F = _E, { armoredSignature: e2, binarySignature: t2, config: r2 } = _F, i2 = __objRest(_F, ["armoredSignature", "binarySignature", "config"]);
      r2 = __spreadValues(__spreadValues({}, ge), r2);
      let n2 = e2 || t2;
      if (!n2)
        throw Error("readSignature: must pass options object containing `armoredSignature` or `binarySignature`");
      if (e2 && !ce.isString(e2))
        throw Error("readSignature: options.armoredSignature must be a string");
      if (t2 && !ce.isUint8Array(t2))
        throw Error("readSignature: options.binarySignature must be a Uint8Array");
      const a2 = Object.keys(i2);
      if (a2.length > 0)
        throw Error("Unknown option: " + a2.join(", "));
      if (e2) {
        const { type: e3, data: t3 } = await Pe(n2, r2);
        if (e3 !== me.armor.signature)
          throw Error("Armored text not of type signature");
        n2 = t3;
      }
      const s2 = await so.fromBinary(n2, Uo, r2);
      return new Bo(s2);
    }, exports2.reformatKey = async function(_G) {
      var _H = _G, { privateKey: e2, userIDs: t2 = [], passphrase: r2 = "", keyExpirationTime: i2 = 0, date: n2, format: a2 = "armored", config: s2 } = _H, o2 = __objRest(_H, ["privateKey", "userIDs", "passphrase", "keyExpirationTime", "date", "format", "config"]);
      wc(s2 = __spreadValues(__spreadValues({}, ge), s2)), t2 = vc(t2);
      const c2 = Object.keys(o2);
      if (c2.length > 0)
        throw Error("Unknown option: " + c2.join(", "));
      if (t2.length === 0)
        throw Error("UserIDs are required for key reformat");
      const u2 = { privateKey: e2, userIDs: t2, passphrase: r2, keyExpirationTime: i2, date: n2 };
      try {
        const { key: e3, revocationCertificate: t3 } = await async function(e4, t4) {
          e4 = o3(e4);
          const { privateKey: r3 } = e4;
          if (!r3.isPrivate())
            throw Error("Cannot reformat a public key");
          if (r3.keyPacket.isDummy())
            throw Error("Cannot reformat a gnu-dummy primary key");
          if (!r3.getKeys().every(({ keyPacket: e5 }) => e5.isDecrypted()))
            throw Error("Key is not decrypted");
          const i3 = r3.keyPacket;
          e4.subkeys || (e4.subkeys = await Promise.all(r3.subkeys.map(async (e5) => {
            const r4 = e5.keyPacket, n4 = { key: i3, bind: r4 }, a4 = await qo(e5.bindingSignatures, i3, me.signature.subkeyBinding, n4, null, t4).catch(() => ({}));
            return { sign: a4.keyFlags && a4.keyFlags[0] & me.keyFlags.signData };
          })));
          const n3 = r3.subkeys.map((e5) => e5.keyPacket);
          if (e4.subkeys.length !== n3.length)
            throw Error("Number of subkey options does not match number of subkeys");
          e4.subkeys = e4.subkeys.map((t5) => o3(t5, e4));
          const a3 = await sc(i3, n3, e4, t4), s3 = await a3.getRevocationCertificate(e4.date, t4);
          return a3.revocationSignatures = [], { key: a3, revocationCertificate: s3 };
          function o3(e5, t5 = {}) {
            return e5.keyExpirationTime = e5.keyExpirationTime || t5.keyExpirationTime, e5.passphrase = ce.isString(e5.passphrase) ? e5.passphrase : t5.passphrase, e5.date = e5.date || t5.date, e5;
          }
        }(u2, s2);
        return { privateKey: Ac(e3, a2, s2), publicKey: Ac(e3.toPublic(), a2, s2), revocationCertificate: t3 };
      } catch (e3) {
        throw ce.wrapError("Error reformatting keypair", e3);
      }
    }, exports2.revokeKey = async function(_I) {
      var _J = _I, { key: e2, revocationCertificate: t2, reasonForRevocation: r2, date: i2 = new Date(), format: n2 = "armored", config: a2 } = _J, s2 = __objRest(_J, ["key", "revocationCertificate", "reasonForRevocation", "date", "format", "config"]);
      wc(a2 = __spreadValues(__spreadValues({}, ge), a2));
      const o2 = Object.keys(s2);
      if (o2.length > 0)
        throw Error("Unknown option: " + o2.join(", "));
      try {
        const s3 = t2 ? await e2.applyRevocationCertificate(t2, i2, a2) : await e2.revoke(r2, i2, a2);
        return s3.isPrivate() ? { privateKey: Ac(s3, n2, a2), publicKey: Ac(s3.toPublic(), n2, a2) } : { privateKey: null, publicKey: Ac(s3, n2, a2) };
      } catch (e3) {
        throw ce.wrapError("Error revoking key", e3);
      }
    }, exports2.sign = async function(_K) {
      var _L = _K, { message: e2, signingKeys: t2, format: r2 = "armored", detached: i2 = false, signingKeyIDs: n2 = [], date: a2 = new Date(), signingUserIDs: s2 = [], config: o2 } = _L, c2 = __objRest(_L, ["message", "signingKeys", "format", "detached", "signingKeyIDs", "date", "signingUserIDs", "config"]);
      if (wc(o2 = __spreadValues(__spreadValues({}, ge), o2)), bc(e2), mc(r2), t2 = vc(t2), n2 = vc(n2), s2 = vc(s2), c2.privateKeys)
        throw Error("The `privateKeys` option has been removed from openpgp.sign, pass `signingKeys` instead");
      if (c2.armor !== void 0)
        throw Error("The `armor` option has been removed from openpgp.sign, pass `format` instead.");
      const u2 = Object.keys(c2);
      if (u2.length > 0)
        throw Error("Unknown option: " + u2.join(", "));
      if (e2 instanceof pc && r2 === "binary")
        throw Error("Cannot return signed cleartext message in binary format");
      if (e2 instanceof pc && i2)
        throw Error("Cannot detach-sign a cleartext message");
      if (!t2 || t2.length === 0)
        throw Error("No signing keys provided");
      try {
        let c3;
        if (c3 = i2 ? await e2.signDetached(t2, void 0, n2, a2, s2, o2) : await e2.sign(t2, void 0, n2, a2, s2, o2), r2 === "object")
          return c3;
        const u3 = r2 === "armored";
        return c3 = u3 ? c3.armor(o2) : c3.write(), i2 && (c3 = X(e2.packets.write(), async (e3, t3) => {
          await Promise.all([V(c3, t3), ie(e3).catch(() => {
          })]);
        })), _c(c3, e2.fromStream, u3 ? "utf8" : "binary");
      } catch (e3) {
        throw ce.wrapError("Error signing message", e3);
      }
    }, exports2.unarmor = Pe, exports2.verify = async function(_M) {
      var _N = _M, { message: e2, verificationKeys: t2, expectSigned: r2 = false, format: i2 = "utf8", signature: n2 = null, date: a2 = new Date(), config: s2 } = _N, o2 = __objRest(_N, ["message", "verificationKeys", "expectSigned", "format", "signature", "date", "config"]);
      if (wc(s2 = __spreadValues(__spreadValues({}, ge), s2)), bc(e2), t2 = vc(t2), o2.publicKeys)
        throw Error("The `publicKeys` option has been removed from openpgp.verify, pass `verificationKeys` instead");
      const c2 = Object.keys(o2);
      if (c2.length > 0)
        throw Error("Unknown option: " + c2.join(", "));
      if (e2 instanceof pc && i2 === "binary")
        throw Error("Can't return cleartext message data as binary");
      if (e2 instanceof pc && n2)
        throw Error("Can't verify detached cleartext signature");
      try {
        const o3 = {};
        if (o3.signatures = n2 ? await e2.verifyDetached(n2, t2, a2, s2) : await e2.verify(t2, a2, s2), o3.data = i2 === "binary" ? e2.getLiteralData() : e2.getText(), e2.fromStream && kc(o3, e2), r2) {
          if (o3.signatures.length === 0)
            throw Error("Message is not signed");
          o3.data = W([o3.data, ae(async () => {
            await ce.anyPromise(o3.signatures.map((e3) => e3.verified));
          })]);
        }
        return o3.data = await _c(o3.data, e2.fromStream, i2), o3;
      } catch (e3) {
        throw ce.wrapError("Error verifying signed message", e3);
      }
    };
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/constants.js"(exports2, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH,
      MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/debug.js"(exports2, module2) {
    var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug2;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/re.js"(exports2, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
    var debug2 = require_debug();
    exports2 = module2.exports = {};
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.t = {};
    var R = 0;
    var createToken = (name, value, isGlobal) => {
      const index = R++;
      debug2(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports2.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports2.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports2.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/parse-options.js"(exports2, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/internal/identifiers.js"(exports2, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/semver.js
var require_semver2 = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/semver.js"(exports2, module2) {
    var debug2 = require_debug();
    var { MAX_LENGTH, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER2 } = require_constants2();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version, options) {
        options = parseOptions(options);
        if (version instanceof SemVer) {
          if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
            return version;
          } else {
            version = version.version;
          }
        } else if (typeof version !== "string") {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        if (version.length > MAX_LENGTH) {
          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug2("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER2 || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER2 || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER2 || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER2) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug2("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug2("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/parse.js"(exports2, module2) {
    var { MAX_LENGTH } = require_constants2();
    var { re, t } = require_re();
    var SemVer = require_semver2();
    var parseOptions = require_parse_options();
    var parse = (version, options) => {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      const r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/valid.js"(exports2, module2) {
    var parse = require_parse();
    var valid = (version, options) => {
      const v = parse(version, options);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/clean.js"(exports2, module2) {
    var parse = require_parse();
    var clean = (version, options) => {
      const s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/inc.js"(exports2, module2) {
    var SemVer = require_semver2();
    var inc = (version, release, options, identifier) => {
      if (typeof options === "string") {
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare.js"(exports2, module2) {
    var SemVer = require_semver2();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/eq.js"(exports2, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/diff.js"(exports2, module2) {
    var parse = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v1 = parse(version1);
        const v2 = parse(version2);
        const hasPre = v1.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/major.js"(exports2, module2) {
    var SemVer = require_semver2();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/minor.js"(exports2, module2) {
    var SemVer = require_semver2();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/patch.js"(exports2, module2) {
    var SemVer = require_semver2();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/prerelease.js"(exports2, module2) {
    var parse = require_parse();
    var prerelease = (version, options) => {
      const parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/rcompare.js"(exports2, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare-loose.js"(exports2, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/compare-build.js"(exports2, module2) {
    var SemVer = require_semver2();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/sort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/rsort.js"(exports2, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/gt.js"(exports2, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/lt.js"(exports2, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/neq.js"(exports2, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/gte.js"(exports2, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/lte.js"(exports2, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/cmp.js"(exports2, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/coerce.js"(exports2, module2) {
    var SemVer = require_semver2();
    var parse = require_parse();
    var { re, t } = require_re();
    var coerce = (version, options) => {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
    };
    module2.exports = coerce;
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports2, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/range.js"(exports2, module2) {
    var Range = class {
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range;
        this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        range = range.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range}`;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug2("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug2("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        range = range.split(/\s+/).join(" ");
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug2("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug2("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      test(version) {
        if (!version) {
          return false;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug2 = require_debug();
    var SemVer = require_semver2();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options) => {
      debug2("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug2("caret", comp);
      comp = replaceTildes(comp, options);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug2("xrange", comp);
      comp = replaceStars(comp, options);
      debug2("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options);
    }).join(" ");
    var replaceTilde = (comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug2("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options);
    }).join(" ");
    var replaceCaret = (comp, options) => {
      debug2("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug2("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options) => {
      debug2("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options);
      }).join(" ");
    };
    var replaceXRange = (comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug2("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options) => {
      debug2("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options) => {
      debug2("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug2(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/classes/comparator.js"(exports2, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug2("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug2("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version) {
        debug2("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
          return true;
        }
        if (typeof version === "string") {
          try {
            version = new SemVer(version, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options || typeof options !== "object") {
          options = {
            loose: !!options,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug2 = require_debug();
    var SemVer = require_semver2();
    var Range = require_range();
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/functions/satisfies.js"(exports2, module2) {
    var Range = require_range();
    var satisfies = (version, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    };
    module2.exports = satisfies;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/to-comparators.js"(exports2, module2) {
    var Range = require_range();
    var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/max-satisfying.js"(exports2, module2) {
    var SemVer = require_semver2();
    var Range = require_range();
    var maxSatisfying = (versions, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/min-satisfying.js"(exports2, module2) {
    var SemVer = require_semver2();
    var Range = require_range();
    var minSatisfying = (versions, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/min-version.js"(exports2, module2) {
    var SemVer = require_semver2();
    var Range = require_range();
    var gt = require_gt();
    var minVersion = (range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/valid.js"(exports2, module2) {
    var Range = require_range();
    var validRange = (range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/outside.js"(exports2, module2) {
    var SemVer = require_semver2();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version, range, hilo, options) => {
      version = new SemVer(version, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/gtr.js"(exports2, module2) {
    var outside = require_outside();
    var gtr = (version, range, options) => outside(version, range, ">", options);
    module2.exports = gtr;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/ltr.js"(exports2, module2) {
    var outside = require_outside();
    var ltr = (version, range, options) => outside(version, range, "<", options);
    module2.exports = ltr;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/intersects.js"(exports2, module2) {
    var Range = require_range();
    var intersects = (r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/simplify.js"(exports2, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options));
      for (const version of v) {
        const included = satisfies(version, range, options);
        if (included) {
          prev = version;
          if (!first) {
            first = version;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/ranges/subset.js"(exports2, module2) {
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var simpleSubset = (sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = [new Comparator(">=0.0.0-0")];
        } else {
          sub = [new Comparator(">=0.0.0")];
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = [new Comparator(">=0.0.0")];
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/.pnpm/semver@7.3.7/node_modules/semver/index.js
var require_semver3 = __commonJS({
  "node_modules/.pnpm/semver@7.3.7/node_modules/semver/index.js"(exports2, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants2().SEMVER_SPEC_VERSION,
      SemVer: require_semver2(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/.pnpm/pend@1.2.0/node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/.pnpm/fd-slicer@1.1.0/node_modules/fd-slicer/index.js"(exports2) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer3 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer3.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer3.alloc === "function" && typeof Buffer3.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer3.alloc(input) : new Buffer3(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer3.from(input) : new Buffer3(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer3.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/.pnpm/yauzl@2.10.0/node_modules/yauzl/index.js"(exports2) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray2(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return toString.call(val) === "[object FormData]";
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction2(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction2(val.pipe);
    }
    function isURLSearchParams(val) {
      return toString.call(val) === "[object URLSearchParams]";
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray2(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray2(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray: isArray2,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request2, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request2;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request2, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request2, response);
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request2 = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          var response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request2));
          request2 = null;
        };
        request2.onerror = function handleError() {
          reject(createError("Network Error", config, null, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request2));
          request2 = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request2.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request2.send(requestData);
      });
    };
  }
});

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os2 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          return 1;
        }
        if (env.FORCE_COLOR === "false") {
          return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os2.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, __spreadValues({
        streamIsTTY: stream && stream.isTTY
      }, options));
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
      stderr: getSupportLevel({ isTTY: tty.isatty(2) })
    };
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/.pnpm/follow-redirects@1.15.1/node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.1/node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug2;
    module2.exports = function() {
      if (!debug2) {
        try {
          debug2 = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug2 !== "function") {
          debug2 = function() {
          };
        }
      }
      debug2.apply(null, arguments);
    };
  }
});

// node_modules/.pnpm/follow-redirects@1.15.1/node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/.pnpm/follow-redirects@1.15.1/node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug2 = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request2._redirectable = this;
      for (var event of events) {
        request2.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : this._currentUrl = this._options.path;
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
        return;
      }
      debug2("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (typeof beforeRedirect === "function") {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError(cause));
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request2(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug2("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request2) {
      for (var event of events) {
        request2.removeListener(event, eventHandlers[event]);
      }
      request2.on("error", noop);
      request2.abort();
    }
    function isSubdomain(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.25.0"
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data().version;
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(createError("Request body larger than maxBodyLength limit", config));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(createError("error request aborted", config, "ERR_REQUEST_ABORTED", lastRequest));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(enhanceError(err, config, err.code, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError("error trying to parse `config.timeout` to int", config, "ERR_PARSE_TIMEOUT", req));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || defaults.transitional;
            reject(createError("timeout of " + timeout + "ms exceeded", config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var defaults = require_defaults();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version ? " in " + version : "")));
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request2(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      if (!config.url) {
        throw new Error("Provided config url is not valid");
      }
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.VERSION = require_data().version;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/.pnpm/axios@0.25.0/node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/.pnpm/axios@0.25.0/node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/agent-base@6.0.2/node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug2 = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug2("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug2("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug2("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug2("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug2("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug2 = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug2("onclose had error %o", err);
        }
        function onend() {
          debug2("onend");
        }
        function onerror(err) {
          cleanup();
          debug2("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug2("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug2("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug2 = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug2("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug2("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug2("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug2("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug2("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/https-proxy-agent@5.0.1/node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/.pnpm/@hashicorp+js-releases@1.6.0/node_modules/@hashicorp/js-releases/out/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@hashicorp+js-releases@1.6.0/node_modules/@hashicorp/js-releases/out/utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.request = void 0;
    var axios_1 = require_axios2();
    var HttpsProxyAgent = require_dist();
    var httpProxy = process.env["HTTP_PROXY"] || process.env["http_proxy"];
    var httpsProxy = process.env["HTTPS_PROXY"] || process.env["https_proxy"];
    var proxyConf = {};
    if (httpProxy || httpsProxy) {
      proxyConf = {
        proxy: false,
        httpAgent: httpProxy ? new HttpsProxyAgent(httpProxy) : void 0,
        httpsAgent: httpsProxy ? new HttpsProxyAgent(httpsProxy) : void 0
      };
    }
    var axios = axios_1.default.create(Object.assign({}, proxyConf));
    function request2(url, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield axios.get(url, Object.assign({}, options));
        return result.data;
      });
    }
    exports2.request = request2;
  }
});

// node_modules/.pnpm/@hashicorp+js-releases@1.6.0/node_modules/@hashicorp/js-releases/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/@hashicorp+js-releases@1.6.0/node_modules/@hashicorp/js-releases/out/index.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRelease = exports2.Release = void 0;
    var crypto2 = require("crypto");
    var fs = require("fs");
    var openpgp = require_openpgp_min();
    var semver2 = require_semver3();
    var stream = require("stream");
    var yauzl = require_yauzl();
    var util_1 = require("util");
    var utils_1 = require_utils3();
    var finished = (0, util_1.promisify)(stream.finished);
    var hashiPublicKeyId = "72D7468F";
    var hashiPublicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGB9+xkBEACabYZOWKmgZsHTdRDiyPJxhbuUiKX65GUWkyRMJKi/1dviVxOX
PG6hBPtF48IFnVgxKpIb7G6NjBousAV+CuLlv5yqFKpOZEGC6sBV+Gx8Vu1CICpl
Zm+HpQPcIzwBpN+Ar4l/exCG/f/MZq/oxGgH+TyRF3XcYDjG8dbJCpHO5nQ5Cy9h
QIp3/Bh09kET6lk+4QlofNgHKVT2epV8iK1cXlbQe2tZtfCUtxk+pxvU0UHXp+AB
0xc3/gIhjZp/dePmCOyQyGPJbp5bpO4UeAJ6frqhexmNlaw9Z897ltZmRLGq1p4a
RnWL8FPkBz9SCSKXS8uNyV5oMNVn4G1obCkc106iWuKBTibffYQzq5TG8FYVJKrh
RwWB6piacEB8hl20IIWSxIM3J9tT7CPSnk5RYYCTRHgA5OOrqZhC7JefudrP8n+M
pxkDgNORDu7GCfAuisrf7dXYjLsxG4tu22DBJJC0c/IpRpXDnOuJN1Q5e/3VUKKW
mypNumuQpP5lc1ZFG64TRzb1HR6oIdHfbrVQfdiQXpvdcFx+Fl57WuUraXRV6qfb
4ZmKHX1JEwM/7tu21QE4F1dz0jroLSricZxfaCTHHWNfvGJoZ30/MZUrpSC0IfB3
iQutxbZrwIlTBt+fGLtm3vDtwMFNWM+Rb1lrOxEQd2eijdxhvBOHtlIcswARAQAB
tERIYXNoaUNvcnAgU2VjdXJpdHkgKGhhc2hpY29ycC5jb20vc2VjdXJpdHkpIDxz
ZWN1cml0eUBoYXNoaWNvcnAuY29tPokCVAQTAQoAPhYhBMh0AR8KtAURDQIQVTQ2
XZRy10aPBQJgffsZAhsDBQkJZgGABQsJCAcCBhUKCQgLAgQWAgMBAh4BAheAAAoJ
EDQ2XZRy10aPtpcP/0PhJKiHtC1zREpRTrjGizoyk4Sl2SXpBZYhkdrG++abo6zs
buaAG7kgWWChVXBo5E20L7dbstFK7OjVs7vAg/OLgO9dPD8n2M19rpqSbbvKYWvp
0NSgvFTT7lbyDhtPj0/bzpkZEhmvQaDWGBsbDdb2dBHGitCXhGMpdP0BuuPWEix+
QnUMaPwU51q9GM2guL45Tgks9EKNnpDR6ZdCeWcqo1IDmklloidxT8aKL21UOb8t
cD+Bg8iPaAr73bW7Jh8TdcV6s6DBFub+xPJEB/0bVPmq3ZHs5B4NItroZ3r+h3ke
VDoSOSIZLl6JtVooOJ2la9ZuMqxchO3mrXLlXxVCo6cGcSuOmOdQSz4OhQE5zBxx
LuzA5ASIjASSeNZaRnffLIHmht17BPslgNPtm6ufyOk02P5XXwa69UCjA3RYrA2P
QNNC+OWZ8qQLnzGldqE4MnRNAxRxV6cFNzv14ooKf7+k686LdZrP/3fQu2p3k5rY
0xQUXKh1uwMUMtGR867ZBYaxYvwqDrg9XB7xi3N6aNyNQ+r7zI2lt65lzwG1v9hg
FG2AHrDlBkQi/t3wiTS3JOo/GCT8BjN0nJh0lGaRFtQv2cXOQGVRW8+V/9IpqEJ1
qQreftdBFWxvH7VJq2mSOXUJyRsoUrjkUuIivaA9Ocdipk2CkP8bpuGz7ZF4uQIN
BGB9+xkBEACoklYsfvWRCjOwS8TOKBTfl8myuP9V9uBNbyHufzNETbhYeT33Cj0M
GCNd9GdoaknzBQLbQVSQogA+spqVvQPz1MND18GIdtmr0BXENiZE7SRvu76jNqLp
KxYALoK2Pc3yK0JGD30HcIIgx+lOofrVPA2dfVPTj1wXvm0rbSGA4Wd4Ng3d2AoR
G/wZDAQ7sdZi1A9hhfugTFZwfqR3XAYCk+PUeoFrkJ0O7wngaon+6x2GJVedVPOs
2x/XOR4l9ytFP3o+5ILhVnsK+ESVD9AQz2fhDEU6RhvzaqtHe+sQccR3oVLoGcat
ma5rbfzH0Fhj0JtkbP7WreQf9udYgXxVJKXLQFQgel34egEGG+NlbGSPG+qHOZtY
4uWdlDSvmo+1P95P4VG/EBteqyBbDDGDGiMs6lAMg2cULrwOsbxWjsWka8y2IN3z
1stlIJFvW2kggU+bKnQ+sNQnclq3wzCJjeDBfucR3a5WRojDtGoJP6Fc3luUtS7V
5TAdOx4dhaMFU9+01OoH8ZdTRiHZ1K7RFeAIslSyd4iA/xkhOhHq89F4ECQf3Bt4
ZhGsXDTaA/VgHmf3AULbrC94O7HNqOvTWzwGiWHLfcxXQsr+ijIEQvh6rHKmJK8R
9NMHqc3L18eMO6bqrzEHW0Xoiu9W8Yj+WuB3IKdhclT3w0pO4Pj8gQARAQABiQI8
BBgBCgAmFiEEyHQBHwq0BRENAhBVNDZdlHLXRo8FAmB9+xkCGwwFCQlmAYAACgkQ
NDZdlHLXRo9ZnA/7BmdpQLeTjEiXEJyW46efxlV1f6THn9U50GWcE9tebxCXgmQf
u+Uju4hreltx6GDi/zbVVV3HCa0yaJ4JVvA4LBULJVe3ym6tXXSYaOfMdkiK6P1v
JgfpBQ/b/mWB0yuWTUtWx18BQQwlNEQWcGe8n1lBbYsH9g7QkacRNb8tKUrUbWlQ
QsU8wuFgly22m+Va1nO2N5C/eE/ZEHyN15jEQ+QwgQgPrK2wThcOMyNMQX/VNEr1
Y3bI2wHfZFjotmek3d7ZfP2VjyDudnmCPQ5xjezWpKbN1kvjO3as2yhcVKfnvQI5
P5Frj19NgMIGAp7X6pF5Csr4FX/Vw316+AFJd9Ibhfud79HAylvFydpcYbvZpScl
7zgtgaXMCVtthe3GsG4gO7IdxxEBZ/Fm4NLnmbzCIWOsPMx/FxH06a539xFq/1E2
1nYFjiKg8a5JFmYU/4mV9MQs4bP/3ip9byi10V+fEIfp5cEEmfNeVeW5E7J8PqG9
t4rLJ8FR4yJgQUa2gs2SNYsjWQuwS/MJvAv4fDKlkQjQmYRAOp1SszAnyaplvri4
ncmfDsf0r65/sd6S40g5lHH8LIbGxcOIN6kwthSTPWX89r42CbY8GzjTkaeejNKx
v1aCrO58wAtursO1DiXCvBY7+NdafMRnoHwBk50iPqrVkNA8fv+auRyB2/G5Ag0E
YH3+JQEQALivllTjMolxUW2OxrXb+a2Pt6vjCBsiJzrUj0Pa63U+lT9jldbCCfgP
wDpcDuO1O05Q8k1MoYZ6HddjWnqKG7S3eqkV5c3ct3amAXp513QDKZUfIDylOmhU
qvxjEgvGjdRjz6kECFGYr6Vnj/p6AwWv4/FBRFlrq7cnQgPynbIH4hrWvewp3Tqw
GVgqm5RRofuAugi8iZQVlAiQZJo88yaztAQ/7VsXBiHTn61ugQ8bKdAsr8w/ZZU5
HScHLqRolcYg0cKN91c0EbJq9k1LUC//CakPB9mhi5+aUVUGusIM8ECShUEgSTCi
KQiJUPZ2CFbbPE9L5o9xoPCxjXoX+r7L/WyoCPTeoS3YRUMEnWKvc42Yxz3meRb+
BmaqgbheNmzOah5nMwPupJYmHrjWPkX7oyyHxLSFw4dtoP2j6Z7GdRXKa2dUYdk2
x3JYKocrDoPHh3Q0TAZujtpdjFi1BS8pbxYFb3hHmGSdvz7T7KcqP7ChC7k2RAKO
GiG7QQe4NX3sSMgweYpl4OwvQOn73t5CVWYp/gIBNZGsU3Pto8g27vHeWyH9mKr4
cSepDhw+/X8FGRNdxNfpLKm7Vc0Sm9Sof8TRFrBTqX+vIQupYHRi5QQCuYaV6OVr
ITeegNK3So4m39d6ajCR9QxRbmjnx9UcnSYYDmIB6fpBuwT0ogNtABEBAAGJBHIE
GAEKACYCGwIWIQTIdAEfCrQFEQ0CEFU0Nl2UctdGjwUCYH4bgAUJAeFQ2wJAwXQg
BBkBCgAdFiEEs2y6kaLAcwxDX8KAsLRBCXaFtnYFAmB9/iUACgkQsLRBCXaFtnYX
BhAAlxejyFXoQwyGo9U+2g9N6LUb/tNtH29RHYxy4A3/ZUY7d/FMkArmh4+dfjf0
p9MJz98Zkps20kaYP+2YzYmaizO6OA6RIddcEXQDRCPHmLts3097mJ/skx9qLAf6
rh9J7jWeSqWO6VW6Mlx8j9m7sm3Ae1OsjOx/m7lGZOhY4UYfY627+Jf7WQ5103Qs
lgQ09es/vhTCx0g34SYEmMW15Tc3eCjQ21b1MeJD/V26npeakV8iCZ1kHZHawPq/
aCCuYEcCeQOOteTWvl7HXaHMhHIx7jjOd8XX9V+UxsGz2WCIxX/j7EEEc7CAxwAN
nWp9jXeLfxYfjrUB7XQZsGCd4EHHzUyCf7iRJL7OJ3tz5Z+rOlNjSgci+ycHEccL
YeFAEV+Fz+sj7q4cFAferkr7imY1XEI0Ji5P8p/uRYw/n8uUf7LrLw5TzHmZsTSC
UaiL4llRzkDC6cVhYfqQWUXDd/r385OkE4oalNNE+n+txNRx92rpvXWZ5qFYfv7E
95fltvpXc0iOugPMzyof3lwo3Xi4WZKc1CC/jEviKTQhfn3WZukuF5lbz3V1PQfI
xFsYe9WYQmp25XGgezjXzp89C/OIcYsVB1KJAKihgbYdHyUN4fRCmOszmOUwEAKR
3k5j4X8V5bk08sA69NVXPn2ofxyk3YYOMYWW8ouObnXoS8QJEDQ2XZRy10aPMpsQ
AIbwX21erVqUDMPn1uONP6o4NBEq4MwG7d+fT85rc1U0RfeKBwjucAE/iStZDQoM
ZKWvGhFR+uoyg1LrXNKuSPB82unh2bpvj4zEnJsJadiwtShTKDsikhrfFEK3aCK8
Zuhpiu3jxMFDhpFzlxsSwaCcGJqcdwGhWUx0ZAVD2X71UCFoOXPjF9fNnpy80YNp
flPjj2RnOZbJyBIM0sWIVMd8F44qkTASf8K5Qb47WFN5tSpePq7OCm7s8u+lYZGK
wR18K7VliundR+5a8XAOyUXOL5UsDaQCK4Lj4lRaeFXunXl3DJ4E+7BKzZhReJL6
EugV5eaGonA52TWtFdB8p+79wPUeI3KcdPmQ9Ll5Zi/jBemY4bzasmgKzNeMtwWP
fk6WgrvBwptqohw71HDymGxFUnUP7XYYjic2sVKhv9AevMGycVgwWBiWroDCQ9Ja
btKfxHhI2p+g+rcywmBobWJbZsujTNjhtme+kNn1mhJsD3bKPjKQfAxaTskBLb0V
wgV21891TS1Dq9kdPLwoS4XNpYg2LLB4p9hmeG3fu9+OmqwY5oKXsHiWc43dei9Y
yxZ1AAUOIaIdPkq+YG/PhlGE4YcQZ4RPpltAr0HfGgZhmXWigbGS+66pUj+Ojysc
j0K5tCVxVu0fhhFpOlHv0LWaxCbnkgkQH9jfMEJkAWMOuQINBGCAXCYBEADW6RNr
ZVGNXvHVBqSiOWaxl1XOiEoiHPt50Aijt25yXbG+0kHIFSoR+1g6Lh20JTCChgfQ
kGGjzQvEuG1HTw07YhsvLc0pkjNMfu6gJqFox/ogc53mz69OxXauzUQ/TZ27GDVp
UBu+EhDKt1s3OtA6Bjz/csop/Um7gT0+ivHyvJ/jGdnPEZv8tNuSE/Uo+hn/Q9hg
8SbveZzo3C+U4KcabCESEFl8Gq6aRi9vAfa65oxD5jKaIz7cy+pwb0lizqlW7H9t
Qlr3dBfdIcdzgR55hTFC5/XrcwJ6/nHVH/xGskEasnfCQX8RYKMuy0UADJy72TkZ
bYaCx+XXIcVB8GTOmJVoAhrTSSVLAZspfCnjwnSxisDn3ZzsYrq3cV6sU8b+QlIX
7VAjurE+5cZiVlaxgCjyhKqlGgmonnReWOBacCgL/UvuwMmMp5TTLmiLXLT7uxeG
ojEyoCk4sMrqrU1jevHyGlDJH9Taux15GILDwnYFfAvPF9WCid4UZ4Ouwjcaxfys
3LxNiZIlUsXNKwS3mhiMRL4TRsbs4k4QE+LIMOsauIvcvm8/frydvQ/kUwIhVTH8
0XGOH909bYtJvY3fudK7ShIwm7ZFTduBJUG473E/Fn3VkhTmBX6+PjOC50HR/Hyb
waRCzfDruMe3TAcE/tSP5CUOb9C7+P+hPzQcDwARAQABiQRyBBgBCgAmFiEEyHQB
Hwq0BRENAhBVNDZdlHLXRo8FAmCAXCYCGwIFCQlmAYACQAkQNDZdlHLXRo/BdCAE
GQEKAB0WIQQ3TsdbSFkTYEqDHMfIIMbVzSerhwUCYIBcJgAKCRDIIMbVzSerh0Xw
D/9ghnUsoNCu1OulcoJdHboMazJvDt/znttdQSnULBVElgM5zk0Uyv87zFBzuCyQ
JWL3bWesQ2uFx5fRWEPDEfWVdDrjpQGb1OCCQyz1QlNPV/1M1/xhKGS9EeXrL8Dw
F6KTGkRwn1yXiP4BGgfeFIQHmJcKXEZ9HkrpNb8mcexkROv4aIPAwn+IaE+NHVtt
IBnufMXLyfpkWJQtJa9elh9PMLlHHnuvnYLvuAoOkhuvs7fXDMpfFZ01C+QSv1dz
Hm52GSStERQzZ51w4c0rYDneYDniC/sQT1x3dP5Xf6wzO+EhRMabkvoTbMqPsTEP
xyWr2pNtTBYp7pfQjsHxhJpQF0xjGN9C39z7f3gJG8IJhnPeulUqEZjhRFyVZQ6/
siUeq7vu4+dM/JQL+i7KKe7Lp9UMrG6NLMH+ltaoD3+lVm8fdTUxS5MNPoA/I8cK
1OWTJHkrp7V/XaY7mUtvQn5V1yET5b4bogz4nME6WLiFMd+7x73gB+YJ6MGYNuO8
e/NFK67MfHbk1/AiPTAJ6s5uHRQIkZcBPG7y5PpfcHpIlwPYCDGYlTajZXblyKrw
BttVnYKvKsnlysv11glSg0DphGxQJbXzWpvBNyhMNH5dffcfvd3eXJAxnD81GD2z
ZAriMJ4Av2TfeqQ2nxd2ddn0jX4WVHtAvLXfCgLM2Gveho4jD/9sZ6PZz/rEeTvt
h88t50qPcBa4bb25X0B5FO3TeK2LL3VKLuEp5lgdcHVonrcdqZFobN1CgGJua8TW
SprIkh+8ATZ/FXQTi01NzLhHXT1IQzSpFaZw0gb2f5ruXwvTPpfXzQrs2omY+7s7
fkCwGPesvpSXPKn9v8uhUwD7NGW/Dm+jUM+QtC/FqzX7+/Q+OuEPjClUh1cqopCZ
EvAI3HjnavGrYuU6DgQdjyGT/UDbuwbCXqHxHojVVkISGzCTGpmBcQYQqhcFRedJ
yJlu6PSXlA7+8Ajh52oiMJ3ez4xSssFgUQAyOB16432tm4erpGmCyakkoRmMUn3p
wx+QIppxRlsHznhcCQKR3tcblUqH3vq5i4/ZAihusMCa0YrShtxfdSb13oKX+pFr
aZXvxyZlCa5qoQQBV1sowmPL1N2j3dR9TVpdTyCFQSv4KeiExmowtLIjeCppRBEK
eeYHJnlfkyKXPhxTVVO6H+dU4nVu0ASQZ07KiQjbI+zTpPKFLPp3/0sPRJM57r1+
aTS71iR7nZNZ1f8LZV2OvGE6fJVtgJ1J4Nu02K54uuIhU3tg1+7Xt+IqwRc9rbVr
pHH/hFCYBPW2D2dxB+k2pQlg5NI+TpsXj5Zun8kRw5RtVb+dLuiH/xmxArIee8Jq
ZF5q4h4I33PSGDdSvGXn9UMY5Isjpg==
=7pIB

-----END PGP PUBLIC KEY BLOCK-----`;
    var releasesUrl2 = "https://releases.hashicorp.com";
    var Release2 = class {
      constructor(release) {
        this.name = release.name;
        this.version = release.version;
        this.builds = release.builds;
        this.shasums = release.shasums;
        if (release.shasums_signatures) {
          this.shasums_signature = release.shasums_signatures.find((sig) => sig.endsWith(`_SHA256SUMS.${hashiPublicKeyId}.sig`));
        } else {
          this.shasums_signature = release.shasums_signature;
        }
      }
      getBuild(platform, arch) {
        return this.builds.find((b) => b.os === platform && b.arch === arch);
      }
      download(downloadUrl, installPath, identifier) {
        return __awaiter(this, void 0, void 0, function* () {
          const headers = { "User-Agent": identifier };
          const writer = fs.createWriteStream(installPath);
          const result = yield (0, utils_1.request)(downloadUrl, { headers: Object.assign({}, headers), responseType: "stream" });
          result.pipe(writer);
          yield finished(writer);
        });
      }
      verify(pkg, buildName) {
        return __awaiter(this, void 0, void 0, function* () {
          const [localSum, remoteSum] = yield Promise.all([
            this.calculateFileSha256Sum(pkg),
            this.downloadSha256Sum(buildName)
          ]);
          if (remoteSum !== localSum) {
            throw new Error(`Install error: SHA sum for ${buildName} does not match.
(expected: ${remoteSum} calculated: ${localSum})`);
          }
        });
      }
      calculateFileSha256Sum(path) {
        return new Promise((resolve, reject) => {
          const hash = crypto2.createHash("sha256");
          fs.createReadStream(path).on("error", reject).on("data", (data) => hash.update(data)).on("end", () => resolve(hash.digest("hex")));
        });
      }
      downloadSha256Sum(buildName) {
        return __awaiter(this, void 0, void 0, function* () {
          const [shasumsResponse, shasumsSignature] = yield Promise.all([
            (0, utils_1.request)(`${releasesUrl2}/${this.name}/${this.version}/${this.shasums}`, {
              responseType: "text"
            }),
            (0, utils_1.request)(`${releasesUrl2}/${this.name}/${this.version}/${this.shasums_signature}`, {
              responseType: "arraybuffer"
            })
          ]);
          const publicKey = yield openpgp.readKey({ armoredKey: hashiPublicKey });
          const signature = yield openpgp.readSignature({ binarySignature: Buffer.from(shasumsSignature, "hex") });
          const message = yield openpgp.createMessage({ text: shasumsResponse });
          const verified = yield openpgp.verify({
            message,
            verificationKeys: publicKey,
            signature
          });
          if (!verified) {
            throw new Error("signature could not be verified");
          }
          const shasumLine = shasumsResponse.split(`
`).find((line) => line.includes(buildName));
          if (!shasumLine) {
            throw new Error(`Install error: no matching SHA sum for ${buildName}`);
          }
          return shasumLine.split("  ")[0];
        });
      }
      unpack(directory, pkgName) {
        return new Promise((resolve, reject) => {
          let executable;
          yauzl.open(pkgName, { lazyEntries: true }, (err, zipfile) => {
            if (err) {
              return reject(err);
            }
            zipfile.readEntry();
            zipfile.on("entry", (entry) => {
              zipfile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  return reject(err2);
                }
                readStream.on("end", () => {
                  zipfile.readEntry();
                });
                executable = `${directory}/${entry.fileName}`;
                const destination = fs.createWriteStream(executable);
                readStream.pipe(destination);
              });
            });
            zipfile.on("close", () => {
              fs.chmodSync(executable, "755");
              return resolve();
            });
          });
        });
      }
    };
    exports2.Release = Release2;
    function getRelease2(product, version, userAgent, includePrerelease) {
      return __awaiter(this, void 0, void 0, function* () {
        const validVersion = semver2.validRange(version, { includePrerelease, loose: true });
        const indexUrl = `${releasesUrl2}/${product}/index.json`;
        const headers = userAgent ? { "User-Agent": userAgent } : null;
        const response = yield (0, utils_1.request)(indexUrl, { headers });
        let release;
        if (!validVersion) {
          const releaseVersions = Object.keys(response.versions).filter((v) => !semver2.prerelease(v));
          version = releaseVersions.sort((a, b) => semver2.rcompare(a, b))[0];
          release = new Release2(response.versions[version]);
        } else {
          release = matchVersion2(response.versions, validVersion, includePrerelease);
        }
        return release;
      });
    }
    exports2.getRelease = getRelease2;
    function matchVersion2(versions, range, includePrerelease) {
      const version = semver2.maxSatisfying(Object.keys(versions), range, { includePrerelease });
      if (version) {
        return new Release2(versions[version]);
      } else {
        throw new Error("No matching version found");
      }
    }
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/bind.js
var require_bind2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind2();
    var toString = Object.prototype.toString;
    var kindOf = function(cache) {
      return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray2(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer2(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString2(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject2(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction2(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction2(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction2(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray2(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject2(result[key]) && isPlainObject2(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject2(val)) {
          result[key] = merge({}, val);
        } else if (isArray2(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if (!merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      var i = thing.length;
      if (isUndefined(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray2 = function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    module2.exports = {
      isArray: isArray2,
      isArrayBuffer,
      isBuffer: isBuffer2,
      isFormData,
      isArrayBufferView,
      isString: isString2,
      isNumber,
      isObject: isObject2,
      isPlainObject: isPlainObject2,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction: isFunction2,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray: isTypedArray2,
      isFileList
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/buildURL.js
var require_buildURL2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/AxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    function AxiosError(message, code, config, request2, response) {
      Error.call(this);
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request2 && (this.request = request2);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED"
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request2, response, customProps) {
      var axiosError = Object.create(prototype);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request2, response);
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module2.exports = AxiosError;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/transitional.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/toFormData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    function toFormData(obj, formData) {
      formData = formData || new FormData();
      var stack = [];
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils.isDate(value)) {
          return value.toISOString();
        }
        if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
          return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function build(data, parentKey) {
        if (utils.isPlainObject(data) || utils.isArray(data)) {
          if (stack.indexOf(data) !== -1) {
            throw Error("Circular reference detected in " + parentKey);
          }
          stack.push(data);
          utils.forEach(data, function each(value, key) {
            if (utils.isUndefined(value))
              return;
            var fullKey = parentKey ? parentKey + "." + key : key;
            var arr;
            if (value && !parentKey && typeof value === "object") {
              if (utils.endsWith(key, "{}")) {
                value = JSON.stringify(value);
              } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                arr.forEach(function(el) {
                  !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                });
                return;
              }
            }
            build(value, fullKey);
          });
          stack.pop();
        } else {
          formData.append(parentKey, convertValue(data));
        }
      }
      build(obj);
      return formData;
    }
    module2.exports = toFormData;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/settle.js
var require_settle2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    module2.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError("Request failed with status code " + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
      }
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/cookies.js
var require_cookies2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL2();
    var combineURLs = require_combineURLs2();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CanceledError.js"(exports2, module2) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils = require_utils4();
    function CanceledError(message) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module2.exports = CanceledError;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/parseProtocol.js"(exports2, module2) {
    "use strict";
    module2.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/xhr.js
var require_xhr2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var settle = require_settle2();
    var cookies = require_cookies2();
    var buildURL = require_buildURL2();
    var buildFullPath = require_buildFullPath2();
    var parseHeaders = require_parseHeaders2();
    var isURLSameOrigin = require_isURLSameOrigin2();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request2 = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request2.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request2.timeout = config.timeout;
        function onloadend() {
          if (!request2) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders(request2.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
          var response = {
            data: responseData,
            status: request2.status,
            statusText: request2.statusText,
            headers: responseHeaders,
            config,
            request: request2
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request2 = null;
        }
        if ("onloadend" in request2) {
          request2.onloadend = onloadend;
        } else {
          request2.onreadystatechange = function handleLoad() {
            if (!request2 || request2.readyState !== 4) {
              return;
            }
            if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request2.onabort = function handleAbort() {
          if (!request2) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
          request2 = null;
        };
        request2.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2, request2));
          request2 = null;
        };
        request2.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request2));
          request2 = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request2) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request2.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request2.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request2.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request2.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request2.upload) {
          request2.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request2) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
            request2.abort();
            request2 = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request2.send(requestData);
      });
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/env/data.js
var require_data2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/env/data.js"(exports2, module2) {
    module2.exports = {
      "version": "0.27.2"
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/http.js
var require_http2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var settle = require_settle2();
    var buildFullPath = require_buildFullPath2();
    var buildURL = require_buildURL2();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var VERSION = require_data2().version;
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var isHttps = /https:?/;
    var supportedProtocols = ["http:", "https:", "file:"];
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var rejected = false;
        var reject = function reject2(value) {
          done();
          rejected = true;
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
          Object.assign(headers, data.getHeaders());
        } else if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", AxiosError.ERR_BAD_REQUEST, config));
          }
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError("Request body larger than maxBodyLength limit", AxiosError.ERR_BAD_REQUEST, config));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || supportedProtocols[0];
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_BAD_REQUEST, config));
        }
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        try {
          buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, "");
        } catch (err) {
          var customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          reject(customErr);
        }
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirect = config.beforeRedirect;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                stream.destroy();
                reject(new AxiosError("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
              }
            });
            stream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              stream.destroy();
              reject(new AxiosError("maxContentLength size of " + config.maxContentLength + " exceeded", AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              try {
                var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (config.responseType !== "arraybuffer") {
                  responseData = responseData.toString(config.responseEncoding);
                  if (!config.responseEncoding || config.responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(new AxiosError("error trying to parse `config.timeout` to int", AxiosError.ERR_BAD_OPTION_VALUE, config, req));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || transitionalDefaults;
            reject(new AxiosError("timeout of " + timeout + "ms exceeded", transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(AxiosError.from(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/populate.js"(exports2, module2) {
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/.pnpm/form-data@4.0.0/node_modules/form-data/lib/form_data.js"(exports2, module2) {
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value == "number") {
        value = "" + value;
      }
      if (util.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (value.hasOwnProperty("fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value.hasOwnProperty("httpVersion")) {
        callback(null, +value.headers["content-length"]);
      } else if (value.hasOwnProperty("httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, +response.headers["content-length"]);
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value.name || value.path) {
        filename = path.basename(options.filename || value.name || value.path);
      } else if (value.readable && value.hasOwnProperty("httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request2, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request2 = https.request(options);
      } else {
        request2 = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request2.setHeader("Content-Length", length);
        }
        this.pipe(request2);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request2.removeListener("error", callback);
            request2.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request2.on("error", callback);
          request2.on("response", onResponse);
        }
      }.bind(this));
      return request2;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/env/FormData.js
var require_FormData = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/env/FormData.js"(exports2, module2) {
    module2.exports = require_form_data();
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/index.js
var require_defaults2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/defaults/index.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var normalizeHeaderName = require_normalizeHeaderName2();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr2();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http2();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isObjectPayload = utils.isObject(data);
        var contentType = headers && headers["Content-Type"];
        var isFileList;
        if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
        } else if (isObjectPayload || contentType === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: require_FormData()
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/transformData.js
var require_transformData2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var defaults = require_defaults2();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/isCancel.js
var require_isCancel2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var transformData = require_transformData2();
    var isCancel = require_isCancel2();
    var defaults = require_defaults2();
    var CanceledError = require_CanceledError();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/validator.js
var require_validator2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var VERSION = require_data2().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError.ERR_DEPRECATED);
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module2.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/Axios.js
var require_Axios2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var buildURL = require_buildURL2();
    var InterceptorManager = require_InterceptorManager2();
    var dispatchRequest = require_dispatchRequest2();
    var mergeConfig = require_mergeConfig2();
    var buildFullPath = require_buildFullPath2();
    var validator = require_validator2();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request2(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module2.exports = Axios;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/spread.js
var require_spread2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError2 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/axios.js
var require_axios3 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var bind = require_bind2();
    var Axios = require_Axios2();
    var mergeConfig = require_mergeConfig2();
    var defaults = require_defaults2();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.CanceledError = require_CanceledError();
    axios.CancelToken = require_CancelToken2();
    axios.isCancel = require_isCancel2();
    axios.VERSION = require_data2().version;
    axios.toFormData = require_toFormData();
    axios.AxiosError = require_AxiosError();
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread2();
    axios.isAxiosError = require_isAxiosError2();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// node_modules/.pnpm/axios@0.27.2/node_modules/axios/index.js
var require_axios4 = __commonJS({
  "node_modules/.pnpm/axios@0.27.2/node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios3();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  run: () => run
});
module.exports = __toCommonJS(src_exports);
var core = __toESM(require_core());
var tc = __toESM(require_tool_cache());

// src/vendor.ts
var import_js_releases = __toESM(require_out());
var import_axios = __toESM(require_axios4());
var import_semver = __toESM(require_semver3());
var releasesUrl = "https://releases.hashicorp.com";
async function getRelease(product, version, userAgent, includePrerelease) {
  const range = import_semver.default.validRange(version, {
    includePrerelease,
    loose: true
  });
  const indexUrl = `${releasesUrl}/${product}/index.json`;
  const headers = userAgent !== void 0 ? { "User-Agent": userAgent } : void 0;
  const response = await (0, import_axios.default)(indexUrl, { headers });
  const versions = response.data.versions;
  let release;
  if (range == null) {
    const releaseVersions = Object.keys(versions).filter((v) => import_semver.default.valid(v) !== null).filter((v) => import_semver.default.prerelease(v) == null);
    version = releaseVersions.sort((a, b) => import_semver.default.rcompare(a, b))[0];
    release = new import_js_releases.Release(versions[version]);
  } else {
    release = matchVersion(versions, range, includePrerelease);
  }
  return release;
}
function matchVersion(versions, range, includePrerelease) {
  const version = import_semver.default.maxSatisfying(Object.keys(versions), range, {
    includePrerelease
  });
  if (version !== null) {
    return new import_js_releases.Release(versions[version]);
  } else {
    throw new Error("No matching version found");
  }
}

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_WeakMap.js
var WeakMap = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_default = isLength;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_isPrototype.js
var objectProto4 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto4;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isArguments.js
var objectProto5 = Object.prototype;
var hasOwnProperty3 = objectProto5.hasOwnProperty;
var propertyIsEnumerable = objectProto5.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_baseKeys.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto7 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isError.js
var domExcTag = "[object DOMException]";
var errorTag2 = "[object Error]";
function isError(value) {
  if (!isObjectLike_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject_default(value);
}
var isError_default = isError;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isString.js
var stringTag2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag2;
}
var isString_default = isString;

// node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/isEmpty.js
var mapTag3 = "[object Map]";
var setTag3 = "[object Set]";
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag = getTag_default(value);
  if (tag == mapTag3 || tag == setTag3) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty6.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// src/index.ts
var import_os = __toESM(require("os"));
var mapArch = (arch) => ({
  x32: "386",
  arm64: "arm64",
  x64: "amd64"
})[arch] ?? arch;
var mapOS = (os2) => ({
  win32: "windows"
})[os2] ?? os2;
var USER_AGENT = "escapace/setup-vault";
async function download(url, verify) {
  core.debug(`Downloading Vault from ${url}`);
  const pathToZip = await tc.downloadTool(url);
  await verify(pathToZip);
  const pathToFile = await tc.extractZip(pathToZip);
  core.debug(`Vault path is ${pathToFile}.`);
  if (!isString_default(pathToZip) || !isString_default(pathToFile)) {
    throw new Error(`Unable to download Vault from ${url}`);
  }
  return pathToFile;
}
async function run() {
  try {
    const version = core.getInput("vault-version");
    const platform = mapOS(import_os.default.platform());
    const arch = mapArch(import_os.default.arch());
    core.debug(`Finding releases for Vault version ${version}`);
    const release = await getRelease("vault", version, USER_AGENT);
    core.debug(`Getting build for Vault version ${release.version}: ${platform} ${arch}`);
    const build = release.getBuild(platform, arch);
    if (!build) {
      throw new Error(`Vault version ${version} not available for ${platform} and ${arch}`);
    }
    let toolPath = tc.find("vault", release.version, arch);
    if (!isString_default(toolPath) || isEmpty_default(toolPath)) {
      toolPath = await download(build.url, async (zipFile) => await release.verify(zipFile, build.filename));
    }
    core.addPath(toolPath);
  } catch (error) {
    if (isError_default(error)) {
      core.setFailed(error.message);
    } else if (isString_default(error)) {
      core.setFailed(error);
    }
    core.setFailed("Unknown Error");
  }
}
void run();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  run
});
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! OpenPGP.js v5.1.0 - 2022-01-24 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */
/**
 * @license
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="es" -o ./`
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
//# sourceMappingURL=index.cjs.map
